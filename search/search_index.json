{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Lagrange","text":"<p>Project Lagrange is an initiative to bring the power of robust geometry processing to Adobe products. It bridges cutting edge research works with cutting edge products. Project Lagrange is built on the following design principles:</p>"},{"location":"#modular-design","title":"Modular Design","text":"<p>Large features should be decomposed into smaller single functionality modules that are as decoupled as possible from each other.  Modular design enables unit testing, prevents small change from propagating widely in the code base, and makes adding new functionalities easy.</p>"},{"location":"#preconditions-guarantees","title":"Preconditions + Guarantees","text":"<p>Algorithmic correctness should be rigorously enforced.  This is achieved by clearly documenting and checking the precise precondition and the corresponding guarantees of each module.  Algorithms relying on input-dependent parameter tuning should be avoided.</p>"},{"location":"#interface-compute-engine","title":"Interface + Compute Engine","text":"<p>The interface of a functionality should be decoupled from the computation algorithms.  This makes swapping out an algorithm with a better algorithm possible and ideally should not require change in client codes.</p>"},{"location":"#large-scale-testing","title":"Large Scale Testing","text":"<p>Large scale, empirical testing on major functionalities should be carried out periodically to ensure their correctness and robustness.  Let data speak for itself.</p>"},{"location":"build/","title":"Compilation Instructions","text":""},{"location":"build/#build","title":"Build","text":"<p>Lagrange requires a modern C++ compiler that supports C++17 features. Lagrange data structures are compatible with Eigen matrices. Other dependencies such as libigl and imgui will be downloaded by the build system as needed.</p>"},{"location":"build/#checkout","title":"Checkout","text":"<p>To checkout the code:</p> <pre><code>git clone git@github.com:adobe/lagrange.git\n</code></pre>"},{"location":"build/#compiling","title":"Compiling","text":"<p>To build the code:</p> <pre><code>cd Lagrange\nmkdir build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Release\n</code></pre> <p>You can then select the Lagrange modules to build with <code>cmake-gui .</code> or specify them from command line with:</p> <pre><code>cmake .. -DLAGRANGE_MODULE_&lt;name&gt;=ON # For example, -DLAGRANGE_MODULE_UI=ON\n</code></pre> <p>To see available CMake options, please take a look at the file LagrangeOptions.cmake.sample in the root of the Lagrange repository.</p> <p>Setting Up CMake Options</p> <p>Lagrange has a lot of CMake options that can be configured. It may not be practical to pass those options via command-line, and manually checking boxes in CMake-GUI can be tedious. To facilitate setting up CMake options for Lagrange, simply rename <code>LagrangeOptions.cmake.sample -&gt; LagrangeOptions.cmake</code> and uncomment options that you wish to change.</p> <p>Note that since options are cached by CMake, you will need to delete your <code>&lt;build&gt;/CMakeCache.txt</code> before re-running CMake in order for a change in <code>LagrangeOptions.cmake</code> to take effect.</p> <p>Useful CMake Options</p> <ul> <li><code>LAGRANGE_UNIT_TESTS</code>: build unit tests.</li> <li><code>LAGRANGE_PERFORMANCE_TESTS</code>: build performance tests.</li> <li><code>LAGRANGE_EXAMPLES</code>: build examples.</li> <li><code>LAGRANGE_USE_PCH</code>: build with precomplied headers.</li> <li><code>LAGRANGE_WITH_ONETBB</code>: build with oneTBB.</li> <li><code>LAGRANGE_WITH_TRACY</code>: build with tracy profiling support.</li> <li><code>USE_SANITIZER</code>: build with sanitizer support, options are \"Address\", \"Memory\", \"MemoryWithOrigins\", \"Undefined\", \"Thread\", \"Leak\".</li> </ul> <p>Finally, build with</p> <pre><code>cmake --build . -j 8\n</code></pre> <p>Compilation Issues</p> <p>If an issue occurs during compilation, especially after an update, try to</p> <ol> <li>Delete your <code>&lt;build&gt;/CMakeCache.txt</code> and re-run CMake to configure your project.</li> <li>The nuclear option: delete the whole <code>&lt;build&gt;</code> folder and re-run CMake to configure your project.</li> </ol> <p>If neither option works, please ask for help on #lib-lagrange.</p>"},{"location":"build/#unit-tests","title":"Unit Tests","text":"<p>When <code>LAGRANGE_UNIT_TESTS</code> is <code>ON</code>, unit tests are built automatically. To run all unit tests, either run the special target <code>RUN_TESTS</code> in your Visual Studio/Xcode project, or simply run <code>ctest</code> in the command-line in your build folder. Further instructions on running unit tests are available on this page.</p>"},{"location":"build/#platform-specific-steps","title":"Platform-Specific Steps","text":""},{"location":"build/#windows","title":"Windows","text":"<p>For Visual Studio, you might have to force 64-bit compilation depending on your exact compiler version, e.g.:</p> <pre><code>cmake -A x64 ..\ncmake -G \"Visual Studio 17 2022\" -A x64 ..\ncmake -G \"Visual Studio 16 2019\" -A x64 ..\ncmake -G \"Visual Studio 15 2017 Win64\" ..\ncmake -G \"Visual Studio 14 2015 Win64\" ..\n</code></pre>"},{"location":"build/#unix","title":"Unix","text":"<p>You may have to install Zenity for the file dialog window to work:</p> <pre><code>sudo apt-get install zenity\n</code></pre>"},{"location":"build/#run","title":"Run","text":"<p>Executables are compiled into the following folders:</p> <ul> <li><code>&lt;build&gt;/examples</code> for examples covering various Lagrange features.</li> <li><code>&lt;build&gt;/tests</code> for unit test executables.</li> <li><code>&lt;build&gt;/performance</code> for performance test executables (legacy code).</li> </ul>"},{"location":"build/#dependencies","title":"Dependencies","text":"<p>Lagrange's CMake build system will download and build any and all dependencies required by the current build setup. This includes both core dependencies (e.g., Eigen) and optional ones (e.g., tinyobjloader for the IO module). If you are using Lagrange in your project and you wish to override Lagrange dependencies, make sure they are specified as CMake targets before calling <code>add_subdirectory(&lt;lagrange&gt;)</code>.</p>"},{"location":"goals/","title":"Library Goals &amp; Design Principles","text":"<p>There are a lot of geometry processing libraries out there, and it might be a little confusing where Lagrange stands in the current landscape. In this page, we highlight some of the goals and key design principles that go into Lagrange.</p> <ol> <li> <p>Do Not Reinvent The Wheel. If a library exists that already solves a particular problem    (nanoflann, embree, etc.) we will use it instead of reinventing the wheel. As such, we have    libigl-style wrappers around some common third-party libraries. Note that we only use external    libraries that are available under commercial friendly licenses. Please consult our dedicated    page for more information.</p> </li> <li> <p>Powerful Mesh Data Structure. Our mesh data structure can represent any type of mesh    (triangle mesh, quad-dominant, polygonal mesh, 2D, 3D, etc.). It is memory-efficient, support    generic attributes, navigation, dynamic editing, etc. More information is available on our    dedicated Mesh Class user guide.</p> </li> <li> <p>Interoperability. Our mesh data structure is designed to allow wrapping any continuous    buffers as regular mesh attributes. This allows creating a Lagrange mesh from an external buffer    without copying any data, as long as memory layout is compatible. Furthermore, you can export    attributes to reuse our buffers after a mesh object is destroyed. And because our attributes can    be viewed as Eigen matrices, our mesh data structure is directly compatible with libigl. We are    planning to implement conversion functions for other mesh processing libraries in the future.</p> Interoperability With Others Libraries Name From Lagrange Mesh To Lagrange Mesh Comment cinolib geogram Planned. geometry-central Planned. libigl  (no copy)  (may copy) pmp-library </li> <li> <p>Clean Build System. Lagrange has a clean and polished CMake build system. Getting started    with Lagrange is incredibly simple, just add 5 lines to your CMake project (no git submodule    needed):</p> <pre><code>include(FetchContent)\nFetchContent_Declare(lagrange\nGIT_REPOSITORY &lt;lagrange-url&gt;\nGIT_TAG        &lt;sha256&gt;\n)\nFetchContent_MakeAvailable(lagrange)\n\ntarget_link_libraries(my_project PUBLIC lagrange::core)\n</code></pre> <p>If you are not a fan of CMake, all Lagrange modules follow the same organization, so it should be easy to add them to your build system, provided you can compile the required dependencies.</p> </li> <li> <p>Ease Of Use. Lagrange meshes have a clean and well-documented API. Any mesh attribute can be    viewed as a Eigen matrix, ensuring compatibility with libigl functions. Combined with our simple    CMake system, Lagrange is an ideal framework for prototyping C++ applications with advanced    geometry processing features.</p> </li> <li> <p>Modularity. Lagrange features are split into modules, based on specific features and    dependencies. Module names are sensible and short. While <code>lagrange::core</code> is relatively small,    bringing additional modules to your project can provide more advanced features.</p> </li> <li> <p>File Formats. Our IO module supports reading/writing a variety of standard file formats used    in the industry. Rather than writing our own parsers, we leverage existing libraries such as    tinyobj to provide IO functionalities.</p> Supported File Formats </li> <li> <p>Performance. Lagrange functions are written with performance in mind. We use TBB for    multithreading, and avoid unnecessary heap memory allocation or data copies. Lagrange should be    able to process large assets that are often encountered in the industry. If you encounter any    performance limitation, please reach out to us.</p> </li> <li> <p>Advanced Viewer. We provide an advanced mesh viewer for building interactive applications with realistic shading. We use a modified ImGui that conforms to the Spectrum specification to provide a user experience more consistent with Adobe products.</p> Viewer Key Features <ul> <li>Support for all lagrange mesh types</li> <li>Customizable renderer that includes PBR</li> <li>Gizmos for interactive mesh and element manipulation</li> <li>Easy to add your own UI via ImGui</li> <li>Variety of visualization options - mix and match indexing/colormapping/rendered primitive/shading.</li> </ul> </li> <li> <p>Robustness/Support. Being backed by a company, Lagrange has a strong focus on correctness/being as bug free as possible. We have extensive unit testing internally, with more than 400 unit tests. Specifically, we try to ensure the following:</p> <ul> <li>Corner Cases. Special cases should not crash the program. Incorrect inputs may result in exceptions being thrown.</li> <li>Determinism. Parallel algorithms should produce the same results when called repeatedly with the same inputs.</li> <li>Regression Tests. We should have unit tests to ensure that algorithms produce the same output whenever code changes. Changes in algorithm behaviors should be documented.</li> <li>Cross-Platform. Algorithms should produce the same result on all three platforms whenever possible (macOS/Linux/Windows). This means avoiding <code>std::default_random_engine</code> and other platform-specific constructs.</li> </ul> </li> <li>Useful Feedbacks. Being integrated into a product means we often need to provide some simple feedback mechanisms, such as logging, cancellation and progress report.<ul> <li>Logger. We use spdlog to provide beautiful logging messages. The global logger is thread-safe, and can be turned off or redirected as needed by the client application.</li> <li>Cancellation. It should be possible to cancel any running function by switching a <code>std::atomic_bool &amp;</code> flag.</li> <li>Progress Report. A simple thread-safe callback mechanism can be used in certain functions to report progress. This is useful to inform the user about the advancement of certain tasks that can be slow (e.g. mesh cleanup, etc.).</li> <li>Error Mechanism. We use exception throwing as the mechanism to report an error. While returning error code has certain advantages over exceptions, third-party libraries or the STL can still throw exceptions, and thus it is the user's responsibility to catch them should they occur.</li> </ul> </li> <li>Documentation/Code Style. Our codebase is formatted via clang-format for consistency. We aim to provide both libigl-style tutorials to get started using Lagrange, as well as detailed API documentation written in Doxygen.</li> </ol> <ol> <li> <p>Requires Assimp to be enabled.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"goals/#legacy-mesh-io","title":"Legacy Mesh IO","text":"<p>IO for our legacy Mesh class (will be retired in the future).</p> Format Read Write Comment FBX Via Assimp glTF Via Assimp HDF5 Planned OBJ Via tinyobj/libigl OFF Via libigl PLY Via tinyply/libigl USD Planned VTK Custom writer"},{"location":"goals/#surface-mesh-io","title":"Surface Mesh IO","text":"<p>IO for our new polygonal mesh class.</p> Format Read Write Comment FBX 1 Via Assimp glTF Via tinygltf HDF5 Planned MSH Via MshIO OBJ Read via tinyobj, custom writer PLY Read via libigl, write via happly USD Planned Other 1 Via Assimp"},{"location":"goals/#simple-scene-io","title":"Simple Scene IO","text":"<p>IO for our simple scene class, supporting a list of instanced meshes.</p> Format Read Write Comment glTF Via tinygtlf FBX 1 Via Assimp Other 1 Via Assimp"},{"location":"setup/","title":"Getting Started","text":""},{"location":"setup/#compiling-lagrange","title":"Compiling Lagrange","text":"<ul> <li>How to compile Lagrange.</li> <li> <p>How to run unit tests.</p> </li> <li> <p>Example project template using Lagrange.</p> </li> </ul>"},{"location":"setup/#contributing","title":"Contributing","text":"<ul> <li>Read our contributing page.</li> <li>Read our code style guide.</li> </ul>"},{"location":"third-party/","title":"Third Party Libraries","text":""},{"location":"third-party/#external-dependencies","title":"External Dependencies","text":"<p>Here is a list of third party libraries used in Lagrange. Those external dependencies will be automatically downloaded by our CMake system depending on which Lagrange module is enabled.</p> <p>Direct vs Indirect Dependencies</p> <p>This table only lists direct dependencies of various Lagrange modules. Indirect dependencies are not listed there. </p> Library Name License Used By Assimp1 BSD-3 IO Boost2 Boost FS CLI11 BSD-3 Examples3, Performance Tests (Core) Catch2 Boost Testing Dear ImGui MIT UI Eigen MPL2 Core, UI Embree Apache 2 Raycasting EnTT MIT UI Filesystem4 MIT FS GLFW MIT UI Happly MIT IO ImGuizmo MIT UI JSON for Modern C++ MIT Examples (Winding), UI Libigl MPL2 BVH, IO METIS Apache 2 Partitioning MikkTSpace zlib Unit Tests (Core) MshIO Apache 2 IO Nanobind BSD-3 Python OpenSubdiv Apache 2 Subdivision OpenVDB MPL2 Volume Portable File Dialogs WTFPL (public domain) UI StackWalker BSD-2 Testing Threading Building Blocks Apache 2 Core Tracy5 BSD-3 Core WindingNumber MIT Unit Tests (Winding), Winding gl3w MIT UI imgui fonts MIT UI nanoflann BSD-2 BVH, UI span-lite Boost Core spdlog MIT Core stb Public domain UI, Unit Tests (IO) tinygltf MIT IO tinyobjloader MIT IO"},{"location":"third-party/#bundled-dependencies","title":"Bundled Dependencies","text":"<p>Lagrange integrates some third-party code directly into its codebase. Those files have usually been modified to work with Eigen, and their functions wrapped into the <code>lagrange</code> namespace. This table summarize the list of third-party code that is directly bundled into Lagrange, as well as the appropriate licenses and files that are affected.</p> Library Name License Used By Files Boost.Functional/Hash Boost Core hash.h Christer Ericson, Real-Time Collision Detection Software License Agreement Core segment_segment_squared_distance.h CMake Scripts Apache 2 CMake Build System sanitizers.cmake, code-coverage.cmake CPM MIT CMake Build System CPM.cmake e-maxx.ru Public domain Core remove_duplicate_facets.cpp Earcut ISC Core earcut.h Embree Apache 2 Raycasting embree_closest_point.h Floating-point exception handling example Public domain Core fpe.cpp function_ref CC0 Core function_ref.h Geogram BSD-3 Core point_triangle_squared_distance.h, point_segment_squared_distance.h ImGui Progress Indicators MIT UI progress.h, progress.cpp Libigl MPL-2.0 Core bfs_orient.h, doublearea.h, orientable_patches.h, unique_rows.h, vertex_components.h scope_guard Public domain Core scope_guard.h Shewchuk's predicates Public domain Core predicates.cpp small_vector Unlicense Core SmallVector.h smart_ptr MIT Core control_block.h, default_delete.h, ptr.h, shared_ptr.h, weak_ptr.h valuable MIT Core value_ptr.h <ol> <li> <p>Assimp is an optional dependency of the IO module.\u00a0\u21a9</p> </li> <li> <p>Boost::filesystem is an optional backend of the FS module.\u00a0\u21a9</p> </li> <li> <p>CLI11 is used by the examples in the following modules: BVH, Core, IO, Partitioning, Raycasting, Subdivision, UI, Volume, Winding\u00a0\u21a9</p> </li> <li> <p><code>gulrak/filesystem</code> is only needed when the IO module is compiled in C++14 mode. In C++17 mode, the IO module will defaults to <code>std::filesystem</code>.\u00a0\u21a9</p> </li> <li> <p>Tracy is an optional dependency of the core module.\u00a0\u21a9</p> </li> </ol>"},{"location":"dev/clangd/","title":"Autocompletion With Clangd","text":"<p>Are you coding in a text editor like Vim/NeoVim, VSCode, Sublime, and miss powerful IDE features such as provided by Visual Studio? The new kid in the block for intelligent autocompletion and smart code editing is clangd.</p>"},{"location":"dev/clangd/#retrieve-llvm-and-clangd","title":"Retrieve LLVM and Clangd","text":"<p>clangd is part of the LLVM project, so it should be present on your machine if you have a local installation of llvm-clang. However, due to certain issues with header-only code completion, as of today (05-18-20) we need to compile LLVM from source and patch it manually for it to work well with Lagrange:</p> <ol> <li> <p>Clone the LLVM git repository (we used <code>7ee479a76</code> as of this writing)     <pre><code>git clone --depth 1 https://github.com/llvm/llvm-project.git\ncd llvm-project\n</code></pre></p> </li> <li> <p>Download and apply patch for this issue (if still    applicable)     <pre><code>wget https://reviews.llvm.org/file/data/p524ff355qzqwqvmqoiy/PHID-FILE-agyvgty5nzpa5wvyoice/D78038.diff\ngit apply D78038.diff\n</code></pre></p> </li> <li> <p>Build clang and clangd:     <pre><code>mkdir build\ncd build\ncmake -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr/local/opt/llvm-git lang -DLLVM_ENABLE_PROJECTS=\"clang;clang-tools-extra;libcxx;libcxxabi;polly;lldb;lld;compiler-rt\" ../llvm\nninja\nninja install\n</code></pre>     You can change the install directory from <code>/usr/local/opt/llvm-git</code> to suit your preference.</p> </li> </ol>"},{"location":"dev/clangd/#install-editor-plugin-for-clangd","title":"Install Editor Plugin For Clangd","text":"<p>Please check out the clangd website for instructions on how to install the clangd plugin for your favorite editor. In this tutorial we will use VSCode. Users of Vim/NeoVim can also check out coc.vim.</p> <p>For the VSCode plugin, do not forget to set the <code>clangd</code> path to the binary compiled in the previous step: <pre><code>\"clangd.path\": \"/usr/local/opt/llvm-git/bin/clangd\"\n</code></pre></p> <p>Also the <code>compile_commands.json</code> file should be in your project root folder, and the default Microsoft C/C++ plugin (Intellisense...) must be uninstalled or disabled.</p>"},{"location":"dev/clangd/#configure-your-project","title":"Configure Your Project","text":""},{"location":"dev/clangd/#cmake","title":"CMake","text":"<p>Make sure you configure your CMake project with the following options:</p> <pre><code># Generates a `compile_commands.json` that can be used for autocompletion\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON CACHE BOOL \"Enable/Disable output of compile commands during generation.\")\n\n# Use a specific C/C++ compiler, e.g. llvm-clang on macOS (so we can use clangd)\nset(CMAKE_C_COMPILER   \"/usr/local/opt/llvm-git/bin/clang\" CACHE STRING \"C compiler\" FORCE)\nset(CMAKE_CXX_COMPILER \"/usr/local/opt/llvm-git/bin/clang++\" CACHE STRING \"C++ compiler\" FORCE)\n</code></pre> <p>You can also pass those options via the command line when you first configure your project (<code>cmake -DCMAKE_CXX_COMPILER=&lt;...&gt; ..</code>). For Lagrange, you can put those lines in a file <code>LagrangeOptions.cmake</code> at the root of the repository. When configuring your own CMake project, make sure the <code>CMAKE_CXX_COMPILER</code> cache variable is set before the first call to <code>project()</code> in your CMake script.</p>"},{"location":"dev/clangd/#xcode","title":"Xcode","text":"<p>If you have an xcode project (generated by gyp or metabuild) for example, you can use xcpretty to generate the <code>compile_commands.json</code> (thanks to this link).</p> <ul> <li>Install xcpretty <code>sudo gem install xcpretty</code>.</li> <li>Clean up your project <pre><code>xcodebuild clean -project /path/to/project.xcodeproj -scheme main/scheme/name\n</code></pre></li> <li>Generate the compile commands <pre><code>xcodebuild -project /path/to/project.xcodeproj -scheme main/scheme/name | xcpretty -r json-compilation-database -o compile_commands.json\n</code></pre></li> </ul>"},{"location":"dev/clangd/#better-completion-database","title":"Better Completion Database","text":"<p>By default, the <code>compile_commands.json</code> generated by CMake only contains compilation instructions for each translation unit in your project. We will use compdb to generate a new compilation database that includes header files.</p> <ol> <li> <p>Install compdb using pip:     <pre><code>pip install --user compdb\n</code></pre>     You can also install compdb via conda using     the following environment:     <pre><code>name: compdb\ndependencies:\n  - python=3.7\n  - pip\n  - pip:\n    - compdb\n</code></pre></p> </li> <li> <p>Generate a new completion database containing header files:     <pre><code>python -m compdb -p /folder/containing/initial/compile_commands.json list &gt; compile_commands.json\n</code></pre>     This last step needs to be re-run anytime you add a new file to your project, or change any     compilation options.</p> </li> </ol>"},{"location":"dev/clangd/#enjoy","title":"Enjoy!","text":""},{"location":"dev/code-style/","title":"Code Style","text":"<p>Apply Clang Format</p> <p>Our code style configuration is stored in a file <code>.clang-format</code> at the root of the repository. It is highly recommended that you install and configure ClangFormat for your favorite editor. This will allow you to automatically format your code to adopt a consistent style with the rest of Lagrange.</p> <p>We follow the Google C++ Style Guide, modified for the needs of the Lagrange project. To get a quick taste of our style, here is a simple function declaration:</p> <pre><code>#include &lt;lagrange/compute_vertex_normal.h&gt;\n\nnamespace lagrange {\n\n/**\n * One sentence description of the function.\n *\n * More detailed description (optional).\n *\n * @param[in]  input_mesh  Input mesh description.\n *\n * @tparam     MeshType    Mesh type.\n */\ntemplate &lt;typename MeshType&gt;\nvoid process_mesh(std::shared_ptr&lt;MeshType&gt; input_mesh)\n{\n...\ncompute_vertex_normal(input_mesh);\n...\n}\n\n} // namespace lagrange\n</code></pre> <p>and here is an example for class declaration:</p> <pre><code>namespace lagrange {\n\n/**\n * One sentence description of the class.\n *\n * @tparam     MeshType  Mesh type.\n */\ntemplate &lt;typename MeshType&gt;\nclass MeshProcesser\n{\npublic:\n/**\n     * One sentence description.\n     *\n     * @param[in]  mesh  Mesh description.\n     */\nvoid set_mesh(std::shared_ptr&lt;MeshType&gt; mesh)\n{\n// Inline comment\nm_mesh = mesh;\n}\n\nprivate:\nstd::shared_ptr&lt;MeshType&gt; m_mesh;\n};\n\n} // namespace lagrange\n</code></pre> <p>Here are a few items to highlight:</p> <ul> <li>Indentation consists of 4 spaces.</li> <li>Keep each line below 100 characters long.</li> <li>All functions and classes should be inside of the <code>lagrange</code> namespace.<ul> <li>All the code in the <code>core</code> module lives directly under the <code>lagrange</code> namespace.</li> <li>Individual modules use their own sub-namespace, e.g. <code>lagrange::io</code>.</li> </ul> </li> <li>C++ <code>namespace</code> is not indented.</li> <li>Function and variable names are in snake_case while class names are in CamelCase.</li> <li>Member variables are prefixed with <code>m_</code>.</li> <li>The opening bracket placement is dictated by our <code>.clang-format</code>: always attach braces to surrounding context, except for functions and classes, where it is placed on a newline.</li> <li>Commented/dead code should be removed.</li> <li>New code is encouraged to use Doxygen-style comments if possible, in particular for public headers. Here is an example for a function, and for a class.</li> <li>When in doubt, we recommend using fenced <code>/** */</code> blocks for function/class descriptions, and <code>//</code> for inline comments.</li> <li><code>#include</code> statement uses full path in angle brackets, for example:   <pre><code>#include &lt;lagrange/filename.h&gt;\n</code></pre></li> <li>The order of <code>#include</code> statements should be local to global, as explained in this post:<ol> <li>Immediate <code>.h</code> file that this file is implementing if applicable.</li> <li>Lagrange headers.</li> <li>Third party dependency headers if any.</li> <li>C/C++ system headers if any.</li> </ol> </li> </ul> <p>Lastly, no style guide is complete or correct all the time. Older code in Lagrange may not follow all the items described here. Use your professional judgment when necessary.</p>"},{"location":"dev/compilation-profiling/","title":"Profiling Compilation Times","text":"<p>Who doesn't love a slow compiling C++ project? Here are some simple tools to help you figure out which part of your project takes the cake when it comes to compilation times. Once you have a better idea of what to improve, head over to our Speeding Up Compilation page for some tips on how to improve this.</p>"},{"location":"dev/compilation-profiling/#using-ninja","title":"Using Ninja","text":"<p>When compiling a CMake project using Ninja instead of Make or MSBuild, one can use ninjatracing to convert ninja log files to chrome's <code>about:tracing</code> format:</p> <p></p> <p>To build a project with Ninja, simply use the <code>-G Ninja</code> when generating the build system:</p> <pre><code>mkdir build\ncd build\ncmake -G Ninja ..\nninja # Or cmake --build .\n</code></pre> <p>Windows &amp; Ninja</p> <p>The Ninja generator is also available on Windows. Make sure you are in a x64 Visual Studio Developer Command Prompt before running <code>cmake -G ...</code>.</p> <p>Once you have build your project with Ninja, you can convert the log files with ninjatracing:</p> <pre><code>ninjatracing $BUILD_DIR/.ninja_log &gt; trace.json\n</code></pre> <p>Open the resulting <code>trace.json</code> in Chrome (<code>about:tracing</code>).</p> <p>Incremental Compilation</p> <p>When incrementally compiling an existing project, only newly compiled files will appear in the <code>trace.json</code> file produced by ninjatracing.</p>"},{"location":"dev/compilation-profiling/#using-clang-ninja","title":"Using Clang + Ninja","text":"<p>When compiling with clang, one can use the -ftime-trace flag to get detailed information on where clang spends most of its time compiling your project:</p> <pre><code>cmake -G Ninja -DCMAKE_CXX_FLAGS=\"-ftime-trace\" ..\nninja\n</code></pre> <p>Then, simply add <code>-e</code> to the <code>ninjatracing</code> call:</p> <pre><code>ninjatracing -e $BUILD_DIR/.ninja_log &gt; trace.json\n</code></pre> <p>Open the resulting trace file in Chrome: </p>"},{"location":"dev/compilation-profiling/#using-the-clang-build-analyzer","title":"Using The Clang Build Analyzer","text":"<p>Go to the Clang Build Analyzer repository and compile the tool, then simply follow the instructions in the README (copied below):</p>"},{"location":"dev/compilation-profiling/#usage","title":"Usage","text":"<ol> <li>Start the build capture: <code>ClangBuildAnalyzer --start &lt;artifacts_folder&gt;</code>    This will write current timestamp in a <code>ClangBuildAnalyzerSession.txt</code> file under the given <code>artifacts_folder</code>. The artifacts    folder is where the compiled object files (and time trace report files) are expected to be produced by your build.</li> <li>Do your build. Does not matter how; an IDE build, a makefile, a shell script, whatever. As long as it invokes    Clang and passes <code>-ftime-trace</code> flag to the compiler (Clang 9.0 or later is required for this).</li> <li>Stop the build capture: <code>ClangBuildAnalyzer --stop &lt;artifacts_folder&gt; &lt;capture_file&gt;</code>    This will load all Clang time trace compatible <code>*.json</code> files under the given <code>artifacts_folder</code> that were modified after    <code>--start</code> step was done (Clang <code>-ftime-trace</code> produces one JSON file next to each object file), process them and store data file into    a binary <code>capture_file</code>.</li> <li>Run the build analysis: <code>ClangBuildAnalyzer --analyze &lt;capture_file&gt;</code>    This will read the <code>capture_file</code> produced by <code>--stop</code> step, calculate the slowest things and print them. If a    <code>ClangBuildAnalyzer.ini</code> file exists in the current folder, it will be read to control how many of various things to print.</li> </ol> <p>Aternatively, instead of doing <code>--start</code> and <code>--stop</code> steps, you can do <code>ClangBuildAnalyzer --all &lt;artifacts_folder&gt; &lt;capture_file&gt;</code> after your build; that will include all the compatible <code>*.json</code> files for analysis, no matter when they were produced.</p>"},{"location":"dev/compilation-profiling/#analysis-output","title":"Analysis Output","text":"<p>The analysis output will look something like this:</p> <pre><code>Analyzing build trace from 'artifacts/FullCapture.bin'...\n**** Time summary:\nCompilation (1761 times):\n  Parsing (frontend):         5167.4 s\n  Codegen &amp; opts (backend):   7576.5 s\n\n**** Files that took longest to parse (compiler frontend):\n 19524 ms: artifacts/Modules_TLS_0.o\n 18046 ms: artifacts/Editor_Src_4.o\n 17026 ms: artifacts/Modules_Audio_Public_1.o\n 16581 ms: artifacts/Runtime_Camera_4.o\n\n**** Files that took longest to codegen (compiler backend):\n145761 ms: artifacts/Modules_TLS_0.o\n123048 ms: artifacts/Runtime_Core_Containers_1.o\n 56975 ms: artifacts/Runtime_Testing_3.o\n 52031 ms: artifacts/Tools_ShaderCompiler_1.o\n\n**** Templates that took longest to instantiate:\n 19006 ms: std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::... (2665 times, avg 7 ms)\n 12821 ms: std::__1::map&lt;core::basic_string&lt;char, core::StringStorageDefault&lt;ch... (250 times, avg 51 ms)\n  9142 ms: std::__1::map&lt;core::basic_string&lt;char, core::StringStorageDefault&lt;ch... (432 times, avg 21 ms)\n  8515 ms: std::__1::map&lt;int, std::__1::pair&lt;List&lt;ListNode&lt;Behaviour&gt; &gt; *, List... (392 times, avg 21 ms)\n\n**** Functions that took longest to compile:\n  8710 ms: yyparse(glslang::TParseContext*) (External/ShaderCompilers/glslang/glslang/MachineIndependent/glslang_tab.cpp)\n  4580 ms: LZ4HC_compress_generic_dictCtx (External/Compression/lz4/lz4hc_quarantined.c)\n  4011 ms: sqlite3VdbeExec (External/sqlite/sqlite3.c)\n  2737 ms: ProgressiveRuntimeManager::Update() (artifacts/Editor_Src_GI_Progressive_0.cpp)\n\n*** Expensive headers:\n136567 ms: /BuildEnvironment/MacOSX10.14.sdk/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h (included 92 times, avg 1484 ms), included via:\n  CocoaObjectImages.o AppKit.h  (2033 ms)\n  OSXNativeWebViewWindowHelper.o OSXNativeWebViewWindowHelper.h AppKit.h  (2007 ms)\n  RenderSurfaceMetal.o RenderSurfaceMetal.h MetalSupport.h Metal.h MTLTypes.h  (2003 ms)\n  OSXWebViewWindowPrivate.o AppKit.h  (1959 ms)\n  ...\n\n112344 ms: Runtime/BaseClasses/BaseObject.h (included 729 times, avg 154 ms), included via:\n  PairTests.cpp TestFixtures.h  (337 ms)\n  Stacktrace.cpp MonoManager.h GameManager.h EditorExtension.h  (312 ms)\n  PlayerPrefs.o PlayerSettings.h GameManager.h EditorExtension.h  (301 ms)\n  Animation.cpp MaterialDescription.h  (299 ms)\n  ...\n\n103856 ms: Runtime/Threads/ReadWriteLock.h (included 478 times, avg 217 ms), included via:\n  DownloadHandlerAssetBundle.cpp AssetBundleManager.h  (486 ms)\n  LocalizationDatabase.cpp LocalizationDatabase.h LocalizationAsset.h StringTable.h  (439 ms)\n  Runtime_BaseClasses_1.o MonoUtility.h ScriptingProfiler.h  (418 ms)\n  ...\n</code></pre>"},{"location":"dev/contribute/","title":"Contributor Guidelines","text":"<p>So, you want to contribute code to Lagrange? Great! Here are a few bits of information and tips:</p>"},{"location":"dev/contribute/#checklist","title":"Checklist","text":"<ol> <li>Fork the Lagrange repository in    GitHub.</li> <li>Check our code of conduct.</li> <li>Check our code style + make sure .clang-format is applied.</li> <li>Run unit tests + upload your own unit test data to our test data    repository.</li> <li>Push your work to a new branch in your own fork.</li> <li>Open a pull request on github and give it a readable    title.</li> </ol>"},{"location":"dev/contribute/#coding-style-and-conventions","title":"Coding Style And Conventions","text":"<p>Please check our coding style guide.</p> <p>Unfortunately, some files in Lagrange may not be following the above guide. If you change those files, feel free to fix them accordingly, or respect the existing style. Do not output a file with inconsistent code style.</p> <p>Try to write code that compiles without compiler warnings. Follow the general design principles. Check the mesh class for common functionality, and use similar template and type names. Use utility functions for common functionalities such as logging, timing, casting, and optionally ranges.</p>"},{"location":"dev/contribute/#creating-new-files","title":"Creating New Files","text":"<p>Please name your new file consistently with the functionality implemented inside. Use lowercase <code>compute_something.h</code> for functions and Uppercase <code>SomeNewType.h</code> for types (classes). If your file contains more than one function, please document an overview of the contents at the top. After creating the new file, you may need to add it to the CMake build system, and run <code>cmake ..</code> again.</p>"},{"location":"dev/contribute/#adding-a-new-module","title":"Adding A New Module","text":"<p>It is possible for your contribution to justify the creation of a new Lagrange module. This is especially encouraged for large contributions, or those that require external dependencies.</p> <p>To create a new module, pick an expressive and concise name, and use it consistently across CMake, folders, and C++ namespaces. Use existing modules as reference. You should add your new module to the <code>modules</code> directory. Each module has similar subdirectory setup:</p> <ul> <li><code>CMakeLists.cmake</code> to specify how to build the module.</li> <li><code>include/lagrange/&lt;module_name&gt;/</code> contains the header files.</li> <li><code>src/</code> contains the source codes.</li> <li><code>tests/</code> contains unit tests specific to this module.</li> <li><code>performance/</code> contains performance tests.</li> <li><code>examples/</code> contains stand alone examples illustrating typical usage.</li> </ul>"},{"location":"dev/contribute/#adding-new-third-party-code","title":"Adding New Third-Party Code","text":"<p>License Considerations</p> <p>Make sure the third-party code uses an acceptable license. Please open an issue to discuss the matter if you are unsure about it.</p> <ul> <li>When adding a new third-party dependency:<ol> <li>Place the corresponding <code>foo.cmake</code> file in <code>cmake/recipes</code> following existing models.</li> <li>Update the <code>ALL_THIRD_PARTIES</code> in <code>scripts/lagrange_ci/third_parties.py</code> accordingly.</li> </ol> </li> <li>When adding new bundled code directly into the Lagrange repository:<ol> <li>Make sure the file header gives proper attribution to the source code origin.</li> <li>Update the <code>NOTICE_LIST</code> in <code>scripts/lagrange_ci/notice.py</code>.</li> </ol> </li> </ul>"},{"location":"dev/contribute/#unit-testing","title":"Unit Testing","text":"<p>Please check our unit tests guide. Tests are awesome and highly encouraged. You can add your unit tests in <code>modules/&lt;module_name&gt;/tests</code>.</p> <p>While developing your code, you can run only your specific test case(s) by passing the name(s) as argument to the test executable. You can also tag your new tests according to your new feature, and run all of them.</p> <pre><code>./tests/test_lagrange_core \"SafeCast\"  # Run SafeCast test case.\n./tests/test_lagrange_core \"[mesh]\"  # Run all test cases tagged with \"[mesh]\"\n</code></pre> <p>In case you also develop a small application that uses your new feature, feel free to include that in <code>modules/&lt;module_name&gt;/examples</code>.</p> <p>Legacy Performance Tests</p> <p>Some modules have a <code>modules/&lt;module_name&gt;/performance</code> subfolder containing some \"performance\" tests. This is legacy code. New benchmarking tests should be written along with other unit tests, use Catch2's benchmarking framework, and be tagged as <code>[!benchmark]</code>.</p>"},{"location":"dev/contribute/#pull-requests","title":"Pull Requests","text":"<p>You can create a pull request (PR) at any time from the GitHub web interface.  When your code is ready, request a review, and stay updated for any feedback.</p>"},{"location":"dev/runtime-profiling/","title":"Runtime Profiling with Tracy","text":"<p>Tracy is a real-time profiler using a client/server model. It is cross-platform (Windows, Linux, macOS) and support GPU (OpenGL, Vulkan, etc.). This page explains how to use Tracy with Lagrange.</p> <p></p>"},{"location":"dev/runtime-profiling/#enabling-the-tracy-client","title":"Enabling The Tracy Client","text":"<p>Tracy uses a client-server model to profile applications. This means we need to inject the Tracy client (a single .cpp file) into our application to enable profiling. To enable the Tracy client with Lagrange, simply enable the CMake option <code>LAGRANGE_WITH_TRACY</code> in your CMake setup.</p> <p>Compile Options</p> <p>On macOs and Linux, do not forget to compile your application with <code>-g</code>, <code>-fno-omit-frame-pointer</code>, and <code>-rdynamic</code> (see tracy manual for explanations). When using <code>LAGRANGE_WITH_TRACY=ON</code>, those options will be automatically enabled by the Lagrange CMake.</p>"},{"location":"dev/runtime-profiling/#instrumenting-your-code","title":"Instrumenting Your Code","text":"<p>The next step will be to instrument your code. In short:</p> <ol> <li>Include <code>&lt;Tracy.hpp&gt;</code> in every file you are interested in profiling.</li> <li>Add the macro <code>FrameMark</code> at the end of each frame loop.</li> <li>Add the macro <code>ZoneScoped</code> as the first line of your function definitions to include them in the    profile.</li> </ol> <p>Convenience Macros</p> <p>Since Tracy is an optional dependency in Lagrange, we provide a convenience header to include Tracy without having to test the <code>TRACY_ENABLE</code> macro:</p> <pre><code>#include &lt;lagrange/utils/tracy.h&gt;\n</code></pre> <p>This header provides the following alias macros for Tracy:</p> <ul> <li><code>LAGRANGE_ZONE_SCOPED</code> for <code>ZoneScoped</code></li> <li><code>LAGRANGE_FRAME_MARK</code> for <code>FrameMark</code></li> </ul> <p>When Tracy is disabled (<code>LAGRANGE_WITH_TRACY=OFF</code> in CMake), these macros will expand to a no-op.</p>"},{"location":"dev/runtime-profiling/#running-the-tracy-profiler","title":"Running The Tracy Profiler","text":"<p>Make sure to compile the profiler (server) using the same version of Tracy as in Lagrange. The easiest way to do so is to build from the <code>&lt;build&gt;/_deps/tracy-src</code>. This folder is downloaded by CMake when building Lagrange with <code>LAGRANGE_WITH_TRACY=ON</code>.</p>"},{"location":"dev/runtime-profiling/#windows","title":"Windows","text":"<ol> <li>Download the pre-built binaries corresponding to the version of Tracy used in Lagrange (see    <code>cmake/recipes/external/tracy.cmake</code>).</li> <li>Run the Tracy executable and your program.</li> <li>Click \"Connect\" in the Tracy profiler.</li> </ol>"},{"location":"dev/runtime-profiling/#macos","title":"macOS","text":"<ol> <li>Install prerequisites using homebrew     <pre><code>brew install freetype capstone gtk glfw\n</code></pre></li> <li>Build the profiler (server):     <pre><code>cd &lt;build&gt;/_deps/tracy-src/profiler/build/unix\nmake release -j8\n</code></pre></li> <li>Run the profiler:     <pre><code>./Tracy-release\n</code></pre></li> <li>Run your program, and click \"Connect\" in the Tracy profiler.</li> </ol>"},{"location":"dev/speeding-up-compilation/","title":"Tips To Speed Up Compilation Times","text":"<p>If your hand has reached too deep into the depth of C++ template meta-programming and header-only libraries, you might find yourself in a hot mess of slow-compiling projects and long wait-time between recompilations.</p> <p></p> <p>Unfortunately, it is very easy to shoot oneself in the foot and blow up compilation times in a C++ project. In this page we will discuss various ways to alleviate the problem.</p>"},{"location":"dev/speeding-up-compilation/#placebo-solutions","title":"Placebo Solutions","text":"<p>These are some \"simple\" solutions we can use to treat the symptoms (slow compile times) without addressing the root cause (code architecture). Pre-compiled headers are pretty much a no-brainer to use with CMake, and may or may not provide some speedup in your project. On Windows, many people use IncrediBuild for distributed compilation/caching to dramatically improve compilation performance. On Linux and macOS, you can use ccache for to improve the performance of repeated builds. Combined with a shared cache database stored in a Redis server, this will provide additional performance (e.g. in a Jenkins build cluster). sccache is an alternative to ccache that also works on Windows and support cloud storage. Finally, for distributed compilation on Linux, you can also look into icecream.</p>"},{"location":"dev/speeding-up-compilation/#use-pre-compiled-headers","title":"Use Pre-Compiled Headers","text":"<p>The basic CMake file to enable pre-compiled headers for your project look like this:</p> <pre><code># We use an interface target to define commonly used pre-compiled headers\nadd_library(mylib_pch INTERFACE)\n\n# Always define an alias in the form foo::bar to prevent silly CMake errors\nadd_library(mylib::pch ALIAS mylib_pch)\n\n# Define commonly used headers here\ntarget_precompile_headers(mylib_pch INTERFACE\n# C++ headers\n&lt;algorithm&gt;\n&lt;chrono&gt;\n&lt;functional&gt;\n\n# Third party libraries\n&lt;Eigen/Core&gt;\n\n# Your own library headers\n&lt;mylib/common.h&gt;\n&lt;mylib/Mesh.h&gt;\n&lt;mylib/logger.h&gt;\n)\n\n# Reuse the same pre-compiled headers for both lib, executable and unit tests\n# (but do not make it a PUBLIC dependency of `mylib`).\ntarget_link_libraries(mylib PRIVATE mylib::pch)\ntarget_link_libraries(myexecutable PRIVATE mylib::pch)\n</code></pre> <p>Choice of Precompiled Headers</p> <p>You want to add headers that are used often in the project, ideally in at least a third of the compilation units. Avoid adding a header to PCH if you are actively working on it.</p> <p>And that's it! Please consult the official documentation of the target_precompile_headers() function for more information. For example, one could use the <code>REUSE_FROM</code> syntax to reuse a list of pre-compiled headers from one target to the next, rather than using an interface target for this purpose.</p>"},{"location":"dev/speeding-up-compilation/#using-ccache","title":"Using ccache","text":"<p>Ccache can be used to speed up compilation on macOS and Linux. There are similar tools that also work on Windows, such as sscache (developed by Mozilla).</p> <p>First, make sure you set a cache size large enough to accommodate your C++ projects: <pre><code>ccache -M 100G # set max cache size\nccache -s # show stats\n</code></pre></p> <p>To enable ccache in a CMake project, simply set the <code>CMAKE_CXX_COMPILER_LAUNCHER</code> variable to the ccache executable. This simple CMake snippet will work on machines with and without ccache installed:</p> <pre><code>find_program(CCACHE_PROGRAM ccache)\nif(CCACHE_PROGRAM)\nset(CMAKE_C_COMPILER_LAUNCHER   ${CCACHE_PROGRAM})\nset(CMAKE_CXX_COMPILER_LAUNCHER ${CCACHE_PROGRAM})\nendif()\n</code></pre> <p>Without any additional settings however, it is likely that you will not have as many cache hits as you would like. Here are some important settings to experiment with:</p> <ul> <li><code>CCACHE_BASEDIR</code>: Should be set to either <code>${CMAKE_BINARY_DIR}</code> or <code>${CMAKE_SOURCE_DIR}</code>.</li> <li><code>CCACHE_SLOPPINESS</code>: When using pre-compiled headers, it is important to define this to   <code>pch_defines,time_macros</code>. Other settings may improve cache hit performance, such as   <code>include_file_mtime</code>.</li> <li><code>CCACHE_PREFIX</code>: Should be set when combining ccache with another compiler wrapper (such as   distcc or icecc for distributed compilation, e.g. <code>CCACHE_PREFIX=icecc</code>).</li> </ul> <p>To set those options from your CMake project, you can use the following code snippet:</p> <pre><code>find_program(CCACHE_PROGRAM ccache)\nif(CCACHE_PROGRAM)\nset(ccacheEnv\nCCACHE_BASEDIR=${CMAKE_BINARY_DIR}\nCCACHE_SLOPPINESS=clang_index_store,include_file_ctime,include_file_mtime,locale,pch_defines,time_macros\n)\nforeach(lang IN ITEMS C CXX CUDA)\nset(CMAKE_${lang}_COMPILER_LAUNCHER\n${CMAKE_COMMAND} -E env ${ccacheEnv} ${CCACHE_PROGRAM}\nPARENT_SCOPE\n)\nendforeach()\nendif()\n</code></pre>"},{"location":"dev/speeding-up-compilation/#real-solutions","title":"Real Solutions","text":"<p>Profile Compilation Times First!</p> <p>Before going head-over-heel and refactor all your code, it is essential that you run some simple profiling tools to help you analyze what parts of your project are slow to compile.</p>"},{"location":"dev/speeding-up-compilation/#accepting-trade-offs","title":"Accepting Trade-Offs","text":"<p>To really reduce compile times in a C++ project, we need to re-think its architecture and accept trade-offs. Why are C++ projects slow to compile in the first place? In my experience the main culprit is often 1) long header parsing time and 2) long codegen time for templated code.</p> <p>The C++ syntax is incredibly complicated, and after pre-processor STL headers can expand to thousands of lines of code. Compilers need to work extra hard to parse the language correctly, a phenomenon that does not improve with new versions of the C++ standard.</p> <p>Secondly, templated code require the compiler to generate code at each location where a templated function is used. In a project where everything is templated, deeply nested calls to templated functions means that the compiler will basically have to compile the whole project for each translation unit. This kinda defeats the purpose of separating a project in single compilation units in the first place. Because templated code is usually header-only, pulling a complicated templated function will pull a lot of dependent headers, which will need to be parsed, and compiled, etc. The result is a big quagmire of header files that the compiler needs to go through every time, which leads to tremendously slow compilation times.</p> <p>To remedy this, one needs to find compromise, and refactor your code accordingly:</p> <ol> <li>Do you need to support generic templated types, or do you only need to support a limited number    of instantiations? E.g. <code>float</code> and <code>double</code>, or dimensions <code>2</code> and <code>3</code>?</li> <li>Can you get away with runtime polymorphism (virtual methods, function pointers, etc.) instead of    compile time polymorphism (templates)? Yes there is an small overhead, but your development time    might be more valuable than the incurred performance cost. Most of the time, I find that if you    really need to support a generic type, a virtual class will do just fine.</li> </ol>"},{"location":"dev/speeding-up-compilation/#explicit-template-instantiation","title":"Explicit Template Instantiation","text":"<p>The first step to sanitize a C++ project slowed down by expensive templates is to get rid of them. Seriously. Do not use templates unless you have to.</p> <p>If you absolutely need do use templates, consider the following:</p> <ol> <li>If you only need to support a limited number of types, use explicit template instantiation.</li> <li>Write separate files for function declaration and definition, just like you would for a regular    C++ function.</li> </ol>"},{"location":"dev/speeding-up-compilation/#before","title":"Before","text":"sum.hmain.cpp <pre><code>#pragma once\n\n#include &lt;expensive_operation&gt; // Expensive header to parse\n\ntemplate &lt;typename Scalar&gt;\nScalar sum(const std::vector&lt;Scalar&gt; &amp;pts) {\nScalar x = 0;\nfor (size_t i = 0; i &lt; pts.size(); ++i) {\nx += expensive_operation(pts[i]);\n}\nreturn x;\n}\n</code></pre> <pre><code>// This will pull other headers, such as `expensive_operation`\n#include \"sum.h\"\n\nint main(void) {\nstd::vector&lt;float&gt; pts = {0, 1, 2, 3};\nsum(pts);\nreturn 0;\n}\n</code></pre>"},{"location":"dev/speeding-up-compilation/#after","title":"After","text":"sum.hsum.cppmain.cpp <pre><code>#pragma once\n\ntemplate &lt;typename Scalar&gt;\nScalar sum(const std::vector&lt;Scalar&gt; &amp;pts);\n</code></pre> <pre><code>#include \"sum.h\"\n\n// Now `expensive_operation` is safely hidden inside the .cpp\n#include &lt;expensive_operation&gt;\n\ntemplate &lt;typename Scalar&gt;\nScalar sum(const std::vector&lt;Scalar&gt; &amp;pts) {\nScalar x = 0;\nfor (size_t i = 0; i &lt; pts.size(); ++i) {\nx += expensive_operation(pts[i]);\n}\nreturn x;\n}\n\n// Explicit template instantiation\ntemplate float sum(const std::vector&lt;float&gt; &amp;pts);\ntemplate double sum(const std::vector&lt;double&gt; &amp;pts);\n</code></pre> <pre><code>// Now this header is cheap to parse\n#include \"sum.h\"\n\nint main(void) {\nstd::vector&lt;float&gt; pts = {0, 1, 2, 3};\nsum(pts);\nreturn 0;\n}\n</code></pre> <p>To avoid repeating explicit template instantiations for various types, we can use a cool macro trick described at the end of this page.</p> <p>Definitions In Header Files</p> <p>One could also envision using separate header files for the declaration/definition of a templated function (as opposed to a header file + source file). But this gets tricky when nesting templated function calls and trying to instantiate them with new types.</p> <p>Extern Templates</p> <p>While extern template might seem like a good idea, they will only save time on code generation, not parsing. If your templated function only need to support a finite number of fundamental types, moving their definition into a separate source file will save you the additional parsing overhead and avoid header pollution.</p>"},{"location":"dev/speeding-up-compilation/#limit-header-pollution","title":"Limit Header Pollution","text":"<p>Remember that a large portion of a compiler's time is spent parsing headers. STL headers in particular will have various impact on compilation times. Some headers like <code>&lt;type_traits&gt;</code> will have a minimal overhead, while <code>&lt;filesystem&gt;</code> or <code>&lt;regex&gt;</code> can take more than 200ms to parse on a powerful machine. See this website for detailed statistics on all STL headers.</p> <p>To limit compilation overhead due to header parsing, you can do the following:</p> <ul> <li>Profile your compilation times to find out which header takes the most   time to parse.</li> <li>Separate your code between source and header files. Move header includes to the .cpp if they are   not needed in the .h.</li> <li>Separate expensive headers from cheap-but-commonly-used ones, and only include what you need.</li> <li>Avoid having a <code>all.h</code> or <code>common.h</code> that include all headers from your library. This may seem   convenient, but will increase compilation times for your users.</li> <li>Use forward declarations to avoid pulling expensive headers.</li> <li>Use the PIMPL idiom to hide implementation details from header files of a   class.</li> </ul> <p>Forward Declarations And Pass-By-Value</p> <p>I was surprised to learn that you can declare a function taking a forward declared class as a by-value argument and as a result. I.e. this works just fine:</p> <pre><code>class type;\ntype function(type);\n</code></pre> <p>Forward Declarations And Circular Dependencies</p> <p>The Google C++ Style Guide cautions against using forward declarations whenever possible. Forward declaration can hide circular dependencies which should be a red flag in your code architecture. My advice would be to use them sparingly when it makes sense, and measure the performance impact on your project when possible.</p>"},{"location":"dev/speeding-up-compilation/#the-pimpl-idiom","title":"The PIMPL idiom","text":"<p>TL;DR</p> <p>Use valuable::value_ptr&lt;&gt; or spimpl::impl_ptr&lt;&gt;.</p> <p>When defining a class in C++, the types of its member variables need to be known, as the compiler needs to determine the size of the object. However, sometimes we have private member variables whose type do not need to be exposed in the class header. Their type is an implementation detail, and we do not want to expose the additional dependency.</p> <p>The PIMPL idiom (Pointer to IMPLementation) is a technique to hide this implementation detail, such that the underlying types used in a class are not exposed in the class header. Of course there is a small price to pay. In most cases this means an extra heap allocation and pointer indirection. Oftentimes the trade-off is worth it, but this depends on your specific use case.</p> <p>There are several ways to implement a PIMPL in your code (from bad to good):</p> <ol> <li>[Bad] Use a raw <code>T * m_foo;</code> member variable and forward-declare <code>T</code>. But this is bad    because there is no lifetime management (when the encapsulating class is destroyed/moved/copied,    etc.).     <pre><code>class HiddenType;\n\nclass Bar {\nprotected:\n// No lifetime management = bad\nHiddenType * m_foo;\n};\n</code></pre></li> <li> <p>[Not Great] Use a <code>std::unique_ptr&lt;T&gt; m_foo</code>. This would work, but there are two problems    with that.</p> <ol> <li> <p>The <code>std::unique_ptr&lt;&gt;</code> needs to know how to destroy the object, so you need to define the    encapsulating class destructor in the .cpp source file, or you would be forced to pull    <code>&lt;HiddenType.h&gt;</code> in <code>&lt;Bar.h&gt;</code>.</p> Bar.hBar.cpp <pre><code>class HiddenType;\n\nclass Bar {\n~Bar();\nprotected:\nstd::unique_ptr&lt;HiddenType&gt; m_foo;\n};\n</code></pre> <pre><code>#include &lt;HiddenType.h&gt;\n\n// The destructor needs to know HiddenType\nBar::~Bar() = default;\n</code></pre> </li> <li> <p>You lose value semantics on the encapsulating type. I.e. you can no longer copy the object    easily, just move it.</p> </li> </ol> </li> <li> <p>[Not Great] Use a <code>std::shared_ptr&lt;T&gt; m_foo</code>. This has the same issues as the    <code>std::unique_ptr&lt;&gt;</code> solution. You lose value semantics, but you may also incur additional bugs    due to the shared ownership of the hidden object (e.g. in case a copy of <code>Bar</code> is created).</p> </li> <li>[Good] Use a thin-wrapper around <code>std::unique_ptr&lt;&gt;</code> that provides copy/value semantics. Here    are some readily available single-file implementations:<ul> <li>valuable::value_ptr&lt;&gt; (with accompanying blog   post).</li> <li>spimpl::impl_ptr&lt;&gt; very similar.</li> </ul> </li> </ol> <p>Pointers &amp; Const-Correctness</p> <p>When storing member variables that are pointers to data, you need to be very careful regarding const-correctness. <pre><code>#include &lt;ExplicitType.h&gt;\n\nclass Bar {\n~Bar();\npublic:\n// Will compile, but this is NOT ok\nExplicitType &amp; get_foo_bad() const { return *m_foo; }\n\n// Const accessors should return pointers/reference to _const_ data.\nconst ExplicitType &amp; get_foo_good() const { return *m_foo; }\n\n// This is a const method, so it should return a pointer to a _const_ data.\nstd::shared_ptr&lt;const ExplicitType&gt; get_foo_ptr() const { return m_foo; }\n\nprotected:\nstd::shared_ptr&lt;ExplicitType&gt; m_foo;\n};\n</code></pre></p> <p>Example</p> <p>An example usage of the PIMPL idiom in Lagrange is the <code>AttributeManager</code> class in SurfaceMesh.h.</p>"},{"location":"dev/speeding-up-compilation/#x-macro-trick-for-explicit-instantiations","title":"X Macro Trick For Explicit Instantiations","text":"<p>Repeating explicit template instantiations for various types can be a tedious task. It makes code lengthy, hard to read and hard to extend when adding new types/functions to your codebase. Fortunately we can use a cool preprocessor trick known as X macros to iterate over a list of types and generate a list of explicit template instantiation for various classes/functions.</p> <p>While you could use the Boost Preprocessing library and macros such as <code>BOOST_PP_SEQ_FOR_EACH</code>, you can also roll out your own solution, which requires very little code and is easy to understand.</p> <p>The basic idea is as follows:</p> Attribute.hAttributeTypes.hAttribute.cpp <pre><code>#pragma once\n\n#include &lt;vector&gt;\n\u200b\nnamespace mylib {\n\ntemplate&lt;typename T&gt;\nstruct Attribute {\nvoid some_method();\nstd::vector&lt;T&gt; m_data;\n};\n\n} // namespace mylib\n</code></pre> <pre><code>#pragma once\n\n// Define the X macro arguments here (= the list of types to instantiate)\n#define MYLIB_ATTRIBUTE_X(mode, data) \\\n    MYLIB_X_##mode(data, int8_t) \\\n    MYLIB_X_##mode(data, int16_t) \\\n    MYLIB_X_##mode(data, int32_t) \\\n    MYLIB_X_##mode(data, int64_t) \\\n    MYLIB_X_##mode(data, uint8_t) \\\n    MYLIB_X_##mode(data, uint16_t) \\\n    MYLIB_X_##mode(data, uint32_t) \\\n    MYLIB_X_##mode(data, uint64_t) \\\n    MYLIB_X_##mode(data, float) \\\n    MYLIB_X_##mode(data, double)\n</code></pre> <pre><code>#include &lt;mylib/Attribute.h&gt;\n\nnamespace mylib {\n\ntemplate &lt;typename T&gt;\nvoid Attribute&lt;T&gt;::some_method() {\n// do something\n}\n\n// Explicit template instantiation using X macros\n#include &lt;mylib/AttributeTypes.h&gt;\n#define MYLIB_X_attr_class(_, T) template class Attribute&lt;T&gt;;\nMYLIB_ATTRIBUTE_X(attr_class, 0)\n#undef MYLIB_X_attr_class\n\n} // namespace mylib\n</code></pre> <p>Macro Cleanup</p> <p>There is no need to <code>#undef MYLIB_X_attr_class</code> at the end of <code>Attribute.cpp</code>, since the macro is usually defined at the end of a .cpp file. But if you are planning on doing Unity builds and are not using unique names for your macro, then it is a good idea to do so.</p> <p>The above solution works well for a single list of types to instantiate. But what if we are mixing functions that depend on two different types <code>U</code> and <code>T</code>? This is where the extra parameter <code>data</code> comes in. You can think of it as a continuation parameter to recursively instantiate nested type lists.</p> <p>Here is an concrete example:</p> Header.hTypes.hSource.cpp <pre><code>#pragma once\n\n#include &lt;vector&gt;\n\ntemplate&lt;typename T&gt;\nstruct Attribute {\nvoid some_method();\nstd::vector&lt;T&gt; m_data;\n};\n\ntemplate&lt;typename Scalar&gt;\nstruct Mesh {\nstd::vector&lt;Scalar&gt; m_vertices;\n};\n\ntemplate&lt;size_t Dim&gt;\nstruct Volume {\nsize_t m_volume = Dim;\n};\n\ntemplate&lt;typename T, typename Scalar&gt;\nvoid set_attribute(Mesh&lt;Scalar&gt; &amp;mesh, const Attribute&lt;T&gt; &amp;attr);\n\ntemplate&lt;typename T, typename Scalar, size_t D&gt;\nvoid set_volume(Mesh&lt;Scalar&gt; &amp;mesh, const Attribute&lt;T&gt; &amp;attr, Volume&lt;D&gt; &amp;vol);\n</code></pre> <pre><code>#pragma once\n\n// Define the X macro arguments for each type list\n\n#define MYLIB_ATTRIBUTE_X(mode, data) \\\n    MYLIB_X_##mode(data, int8_t) \\\n    MYLIB_X_##mode(data, int16_t) \\\n    MYLIB_X_##mode(data, int32_t) \\\n    MYLIB_X_##mode(data, int64_t) \\\n    MYLIB_X_##mode(data, uint8_t) \\\n    MYLIB_X_##mode(data, uint16_t) \\\n    MYLIB_X_##mode(data, uint32_t) \\\n    MYLIB_X_##mode(data, uint64_t) \\\n    MYLIB_X_##mode(data, float) \\\n    MYLIB_X_##mode(data, double)\n\n#define MYLIB_MESH_X(mode, data) \\\n    MYLIB_X_##mode(data, double) \\\n    MYLIB_X_##mode(data, float)\n\n#define MYLIB_VOL_X(mode, data) \\\n    MYLIB_X_##mode(data, 2) \\\n    MYLIB_X_##mode(data, 3)\n</code></pre> <pre><code>#include \"Header.h\"\n#include \"Types.h\"\n\n// Method/function definitions in the source file\n\ntemplate &lt;typename T&gt;\nvoid Attribute&lt;T&gt;::some_method() {\n// do something\n}\n\u200b\ntemplate&lt;typename T, typename Scalar&gt;\nvoid set_attribute(Mesh&lt;Scalar&gt; &amp;mesh, const Attribute&lt;T&gt; &amp;attr) {\n// do something\n}\n\u200b\ntemplate&lt;typename T, typename Scalar, size_t D&gt;\nvoid set_volume(Mesh&lt;Scalar&gt; &amp;mesh, const Attribute&lt;T&gt; &amp;attr, Volume&lt;D&gt; &amp;vol) {\n// do something\n}\n\n// Explicit instantiation\n\u200b\n// 1. Simple type lists (Attribute&lt;&gt; and Mesh&lt;&gt; classes)\n#define MYLIB_X_attr_class(_, T) template class Attribute&lt;T&gt;;\nMYLIB_ATTRIBUTE_X(attr_class, 0)\n\u200b\n#define MYLIB_X_mesh_class(_, S) template class Mesh&lt;S&gt;;\nMYLIB_MESH_X(mesh_class, 0)\n\u200b\n// 2. Cartesian product with two types S x T\n#define MYLIB_X_attr_set(S, T) template void set_attribute(Mesh&lt;S&gt; &amp;mesh, const Attribute&lt;T&gt; &amp;attr);\n#define MYLIB_X_mesh_set(_, S) MYLIB_ATTRIBUTE_X(attr_set, S)\n\u200b\nMYLIB_MESH_X(mesh_set, 0)\n\u200b\n// 3. Cartesian product with three types S x D x T.\n//    We need to define helper macros to unpack argument tuples.\n#define fst(first, second) first\n#define snd(first, second) second\n#define MYLIB_X_attr_vol(SD, T) template void set_volume(Mesh&lt;fst SD&gt; &amp;mesh, const Attribute&lt;T&gt; &amp;attr, Volume&lt;snd SD&gt; &amp;vol);\n#define MYLIB_X_mesh_vol(D, S) MYLIB_ATTRIBUTE_X(attr_vol, (S, D))\n#define MYLIB_X_dim_vol(_, D) MYLIB_MESH_X(mesh_vol, D)\n\u200b\nMYLIB_VOL_X(dim_vol, 0)\n</code></pre>"},{"location":"dev/unit-tests/","title":"Unit Tests","text":""},{"location":"dev/unit-tests/#running-tests","title":"Running Tests","text":"<p>When <code>LAGRANGE_UNIT_TESTS</code> is <code>ON</code>, unit tests are built automatically. Running unit tests can be done either</p> <ul> <li> <p>Option 1 From the command-line in your build folder:</p> <pre><code>ctest # or\nmake test # or\nninja test\n</code></pre> </li> <li> <p>Option 2 From Visual Studio or Xcode, by executing the special target <code>RUN_TESTS</code>:</p> <ul> <li> <p>Visual Studio</p> <p></p> </li> <li> <p>Xcode</p> <p>![unit-tests-xcode](img/unit-tests-xcode.png     ```</p> </li> </ul> </li> </ul>"},{"location":"dev/unit-tests/#debugging","title":"Debugging","text":"<p>When running unit tests through CMake/CTest, logs for the last failed tests are available under <pre><code>&lt;build&gt;/Testing/Temporary/LastTestsFailed.log\n</code></pre></p> <p>You can run tests individually, all test executables are located in the <code>tests</code> folder, e.g.:</p> <pre><code>./tests/test_lagrange_core\n</code></pre> <p>Some tests are tagged <code>[.slow]</code> and skipped by default. If you wish to run them, you need to pass <code>[slow]</code> as an argument, or the name of a specific test, e.g.:</p> <pre><code>./tests/test_lagrange_core \"[slow]\"\n</code></pre> <p>Running Individual Tests</p> <p>You can also run only your specific test case(s) by passing the name(s) as argument to the test executable. For more details on the available command-line options, please refer to this page of the Catch2 documentation. )</p> <pre><code>./tests/test_lagrange_core \"MeshCreation\"\n</code></pre>"},{"location":"dev/unit-tests/#writing-unit-tests","title":"Writing Unit Tests","text":"<p>Writing new unit tests should be pretty straightforward. Please refer to the Catch2 documentation to get you started. However, there are some idiosyncrasies specifics to Lagrange:</p> <ul> <li> <p>Unit test data is stored in a separate data   repository. Assets are downloaded by CMake, and can   be loaded via the convenience function <code>lagrange::testing::load_mesh()</code>:</p> <pre><code>TEST_CASE(\"thicken_and_close_mesh stanford-bunny\", \"[mesh][thicken_and_close_mesh][stanford-bunny]\")\n{\nauto mesh = lagrange::testing::load_mesh&lt;TriangleMesh3Df&gt;(\"open/core/stanford-bunny.obj\");\nREQUIRE(...);\n}\n</code></pre> </li> <li> <p>If a test may be failing, e.g., because it is a work in progress, you may use the   <code>LA_MAYFAIL_FLAG</code> tag. Contrary to Catch2's <code>[!mayfail]</code>, our <code>LA_MAYFAIL_FLAG</code> tag expands to   an empty string when Lagrange is compiled during continuous integration, in order to avoid   reporting false positives.</p> <pre><code>TEST_CASE(\"Constrained Quadratic Problem 0\", \"[decimation]\" LA_MAYFAIL_FLAG)\n{\n// ...\n}\n</code></pre> </li> </ul>"},{"location":"dev/unit-tests/#writing-benchmarks","title":"Writing Benchmarks","text":"<p>Benchmarking code should be written alongside regular unit tests, and be tagged with the special flag <code>[!benchmark]</code>. Please read this page for detailed instructions regarding Catch2's benchmarking macros.</p> <p>By default, Catch2 runs benchmarks with 100 samples to produce accurate average timings. If your benchmark takes some time to run, you might want to use fewer samples.</p>"},{"location":"dev/visualstudio-wsl/","title":"Building Lagrange with GCC Clang in Visual Studio via WSL","text":""},{"location":"dev/visualstudio-wsl/#system-preparation","title":"System Preparation","text":""},{"location":"dev/visualstudio-wsl/#install-wsl-windows-subsystem-for-linux","title":"Install WSL (Windows Subsystem For Linux)","text":"<p>Detailed instructions here.</p> <p>In short,</p> <ol> <li>Run <code>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code> in PowerShell as administrator</li> <li>Restart computer</li> <li>Go to Microsoft Store, search for Ubuntu or other distro and install it. (tested Ubuntu 20 LTS)</li> </ol>"},{"location":"dev/visualstudio-wsl/#install-unix-libraries","title":"Install Unix Libraries","text":"<p>Start Ubuntu (found in Start menu)</p> <p>To enable Visual Studio - WSL integration</p> <pre><code>sudo apt install g++ gdb make rsync zip\n</code></pre> <p>For clang, run also <pre><code>sudo apt install clang\n</code></pre></p> <p>More details here.</p> <p>If building UI, install further dependencies</p> <pre><code>sudo apt-get install libglu1-mesa-dev freeglut3-dev mesa-common-dev build-essential libgtk-3-dev xorg-dev\n</code></pre>"},{"location":"dev/visualstudio-wsl/#install-cmake","title":"Install CMake","text":"<p>Visual Studio can install CMake for you automatically (a popup will appear) and it will install it into <code>$HOME/.vs/cmake/bin/cmake</code> However, to make sure FetchContent works with direct URL downloads, it seems you have to install CMake into Ubuntu directly via: <pre><code>sudo apt-get install cmake\n</code></pre> You will have to switch the CMake executable option in <code>CMakeSettings.json</code> (under Advanced) to <code>/usr/bin/cmake</code> or wherever your <code>apt-get</code> installs <code>cmake</code>.</p>"},{"location":"dev/visualstudio-wsl/#modify-visual-studio-installation","title":"Modify Visual Studio Installation","text":"<ol> <li>Go to <code>Add or Remove Programs -&gt; Visual Studio Installer -&gt; Modify</code></li> <li>Select your installation <code>More -&gt; Modify</code></li> <li>Enable <code>Linux development with C++</code> and update</li> <li>Update to latest Visual Studio version for best results.</li> </ol>"},{"location":"dev/visualstudio-wsl/#install-ssh-keys","title":"Install SSH Keys","text":"<ol> <li>Install keychain <code>sudo apt-get install keychain</code></li> <li>You can copy your windows id_rsa key to <code>~/.ssh/</code> or generate a new one</li> <li>Add this line to .bashrc:     <pre><code>eval \\`keychain --agents ssh --eval id_rsa\\`\n</code></pre></li> <li>Make sure ~/.ssh/id_rsa has chmod 0600</li> </ol>"},{"location":"dev/visualstudio-wsl/#build-lagrange","title":"Build Lagrange","text":""},{"location":"dev/visualstudio-wsl/#configuration","title":"Configuration","text":"<ol> <li>Clone the repository</li> <li><code>Open Visual Studio -&gt; File -&gt; Open Folder -&gt; Open Folder lagrange root folder</code></li> <li>Click on <code>Open the CMake Settings Editor</code></li> <li>Click on the plus icon,  select <code>WSL-Debug</code> or <code>WSL-Release</code> (this will build with GCC)</li> <li><code>Ctrl + S</code> or save the file to run CMake</li> <li>In the <code>CmakeSettings.json</code> editor, you'll be able to select which lagrange modules to build</li> <li>Save the config file again to generate the project</li> </ol>"},{"location":"dev/visualstudio-wsl/#selecting-targets","title":"Selecting Targets","text":"<p>Solution explorer has two views 1. <code>File hierarchy</code> 2. <code>CMake Targets View</code></p> <p>Switch to <code>CMake Targets View</code>, navigate to target you want to build, right click <code>Set as Startup Item</code> and build.</p>"},{"location":"dev/visualstudio-wsl/#controlling-configuration-step","title":"Controlling Configuration Step","text":"<p>CMake will run automatically when cache is invalidated. To prevent that go to <code>Tools -&gt; Options -&gt; CMake -&gt; When cache is out of date</code> and select your preferred option.</p> <p>If you want to trigger configuration step manually, in <code>Cmake Targets View</code> right click <code>Lagrange Project</code> and select <code>Generate Cache</code></p>"},{"location":"dev/visualstudio-wsl/#terminal","title":"Terminal","text":"<p>Go to <code>Debug</code> -&gt; <code>Linux Console</code> to see the linux terminal.</p>"},{"location":"dev/visualstudio-wsl/#bonus-running-ui-window-from-wsl","title":"Bonus: Running UI Window from WSL","text":"<p>Note: WSL does not support GPU rendering, UI will be rendered through software driver - therefore it's quite slow. In particular, IBL generation is slow so setting <code>Viewer::WindowOptions::default_ibl = \"\"</code> is recommended.</p> <ol> <li>Download and run MobaXTerm (https://mobaxterm.mobatek.net/download.html), go to X Server -&gt; Start X Server  (other alternatives like Xming use older GLX version)</li> <li>To test if it works, Run <code>export DISPLAY=:0</code> and then <code>sudo apt install mesa-utils</code> and run <code>glxgears</code></li> <li><code>OpenCmakeSettings.json</code> in the lagrange project and add this before <code>configurations</code>: <pre><code>\"environments\": [\n    {\n      \"DISPLAY\": \":0\"\n    }\n  ],\n</code></pre></li> <li>Build and run UI examples</li> </ol>"},{"location":"dev/visualstudio-wsl/#more-resources","title":"More resources","text":"<ul> <li>Pure Virtual C++ 2020 (WSL specific session starts at 2:06:00)</li> <li>C++ with Visual Studio 2019 and Windows Subsystem for Linux (WSL)</li> <li>CMake projects in Visual Studio</li> <li>Launch.vs.json reference for remote projects and WSL</li> </ul>"},{"location":"dev/vscode/","title":"VSCode Tips and Tricks","text":""},{"location":"dev/vscode/#recommended-extensions","title":"Recommended Extensions","text":"<ul> <li>Syntax Highlighting<ul> <li>C/C++ Themes</li> <li>CMake</li> <li>Python</li> <li>Rainbow CSV</li> </ul> </li> <li>Theming<ul> <li>VScode Icons</li> <li>Readability Extension Pack</li> <li>Better C++ Syntax</li> </ul> </li> <li>Tools<ul> <li>Clang-format</li> <li>CMake Tools</li> </ul> </li> <li>Documentation<ul> <li>Code Spell Checker</li> <li>Doxygen Documentation Generator</li> </ul> </li> <li>Settings<ul> <li>Settings Sync</li> <li>Sublime Text Keymap and Settings Importer</li> </ul> </li> </ul>"},{"location":"user/core/attributes/","title":"Mesh Attributes","text":"<p>Legacy Mesh vs Surface Mesh</p> <p>Since v6.0.0, Lagrange introduced a new polygonal mesh class that is meant to replace the original mesh class used throughout Lagrange. While currently few of the Lagrange functions use this new mesh class, over time old and new features will transition to use this new data structure.</p> <p>Mesh attributes are buffers of data associated to a mesh element. They are characterized by the following:</p> <ul> <li>Name: A string that uniquely identifies the attribute in the mesh, irrespectively of which   mesh element it is associated to.</li> <li>Id: A 32bit unsigned integer that uniquely identifies the attribute in the mesh. Ids are   assigned at attribute creation and will not be invalidated if other attributes are   removed/created.</li> <li> <p>Value Type: Value type of the data being stored in the attribute. We only support fixed-sized   integer and floating point types.</p> Supported Value Types (Click to expand) <ul> <li><code>int8_t</code></li> <li><code>int16_t</code></li> <li><code>int32_t</code></li> <li><code>int64_t</code></li> <li><code>uint8_t</code></li> <li><code>uint16_t</code></li> <li><code>uint32_t</code></li> <li><code>uint64_t</code></li> <li><code>float</code></li> <li><code>double</code></li> </ul> </li> <li> <p>Element: Type of mesh element the attribute is associated to. It can be one of the following:</p> <code>AttributeElement</code> Description <code>Vertex</code> Attribute associated to mesh vertices (e.g., positions). <code>Facet</code> Attribute associated to mesh facets. <code>Edge</code> Attribute associated to mesh edges. <code>Corner</code> Attribute associated to mesh facet corners (e.g. vertex indices). <code>Value</code> Attribute that is not associated to any mesh element (arbitrary size). <code>Indexed</code> A pair of (<code>Corner</code>, <code>Value</code>) attributes, where the corner attribute is anindex into the value attribute buffer (e.g. a UV). <p>Automatic Resizing</p> <p><code>Vertex</code>, <code>Facet</code>, <code>Edge</code> and <code>Corner</code> attributes are resized accordingly to their respective mesh element when inserting/removing vertices/facets, while a <code>Value</code> attribute is never resized automatically.</p> </li> <li> <p>Usage: A usage tag is an optional tag that can be used to determine how attribute values are   affected by other mesh operations. See the reference documentation for a list   of available usage tags.</p> <p>Example</p> <p>When applying a rigid transform \\(M\\) to a mesh, attributes with the <code>Normal</code> tag will be transformed according to \\(M^{-T}\\). Similarly, when removing mesh vertices, attributes with the <code>VertexIndex</code> tag will be remapped accordingly.</p> </li> <li> <p>Channels: Number of channels for each mesh element in the attribute. The number of possible   channels for an attribute is restricted by the attribute usage tag.</p> <p>Example</p> <p>An attribute with the <code>VertexIndex</code> tag must have a single channel, while attributes with the <code>Color</code> tag can have between 1 and 4 channels.</p> </li> </ul> <p>Memory Layout</p> <p>Mesh attributes are stored continuous in memory. For example, the vertex positions of a 3D mesh will be stored in memory as <code>[x0, y0, z0, x1, y1, z1, ...]</code> etc. If you need to wrap external data with a compatible memory layout, please read our dedicated section on wrapping external buffers. If you need to track ownership, you can use a SharedSpan object.</p>"},{"location":"user/core/attributes/#attribute-creation","title":"Attribute Creation","text":"<p>To create a new attribute and return its id:</p> <pre><code>lagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\n\n// Minimal version only requires name + element type.\nauto id0 = mesh.create_attribute&lt;double&gt;(\n\"color\",\nlagrange::AttributeElement::Corner);\n\n// Optionally specify usage tag + num channels.\nauto id1 = mesh.create_attribute&lt;float&gt;(\n\"normals\",\nlagrange::AttributeElement::Vertex,\nlagrange::AttributeUsage::Normal,\n3);\n\n// View attribute as a Eigen::Map&lt;const ...&gt;\nauto attr_matrix = matrix_view(mesh.get_attribute&lt;float&gt;(id1));\n</code></pre>"},{"location":"user/core/attributes/#accessing-attribute-values","title":"Accessing Attribute Values","text":"<pre><code>lagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\n\n// ...\n\n// Returns a const Attribute&lt;T&gt; &amp;\nauto&amp; attr = mesh.get_attribute&lt;Scalar&gt;(\"normals\");\n\n// Alternative: use id to retrieve attr (avoids a hash map lookup)\nauto attr_id = mesh.get_attribute_id(\"normals\");\nauto&amp; attr2 = mesh.get_attribute&lt;Scalar&gt;(attr_id);\n\n// Wrap as an Eigen matrix as usual\nauto attr_matrix = matrix_view(attr);\n</code></pre> <p>Using Attribute Ids</p> <p>Using the attribute id instead of its name avoids a <code>std::string -&gt; uint32_t</code> lookup. Since attribute ids are guaranteed to not be invalidated, you may also store it in your application (e.g. UI menus, etc.).</p> <p>Disabled Implicit Copies</p> <p>It is important to note that implicit copies of an <code>Attribute</code> object is forbidden. Since Attribute buffers have value semantics (like <code>std::vector&lt;&gt;</code>), storing the result of <code>mesh.get_attribute&lt;&gt;()</code> in a <code>auto attr</code> variable would lead to an implicit copy. For this reason, the following code will not compile and produce an error:</p> <pre><code>// The following will NOT compile (Attribute copy is explicit)\n// auto attr3 = mesh.get_attribute&lt;float&gt;(\"normals\");\n</code></pre> <p>Copy-on-write handling of attribute buffers is done at the mesh level, i.e. when copying a <code>SurfaceMesh</code> object, or when calling methods such as <code>SurfaceMesh::duplicate_attribute()</code>.</p>"},{"location":"user/core/attributes/#iterating-over-mesh-attributes","title":"Iterating Over Mesh Attributes","text":"<p>In many situation, it is desirable to iterate over existing mesh attributes to extract some information, or process existing attributes. We provide utility functions to iterate over existing mesh attributes, with additional filtering based on element types.</p> <p>Basic example: <pre><code>#include &lt;lagrange/foreach_attribute.h&gt;\n#include &lt;lagrange/Logger.h&gt;\n\nlagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\n\n// ...\n\n// Iterate over each attribute sequentially\nseq_foreach_attribute_read(mesh, [](auto&amp;&amp; attr) {\nlagrange::logger().info(\"Attribute with {} channels\", attr.get_num_channels());\n});\n\n// Same, but retrieves attribute names while iterating\nseq_foreach_named_attribute_read(mesh, [&amp;](std::string_view name, auto&amp;&amp; attr) {\nlagrange::logger().info(\"Attribute named '{}' with {} channels\",\nname, attr.get_num_channels());\n});\n</code></pre></p> <p>Iterator functions follow the same naming convention, with variations being as follows:</p> Variation Description seq vs par Iterate sequentially or in parallel over available mesh attributes. named vs unnamed Whether to pass attribute names to the callback function . read vs write Whether read-only or writable references to the attributes are required. <p>See reference documentation for additional details.</p>"},{"location":"user/core/attributes/#inferring-value-type","title":"Inferring Value Type","text":"<p>Since we use generic lambda to iterate over attributes of different types, it is possible to deduce the value type of the current attribute in the following manner:</p> <pre><code>lagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\n\n// ...\n\nseq_foreach_attribute_read(mesh, [](auto&amp;&amp; attr) {\n// Retrieve the attribute value type within the lambda\nusing AttributeType = std::decay_t&lt;decltype(attr)&gt;;\nusing ValueType = typename AttributeType::ValueType;\nlagrange::logger().info(\"Attribute value type size: {}\", sizeof(ValueType));\n});\n</code></pre>"},{"location":"user/core/attributes/#filtering-element-types","title":"Filtering Element Types","text":"<p>Since indexed attributes have a different interface from non-indexed attributes, it is often necessary to use two different code path when iterating over mesh attributes. Fortunately, it is possible to do so concisely thanks to C++17's <code>if constexpr()</code>, like so:</p> <pre><code>lagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\n\n// ...\n\n// Use compile-time if to check for indexed attributes\nseq_foreach_named_attribute_read(mesh, [](std::string_view name, auto&amp;&amp; attr) {\nusing AttributeType = std::decay_t&lt;decltype(attr)&gt;;\nif constexpr (AttributeType::IsIndexed) {\nlagrange::logger().info(\n\"Indexed attribute '{}' with {} values\",\nname,\nattr.values().get_num_elements());\n} else {\nlagrange::logger().info(\n\"Non-indexed attribute '{}' with {} elements\",\nname,\nattr.get_num_elements());\n}\n});\n</code></pre> <p>Alternatively, one can provide an optional template argument to the  <code>foreach</code> function to iterate over a specific element type:</p> <pre><code>lagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\n\n// ...\n\n// Iterate over non-indexed attributes\nlagrange::seq_foreach_named_attribute_read&lt;~lagrange::AttributeElement::Indexed&gt;(\nmesh,\n[&amp;](std::string_view name, auto&amp;&amp; attr) {\nlagrange::logger().info(\n\"Attribute named '{}' with {} elements\",\nname,\nattr.get_num_elements());\n});\n\n// Iterate over indexed attributes only\nlagrange::seq_foreach_attribute_read&lt;lagrange::AttributeElement::Indexed&gt;(\nmesh,\n[](auto&amp;&amp; attr) {\nusing AttributeType = std::decay_t&lt;decltype(attr)&gt;;\nusing ValueType = typename AttributeType::ValueType;\nusing Index = typename AttributeType::Index;\nlagrange::logger().info(\n\"Indexed attribute using value type size {} and index size {}\",\nsizeof(ValueType),\nsizeof(Index));\n});\n</code></pre> <p>Argument-Dependent Lookup</p> <p>With this variant, ADL no longer work, so you need to explicitly call <code>lagrange::seq_foreach_attribute_read(mesh, ...)</code> rather than <code>seq_foreach_attribute_read(mesh, ...)</code>.</p> <p>Finally, it is possible to combine template argument filters via bitwise boolean operations:</p> <pre><code>lagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\n\n// ...\n\n// Iterate over vertex, facet and corner attributes:\nlagrange::seq_foreach_attribute_read&lt;\nlagrange::AttributeElement::Vertex | lagrange::AttributeElement::Facet |\nlagrange::AttributeElement::Corner&gt;(mesh, [&amp;](auto&amp;&amp; attr) {\nlagrange::logger().info(\n\"Non-indexed attribute with {} elements\",\nattr.get_num_elements());\n});\n</code></pre>"},{"location":"user/core/attributes/#a-note-on-thread-safety","title":"A Note On Thread-Safety","text":"<p>The following operations are safe to do in parallel:</p> <ul> <li>Writing to two separate mesh attributes pointing to the same buffer (a deep copy will be created).</li> </ul> <p>The following operations are not safe to do in parallel:</p> <ul> <li>Writing to an attribute while creating other mesh attributes.</li> <li>Adding elements to a mesh while writing to another attribute of the same mesh.</li> </ul> <p>From a practical standpoint, copy-on-write attributes behave as if each mesh owns its own <code>std::vector&lt;&gt;</code> for each attribute. Adding an element to a mesh would resize the corresponding mesh attributes, making concurrent writes unsafe. Creating new mesh attributes will move existing mesh attributes, making concurrent writes also unsafe.</p> <p>Note that if two meshes are shallow copies of each other, it is perfectly safe to add elements to each of them concurrently. The same goes for writing in parallel to mesh attributes that are duplicates of each others: each attribute behaves as if it owns its own copy of the data.</p> <p>Temporary Copy On Concurrent Writes</p> <p>While concurrent writing to mesh attributes is a thread-safe operation, note that it may sometimes create an unnecessary temporary copy of the data. To avoid this, we would need to block every write operation with a mutex, which would involve an expensive context switch. Instead, we simply rely on the atomic counter from the <code>shared_ptr&lt;&gt;</code> to decide whether to copy/acquire ownership of the data. While this is a thread-safe operation, it may create a temporary copy of the data.</p>"},{"location":"user/core/attributes/#wrapping-external-buffers","title":"Wrapping External Buffers","text":"<p>A key feature of our attribute system is the possibility to easily wrap external buffer and treat them as regular mesh attributes, avoiding any data copy. As long as the data layout is compatible, you will be able to wrap a continuous buffer as a mesh attribute and pass it around.</p> <pre><code>lagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\nmesh.add_vertices(10);\n\nIndex num_verts = mesh.get_num_vertices();\nIndex num_coords = mesh.get_dimension();\n\n// Create a flat buffer to use as external attribute data\nstd::vector&lt;Scalar&gt; normals(num_verts * num_coords);\n\n// Wrap external buffer as a read-write attribute\nmesh.wrap_as_attribute&lt;Scalar&gt;(\n\"normals\",\nlagrange::AttributeElement::Vertex,\nlagrange::AttributeUsage::Normal,\nnum_coords,\nnormals);\n\n// Retrieves a Eigen::Map&lt;&gt; view of the attribute\nauto N = lagrange::attribute_matrix_ref&lt;Scalar&gt;(mesh, \"normals\");\n\n// Check that all coordinates are finite (no inf/nan).\nassert(N.allFinite());\n</code></pre> <p>Sometimes, it is necessary to wrap a pointer to a const buffer, to ensure the external buffer will not be be written to:</p> <pre><code>// Wrap external buffer as a read-only attribute\nconst Scalar *const_normals = normals.data();\nmesh.wrap_as_const_attribute&lt;Scalar&gt;(\n\"const_normals\",\nlagrange::AttributeElement::Vertex,\nlagrange::AttributeUsage::Normal,\nnum_coords,\n{const_normals, normals.size()});\n\n// Non-const methods on the normal attr will throw an error\nmesh.ref_attribute&lt;Scalar&gt;(\"const_normals\").ref_all(); // --&gt; throws an exception\n</code></pre> <p>Non-Const Access</p> <p>The following code does not throw an exception:  <pre><code>auto &amp;attr = mesh.ref_attribute&lt;Scalar&gt;(\"const_normals\");\n</code></pre> This is because while <code>attr</code> is a writable reference to the attribute <code>\"const_normals\"</code>, the user could decide to update the attribute itself to wrap another non-const buffer (via <code>attr.wrap(...)</code>). Only methods which provide write access to the actual buffer data (such as <code>attr.ref_all()</code>) will throw an exception.</p> <p>Alternatively, instead of implicitly converting to a <code>span&lt;&gt;</code>, you can explicitly pass a <code>span&lt;&gt;</code> object and let the compiler deduce the <code>Scalar</code> type template argument:</p> <pre><code>// Pass a `span&lt;&gt;` object directly to let the compiler deduce\n// the template value type\nmesh.wrap_as_const_attribute(\n\"normals\",\nlagrange::AttributeElement::Vertex,\nlagrange::AttributeUsage::Normal,\nnum_coords,\nlagrange::span&lt;const Scalar&gt;(normals));\n</code></pre> <p>Tracking Ownership And Moving Eigen Matrices</p> <p>If you need to track the ownership of an external buffer being wrapped as a mesh attribute, please read our documentation about SharedSpan objects. Any <code>wrap_*</code> method that accepts a regular <code>span&lt;&gt;</code> object should also work with a managed <code>SharedSpan</code> object.</p> <p>Using a SharedSpan object to wrap an external object as attribute allows moving a Eigen::Matrix and other arbitrary objects into mesh attributes without any extra buffer copy, as long as the memory layout of the coordinates are compatible.</p>"},{"location":"user/core/attributes/#delete-and-export-attributes","title":"Delete And Export Attributes","text":"<p>To delete an attribute, simply call the eponymous method:</p> <pre><code>lagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\n\n// ...\n\n// Delete attribute\nmesh.delete_attribute(\"normals\");\n</code></pre> <p>More interestingly, the attribute itself can be exported into a <code>std::shared_ptr&lt;Attribute&lt;T&gt;&gt;</code> that can be handed back to the user. This allows client code to reuse the attribute data after the destruction of any mesh object that was containing the attribute: only the <code>std::shared_ptr&lt;Attribute&lt;T&gt;&gt;</code> needs to be kept alive.</p> <pre><code>// Delete and export a std::shared_ptr&lt;Attribute&lt;T&gt;&gt;\nauto attr_ptr = mesh.delete_and_export_attribute&lt;Scalar&gt;(\"normals\");\n\n// Pass a raw pointer/span to the attribute data back to client code\nauto data_ptr = attr_ptr-&gt;ref_all().data();\n</code></pre>"},{"location":"user/core/attributes/#reserved-attribute-names","title":"Reserved Attribute Names","text":"<p>We use the convention that attribute names starting with <code>\"$\"</code> are reserved for internal use by the mesh class. For example, <code>$vertex_to_position</code> and <code>$corner_to_vertex</code> are used for vertex positions and facet indices respectively. The list of available internal attributes and their names is subject to future changes.</p>"},{"location":"user/core/attributes/#attribute-policies","title":"Attribute Policies","text":"<p>Policies can be used to control the behavior when manipulating attributes that wraps external buffers, creating/deleting attributes with reserved names, etc. Policies are runtime properties that need to be set for each attribute separately. They are copied over when an attribute is duplicated via our copy-on-write mechanism.</p>"},{"location":"user/core/attributes/#create-policy","title":"Create Policy","text":"<p>Controls the behavior when creating an attribute with a reserved name (starting with <code>$</code>). The default is to throw an exception. See reference documentation for more details.</p>"},{"location":"user/core/attributes/#copy-policy","title":"Copy Policy","text":"<p>Controls the behavior when copying an attribute that wraps an external buffer. By default, a deep copy of the buffer will be created. See reference documentation for more details.</p>"},{"location":"user/core/attributes/#growth-policy","title":"Growth Policy","text":"<p>Controls the behavior when adding element to an attribute that wrap an external buffer. The default behavior is to throw an exception. See reference documentation for more details.</p> <pre><code>Index dim = 3;\nIndex num_vertices = 10;\nlagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh(dim);\n\n// Define external buffer\nstd::vector&lt;Scalar&gt; buffer(2 * num_vertices * dim);\n\n// ... fill buffer with values ...\n\n// Wrap external buffer AND resize num of vertices\nmesh.wrap_as_vertices(buffer, num_vertices);\n\n// Writable reference to vertex position attribute\nauto&amp; attr = mesh.ref_vertex_to_position();\n\n// Set growth attribute policy\nattr.set_growth_policy(lagrange::AttributeGrowthPolicy::ErrorIfExternal);\nattr.set_growth_policy(lagrange::AttributeGrowthPolicy::AllowWithinCapacity);\nattr.set_growth_policy(lagrange::AttributeGrowthPolicy::WarnAndCopy);\n\n// Inserting more vertices might throw an error, depending on the policy\nmesh.add_vertices(5);\n</code></pre>"},{"location":"user/core/attributes/#write-policy","title":"Write Policy","text":"<p>Controls the behavior when providing writable access to an attribute wrapping a const external buffer. The default behavior is to throw an exception. See reference documentation for more details.</p> <pre><code>Index dim = 3;\nIndex num_vertices = 10;\nlagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh(dim);\n\n// Define external buffer\nconst size_t num_channels = 3;\nstd::vector&lt;Scalar&gt; buffer(mesh.get_num_vertices() * num_channels);\n\n// ... fill buffer with values ...\n\n// Wrap external buffer as read-only attribute\nauto id = mesh.wrap_as_const_attribute&lt;Scalar&gt;(\n\"normals\",\nlagrange::AttributeElement::Vertex,\nlagrange::AttributeUsage::Normal,\nnum_channels,\nbuffer);\nauto&amp; attr = mesh.ref_attribute&lt;Scalar&gt;(id);\n\n// Set write policy for read-only attributes\nattr.set_write_policy(lagrange::AttributeWritePolicy::ErrorIfReadOnly);\nattr.set_write_policy(lagrange::AttributeWritePolicy::WarnAndCopy);\n\n// Write access to the attribute might throw depending on policy\nattr.ref(0) = 3.14;\n</code></pre>"},{"location":"user/core/attributes/#delete-policy","title":"Delete Policy","text":"<p>Controls the behavior when deleting an attribute with a reserved name. The default behavior is to throw an exception. See reference documentation for more details.</p>"},{"location":"user/core/attributes/#export-policy","title":"Export Policy","text":"<p>Controls the behavior when exporting an attribute wrapping an external buffer. The default behavior is to create an internal copy to ensure lifetime of the data is preserved. See reference documentation for more details.</p> <pre><code>Index dim = 3;\nIndex num_vertices = 10;\nlagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh(dim);\n\n// Define external buffer\nconst size_t num_channels = 3;\nstd::vector&lt;Scalar&gt; buffer(mesh.get_num_vertices() * num_channels);\n\n// ... fill buffer with values ...\n\n// Wrap external buffer as read-only attribute\nauto id = mesh.wrap_as_const_attribute&lt;Scalar&gt;(\n\"normals\",\nlagrange::AttributeElement::Vertex,\nlagrange::AttributeUsage::Normal,\nnum_channels,\nbuffer);\n\n// Delete and export might create an internal copy depending on policy\nusing namespace lagrange;\nauto attr_ptr1 = mesh.delete_and_export_attribute&lt;Scalar&gt;(\n\"normals\",\nAttributeDeletePolicy::ErrorIfReserved,\nAttributeExportPolicy::CopyIfExternal);\nauto attr_ptr2 = mesh.delete_and_export_attribute&lt;Scalar&gt;(\n\"normals\",\nAttributeDeletePolicy::ErrorIfReserved,\nAttributeExportPolicy::ErrorIfExternal);\nauto attr_ptr3 = mesh.delete_and_export_attribute&lt;Scalar&gt;(\n\"normals\",\nAttributeDeletePolicy::ErrorIfReserved,\nAttributeExportPolicy::KeepExternalPtr);\n</code></pre>"},{"location":"user/core/general-utilities/","title":"General Utilities","text":""},{"location":"user/core/general-utilities/#general-utility-functions","title":"General Utility Functions","text":""},{"location":"user/core/general-utilities/#logging","title":"Logging","text":"<p>Lagrange uses spdlog for logging purposes. Spdlog provides feature-rich formatting via the excellent fmt library. This provides several advantages over a traditional <code>std::cout</code> messaging:</p> <ul> <li>Python-like formatting syntax improves code readability</li> <li>6 levels of logging: trace, debug, info, warn, error, critical</li> <li>Fast, thread-safe formatting</li> <li>Multiple sinks (file, stdout, etc.)</li> </ul> <p>The default Lagrange logger can be accessed as follows:</p> <pre><code>#include &lt;lagrange/Logger.h&gt;\n\nlagrange::logger().debug(\"This mesh has {} vertices and {} facets\", v, f);\n</code></pre> <p>To control the logging level, or set additional sinks (e.g. to write logs to a file), please read the spdlog documentation.</p> <p>A common pattern we use in example applications is to set the logging level/sink via command-line arguments. E.g. using CLI11 to parse cli args:</p> <pre><code>struct\n{\nstd::string log_file;\nint log_level = 2;\n} args;\n\n// Parse command-line args with CLI11\nCLI::App app{argv[0]};\napp.option_defaults()-&gt;always_capture_default();\napp.add_flag(\"-q,--quiet\", args.quiet, \"Hide logger on stdout.\");\napp.add_option(\"-l,--level\", args.log_level, \"Log level (0 = most verbose, 6 = off).\");\napp.add_option(\"-f,--log-file\", args.log_file, \"Log file.\");\nCLI11_PARSE(app, argc, argv)\n\nif (args.quiet) {\n// Hide stdout default sink\nlagrange::logger().sinks().clear();\n}\nif (!args.log_file.empty()) {\n// Add a new file sink\nlagrange::logger().sinks().emplace_back(\nstd::make_shared&lt;spdlog::sinks::basic_file_sink_mt&gt;(args.log_file, true));\n}\n\n// Set log level\nargs.log_level = std::max(0, std::min(6, args.log_level));\nspdlog::set_level(static_cast&lt;spdlog::level::level_enum&gt;(args.log_level));\n</code></pre>"},{"location":"user/core/general-utilities/#timing","title":"Timing","text":"<p>Lagrange provides handy timing functions based on modern C++'s chrono package. Here is an example use case:</p> <pre><code>#include &lt;lagrange/utils/timing.h&gt;\n\nauto start_time = lagrange::get_timestamp();\n...\nauto finish_time = lagrange::get_timestamp();\n\nauto duration = lagrange::timestamp_diff_in_seconds(start_time, finish_time);\nlagrange::logger().info(\"Duration: {}s\", duration);\n</code></pre>"},{"location":"user/core/general-utilities/#assertion","title":"Assertion","text":"<p>Lagrange provide two types of assertion macros:</p> <ul> <li> <p>Runtime assertions, using <code>la_runtime_assert().</code> Those are used to check the validity of user   inputs as a pre-condition to a function. For example, providing a function with an empty, or a   mesh with incorrect dimension, could result in such an assertion being raised. A runtime assert is   executed even in Release configuration, and indicates a problem with the function input.</p> </li> <li> <p>Debug assertions using <code>la_debug_assert()</code>. Those are only checked in debug code (macro   <code>NDEBUG</code> is undefined). A debug assert is used to check internal code validity, and should not   be triggered under any circumstance by client code. A failed debug assert indicates an error in   the programmer's code, and should be fixed accordingly.</p> </li> </ul> <p>Usage In Expressions</p> <p>Our assert macros behave as functions, meaning they expand to a <code>void</code> expression and can be used in an expression such as <code>y = (la_debug_assert(true), x)</code>.</p> <p>Our assertion macros can take either 1 or 2 arguments, the second argument being an optional error message. To conveniently format assertion messages with a printf-like syntax, use <code>fmt::format</code>:</p> <pre><code>#include &lt;lagrange/utils/assert.h&gt;\n#include &lt;spdlog/fmt/fmt.h&gt;\n\nla_debug_assert(x == 3);\nla_debug_assert(x == 3, \"Error message\");\nla_debug_assert(x == 3, fmt::format(\"Incorrect value of x: {}\", x));\n</code></pre> <p>Break Into Debugger</p> <p>It is possible to have assert macros break into the debugger upon failure. To do that, enable the CMake option <code>LAGRANGE_ASSERT_DEBUG_BREAK</code> when compiling Lagrange into your project.</p>"},{"location":"user/core/general-utilities/#type-cast","title":"Type Cast","text":"<p>It is often necessary to cast a variable from one type to another. To ensure such cast is safe, Lagrange provides an explicit casting function:</p> <pre><code>#include &lt;lagrange/utils/safe_cast.h&gt;\n\n// Cast variable y into variable x of type `type1`\ntype1 x = lagrange::safe_cast&lt;type1&gt;(y);\n</code></pre> <p>Implementation Detail</p> <p><code>safe_cast</code> checks for type compatibility, sign consistency and truncation error.  We recommended to use code that avoids casting in the first place.</p>"},{"location":"user/core/general-utilities/#pointer-type-conversion","title":"Pointer Type Conversion","text":"<p>It often necessary to convert a <code>std::unique_ptr</code> to <code>std::shared_ptr</code>. Lagrange provide a handy function that avoid repeated type specification:</p> <pre><code>#include &lt;lagrange/common.h&gt;\n\nstd::unqiue_ptr&lt;T&gt; unique_val = ...;\nauto shared_val == lagrange::to_shared_ptr(unique_val);\nassert(unique_val == nullptr);\nassert(shared_val.use_count() == 1);\n</code></pre>"},{"location":"user/core/general-utilities/#range","title":"Range","text":"<p>Lagrange provides a handy <code>range()</code> function to enable a python-like range-based for loop:</p> <pre><code>#include &lt;lagrange/range.h&gt;\n\nfor (auto i : lagrange::range(num_vertices)) {\n// i goes from 0 to num_vertices-1\n}\n</code></pre> <p>The advantage of using <code>range()</code> is that the type of the index variable <code>i</code> is automatically inferred from the type of <code>num_vertices</code>.  This reduces the amount of unnecessary implicit casts and compiler warnings.</p> <p>Lagrange also provide <code>range_sparse()</code> to loop through an active subset of the range:</p> <pre><code>#include &lt;lagrange/range.h&gt;\n\nstd::vector&lt;Index&gt; active_set;\n\n// Populate active_set... (optional)\n\nfor (auto i : lagrange::range_sparse(N, active_set)) {\n// i will loop through only the active entries.\n}\n</code></pre> <p>The iterator behaves as follows:</p> <ul> <li>If <code>active_set</code> is empty, <code>range_sparse(N, active_set)</code> will loop from 0 to <code>N</code> (same behavior as   <code>range(N)</code>).</li> <li>However, if <code>active_set</code> is non-empty, <code>range_sparse(N, active_set)</code> will loop through the entries   of <code>active_set</code>.</li> </ul>"},{"location":"user/core/general-utilities/#disjoint-set-union-find","title":"Disjoint-Set / Union-Find","text":"<p>Lagrange provide a simple Disjoint-Set data-structure that can be used to implement algorithms such as Kruskal's minimum spanning tree.</p> <pre><code>#include &lt;lagrange/utils/DisjointSets.h&gt;\n\nusing Edge = std::array&lt;Index, 2&gt;;\n\nstd::vector&lt;Edge&gt; min_spanning_tree(\nIndex num_vertices,\nconst std::vector&lt;Edge&gt;&amp; sorted_edges)\n{\n// Disjoint-sets for efficient union-find operations\nDisjointSets&lt;Index&gt; union_find(num_vertices);\nstd::vector&lt;Edge&gt; output_edges;\n\n// Iterate over all input edges in ascending order\nfor (auto [x, y] : sorted_edges) {\n[x, y] = sorted_edges[e];\n\n// If vertices belong to disconnected unrooted trees,\n// merge them and add edge (x, y) to the solution\nif (union_find.find(x) != union_find.find(y)) {\noutput_edges.emplace_back(x, y);\nunion_find.merge(x, y);\n}\n}\nreturn output_edges;\n}\n</code></pre> <p>Implementation Detail</p> <p>For simplicity, our Disjoint-Set data structure currently only implements path compression, but not union by rank.</p>"},{"location":"user/core/general-utilities/#bitfield","title":"BitField","text":"<p>The BitField class can be used to implement convenient bitwise boolean operations over an enum type.</p> <pre><code>#include &lt;lagrange/utils/BitField.h&gt;\n#include &lt;lagrange/Logger.h&gt;\n\nenum Operation : int {\nTranslation = (1 &lt;&lt; 0),\nRotation = (1 &lt;&lt; 1),\nScaling = (1 &lt;&lt; 2),,\n}\nBitField&lt;Operation&gt; op;\nop.set(Operation::Translation);\nop.set(Operation::Scaling);\nif (op.test(Operation::Scaling)) {\nlagrange::logger().info(\"Scaling bit is set\");\n}\n</code></pre>"},{"location":"user/core/general-utilities/#floating-point-exceptions","title":"Floating Point Exceptions","text":"<p>On certain platforms, it is possible to trap floating point exceptions using compiler-specific functions. This is useful for debugging purposes, e.g. to detect when a NaN is emitted during numerical computation.</p> <p>Lagrange provide a convenient platform-agnostic function called enable_fpe() / disable_fpe() to enable/disable trapping floating point exceptions. Our implementation currently supports Linux and macOS. On non-supported platform, calling the function is a no-op.</p> <pre><code>#include &lt;lagrange/utils/fpe.h&gt;\n\nvoid my_main() {\nlagrange::enable_fpe();\n// call problematic operation []...]\nlagrange::disable_fpe();\n}\n</code></pre> <p>Compilation Issues</p> <p>If our implementation of <code>enable_fpe()</code> casues compilation issues on your target platform (e.g. macOS M1, Emscripten, etc.), it is possible to disable the feature explicitly by setting the CMake option <code>LAGRANGE_DISABLE_FPE=ON</code>. In this case, calling <code>enable_fpe()</code> will do nothing.</p>"},{"location":"user/core/general-utilities/#scope-guard","title":"Scope Guard","text":"<p>Sometimes it is necessary to ensure that certain resources are properly deallocated when leaving the scope of a function. This typically happens when dealing with C API that provide abstract object handling functions such as:</p> <pre><code>struct MyObject;\n\nMyObject * create_object();\n\nvoid delete_object(MyObject *);\n</code></pre> <p>To make object deletion exception-safe in C++, one must ensure that the <code>delete_object()</code> function is called even if an exception is raised. One possibility is to use a RAII class. Lagrange provides a simple make_scope_guard() function that wraps an arbitrary callable using RAII:</p> <pre><code>#include &lt;lagrange/utils/scope_guard.h&gt;\n\nvoid my_function() {\nMyObject *obj = create_object();\n\n// Deferred called to `delete_object()` destructor.\n// Called when `guard` goes out of scope.\nauto guard = lagrange::make_scope_guard([&amp;]( delete_object(obj); ));\n\n// Use `obj` ...\n}\n</code></pre> <p>This paradigm is also useful when using imperative programming, e.g. when implementing an \"editable state\" in an object, and you want to ensure the <code>begin_edit()</code> and <code>end_edit()</code> methods are always called together. It can also be use to wrap calls to <code>glBegin()</code> and <code>glEnd()</code> in OpenGL, ensuring the state machine stays consistent.</p>"},{"location":"user/core/general-utilities/#stack-allocated-containers","title":"Stack-Allocated Containers","text":"<p>Lagrange provides different implementations of stack-allocated containers. Such containers are extremely useful when dealing with many small buffers with a known upper-limit size, or at least a good initial guess. For example if the nodes of a graph have at most 6 neighbors, you can use a stack-allocated containers to store the neighbor indices. Another example is storing a quad-dominant mesh, where facets can have a size 3 or 4.</p> <p>Lagrange currently provide the following implementations:</p> <ul> <li>SmallVector. An implementation of a <code>std::vector&lt;&gt;</code> with a pre-allocated stack   buffer that grow on the heap beyond the initial upper limit.</li> <li>StackVector. An implementation of a <code>std::vector&lt;&gt;</code> with a fixed upper size   provided at compile-time. Inserting new elements beyond the limit will throw an exception.</li> <li>StackSet. An implementation of a <code>std::set&lt;&gt;</code> with a fixed upper size provided at   compile-time. Inserting new elements beyond the limit will throw an exception.</li> </ul>"},{"location":"user/core/general-utilities/#shared-span","title":"Shared Span","text":"<p>Lagrange's SurfaceMesh class relies heavily on a span&lt;&gt; implementation to provide bounds-safe view over raw pointers. Since our mesh attribute supports copy-on-write and wrapping of external buffers, it can be desirable to wrap external buffers as attribute while managing their lifetime.</p> <p>To this end, Lagrange implements a SharedSpan object that offers a bounds-safe view over a raw pointer, while tracking the actual owner object via a different <code>std::shared_ptr&lt;&gt;</code>.</p> <p>Example 1: Buffer Created via a C-style API</p> <pre><code>struct MyMesh {\nstd::vector&lt;float&gt; vertices;\nstd::vector&lt;uint32_t&gt; facets;\n};\n\n// Create a new mesh instance\nMyMesh * mesh_new();\n\n// Free previously allocated mesh instance\nvoid mesh_free(MyMesh* obj);\n\nvoid wrap_mesh(lagrange::SurfaceMesh&lt;float, uint32_t&gt; &amp;mesh)\n{\n// Create vertex buffer via abstract C API\nauto owner_obj = std::shared_ptr&lt;MyObject&gt;(mesh_new(), &amp;mesh_free);\n\n// Number of vertices is number of coordinates divided by 3\nuint32_t num_vertices = owner_obj-&gt;vertices.size() / 3;\n\n// Create a \"view\" of the raw vertices pointer while tracking ownership information\nauto vertices_vew = make_shared_span(\nowner_obj,\nowner_obj-&gt;vertices.data(),\nowner_obj-&gt;vertices.size());\n\nmesh.wrap_as_vertices(vertices_vew, num_vertices);\n\n// Wrap facet buffer sharing the same owner object\nuint32_t num_facets = owner_obj-&gt;facets.size() / 3;\nauto facets_vew = make_shared_span(\nowner_obj,\nowner_obj-&gt;facets.data(),\nowner_obj-&gt;facets.size());\nmesh.wrap_as_facets(facets_view, num_facets, 3);\n}\n</code></pre> <p>Example 2: Buffer Stored as an Eigen Matrix</p> <pre><code>using RowMatrixXd = Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;;\n\n// Moves a N x 3 matrix of vertex positions into a Lagrange SurfaceMesh\n// without copying the underlying buffer\nvoid wrap_vertices(lagrange::SurfaceMesh32d&amp; mesh, RowMatrixXd&amp;&amp; V)\n{\n// Take ownership of the input matrix V\nauto eigen_matrix = std::make_shared&lt;RowMatrixXd&gt;(std::move(V));\n\n// Create a safe view of the raw position data\nauto vertices_view =\nlagrange::make_shared_span(eigen_matrix, eigen_matrix-&gt;data(), eigen_matrix-&gt;size());\n\n// Wrap raw position data as vertices without any copy\nmesh.wrap_as_vertices(vertices_view, eigen_matrix-&gt;rows());\n}\n</code></pre>"},{"location":"user/core/legacy-attributes/","title":"Legacy Mesh Attributes","text":""},{"location":"user/core/legacy-attributes/#legacy-mesh-attributes","title":"Legacy Mesh Attributes","text":"<p>Legacy Mesh</p> <p>Since v6.0.0, Lagrange introduced a new polygonal mesh class that is meant to replace the original mesh class used throughout Lagrange. The old <code>lagrange::Mesh&lt;&gt;</code> class is thus deprecated, but will be kept around for a while until we can transition all our code to the new data structure.</p> <p>Lagrange provides functions to compute some of the commonly used mesh attributes.</p>"},{"location":"user/core/legacy-attributes/#vertex-attributes","title":"Vertex Attributes","text":""},{"location":"user/core/legacy-attributes/#normals","title":"Normals","text":"<p>The following snippet shows how to compute per-vertex normal:</p> <pre><code>#include &lt;lagrange/compute_vertex_normal.h&gt;\n\nlagrange::compute_vertex_normal(mesh);\nassert(mesh.has_vertex_attribute(\"normal\"));\n\nconst auto&amp; vertex_normals =\nmesh.get_vertex_attribute(\"normal\");\nassert(vertex_normals.rows() == mesh.get_num_vertices());\nassert(vertex_normals.cols() == 3);\n</code></pre> <p>Note</p> <p>The resulting vertex normals are stored as a vertex attribute named \"normal\".  Its size is <code>n</code> by <code>3</code>, where <code>n</code> is the number of vertices. In addition, this method only works for 3D mesh.</p> <p>Implementation details</p> <p>The per-vertex normal is computed as the angle weighted average of facet normals.</p>"},{"location":"user/core/legacy-attributes/#vertex-valance","title":"Vertex Valance","text":"<p>In graph theory, vertex valance is the number of edge incident at a vertex.</p> <pre><code>#include &lt;lagrange/compute_vertex_valance.h&gt;\n\nlagrange::compute_vertex_valance(mesh);\nassert(mesh.has_vertex_attribute(\"valance\"));\n\nconst auto&amp; valance =\nmesh.get_vertex_attribute(\"valance\");\nassert(valance.rows() == mesh.get_num_vertices());\nassert(valance.cols() == 1);\n</code></pre> <p>Note</p> <p>The resulting vertex valance data is stored as a vertex attribute named \"valance\".  It is an <code>n</code> by <code>1</code> matrix, where <code>n</code> is the number of vertices.</p>"},{"location":"user/core/legacy-attributes/#facet-attributes","title":"Facet Attributes","text":""},{"location":"user/core/legacy-attributes/#normals_1","title":"Normals","text":"<p>The following snippet computes the per-facet normal:</p> <pre><code>#include &lt;lagrange/compute_triangle_normal.h&gt;\n\nlagrange::compute_triangle_normal(mesh);\nassert(mesh.has_facet_attribute(\"normal\"));\n\nconst auto&amp; facet_normals =\nmesh.get_facet_attribute(\"normal\");\nassert(facet_normals.rows() == mesh.get_num_facets());\nassert(facet_normals.cols() == 3);\n</code></pre> <p>Note</p> <p>The output facet normal is stored as a <code>m</code> by <code>3</code> facet attribute named \"normal\", where <code>m</code> is the number of facets.</p> <p>Limitation</p> <p>For now, only 3D triangle normal computation is supported.</p>"},{"location":"user/core/legacy-attributes/#area","title":"Area","text":"<p>The following snippet computes the per-facet area:</p> <pre><code>#include &lt;lagrange/compute_facet_area.h&gt;\n\nlagrange::compute_facet_area(mesh);\nassert(mesh.has_facet_attribute(\"area\"));\n\nconst auto&amp; areas =\nmesh.get_facet_attribute(\"area\");\nassert(areas.rows() == mesh.get_num_facets());\nassert(areas.cols() == 1);\n</code></pre> <p>Note</p> <p>The output facet area is stored as a <code>m</code> by <code>1</code> facet attribute named \"area\", where <code>m</code> is the number of facets.  Both triangle and quad facet types are supported.</p>"},{"location":"user/core/legacy-attributes/#uv-distortion","title":"UV Distortion","text":"<p>UV distortion measures the amount of skew introduced by a mesh's UV mapping.</p> <pre><code>#include &lt;lagrange/compute_uv_distortion.h&gt;\n\nlagrange::compute_uv_distortion(mesh);\nassert(mesh.has_facet_attribute(\"distortion\"));\n\nconst auto&amp; distortion =\nmesh.get_facet_attribute(\"distortion\");\nassert(distortion.rows() == mesh.get_num_facets());\nassert(distortion.cols() == 1);\n</code></pre> <p>Note</p> <p>The per-facet distortion is a <code>m</code> by <code>1</code> facet attribute named \"distortion\", where <code>m</code> is the number of facets.  The computation of distortion measure requires the input is triangular.  Small positive values indicate low distortion, and negative values indicate inverted triangle in UV space.</p> <p>Implementation details</p> <p>This method computes the 2D conformal AMIPS energy defined in Rabinovich et al. 2017.</p>"},{"location":"user/core/legacy-attributes/#edge-attributes","title":"Edge Attributes","text":""},{"location":"user/core/legacy-attributes/#edge-length","title":"Edge Length","text":"<p>Edge length can be computed:</p> <pre><code>#include &lt;lagrange/compute_edge_lengths.h&gt;\n\nlagrange::compute_edge_lengths(mesh);\nassert(mehs.has_edge_attribute(\"length\"));\n\nconst auto&amp; edge_lengths =\nmesh.get_edge_attribute(\"length\");\nassert(edge_lengths.rows() == mesh.get_num_edges());\nassert(edge_lengths.cols() == 1);\n</code></pre> <p>Note</p> <p>Edge lengths are stored as a <code>e</code> by <code>1</code> per-edge attribute named \"length\", where <code>e</code> is the number of undirected edges.</p>"},{"location":"user/core/legacy-attributes/#dihedral-angle","title":"Dihedral Angle","text":"<p>For manifold meshes, dihedral angle is defined as the angle formed by the normals of two adjacent facets.</p> <pre><code>#include &lt;lagrange/compute_dihedral_angles.h&gt;\n\nlagrange::compute_dihedral_angles(mesh);\nassert(mesh.has_edge_attribute(\"dihedral_angle\"));\n\nconst auto&amp; dihedral_angle =\nmesh.get_edge_attribute(\"dihedral_angle\");\nassert(dihedral_angle.rows() == mesh.get_num_edges());\nassert(dihedral_angle.cols() == 1);\n</code></pre> <p>Note</p> <p>The computed dihedral angles are stored as a <code>e</code> by <code>1</code> edge attribute named \"dihedral_angle\", where <code>e</code> is the number of edges.  All angles are in radians.</p> <p>Limitation</p> <p>The dihedral angle is only well-defined for 3D manifold meshes.</p>"},{"location":"user/core/legacy-mesh/","title":"Legacy Mesh Class","text":""},{"location":"user/core/legacy-mesh/#legacy-mesh-class","title":"Legacy Mesh Class","text":"<p>Legacy Mesh</p> <p>Since v6.0.0, Lagrange introduced a new polygonal mesh class that is meant to replace the original mesh class used throughout Lagrange. The old <code>lagrange::Mesh&lt;&gt;</code> class is thus deprecated, but will be kept around for a while until we can transition all our code to the new data structure.</p> <p>The Mesh class is one of the key data structures used in Lagrange. It provides a standard representation of discretized (triangle or quad) surfaces in 2D and 3D. It is used by nearly all Lagrange functionalities.</p> <p>It consists of the following components</p> <ul> <li>Geometry: Vertices, facets, edges.</li> <li>Attributes: Scalar or vector field associated with vertices, faces, edges and corners (per vertex-facet pair).</li> <li>Connectivity: Vertex-vertex, vertex-facet, facet-facet, edge-facet adjacency matrices.</li> <li>Topology: Manifold/non-manifold check, boundary edge extraction.</li> <li>Components: Lists of facet indices that form connected components.</li> <li>UV: UV coordinates and indices.</li> <li>Matrices: Cache for discrete differential geometry matrices such as Laplacian.</li> </ul> <p></p>"},{"location":"user/core/legacy-mesh/#terminology","title":"Terminology","text":"<p>Throughout the documentation, we will consistently use the following terms:</p> <ul> <li> <p>A vertex of a mesh is point on the surface.  It is typically defined by   its coordinates (<code>(x,y,z)</code> in 3D and <code>(x,y)</code> in 2D).</p> </li> <li> <p>A facet of a mesh is an oriented polygon that represent a piece of the   surface. A facet is typically either a triangle or a quad.  It is defined by   an ordered list of vertex indices that form its boundary (<code>[i,j,k]</code> for   triangle and <code>[i,j,k,l]</code> for quad).</p> </li> </ul>"},{"location":"user/core/legacy-mesh/#template-parameters","title":"Template Parameters","text":"<p>The Mesh class's full signature is</p> <pre><code>lagrange::Mesh&lt;VertexArray, FacetArray&gt;;\n</code></pre> <p>It takes two template parameters, both are based on Eigen matrix type:</p> <ul> <li> <p><code>VertexArray</code> is the Eigen matrix type for representing vertex arrays. It is   typically a <code>n</code> by <code>dim</code> matrix, where <code>n</code> is the number of vertices (or   <code>Eigen::Dynamic</code>)   and <code>dim</code> is either 2 or 3 depending on the dimension of the ambient space.   <code>lagrange::Vertices2D</code> and <code>lagrange::Vertices3D</code> are two possible example   types for <code>VertexArray</code> in 2D and 3D.</p> </li> <li> <p><code>FacetArray</code>: is the Eigen matrix type for representing facet arrays.  It is   typically a <code>m</code> by <code>s</code> matrix, where <code>m</code> is the number of facets (or   <code>Eigen::Dynamic</code>) and <code>s</code> is the number of vertices per facet (3 for triangle   mesh and 4 for quad mesh).  <code>lagrange::Triangles</code> and <code>lagrange::Quads</code> are   two example types for <code>FacetArray</code>.</p> </li> </ul> <p>In addition to <code>VertexArray</code> and <code>FacetArray</code>, two important types are inferred:</p> <ul> <li> <p><code>Scalar</code> is the type for representing a floating point number. Typically it   is <code>float</code> or <code>double</code>.  It is defined as the coefficient type of   <code>VertexArray</code> (i.e. <code>VertexArray::Scalar</code>).</p> </li> <li> <p><code>Index</code> is the type for representing a index. Typically, it is <code>int</code> or   <code>size_t</code>.  It is defined as the coefficient type of <code>FacetArray</code> (i.e.   <code>FacetArray::Scalar</code>).</p> </li> </ul> <p>Note</p> <p>In Lagrange, we often use the type alias <code>MeshType</code> to represent a specific instantiation of the Mesh class. It is equivalent to:</p> <pre><code>using MeshType = Mesh&lt;VertexArray, FacetArray&gt;;\n</code></pre>"},{"location":"user/core/legacy-mesh/#naming-convention","title":"Naming Convention","text":"<p>Within this doc, we use the following naming convention when referring to mesh objects:</p> <ul> <li><code>mesh</code> is used for naming raw objects (<code>MeshType</code>).</li> <li><code>mesh_ptr</code> is used for raw pointers  (<code>MeshType*</code>).</li> <li><code>mesh_ref</code> is used for l-value references (<code>MeshType&amp;</code>).</li> <li><code>mesh_shared</code> is used for shared pointers (<code>std::shared_ptr&lt;MeshType&gt;</code>).</li> <li><code>mesh_unique</code> is used for shared pointers (<code>std::unique_ptr&lt;MeshType&gt;</code>).</li> </ul>"},{"location":"user/core/legacy-mesh/#creation","title":"Creation","text":"<p>It is easy to create a Mesh object from raw data:</p> <pre><code>// Generate raw data for a single triangle.\nlagrange::Vertices3D vertices(3, 3);\nvertices &lt;&lt; 0.0, 0.0, 0.0,\n1.0, 0.0, 0.0,\n0.0, 1.0, 0.0;\nlagrange::Triangles facets(1, 3);\nfacets &lt;&lt; 0, 1, 2;\n\n// Create a mesh object\nauto mesh_unique = lagrange::create_mesh(vertices, facets);\n</code></pre> <p>The return type of <code>lagrange::create_mesh</code> method is a unique pointer of a Mesh object.  Note in this case, the matrices <code>vertices</code> and <code>facets</code> are copied into the <code>mesh</code> object.  If we are certain these matrices will outlive the <code>mesh</code> object, we can avoid the copies with:</p> <pre><code>auto mesh_unique = lagrange::wrap_with_mesh(vertices, facets);\n</code></pre> <p>If we want to move the data from <code>vertices</code> and <code>facets</code> to the <code>mesh</code> object:</p> <pre><code>auto mesh_unique = lagrange::create_mesh(\nstd::move(vertices),\nstd::move(facets));\n</code></pre> <p>A Mesh class object can also be loaded from a file. In this case, one needs to explicitly specify the <code>VertexArray</code> and <code>FacetArray</code> types:</p> <pre><code>using VertexArray = lagrange::Vertices3D;\nusing FacetArray = lagrange::Triangles;\nusing MeshType = lagrange::Mesh&lt;VertexArray, FacetArray&gt;;\n\nauto mesh_unique = lagrange::load_mesh&lt;MeshType&gt;(\"filename.obj\");\n</code></pre> <p>It is often necessary to convert a unique pointer to shared pointer or raw pointer to invoke Lagrange functions.  It can be done easily:</p> <pre><code>#include &lt;lagrange/common.h&gt;\n\n// Get a reference\nauto&amp; mesh_ref = *mesh_unique;\n// `mesh_ref` is of type `MeshType&amp;`.\n\n// Convert to shared_ptr.\nauto mesh_shared = lagrange::to_shared_ptr(mesh_unique);\n// `shared_mesh` is of type `std::shared_ptr&lt;MeshType&gt;`\nassert(mesh_unique == nullptr);\n\n// Get a raw pointer.\n// Warning: Never (!!) wrap the same raw pointer into\n// a new unique_ptr or shared_ptr.\nMeshType* mesh_ptr = mesh_shared.get();\n</code></pre>"},{"location":"user/core/legacy-mesh/#geometry","title":"Geometry","text":"<p>The Mesh class provides a number of handy functions for access geometric data stored in it, for example:</p> <pre><code>const auto dim = mesh.get_dim();\nconst auto vertex_per_facet = mesh.get_vertex_per_facet();\n\nconst auto num_vertices = mesh.get_num_vertices();\nconst auto num_facets = mesh.get_num_facets();\n</code></pre> <p>To access the raw vertex/facet matrix:</p> <pre><code>const auto&amp; vertices = mesh.get_vertices();\nconst auto&amp; facets = mesh.get_facets();\n</code></pre>"},{"location":"user/core/legacy-mesh/#connectivity","title":"Connectivity","text":"<p>Connectivity can be optionally initialized and stored in the Mesh class as adjacency lists. For example:</p> <pre><code>mesh.initialize_connectivity();\nassert(mesh.is_connectivity_initialized());\n\n// To get vertices adjacent to vertex v0:\nconst auto&amp; v0_adj_vertices =\nmesh.get_vertices_adjacent_to_vertex(v0);\n\n// To get facets adjacent to vertex v0:\nconst auto&amp; v0_adj_facets =\nmesh.get_facets_adjacent_to_vertex(v0);\n\n// To get facets adjacent to facet f0:\nconst auto&amp; f0_adj_facets =\nmesh.get_facets_adjacent_to_facet(f0);\n\n// Example usage:\nfor (const auto fi : f0_adj_facets) {\n// `fi` and `f0` are adjacent.\n}\n</code></pre> <p>Note</p> <p>All returned values are of type <code>MeshType::IndexList</code>, which is an alias of <code>std::vector&lt;MeshType::Index&gt;</code>.</p>"},{"location":"user/core/legacy-mesh/#edge-data","title":"Edge Data","text":"<p>An edge in lagrange is an object containing two vertex indices. <code>lagrange::EdgeType</code> takes an <code>Index</code> as a template parameter (e.g. <code>lagrange::EdgeType&lt;int&gt;(0, 1)</code>). <code>Edge</code> is defined in <code>lagrange::Mesh</code> class as an alias to <code>lagrange::EdgeType&lt;Index&gt;</code>.</p> <p>Note that an edge does not define a direction, and <code>Edge(v1, v2) == Edge(v2, v1)</code>. Never use <code>Edge</code> to represent a directed edge.</p> <p>Edge data can be initialized and stored in the Mesh class. This consists of the following data:</p> <ul> <li><code>std::vector&lt;Edge&gt;</code>: A list of edges of the mesh. Edge indices indicate positions in this vector. Edge data below and edge attributes use the same indices.</li> <li><code>std::vector&lt;std::vector&lt;Index&gt;&gt;</code>: Lists the facets adjacent to each edge.</li> <li><code>std::unordered_map&lt;Edge, Index&gt;</code>: Maps each edge to its index.</li> </ul> <pre><code>mesh.initialize_edge_data();\n\nconst auto num_edges = mesh.get_num_edges();\n\nbool boundary = mesh.get_is_edge_boundary({v1, v2});\n\n// iterate over all edges\nfor (const auto&amp; edge : mesh.get_edges()) {\n}\n\n// prefer using indices to avoid multiple map look-ups\nfor (Index e_idx = 0; e_idx &lt; num_edges; ++e_idx) {\nfor (auto Index f : mesh.get_edge_adjacent_facets(e_idx)) {\n// f is an adjacent facet\n}\n}\n</code></pre>"},{"location":"user/core/legacy-mesh/#components","title":"Components","text":"<p>A mesh could contain multiple connected components.  To extract connected components:</p> <pre><code>mesh.initialize_components();\nassert(mesh.is_components_initialized());\n\nconst auto num_comps = mesh.get_num_components();\nconst auto&amp; comps = mesh.get_components();\nassert(num_comps == comps.size());\n\n// To access the first component:\nconst auto&amp; comp_0 = comps.front();\nfor (const auto&amp; fi : comp_0) {\n// Facet indexed by fi belongs to comp_0.\n}\n</code></pre> <p>It is also possible to extract a mapping from facet indices to component indices:</p> <pre><code>const auto&amp; f_to_c_map = mesh.get_per_facet_component_ids();\nassert(f_to_c_map.size() == mesh.get_num_facets());\n\nconst auto num_facets = mesh.get_num_facets();\nfor (Index fi=0; fi &lt; num_facets; fi++) {\n// Facet fi belongs to component f_to_c_map[fi].\n}\n</code></pre>"},{"location":"user/core/legacy-mesh/#topology","title":"Topology","text":"<p>A mesh is called vertex-manifold if and only if the 1-ring neighborhood of all its vertices are topologically equivalent to a disc.  Similarly, a mesh is called edge-manifold if and only if all of its edges are adjacent to at most 2 facets.</p> <p>Lagrange mesh has build-in supports for querying these topological properties:</p> <pre><code>mesh.initialize_topology();\nassert(mesh.is_topology_initialized());\n\nif (mesh.is_vertex_manifold()) {\n...\n}\n\nif (mesh.is_edge_manifold()) {\n...\n}\n</code></pre> <p>Note</p> <p>Vertex-manifold is a stronger condition.  If a mesh is vertex-manifold, it is automatically implies it is also edge-manifold.</p>"},{"location":"user/core/legacy-mesh/#uv","title":"UV","text":"<p>Lagrange mesh has direct support for UV coordinates:</p> <pre><code>assert(mesh.is_uv_initialized());\n\nconst auto&amp; uv_coords = mesh.get_uv();\nconst auto&amp; uv_indices = mesh.get_uv_indices();\n</code></pre> <p>The type of <code>uv_coords</code> is <code>MeshType::UVArray</code> and the type of <code>uv_indices</code> is <code>MeshType::UVIndices</code>.  Both are predefined Eigen matrices using <code>MeshType::Scalar</code> and <code>MeshType::Index</code> as scalar type. The <code>j</code>th vertex of facet <code>i</code> has UV coordinates <code>uv_coords.row(uv_indices(i,j))</code>.</p> <p>Together, <code>uv_coords</code> and <code>uv_indices</code> form a 2D mesh, which can be extracted:</p> <pre><code>assert(mesh.is_uv_initialized());\nauto uv_mesh = mesh.get_uv_mesh();\n</code></pre> <p>It is also possible to erase existing UV and assign a new one:</p> <pre><code>mesh.clear_uv();\nmesh.initialize_uv(uv_coords, uv_indices);\n</code></pre>"},{"location":"user/core/legacy-mesh/#attributes","title":"Attributes","text":"<p>It is often useful to assign spatially varying scalar field or vector over the surface of the mesh.  Lagrange's Mesh class support 4 types of attributes:</p> <ul> <li>Per-vertex attribute: One value per vertex.</li> <li>Per-facet attribute: One value per facet.</li> <li>Per-corner attributer: One value per vertex per facet.</li> <li>Per-edge attribute: One value per undirected edge.</li> </ul> <p>All attributes has a name and are stored as <code>MeshType::AttributeArray</code>, which is Eigen matrix of <code>MeshType::Scalar</code>.  For example, to create a custom per-vertex attribute:</p> <pre><code>MeshType::AttributeArray attr(num_vertices, 1);\n// Initialize the `attr` matrix.\n\nmesh.add_vertex_attribute(\"attr_name\");\nmesh.set_vertex_attribute(\"attr_name\", attr);\n</code></pre> <p>Attribute can be retrieved at any time from its name:</p> <pre><code>if (mesh.has_vertex_attribute(\"attr_name\")) {\nconst auto&amp; attr =\nmesh.get_vertex_attribute(\"attr_name\");\nassert(attr.rows() == mesh.get_num_vertices());\n}\n</code></pre>"},{"location":"user/core/mesh-cleanup/","title":"Mesh Cleanup","text":""},{"location":"user/core/mesh-cleanup/#mesh-cleanup","title":"Mesh Cleanup","text":"<p>Legacy Mesh</p> <p>Documentation on this page relies on our legacy mesh data structure.</p> <p>Lagrange supports a number of mesh cleanup operations.  Typically, a mesh cleanup operation takes an mesh object as input and creates a new Mesh object. For example, all mesh cleanup functions have the same function signature:</p> <pre><code>auto out_mesh_unique = lagrange::function_name(in_mesh);\n</code></pre> <p>Therefore, it is possible to combine mesh cleanup operations by chaining them. Existing vertex/facet/corner attributes can be seamless ported from the input mesh to the output mesh.</p> <p>Limitation</p> <p>Edge attribute is not ported at the moment.</p>"},{"location":"user/core/mesh-cleanup/#remove-isolated-vertices","title":"Remove Isolated Vertices","text":"<p>An isolated vertex is a vertex that is not adjacent to any facet.  It can be removed with <code>remove_isolated_vertex</code> function:</p> <pre><code>#include &lt;lagrange/mesh_cleanup/remove_isolated_vertices.h&gt;\nauto mesh2_unique = lagrange::remove_isolated_vertices(\nmesh);\n</code></pre>"},{"location":"user/core/mesh-cleanup/#remove-duplicate-vertices","title":"Remove Duplicate Vertices","text":"<p>Two vertices are considered duplicates if they have exactly the same coordinates.  To remove duplicate vertices:</p> <pre><code>#include &lt;lagrange/mesh_cleanup/remove_duplicate_vertices.h&gt;\nauto mesh_unique = lagrange::remove_duplicate_vertices(\nmesh);\n</code></pre> <p>It is also possible to add an extra condition when checking for vertex duplicates.  By specifying a vertex attribute, two vertices are considered duplicates if they have exactly the same coordinates and attribute values. For example:</p> <pre><code>#include &lt;lagrange/mesh_cleanup/remove_duplicate_vertices.h&gt;\nauto mesh2_unique = lagrange::remove_duplicate_vertices(\nmesh, \"color\");\n</code></pre> <p>This call will remove all duplicate vertices that have the same coordinates and color as defined by the \"color\" vertex attribute.</p>"},{"location":"user/core/mesh-cleanup/#remove-degenerate-triangles","title":"Remove Degenerate Triangles","text":"<p>A triangle is called degenerate if all of its vertices are exactly collinear. Lagrange relies on exact predicates to check collinearity.</p> <pre><code>#include &lt;lagrange/mesh_cleanup/remove_degenerate_triangles.h&gt;\nauto mesh2_unique = lagrange::remove_degenerate_triangles(\nmesh);\n</code></pre>"},{"location":"user/core/mesh-cleanup/#remove-topologically-degenerate-triangles","title":"Remove Topologically Degenerate Triangles","text":"<p>A triangle is called topologically degenerate if two or more of its vertices are the same topologically.  For example, a triangle <code>[1, 1, 2]</code> is topologically degenerate because two of its vertices are referring to the same vertex (the vertex with index <code>1</code>).  Topological degeneracy is a special case of general degeneracy and it is possible to identify it from connectivity alone.</p> <pre><code>#include &lt;lagrange/mesh_cleanup/remove_topologically_degenerate_triangles.h&gt;\nauto mesh2_unique = lagrange::remove_topologically_degenerate_triangles(\nmesh);\n</code></pre>"},{"location":"user/core/mesh-cleanup/#remove-short-edges","title":"Remove Short Edges","text":"<p>To remove all edges shorter than a given threshold:</p> <pre><code>#include &lt;lagrange/mesh_cleanup/remove_short_edges.h&gt;\nauto mesh2_unqiue = lagrange::remove_short_edges(\nmesh, tol);\n</code></pre> <p>where <code>tol</code> is the target edge length threshold.</p>"},{"location":"user/core/mesh-cleanup/#remove-duplicate-facets","title":"Remove Duplicate Facets","text":"<p>Two facets are considered duplicates of each other if they are formed by the combination of vertices.  E.g. facet <code>[1, 2, 3]</code> is considered as duplicate of facet <code>[3, 2, 1]</code>.  To remove all duplicate facets:</p> <pre><code>#include &lt;lagrange/mesh_cleanup/remove_duplicate_facets.h&gt;\nauto mesh2_unique = lagrange::remove_duplicate_facets(\nmesh);\n</code></pre> <p>Note</p> <p>Facet orientation is not considered.  Even thought facet <code>[1, 2, 3]</code> and <code>[3, 2, 1]</code> have opposite orientations, they are considered as duplicates.</p>"},{"location":"user/core/mesh-cleanup/#split-long-edges","title":"Split Long Edges","text":"<p>It is often that we need to refine a triangular mesh by splitting long edges:</p> <pre><code>#include &lt;lagrange/mesh_cleanup/split_long_edges.h&gt;\nauto mesh2_unique = lagrange::split_long_edges(\nmesh, sq_tol, true);\n</code></pre> <p>Other than the input mesh, <code>lagrange::split_long_edges</code> takes two more parameters:</p> <ul> <li><code>sq_tol</code>: The target edge length squared.  All edges longer than this   threshold will be split.</li> <li><code>recursive</code>: Whether to split recursively.  Because edge splitting will   introduce new edges and these new edges may be longer than the specified   threshold. Splitting recursively will guarantee the output mesh contain no   edge longer than the specified threshold.</li> </ul> <p>Note</p> <p>Only long edges are split.  This is different from uniform refinement where all edges are split.</p>"},{"location":"user/core/mesh-cleanup/#resolve-nonmanifoldness","title":"Resolve Nonmanifoldness","text":"<p>Lagrange can convert a nonmanifold mesh to a manifold mesh:</p> <pre><code>#include &lt;lagrange/mesh_cleanup/resolve_nonmanifoldness.h&gt;\nauto mesh2_unique = lagrange::resolve_nonmanifoldness(\nmesh);\n</code></pre> <p>where nonmanifold vertices and edges are \"pulled apart\".</p> <p>Implementation details</p> <p>Here is an illustration describing how Lagrange \"pulls apart\" nonmanifold vertices and edges:</p> <p></p>"},{"location":"user/core/mesh-cleanup/#convert-quad-mesh-to-triangular-mesh","title":"Convert Quad Mesh To Triangular Mesh","text":"<p>Lagrange also provide handy function to convert a quad to a triangular mesh:</p> <pre><code>#include &lt;lagrange/quad_to_tri.h&gt;\nauto mesh2_unique = lagrange::quad_to_tri(mesh);\n</code></pre> <p>Implementation details</p> <p>Each quad is converted to 2 triangles by inserting one of its diagonals procedurally.</p>"},{"location":"user/core/mesh-cleanup/#submesh-extraction","title":"Submesh Extraction","text":"<p>It is often necessary to extract a subset of the facets from a given mesh.  Such operation is supported via <code>lagrange::extract_submesh</code> function:</p> <pre><code>#include &lt;lagrange/extract_submesh.h&gt;\n\nstd::vector&lt;int&gt; selected_facets;\n// Populate selected_facets with facet indices.\n\nauto submesh_unique = lagrange::extract_submesh(\nmesh, selected_facets);\n</code></pre>"},{"location":"user/core/mesh-utilities/","title":"Mesh Utility Functions","text":"<p>This page describes various mesh and attribute utilities available in Lagrange's core module.</p>"},{"location":"user/core/mesh-utilities/#compute-mesh-normals","title":"Compute Mesh Normals","text":"<p>As described in our Mesh Utilities page, mesh normals can be computed using on of the following function:</p> <pre><code>#include &lt;lagrange/compute_normal.h&gt;\n#include &lt;lagrange/compute_facet_normal.h&gt;\n#include &lt;lagrange/compute_vertex_normal.h&gt;\n\nlagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\n\n// Compute per-facet normals\nlagrange::FacetNormalOptions facet_options;\nauto fid = compute_facet_normal(mesh, facet_options);\n\n// Compute per-vertex normals using a uniform weight for each incident triangle\nVertexNormalOptions vertex_options;\nvertex_options.weight_type = lagrange::NormalWeightingType::Uniform;\nauto vid = compute_vertex_normal(mesh, vertex_options);\n\n// Compute indexed per-corner normals. Edges with a dihedral\n// angle smaller than \u03c0/2 will be considered smooth\nScalar angle_threshold_rad = M_PI * 0.5;\nauto cid = compute_normal(mesh, angle_threshold_rad);\n</code></pre> <p>See Mesh Utilities reference documentation for more details.</p>"},{"location":"user/core/mesh-utilities/#compute-tangent-space","title":"Compute Tangent Space","text":"<p>Lagrange offers a function to compute tangent-space information, following [Mikkelsen 2008]1:</p> <pre><code>#include &lt;lagrange/compute_tangent_bitangent.h&gt;\n\nlagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\nlagrange::TangentBitangentOptions options;\n\n// Pad the 4th channel of the output attributes with\n// a \u00b11 indicating the sign of the UV triangle\noptions.pad_with_sign = true;\n\nauto btn = compute_tangent_bitangent(mesh, options);\nbtn.tangent_id; // id of the generated tangent vector attribute\nbtn.bitangent_id; // id of the generated bitangent vector attribute\n</code></pre> <p>The input mesh must have an existing indexed UV and normal attribute. The <code>options.output_element_type</code> can be either <code>Indexed</code> (default), or <code>Corner</code>:</p> <ul> <li>If the output type is <code>Corner</code>, no averaging is performed, and the output attribute contains   directly the per-corner tangent space.</li> <li>If the output type is <code>Indexed</code>, averaging is performed based on the provided indexed attributes.   Corners with identical normals and UVs will be considered as a single smoothing group for tangent   space computation.</li> </ul> <p>Corners are grouped into different smoothing groups, based on provided   UV and normal attributes. Image from [Mikkelsen 2008]1</p> <p>Accuracy vs Mikktspace</p> <p>We have unit tests comparing our results with the original mikktspace code [Mikkelsen 2008]1. We found that, in floating points, we have a max error of <code>1e-6f</code>.</p> <p>Performance vs Mikktspace</p> <p>Our benchmark shows that we are 5x-6x faster than mikktspace, mostly due to the addition of multithreading.</p> <p>Welding Attributes</p> <p>The original mikktspace code expects the input UV/normals as a per-corner value, and will always weld corners sharing identical UV/normal values. In contrast, our mesh data structure uses a more generic indexed attribute, and we use an attribute's index to identify and group together identical corners.</p> <p>In practice, this means that you will need to weld together any identical attribute that do not share the same indices, or you may end up with different result compared to mikktspace.</p> <p>Limitations: Triangle Meshes vs Quad Meshes</p> <ul> <li>Our code for averaging tangent vectors only support triangle meshes at the moment.</li> <li>Quad meshes and quad-dominant meshes can be used, but only with <code>output_element_type = Corner</code> (no averaging will be performed).</li> <li>General polyhedral facets (with &gt; 4 vertices) are not supported at the moment.</li> </ul>"},{"location":"user/core/mesh-utilities/#normalize-meshes","title":"Normalize Meshes","text":"<p>Meshes can be normalized to fit in a unit box centered at the origin using the <code>normalize_meshes()</code> function, which modifies the mesh in place:</p> <pre><code>#include &lt;lagrange/normalize_meshes.h&gt;\n\n// Normalize a single mesh\nnormalize_mesh(mesh);\n\n// Normalize a list of meshes using the same transform for all meshes\nusing MeshType = SurfaceMesh32f;\nstd::vector&lt;MeshType *&gt; meshes;\nmeshes.push_back(&amp;mesh1);\nmeshes.push_back(&amp;mesh2);\nmeshes.push_back(&amp;mesh3);\nnormalize_meshes(meshes);\n</code></pre> <p>See: Mesh Utilities documentation.</p>"},{"location":"user/core/mesh-utilities/#triangulate-polygonal-facets","title":"Triangulate Polygonal Facets","text":"<p>A mesh with polygonal facets can be turned into a pure triangle mesh by calling the following code:</p> <pre><code>#include &lt;lagrange/triangulate_polygonal_facets.h&gt;\n\n// Modifies the mesh in place\ntriangulate_polygonal_facets(mesh);\n</code></pre> <p>Under the hood we use Mapbox's Earcut implementation for polygonal facets with 5 vertices or more.</p> <p>See: Mesh Utilities documentation.</p>"},{"location":"user/core/mesh-utilities/#transfer-mesh-attributes","title":"Transfer Mesh Attributes","text":"<p>Attributes can be mapped from one type of mesh element to another using the <code>map_attribute()</code> functions.</p> <pre><code>#include &lt;lagrange/compute_normal.h&gt;\n#include &lt;lagrange/map_attribute.h&gt;\n\n// Transfer vertex normal attribute onto mesh facets (values will be averaged)\nauto vid = compute_vertex_normals(mesh);\nauto fid = map_attribute(mesh, vid, \"new_name\", lagrange::AttributeElement::Facet);\n</code></pre> <p>One can also transfer an attribute type in place (i.e. without creating a new attribute, just replacing the old one):</p> <pre><code>#include &lt;lagrange/compute_normal.h&gt;\n#include &lt;lagrange/map_attribute.h&gt;\n\n// Transfer vertex normal attribute onto mesh facets (values will be averaged)\nauto id = compute_vertex_normals(mesh);\nmap_attribute_in_place(mesh, id, lagrange::AttributeElement::Facet);\nauto &amp;attr = mesh.get_attribute&lt;Scalar&gt;(id);\nassert(attr.get_element_type() == lagrange::AttributeElement::Facet);\n</code></pre> <p>Transferring attributes from any element type to any other type is supported. The values will either be dispatched or gathered depending on the type of operation, as summarized below:</p> Source\\Target Vertex Facet Edge Corner Indexed Value Vertex \u2205 Gather Gather Dispatch Dispatch Dispatch Facet Gather \u2205 Gather Dispatch Dispatch Dispatch Edge Gather Gather \u2205 Dispatch Dispatch Dispatch Corner Gather Gather Gather \u2205 Dispatch Dispatch Index Gather Gather Gather Dispatch \u2205 Dispatch Value Dispatch Dispatch Dispatch Dispatch Dispatch \u2205 <p>Example</p> <ul> <li>Transfering a vertex attribute to mesh corner elements is a dispatch operation, and will not modify any value.</li> <li>Transfering a corner attribute to mesh vertex elements is an gather operation, and numerical values will be averaged.</li> </ul> <p>Value Attributes</p> <p>When transfering a value attribute to any other type of element, it is expected that the number of entries in the source attribute matches the target number of mesh element.</p> <p>Conversely, transferring from any other mesh element type to a value attribute will create a buffer with the same number of entries as the input attribute element type.</p> <p>Indexed Attributes and Value Attributes</p> <p>When transfering a value attribute to an indexed attribute (and vice-versa), the value attribute is expected to have a number of elements equals to the number of mesh corners.</p> <ul> <li>Transfering <code>Value</code> -&gt; <code>Indexed</code> will create an indexed attribute with a trivial index buffer (identity mapping corner \\(c_i\\) \\(\\to\\) value \\(i\\)).</li> <li>Transfering <code>Indexed</code> -&gt; <code>Value</code> will interpret the indexed attribute as if it were a corner attribute. The indexing will be lost on conversion.</li> </ul> <p>See: Attributes Utilities documentation.</p>"},{"location":"user/core/mesh-utilities/#unify-index-buffers","title":"Unify Index Buffers","text":"<p>It is possible to unify various indexed attributes so they can share the same index buffer. This is especially useful for rendering, e.g. to turn a mesh with different indexing for normals, uv, etc. into something suitable for the GPU.</p> <pre><code>#include &lt;lagrange/unify_index_buffer.h&gt;\n\n// Using attribute id to identify indexed attribute to unify\nauto unified_mesh = unify_index_buffer(mesh, {normal_id, uv_id});\n\n// Using attribute names instead\nauto unified_mesh = unify_index_buffer(mesh, {\"normals\", \"uv\"});\n</code></pre> <p>Vertex Indices</p> <p>The output mesh will use a unified index buffer for both vertex positions and the provided indexed attributes. As a result, some vertices might be duplicated (e.g. if two incident corners have different normals, or a UV seam).</p> <p>See: Attributes Utilities documentation.</p>"},{"location":"user/core/mesh-utilities/#connected-components","title":"Connected Components","text":"<p>Connected components can be computed via the compute_components() function:</p> <pre><code>#include &lt;lagrange/compute_components.h&gt;\n\nlagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\n\n// Consider facets to be connected if they are touching by a common vertex\nlagrange::ComponentOptions options;\noptions.connectivity_type = lagrange::ComponentOption::ConnectivityType::Vertex;\n\n// Compute connected components as a per-facet attribute\nauto num_components = lagrange::compute_components(mesh, options);\nauto &amp;component_id = mesh.get_attribute&lt;Index&gt;(mesh, options.output_attribute_name).get_all();\n\nfor (Index f = 0; f &lt; mesh.get_num_facets(); ++f) {\nassert(0 &lt;= component_id[f] &amp;&amp; component_id[f] &lt; num_components);\n}\n</code></pre> <p>You can choose between edge-connected and vertex-connected components via the <code>options.connectivity_type</code> parameter.</p>"},{"location":"user/core/mesh-utilities/#combine-meshes","title":"Combine Meshes","text":"<p>It is possible to combine multiple meshes into a single aggregated mesh via the combine_meshes() function. This function preserves attributes by default, unless called with <code>preserve_attributes = false</code>. When preserving input mesh attributes, all attributes in the input meshes must be compatible (i.e. all meshes share the same attributes, with the same type/number of channels, etc.).</p> <pre><code>#include &lt;lagrange/combine_meshes.h&gt;\n\nlagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh1, mesh2, mesh3;\n\n// Call via initializer list of mesh pointers\nauto aggregate_mesh1 = lagrange::combine_meshes({&amp;mesh1, &amp;mesh2, &amp;mesh3});\n\n// Call via an array of meshes (meshes are shallow-copied in this example)\nconstexpr size_t num_meshes = 3;\nstd::array&lt;const SurfaceMesh&lt;Scalar, Index&gt;, num_meshes&gt; mesh_list = {\nmesh1,\nmesh2,\nmesh3};\nauto aggregate_mesh2 = lagrange::combine_meshes(mesh_list);\n\n// Call via generic callbacks\nauto aggregate_mesh3 = lagrange::combine_meshes(num_meshes,\n[](size_t idx) -&gt; const SurfaceMesh&lt;Scalar, Index&gt; &amp; {\nreturn mesh_list[idx];\n});\n</code></pre>"},{"location":"user/core/mesh-utilities/#vertex-valence","title":"Vertex Valence","text":"<p>Vertex valence can be computed using the compute_vertex_valence() function:</p> <pre><code>#include &lt;lagrange/compute_vertex_valence.h&gt;\n#include &lt;lagrange/views.h&gt;\n#include &lt;lagrange/Logger.h&gt;\n\nlagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\n\n// Compute vertex valence as a per-vertex attribute\nauto id = lagrange::compute_vertex_valence(mesh);\n\n// Count regular vertices using a Eigen::Map view of the attribute\nvertex_valence = attribute_vector_view&lt;Index&gt;(mesh, id);\nauto num_regular_vertices = (vertex_valence.array() == 6).count();\n\nlagrange::logger().info(\"The mesh has {} regular vertices\", num_regular_vertices);\n</code></pre>"},{"location":"user/core/mesh-utilities/#adjacency-graph","title":"Adjacency Graph","text":"<p>While our mesh class offers some low-level navigation methods, sometimes it beneficial to operate on an explicit adjacency list representation of a connectivity graph. Currently we offer the function compute_vertex_vertex_adjacency() to compute the corresponding adjacency list graph:</p> <pre><code>#include &lt;lagrange/compute_vertex_vertex_adjacency.h&gt;\n\nlagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\n\n// Build adjacency list representation of the vertex-vertex connectivity graph\nauto graph = lagrange::compute_vertex_vertex_adjacency(mesh);\n\n// Display all edges of the graph\nassert(graph.get_num_entries() == mesh.get_num_vertices());\nfor (Index x = 0; x &lt; mesh.get_num_vertices(); ++x) {\nlagrange::logger().info(\"Vertex v{} has {} neighbors\", x, graph.get_num_neighbors(x));\nfor (Index y : graph.get_neighbors(x)) {\nlagrange::logger().info(\"Edge v{} -&gt; v{}\", x, y);\n}\n}\n</code></pre> <p>Connectivity &amp; Edge Information</p> <p>While our mesh navigation methods require the user to call <code>mesh.initialize_edges()</code> beforehand, <code>compute_vertex_vertex_adjacency()</code> does not have such a requirement, and will compute vertex-vertex connectivity information directly.</p> <ol> <li> <p>Mikkelsen, M. 2008. Simulation of wrinkled surfaces revisited. Simulation of wrinkled surfaces revisited. Master\u2019s thesis, University of Copenhagen, Universitetsparken 1, 2100 K\u00f8benhavn, Denmark, http://www.mikktspace.com/.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"user/core/mesh/","title":"Mesh Class","text":"<p>Legacy Mesh vs Surface Mesh</p> <p>Since v6.0.0, Lagrange introduced a new polygonal mesh class that is meant to replace the original mesh class used throughout Lagrange. While currently few of the Lagrange functions use this new mesh class, over time old and new features will transition to use this new data structure.</p> <p>The SurfaceMesh class is the new generic mesh class in Lagrange to represent meshes. It is a very generic class that supports triangle meshes, quad meshes, as well as quad-dominant and arbitrary polygonal meshes. This new data structure was designed with a couple of key features in mind:</p> <ul> <li>Generic and powerful API:<ul> <li>A generic mesh API that works in 2D, 3D, ND with triangles/quad/hybrid meshes using the same   SurfaceMesh type.</li> <li>A simple API based on <code>std::span&lt;&gt;</code> (pointer + size). This avoids a lot of header-only   template shenanigans, while providing a low-overhead but secure interface to manipulate   continuous buffers.</li> </ul> </li> <li>Clean headers:<ul> <li>The main <code>SurfaceMesh.h</code> header only pulls a few STL headers (<code>&lt;memory&gt;</code>, <code>&lt;string_view&gt;</code>,   <code>&lt;span&gt;</code> and <code>&lt;functional&gt;</code> -- the last one can be avoided easily).</li> <li>A separate header <code>views.h</code> allows to \"view\" mesh buffers as Eigen matrices (e.g., for easy   interfacing with libigl).</li> <li>A separate header <code>foreach_attributes.h</code> provides utility functions to iterate over mesh   attributes.</li> </ul> </li> <li>Efficient memory usage:<ul> <li>Generic copy-on-write mesh attributes (per vertex, facet, edge, etc.).</li> <li>Efficient memory storage: a pure triangle/quad meshes only needs 2 buffers for vertex   positions and facet indices, while hybrid meshes will use an additional offset buffer.</li> <li>Mesh attributes can wrap external buffers (including const buffers), as long as memory layout   is compatible. Policies determine write/growth behavior.</li> <li>Mesh attributes can be exported in a <code>std::shared_ptr&lt;&gt;</code> to be transferred back to client   code.</li> </ul> </li> <li>Dynamic editing capabilities:<ul> <li>Mesh vertices and facets can be dynamically inserted and removed efficiently.</li> </ul> </li> <li>Powerful attribute system:<ul> <li>Generic attribute system supporting any fixed-size integer types (<code>int8_t</code> ... <code>uint64_t</code>) and   floating point types (<code>float</code>, <code>double</code>).</li> <li>Attributes can be attached to any mesh element (vertex, facet, edge, corner), or can indexed   by a secondary buffer (e.g. UVs).</li> <li>Usage tag specifies how attributes are used and transformed (e.g. Color, Normals, UV, etc.).</li> </ul> </li> <li>Optional edge/connectivity attributes:<ul> <li>Mesh edges can be numbered automatically, or based on a user-provided ordering.</li> <li>Connectivity attributes allow efficient navigation around mesh elements (similar to   half-edges).</li> </ul> </li> <li>Fast compilation times1:<ul> <li>Clean separation between class declaration/definition allows for faster build times.</li> <li>Explicit template instantiation is used to limit available types usable with our   <code>SurfaceMesh&lt;&gt;</code> and <code>Attribute&lt;&gt;</code> class.</li> <li>X macros are used to facilitate explicit template instantiation of predetermined types (can   be used by client code).</li> </ul> </li> <li>Extensive documentation<ul> <li>Complete user guide (this document)</li> <li>Full Doxygen API reference.</li> </ul> </li> </ul>"},{"location":"user/core/mesh/#mesh-representation","title":"Mesh Representation","text":"<p>At the core, our mesh data structure is just a collection of mesh elements (vertices, facets, edges, corners), where each element is attached a number of attributes. Specifically, we define the following elements:</p> <ul> <li> <p>Vertices: Points used to form the facets of the mesh. Typically associated with a 2D or 3D   position attribute.</p> <p></p> </li> <li> <p>Facets: Polygons formed by connecting mesh vertices together. In a triangle mesh, all facets   are 3-gons.</p> <p></p> </li> <li> <p>Edges: Edges are formed by unordered pairs of consecutive vertices in a mesh facet. The set of   mesh edges is defined implicitly from the mesh facets. See Mesh Edges for more   details.</p> <p></p> </li> <li> <p>Corners: Facet corner elements can be used to reference vertices in a specific facet. Corners   from the same facets are indexed contiguously in a flat list containing all facet corners.</p> <p></p> </li> </ul> <p>Our mesh data structure is very generic, and can represent any kind of polygonal mesh, non-manifold surface, mesh containing isolated vertices, point clouds, etc.</p>"},{"location":"user/core/mesh/#terminology","title":"Terminology","text":"<ul> <li>Regular mesh: In the context of this documentation, a regular mesh is a mesh whose facets have   the same constant size. E.g. a triangle mesh is a regular mesh (facet size = 3). So is a quad   mesh (facet size = 4), a pentagonal mesh, etc.</li> <li>Hybrid mesh: A hybrid mesh is a mesh whose facets may have varying sizes. E.g. a quad dominant   mesh is a hybrid mesh.</li> <li>Vertex valence: Number of facet corners pointing to a given vertex (repeated vertex indices in   a degenerate facet will count multiple times towards the vertex valence).</li> <li>Facet size: Number of corners/vertices in a facet. Currently we require facet sizes to be &gt; 2,   but this restriction will be lifted in a future version (supporting facets of size 1 and 2).</li> </ul> <p>A hybrid mesh will store an additional \"offset\" attribute for each facet, to determine where each facet starts/ends in the attribute buffer storing vertex indices.</p> <p>Offset Indices</p> <p>In the following mesh, facets <code>[f0, f1, f2]</code> have an \"offset\" attribute of <code>[0, 3, 7]</code>. This means that the first corner of <code>f0</code> is <code>c0</code>, the first corner of <code>f1</code> is <code>c3</code>, etc. The size of a facet can be computed from the difference between two consecutive offsets.</p> <p> </p>"},{"location":"user/core/mesh/#adding-verticesfacets","title":"Adding Vertices/Facets","text":"<p>Simple version:</p> <pre><code>lagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\nmesh.add_vertices(10); // adds 10 vertices with 0-initialized coordinates\nmesh.add_triangles(3); // adds 3 triangles with 0-initialized vertex indices\nmesh.add_quads(2); // adds 2 quads with 0-initialized vertex vertices\n</code></pre> <p>Another example:</p> <pre><code>lagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\nmesh.add_vertex({0.5, 0.2, 0.9}); // adds a vertex at (0.5, 0.2, 0.9)\nmesh.add_triangle(1, 3, 4); // adds triangle (v1, v3, v3)\nmesh.add_quad(1, 3, 4, 2); // adds quad (v1, v3, v4, v2)\nmesh.add_polygon({1, 3, 4, 2, 5}); // adds polygon (v1, v3, v4, v2, v5)\n</code></pre> <p>To create a mesh from an existing buffer (with copy):</p> <pre><code>std::vector&lt;Scalar&gt; vertices; // flat buffer of size N x 3\nstd::vector&lt;Index&gt; facets; // flat buffer of size M x 3\n// ... fill up vertices/facets ...\nIndex num_vertices = Index(vertices.size()) / 3;\nIndex num_facets = Index(facets.size()) / 3;\n\nlagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\nmesh.add_vertices(num_vertices, vertices);\nmesh.add_triangles(num_facets, facets);\n</code></pre> <p>Note that any continuous buffer of the appropriate size will work. If your input buffer is of type <code>std::vector&lt;std::array&lt;Scalar, 3&gt;&gt;</code>, you will need to convert the pointer:</p> <pre><code>std::vector&lt;std::array&lt;Scalar, 3&gt;&gt; vertices;\nlagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\nmesh.add_vertices(\nIndex(vertices.size()),\n{vertices.empty() ? nullptr : vertices[0].data(), 3 * vertices.size()});\n</code></pre> <p>You can add multiple polygonal facets with different sizes in the same function call by using the <code>add_hybrid()</code> method. While this method can take an existing buffer as input, it may be simpler to use it via user-defined callbacks:</p> <pre><code>lagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\nstd::mt19937 gen;\nstd::uniform_int_distribution&lt;Index&gt; random_facet_size(3, 6);\nstd::uniform_int_distribution&lt;Index&gt; random_vertex_index(0, 9);\nstd::uniform_real_distribution&lt;Scalar&gt; random_position(0, 1);\nmesh.add_vertices(10, [&amp;](Index, lagrange::span&lt;Scalar&gt; p) {\np[0] = random_position(gen);\np[1] = random_position(gen);\np[2] = random_position(gen);\n});\nmesh.add_hybrid(4,\n// The first callback determines the degree of facet `f`\n[&amp;](Index f) { return random_facet_size(gen); },\n// The second callback sets the mapping corner id -&gt; vertex id for facet `f`\n[&amp;](Index f, lagrange::span&lt;Index&gt; t) {\nfor (Index i = 0; i &lt; t.size(); ++i) {\n// Assign a random vertex id to each facet corner\nt[i] = random_vertex_index(gen);\n}\n});\n</code></pre> <p>Wrapping External Buffers ans Eigen Matrices</p> <p>Please read our dedicated section on wrapping external buffer, as well as our documentation on SharedSpan for tracking ownership of shared objects when wrapping external buffers.</p>"},{"location":"user/core/mesh/#removing-verticesfacets","title":"Removing Vertices/Facets","text":"<p>Batch Removal Only</p> <p>Currently, we only support efficient batch removal of vertices/facets. This is because removing any mesh element will cause reindexing of all mesh attributes referencing a mesh element (e.g. vertex indices). To allow for \"lazy\" deletion, you can use an attribute to keep track of \"deleted\" vertices/facets until you actually clean them up. An element removal is a O(|V| + |F|) operation.</p> <p>To remove a list of vertices/facets:</p> <pre><code>lagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\nmesh.add_vertices(20);\nmesh.add_triangles(12);\n\n// Remove vertices v2, v5 and v9\nmesh.remove_vertices({2, 5, 9});\n\n// Remove facets v6, v2 and v8\nmesh.remove_facets({6, 2, 8});\n</code></pre> <p>Alternatively, you can use a filter returning a boolean value to determine the vertices/facets to remove:</p> <pre><code>lagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\nmesh.add_vertices(20);\nmesh.add_triangles(12);\n\n// Remove vertices with even index\nmesh.remove_vertices([](Index v) { return (v % 2 == 0); });\n\n// Remove random facets\nstd::mt19937 gen;\nstd::uniform_int_distribution&lt;int&gt; flip_coin(0, 1);\nmesh.remove_facets([&amp;](Index f) { return flip_coin(gen) == 1; });\n</code></pre> <p>Vertex Removal</p> <p>Removing a vertex will automatically remove any facet containing that vertex!</p> <p>Facet Removal</p> <p>Removing a facet will not automatically remove any incident vertex. You can end up with floating/isolated vertices after facet removal. Consider filtering them as a post-processing.</p>"},{"location":"user/core/mesh/#copy-on-write","title":"Copy-On-Write","text":"<p>All mesh data is stored in an Attribute object, including vertex positions, facet indices, etc. These mesh attributes are handled via a copy-on-write mechanism, meaning that copying a mesh is a cheap operation by default: no buffer is actually duplicated until you start writing to it. For this reason, we distinguish most accessors between getters and setters:</p> <ul> <li>Getters start with <code>get_xxx()</code> and provide read-only access to an attribute data. They will   not cause any copy.</li> <li>Setters start with <code>ref_xxx()</code> and will cause an immediate buffer copy if the buffer is not   uniquely owned (i.e. there are more than 1 object referencing the same buffer).</li> </ul> <p>Note that both getters and setters are safe to use concurrently. Please read our \"note on thread-safety\" for more information.</p> <p>See below for a short example:</p> <pre><code>lagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\n// ... Fill up mesh ...\nlagrange::SurfaceMesh&lt;Scalar, Index&gt; copy = mesh;\n\n// Writable reference to a vertex\nauto p = copy.ref_position(1); // &lt;-- leads to a copy of the vertex buffer\np[0] = 0.1;\np[1] = 0.2;\np[2] = 0.3;\n\n// Now vertices v1 are different\nstd::equal(\nmesh.get_position(1).begin(),\nmesh.get_position(1).end(),\ncopy.get_position(1).begin()); // --&gt; false\n\n// The pointers to the vertex positions are now different\nmesh.get_vertex_to_position().get_all().data() ==\ncopy.get_vertex_to_position().get_all().data(); // --&gt; false\n\n// But the pointers to the facet indices are still the same\nmesh.get_corner_to_vertex().get_all().data() ==\ncopy.get_corner_to_vertex().get_all().data(); // --&gt; true\n</code></pre>"},{"location":"user/core/mesh/#eigen-matrix-views","title":"Eigen Matrix Views","text":"<p>Mesh attributes such as positions and facet indices can be views as Eigen matrices. Specifically, we provide read-only views as <code>Eigen::Map&lt;const ...&gt;</code>:</p> <pre><code>#include &lt;lagrange/SurfaceMesh.h&gt;\n#include &lt;lagrange/views.h&gt;\n\n#include &lt;igl/massmatrix.h&gt;\n\nlagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\n\n// Fill up mesh data...\n\n// With ADL, no need to prefix by lagrange::\nauto V_view = vertex_view(mesh);\nauto F_view = facet_view(mesh);\n\n// Call your favorite libigl function\nEigen::SparseMatrix&lt;Scalar&gt; M;\nigl::massmatrix(V_view, F_view, igl::MASSMATRIX_TYPE_VORONOI, M);\n</code></pre> <p>Writable reference are also available:</p> <pre><code>// Writable reference, creates a copy if buffer is not uniquely owned\nauto V_ref = vertex_ref(mesh);\nauto F_ref = facet_ref(mesh);\n\n// Center mesh around vertex barycenter\nV_ref.rowwise() -= V_ref.colwise().mean();\n</code></pre> <p>Regular Meshes Vs Hybrid Meshes</p> <p>On hybrid meshes, it is not possible to \"view\" facet indices as a 2D matrix. This is because each \"row\" of the matrix would have a variable width, due to the varying facet sizes. For this reason, trying to get a <code>facet_view()</code> on a hybrid mesh will throw a runtime exception.</p> <p>Mesh Attributes</p> <p>Arbitrary mesh attributes can be viewed as Eigen matrices via the <code>matrix_view()</code> and <code>matrix_ref()</code> functions. Please read our attribute documentation for some examples.</p>"},{"location":"user/core/mesh/#mesh-edges","title":"Mesh Edges","text":"<p>By default, a mesh object is very lightweight, and does not compute edge ids or connectivity information. If this information is desirable, it is possible to compute it by calling the <code>initialize_edges()</code> method:</p> <pre><code>lagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\nmesh.add_vertices(10);\nmesh.add_triangle(0, 1, 2);\nmesh.add_quad(1, 3, 4, 2);\nmesh.add_polygon({0, 2, 4, 5, 6});\n\n// Let Lagrange assign an id to each edge\nmesh.initialize_edges();\n\n// ...\n\n// Once edge data is no longer needed, clear related mesh attributes:\nmesh.clear_edges();\n</code></pre> <p>In practice, edge and connectivity data are stored as special mesh attributes, which can be accessed/edited like any other mesh attribute!</p> <p>If a specific ordering of the mesh edges is desired, provide it to the <code>initialize_edges()</code> method:</p> <pre><code>// Explicit edge id -&gt; vertex ids mapping\nconst std::vector&lt;std::array&lt;Index, 2&gt;&gt; edges = {\n{0, 1},\n{1, 3},\n{3, 4},\n{4, 5},\n{5, 6},\n{6, 0},\n{1, 2},\n{2, 0},\n{2, 4},\n};\n// Passed to the mesh via a std::span&lt;&gt;\nmesh.initialize_edges({&amp;edges[0][0], 2 * edges.size()});\n</code></pre> <p>Redundant Initialization</p> <p>If a mesh already contains edges information, <code>mesh.initialize_edges()</code> will not do anything. If you want to reorder existing edges, please clear edge attributes first, and re-initialize mesh edges.</p>"},{"location":"user/core/mesh/#connectivity-and-navigation","title":"Connectivity And Navigation","text":"<p>Connectivity And Edge Information</p> <p>Navigating between adjacent and incident mesh elements requires building connectivity information. Since such connectivity information is necessary to uniquely index mesh edges, the two set of attributes are tied together. In practice, this means that calling any mesh navigation method requires having called <code>mesh.initialize_edges()</code> beforehand.</p> <p>To efficiently navigate between adjacent facets, or between incident vertex/facets, we store \"chains\" of corners around vertices and edges as single-linked lists as follows:</p> <ul> <li> <p>Corners Around A Vertex. The chain of corners around a vertex can be represented by two   attributes. One vertex attribute giving the head of each list, and one corner attribute giving the   next corner in the linked list for each \"chain\" around a vertex. Since each corner belongs to one   chain only, we can store all linked lists as flattened attribute for the entire mesh.</p> <p></p> <p>Edges Around A Vertex</p> <p>To iterate over the edges incident to a given vertex, you will notice that we only provide a single method <code>foreach_edge_around_vertex_with_duplicates()</code>. This method will call the callback function repeatedly for each facet which contains an incident edge to the prescribed vertex.</p> </li> <li> <p>Corners Around An Edge. The same principle can be applied to chain corners around a given   edge. Note that since the facets are oriented, we only chain one canonical corner per facet around   a given edge.</p> <p></p> <p>Non-Manifold Edges</p> <p>A nice advantage of this connectivity representation is that we support any type of non-manifold meshes. This is in contrast with most half-edge data structure implementations which assume manifold surfaces.</p> </li> </ul> <p>To navigate around a mesh element (vertices/edges), we provide convenience functions <code>foreach_xxx_around_xxx()</code>:</p> <pre><code>lagrange::SurfaceMesh&lt;Scalar, Index&gt; mesh;\n\n// Fill up mesh...\n\n// Compute vertex valence\nstd::vector&lt;Index&gt; vertex_valence(mesh.get_num_vertices(), 0);\nfor (Index v = 0; v &lt; mesh.get_num_vertices(); ++v) {\nmesh.foreach_facet_around_vertex(v, [&amp;](Index f) {\n++vertex_valence[v];\n});\n}\n</code></pre> <p>In the example above, we could have use the method <code>count_num_corners_around_vertex()</code> to compute vertex valence directly. See SurfaceMesh class documentation for a full reference.</p> <p>Degenerate Facets</p> <p>If a mesh facet is degenerate, and references the same vertex several time (e.g. facet <code>f2 = (0, 1, 1)</code>), then <code>mesh.foreach_facet_around_vertex(1)</code> will call the facet <code>f2</code> twice.</p>"},{"location":"user/core/mesh/#half-edges","title":"Half-Edges","text":"<p>There is a natural correspondence between the usual half-edge notion and a facet corner (see figure below). While Lagrange currently does not offer half-edge data-structure for mesh navigation, corner indices can be used to navigate around mesh elements the same way a half-edge data structure does.</p> Half-edges can be identified with their equivalent facet corners. <p>Twin Half-Edge</p> <p>To implement the <code>twin(h_i)</code> operation, you can use <code>SurfaceMesh::get_next_corner_around_edge()</code>.</p> <p>In the future we may add a half-edge \"proxy\" structure to facilitate mesh navigation.</p>"},{"location":"user/core/mesh/#supported-types","title":"Supported Types","text":"<p>While our <code>SurfaceMesh&lt;&gt;</code> class is templated by both a <code>Scalar</code> and <code>Index</code> type, we only actually support a finite set of template parameters. Specifically:</p> <ul> <li>Scalar can only be <code>float</code> or <code>double</code>.</li> <li>Index can only be <code>uint32_t</code> or <code>uint64_t</code>.</li> </ul> <p>We provide the following type aliases for convenience:</p> Alias Actual Type <code>SurfaceMesh32f</code> <code>SurfaceMesh&lt;float, uint32_t&gt;</code> <code>SurfaceMesh32d</code> <code>SurfaceMesh&lt;double, uint32_t&gt;</code> <code>SurfaceMesh64f</code> <code>SurfaceMesh&lt;float, uint64_t&gt;</code> <code>SurfaceMesh64d</code> <code>SurfaceMesh&lt;double, uint64_t&gt;</code> <p>Linking Error for Unsupported Types</p> <p>If you try to use our <code>SurfaceMesh&lt;&gt;</code> class with an unsupported Scalar/Index type, you will encouter a linking error due to unreferenced symbols.</p> <p>Writing Functions Taking SurfaceMesh As Parameter</p> <p>To write a function taking a <code>SurfaceMesh&lt;&gt;</code> as a parameter, you can use our X macros to explicitly instantiate a templated function with the supported mesh types. For example, the <code>vertex_view()</code> function is instantiated as follows:</p> <pre><code>////////////////\n// In views.h //\n////////////////\n\ntemplate &lt;typename S, typename I&gt;\nConstRowMatrixView&lt;S&gt; vertex_view(const SurfaceMesh&lt;S, I&gt;&amp; mesh);\n\n//////////////////\n// In views.cpp //\n//////////////////\n\ntemplate &lt;typename S, typename I&gt;\nConstRowMatrixView&lt;S&gt; vertex_view(const SurfaceMesh&lt;S, I&gt;&amp; mesh)\n{\n// Function definition\nreturn {};\n}\n\n// Explicit template instantiation\n#define LA_X_views_mesh(_, S, I) \\\n    template ConstRowMatrixView&lt;S&gt; vertex_view(const SurfaceMesh&lt;S, I&gt;&amp; mesh);\nLA_SURFACE_MESH_X(views_mesh, 0)\n</code></pre> <ol> <li> <p>Note that while the new polygonal mesh class is using explicit template instantiation to facilitate compilation, at the time most of Lagrange is still header-only and relying on our legacy mesh data structure. Thus overall compilation times still have room for improvement.\u00a0\u21a9</p> </li> </ol>"},{"location":"user/ui/components/","title":"Components","text":""},{"location":"user/ui/components/#components","title":"Components","text":"<p>Entities can have several components that define their behavior. Here is a list of the common components used throughout Lagrange UI.</p>"},{"location":"user/ui/components/#name","title":"<code>Name</code>","text":"<p>Subclassed <code>std::string</code>. Acts as a display name. Will be shown in UI if it exists, otherwise a generated name will be used. Does not have to be unique.</p>"},{"location":"user/ui/components/#transform","title":"<code>Transform</code>","text":"<p>Contains local and global transformations and a viewport transform.</p> <pre><code>// Translates entity one unit in X direction\nui::Transform &amp; transform = registry.get&lt;ui::Transform&gt;(e);\ntransform.local = Eigen::Translation3f(1,0,0);\n</code></pre> <p>Global transformation is recomputed after each <code>Simulation</code> step. Only change the <code>local</code> transform.</p>"},{"location":"user/ui/components/#tree","title":"<code>Tree</code>","text":"<p>Defines scene tree relationship. Data is stored using <code>parent</code>, <code>first_child</code>, <code>previous_sibling</code> and <code>next_sibling</code> entity IDs.</p> <p>Use helper functions to query or change the tree structure, do not change directly (unless you know what you're doing). <pre><code>//Orphans entity and parents it under new_parent\nui::reparent(registry, entity, new_parent);\n\n//Applies lambda to each direct child entity of parent\nui::foreach_child(registry, parent, [](Entity child){\n//...\n});\n\n//Applies lambda to each  child entity of parent, recursively\nui::foreach_child_recursive(registry, parent, [](Entity child){\n//...\n});\n\n//In-order traversal of scene tree\nui::iterate_inorder(registry, root, [](Entity current){\n//On Enter\n\n//Return true to continue to traverse children\nreturn true;\n},[](Entity current){\n//On Exit\n});\n\n// See utils/treenode.h for more details\n</code></pre></p>"},{"location":"user/ui/components/#meshgeometry","title":"<code>MeshGeometry</code>","text":"<p>Contains reference to geometry entity</p> <pre><code>MeshGeometry mg;\nmg.entity = ..\n</code></pre>"},{"location":"user/ui/components/#hovered-and-selected","title":"<code>Hovered</code> and <code>Selected</code>","text":"<p>These components acts as flags whether the entity is hovered or selected respectively.</p> <p>Useful helper functions <pre><code>bool is_selected(Registry &amp;registry, Entity e);\nbool is_hovered(Registry &amp;registry, Entity e);\nbool select(Registry&amp; registry, Entity e);\nbool deselect(Registry&amp; registry, Entity e);\nstd::vector&lt;Entity&gt; collect_selected(const Registry&amp; registry);\nstd::vector&lt;Entity&gt; collect_hovered(const Registry&amp; registry);\n//See `utils/selection.h` for details\n</code></pre></p>"},{"location":"user/ui/components/#layer","title":"<code>Layer</code>","text":"<p>There are 256 layers an entity can belong to. The <code>Layer</code> component specifies which layers the entity belongs to. Entity can belong to several layers at once. There are several default layers:</p> <ul> <li><code>ui::DefaultLayers::Default</code> - everything belongs to it by default</li> <li><code>ui::DefaultLayers::Selection</code> - selected entities</li> <li><code>ui::DefaultLayers::Hover</code> - hovered entities</li> </ul> <p>Default constructed <code>Layer</code> component belongs to <code>ui::DefaultLayers::Default</code>.</p> <p>You can register your own layer by calling <pre><code>ui::LayerIndex layer_index = ui::register_layer_name(r, \"my layer name\");\n</code></pre></p> <p>There are several utility functions for working with layers: <pre><code>void add_to_layer(Registry&amp;, Entity e, LayerIndex index);\nvoid remove_from_layer(Registry&amp;, Entity e, LayerIndex index);\nbool is_in_layer(Registry&amp;, Entity e, LayerIndex index);\nbool is_in_any_layers(Registry&amp;, Entity e, Layer layers_bitset);\nbool is_visible_in(\nconst Registry&amp;,\nEntity e,\nconst Layer&amp; visible_layers,\nconst Layer&amp; hidden_layers);\n</code></pre></p>"},{"location":"user/ui/components/#uipanel","title":"<code>UIPanel</code>","text":"<p>See User Interface page.</p>"},{"location":"user/ui/components/#viewportcomponent","title":"<code>ViewportComponent</code>","text":"<p>See Viewports page</p>"},{"location":"user/ui/customizing/","title":"Customizing Lagrange UI","text":""},{"location":"user/ui/customizing/#customizing-lagrange-ui","title":"Customizing Lagrange UI","text":"<p>Warning</p> <p>This page is under construction In the meantime, refer to files named <code>default_{}</code> to see how the UI registers the default types and functionality.</p>"},{"location":"user/ui/customizing/#components","title":"Components","text":"<p>You may add any time of component using <code>registry.emplace&lt;ComponentType&gt;(entity)</code>. However to enable more advanced features, you may register the components in the UI:</p> <p><code>register_component&lt;T&gt;</code> - enables reflection - enables runtime add/clone/move of com ponents</p> <p><code>register_component_widget&lt;T&gt;</code> - defines ImGui code to render - enables drag-and-drop</p>"},{"location":"user/ui/customizing/#tools","title":"Tools","text":"<p>TBD</p> <p><code>register_element_type&lt;E&gt;</code> (Object/Facet/Edge/Vertex/...)</p> <p><code>register_tool&lt;E,T&gt;</code> (Select/Translate/Rotate/Scale/...)</p>"},{"location":"user/ui/customizing/#geometry","title":"Geometry","text":"<p>Lagrange meshes must be registered to work. By default, only the <code>TriangleMesh3Df</code> and <code>TriangleMesh3D</code> are registered.</p> <p><code>ui::register_mesh_type&lt;MeshType&gt;()</code></p>"},{"location":"user/ui/customizing/#rendering","title":"Rendering","text":""},{"location":"user/ui/customizing/#shader-and-material-properties","title":"Shader and Material properties","text":"<p>Material properties can be defined in the shader using the following syntax:</p> <pre><code>#pragma property NAME \"DISPLAY NAME\" TYPE(DEFAULT VALUE AND/OR RANGE) [TAG1, TAG2]\n</code></pre> <p>For example: <pre><code>//Defines a 2D texture property with the default value of rgba(0.7,0.7,0.7,1) if no texture is bound\n#pragma property material_base_color \"Base Color\" Texture2D(0.7,0.7,0.7,1)\n//Defines a 2D texture property with the default value of red=0.4 if no texture is bound\n#pragma property material_roughness \"Roughness\" Texture2D(0.4)\n//Defines a 2D texture property with the default value of red=0.1 if no texture is bound\n#pragma property material_metallic \"Metallic\" Texture2D(0.1)\n//Defines a 2D texture property that is to be interpreted as normal texture\n#pragma property material_normal \"Normal\" Texture2D [normal]\n//Defines a float property, with the default value of 1 and range 0,1\n#pragma property material_opacity \"Opacity\" float(1,0,1)\n</code></pre></p> <p>The pragmas are parsed whenever a shader is loaded and replaced with: <pre><code>uniform TYPE NAME = DEFAULT_VALUE\n</code></pre> In case of <code>Texture2D</code>, these uniforms are generated: <pre><code>uniform sampler2D NAME;\nuniform bool NAME_texture_bound = false;\nuniform VEC_TYPE NAME_default_value = DEFAULT_VALUE;\n</code></pre></p>"},{"location":"user/ui/ecs/","title":"Entity Component System","text":""},{"location":"user/ui/ecs/#entity-component-system-ecs","title":"Entity Component System (Ecs)","text":"<p>For more information about the ECS architecture, see:</p> <ul> <li>What you need to know about ECS for quick overview</li> <li>Overwatch Gameplay Architecture - GDC Talk for a good example of usage and design considerations.</li> <li>entt Crash Course for overview of the underlying <code>entt</code> library</li> <li>ECS Back and Forth for more details about ECS design, in particular hierarchies</li> <li>Unity ECS documentation for Unity's version of ECS</li> </ul>"},{"location":"user/ui/ecs/#registry","title":"Registry","text":"<p>The <code>Viewer</code> uses a <code>Registry</code> (alias for <code>entt::registry</code>) to store all entities and their data. To manipulate entities and their components directly, use the object: <pre><code>auto &amp; registry = viewer.registry();\n</code></pre> <code>Viewer</code> class exposes API that simplifies interaction with the <code>Registry</code>, e.g. <code>Viewer::show_mesh</code>.</p>"},{"location":"user/ui/ecs/#entity","title":"Entity","text":"<p>Unique identifier - it's just that. It's used to identify a unique \"object\" or \"entity\". Lagrange UI defines a <code>Entity</code> alias. Internally implemented as <code>std::uint32_t</code>.</p> <p>To create a new entity, use: <pre><code>Entity new_entity = registry.create();\n</code></pre></p> <p>To destroy: <pre><code>registry.destroy(entity);\n</code></pre></p>"},{"location":"user/ui/ecs/#components","title":"Components","text":"<p>Any data that is attached to an <code>Entity</code>. Uniquely identified by template typename <code>&lt;T&gt;</code> and <code>Entity</code>.</p> <p>Components don't have logic, that means no code. They only store data and implicitly define behavior. Ideally, the components should be <code>structs</code> with no functions. However, it may be beneficial to have setters/getters as member functions in some cases.</p> <p>To attach a component of type <code>MyComponent</code> to an entity : <pre><code>// When it doesn't exist\nregistry.emplace&lt;MyComponent&gt;(entity, MyComponent(42))\n\n// When it might exist already\nregistry.emplace_or_replace&lt;MyComponent&gt;(entity, MyComponent(42))\n</code></pre></p> <p>To retrieve a component: <pre><code>// If it exists already\nMyComponent &amp; c = registry.get&lt;MyComponent&gt;(entity);\n\n// If you're not sure it exists\nMyComponent * c = registry.try_get&lt;MyComponent&gt;(entity);\n//or\nif(registry.has&lt;MyComponent&gt;()){\nMyComponent&amp; c = registry.get&lt;MyComponent&gt;(entity);\n}\n</code></pre></p>"},{"location":"user/ui/ecs/#tag-components","title":"Tag Components","text":"<p>\"Empty\" components may be used to tag entities, e.g. <code>Selected</code>, <code>Hovered</code>, etc. These types however must have non-zero size: <pre><code>struct Hidden {\nbool dummy;\n}\n</code></pre></p>"},{"location":"user/ui/ecs/#systems","title":"Systems","text":"<p>Systems are the logic of the application. They are defined as functions that iterate over entities that have specified components only. For example, running this system: <pre><code>registry.view&lt;Velocity, Position&gt;().each([](Entity e, Velocity &amp; velocity, Transform &amp; transform){\ntransform.local = Eigen::Translation3f(velocity) * transform.local;\n});\n</code></pre> will iterate over all entities that have both <code>Velocity</code> and <code>Transform</code> and apply the velocity vector to the transform.</p> <p>Lagrange UI defines <code>System</code> as alias to <code>std::function&lt;void(Registry&amp;)&gt;</code>, that is, a function that does something with the <code>Registry</code>. Typically these will be defined as: <pre><code>System my_system = [](Registry &amp;w){\nw.view&lt;Component1, Component2, ...&gt;.each([](Entity e, Component1 &amp; c1, Component2 &amp; c2, ...){\n//\n});\n};\n</code></pre></p>"},{"location":"user/ui/ecs/#context-variables","title":"Context Variables","text":"<p>Systems do not have data. However, it's often useful to have some state associated with a given system, e.g. for caching. Sometimes it's useful that this state be shared among several systems. Instead of storing this state in some single instance of a component, we can use context variables. These can be thought of as singleton components - only one instance of a <code>Type</code> can exist at a given time.</p> <p><code>InputState</code> is such a singleton component. At the beginning of the frame, it is filled with key/mouse information, including last mouse position, mouse delta, active keybinds, etc.: <pre><code>void update_input_system(Registry &amp; registry){\nInputState &amp; input_state =  registry.ctx_or_set&lt;InputState&gt;();\ninput_state.mouse_pos = ...\ninput_state.mouse_delta = ...\ninput_state.keybinds.update(...);\n}\n</code></pre></p> <p>It can then be used by any other system down the line: <pre><code>void print_mouse_position(Registry &amp; registry){\nconst auto &amp; input_state = registry.ctx&lt;InputState&gt;();\n\nlagrange::logger().info(\"Mouse position: {}\", input_state.mouse_pos);\n}\n</code></pre></p>"},{"location":"user/ui/ecs/#design-considerations","title":"Design Considerations","text":"<p>Rules to follow when designing components and systems:</p> <ul> <li>Components have no functions, only data</li> <li>Systems have no data</li> <li>State associated with systems is stored as context variable (<code>registry.ctx&lt;T&gt;()</code>)</li> </ul>"},{"location":"user/ui/examples/","title":"Examples","text":"<p>Refer to <code>modules/ui/examples</code>. Build Lagrange with <code>-DLAGRANGE_EXAMPLES=On</code>.</p>"},{"location":"user/ui/lights/","title":"Lights","text":""},{"location":"user/ui/lights/#lights","title":"Lights","text":""},{"location":"user/ui/lights/#image-based-lighting","title":"Image Based Lighting","text":"<p>Refer to <code>ui/utils/ibl.h</code> for all IBL utility functions and <code>ui/components/IBL.h</code> for the IBL component.</p>"},{"location":"user/ui/lights/#loadinggenerating-ibl","title":"Loading/Generating IBL","text":"<pre><code>//From disk file\nui::IBL ibl = ui::generate_ibl(\"path.hdr\");\n//From texture\nstd::shared_ptr&lt;ui::Texture&gt; texture;\nui::IBL ibl = ui::generate_ibl(texture);\n</code></pre>"},{"location":"user/ui/lights/#adding-ibl-to-scene","title":"Adding IBL to scene","text":"<pre><code>ui::IBL ibl = ...;\nEntity ibl_entity = ui::add_ibl(registry, ibl);\n</code></pre>"},{"location":"user/ui/lights/#changing-ibl-options","title":"Changing IBL options","text":"<pre><code>//Get IBL (if there are multiple, the first one is returned)\nui::IBL &amp;ibl = *ui::get_ibl(registry);\n\n// Blur the IBL (number corresponds to mip map level)\nibl.blur = 2.0f;\n\n// Disable rendering of the IBL image in the background\n// The IBL is still used for shading objects.\nibl.show_skybox = false;\n</code></pre>"},{"location":"user/ui/lights/#analytic-lights","title":"Analytic Lights","text":"<p>Refer to <code>ui/utils/lights.h</code> for all light utility functions and <code>ui/components/Light.h.</code> for the Light component:</p> <pre><code>// Omni-directional point light source\nEntity point_light = add_point_light(registry, intensity, position);\n\n// Directional light source at infinite distance\nEntity point_light = add_directional_light(registry, intensity, direction);\n\n// Light in a cone\nEntity spot_lighj = add_spot_light(registry, intensity, position, direction, cone_angle_radians);\n</code></pre>"},{"location":"user/ui/mesh-visualization/","title":"Mesh Visualization","text":""},{"location":"user/ui/mesh-visualization/#mesh-visualization","title":"Mesh Visualization","text":""},{"location":"user/ui/mesh-visualization/#geometry-loading-and-registration","title":"Geometry loading and registration","text":""},{"location":"user/ui/mesh-visualization/#loading-mesh","title":"Loading mesh","text":"<p>Creates and entity that represents the mesh. This entity is only a resource - it is not rendered. It can be referenced by components that need this geometry for rendering/picking/etc. These entities have <code>MeshData</code> component attached that contains a <code>lagrange::MeshBase</code> pointer.</p> <pre><code>ui::Entity mesh_from_disk = ui::load_mesh(registry, path);\nui::Entity mesh_from_memory = ui::register_mesh(registry, lagrange::create_sphere());\n</code></pre>"},{"location":"user/ui/mesh-visualization/#retrieving-and-interacting-with-the-mesh","title":"Retrieving and interacting with the mesh","text":"<p>To retrieve a mesh: <pre><code>MeshType &amp; mesh = ui::get_mesh&lt;MeshType&gt;(registry, mesh_entity);\n</code></pre></p> <p>There are several methods that do not require the knowledge of the mesh type. These may however incur copy and conversion costs. <pre><code>RowMajorMatrixXf get_mesh_vertices(const MeshData&amp; d);\nRowMajorMatrixXf get_mesh_facets(const MeshData&amp; d);\nbool has_mesh_vertex_attribute(const MeshData&amp; d, const std::string&amp; name);\nbool has_mesh_facet_attribute(const MeshData&amp; d, const std::string&amp; name);\n...\nRowMajorMatrixXf get_mesh_vertex_attribute(const MeshData&amp; d, const std::string&amp; name);\nRowMajorMatrixXf get_mesh_facet_attribute(const MeshData&amp; d, const std::string&amp; name);\n...\nstd::optional&lt;RayFacetHit&gt; intersect_ray(const MeshData&amp; d, const Eigen::Vector3f&amp; origin, const Eigen::Vector3f&amp; dir);\n...\n</code></pre></p>"},{"location":"user/ui/mesh-visualization/#loading-scene","title":"Loading scene","text":"<p>Loads a scene using Assimp. Creates a hierarchy of entities and loads meshes, materials and textures. Returns the top-level entity.</p> <pre><code>ui::Entity root = ui::load_scene(registry, path);\n</code></pre> <p>To iterate over the scene, see the <code>Tree</code> component.</p>"},{"location":"user/ui/mesh-visualization/#adding-geometry-to-scene","title":"Adding geometry to scene","text":""},{"location":"user/ui/mesh-visualization/#default-physically-based-render-pbr","title":"Default Physically Based Render (PBR)","text":"<p>Adds previously registered mesh geometry to the scene. This mesh will be rendered using PBR.</p> <pre><code>ui::Entity scene_object = ui::show_mesh(registry, mesh_entity);\n</code></pre> <p>Uses <code>DefaultShaders::PBR</code> shader.</p> <p>See Materials section to see how to control the appearance.</p>"},{"location":"user/ui/mesh-visualization/#mesh-visualizations","title":"Mesh visualizations","text":"<p>Adds a visualization of a mesh. </p> <pre><code>auto vertex_viz_entity = ui::show_vertex_attribute(registry, mesh_entity, attribute_name, glyph_type);\nauto facet_viz_entity = ui::show_facet_attribute(registry, mesh_entity, attribute_name, glyph_type);\nauto corner_viz_entity = ui::show_corner_attribute(registry, mesh_entity, attribute_name, glyph_type);\nauto edge_viz_entity = ui::show_edge_attribute(registry, mesh_entity, attribute_name, glyph_type);\n</code></pre> <p>These functions will create a new scene object and render the supplied attribute using the selected glyph type.</p>"},{"location":"user/ui/mesh-visualization/#glyphtypesurface","title":"<code>GlyphType::Surface</code>","text":"<p>Renders unshaded surface with color mapped from the supplied attribute. Supports attributes of dimension: 1, 2, 3, and 4.</p> <ul> <li>Normalization: The attribute value is automatically remapped to (0,1) range. To change the   range, use <code>ui::set_colormap_range</code></li> <li>Colormapping: By default, the attribute is interpreted as R, RG, RGB or RGBA value. To use   different mapping, refer to Colormaps section.</li> </ul>"},{"location":"user/ui/mesh-visualization/#colormaps","title":"Colormaps","text":"<p>If the glyph or shader supports colormapping, use the following function to set the colormap:</p> <p>To use on of the default colormaps: <pre><code>ui::set_colormap(registry, entity, ui::generate_colormap(ui::colormap_magma))\n</code></pre> Or generate your own <pre><code>ui::set_colormap(registry, entity, ui::generate_colormap([](float t){\nreturn Color(\n//... function of t from 0 to 1\n);\n}));\n</code></pre></p> <p>Default colormaps: <pre><code>colormap_viridis\ncolormap_magma\ncolormap_plasma\ncolormap_inferno\ncolormap_turbo\ncolormap_coolwarm\n</code></pre></p>"},{"location":"user/ui/mesh-visualization/#materials","title":"Materials","text":"<p>Any entity with <code>MeshRender</code> component has a <code>Material</code> associated with it (<code>MeshRender::material</code>).</p> <p>To get a reference to entity's material, use:</p> <pre><code>std::shared_ptr&lt;Material&gt; material_ptr = ui::get_material(r, entity_with_meshrender);\n</code></pre> <p>Similarly, you may set a new material: <pre><code>ui::set_material(r, entity_with_mesh_render, std::make_shared&lt;ui::Material&gt;(r, DefaultShaders::PBR);\n</code></pre></p>"},{"location":"user/ui/mesh-visualization/#colortexture-material-properties","title":"Color/Texture Material Properties","text":"<p>You may set colors and textures of materials using the following API:</p> <pre><code>auto &amp; material = *ui::get_material(r, entity_with_meshrender);\n\n//Sets \"property name\" to a red color\nmaterial.set_color(\"property name\", ui::Color(1,0,0));\n\n//Sets \"texture name\" to texture loaded from file\nmaterial.set_texture(\"texture name\", ui::load_texture(\"texture.jpg\"));\n</code></pre>"},{"location":"user/ui/mesh-visualization/#pbrmaterial","title":"PBRMaterial","text":"<p>For the default <code>PBRMaterial</code>, you may use aliases for the property names: <pre><code>//Uniform rgba color\nmaterial.set_color(PBRMaterial::BaseColor, ui::Color(1,0,0,1));\n//RGB(A) color/albedo texture\nmaterial.set_texture(PBRMaterial::BaseColor, ui::load_texture(\"color.jpg\"));\n\n//Normal texture (and texture only)\nmaterial.set_texture(PBRMaterial::Normal, ui::load_texture(\"normal.jpg\"));\n\n//Uniform roughness\nmaterial.set_float(PBRMaterial::Roughness, 0.75f);\n//Roughness texture\nmaterial.set_texture(PBRMaterial::Roughness, ui::load_texture(\"metallic.jpg\"));\n\n//Uniform roughness\nmaterial.set_float(PBRMaterial::Metallic, 0.75f);\n//Metallic texture\nmaterial.set_texture(PBRMaterial::Metallic, ui::load_texture(\"metallic.jpg\"));\n\n//Uniform opacity\nmaterial.set_float(PBRMaterial::Opacity, 1.0f);\n//Opacity texture\nmaterial.set_texture(PBRMaterial::Opacity, ui::load_texture(\"opacity.jpg\"));\n</code></pre></p>"},{"location":"user/ui/mesh-visualization/#rasterizer-properties","title":"Rasterizer Properties","text":"<p>To control OpenGl properties, you may following syntax:</p> <pre><code>material.set_int(RasterizerOptions::PolygonMode, GL_LINE);\nmaterial.set_float(RasterizerOptions::PointSize, PointSize);\n</code></pre> <p>See <code>&lt;lagrange/ui/Shader.h&gt;</code> for a list of supported <code>RasterizerOptions</code>;</p>"},{"location":"user/ui/mesh-visualization/#custom-shader-properties","title":"Custom Shader Properties","text":"<p>You may set arbitrary <code>int</code> or <code>float</code> or <code>Color</code> or <code>Texture</code> to the material. It will be set as a shader uniform if it exists in the shader, otherwise there will be no effect.</p>"},{"location":"user/ui/overview/","title":"Overview","text":""},{"location":"user/ui/overview/#ui-module","title":"UI Module","text":"<p>Lagrange UI module is a mini 3D engine C++ library built on top of <code>EnTT</code>.</p>"},{"location":"user/ui/overview/#prerequistes","title":"Prerequistes","text":"<p>Must have <code>OpenGL 3.3</code> capable drivers and a windowing system (headless is not supported). To use the library, enable <code>LAGRANGE_MODULE_UI</code> in CMake and</p> <pre><code>#include &lt;lagrange/ui/UI.h&gt;\nnamespace ui = lagrange::ui;\n</code></pre>"},{"location":"user/ui/overview/#overview","title":"Overview","text":"<p>Lagrange UI uses an Entity-Component-System (ECS) architecture:</p> <ul> <li>Entity is a unique identifier</li> <li>Components define data and behavior (but no logic)</li> <li>Systems define logic (but no data).</li> </ul> <p>See ECS implementation section for more information about ECS and how it's implemented in Lagrange UI. The underlying library for ECS is <code>EnTT</code>.</p> <p>The entry point to the library is the <code>Viewer</code> class. It instantiates a window and owns a <code>Registry</code> instance and <code>Systems</code> instance. <code>Registry</code> contains all the data (entities and components) and <code>Systems</code> contain all the behavior (sequence of functions that is called every frame). To start the UI:</p> <pre><code>ui::Viewer viewer;\nviewer.run([](){\n//Main loop code\n});\n\n//Or\n\nviewer.run([](ui::Registry &amp; r){\n//Main loop code\nreturn should_continue_running;\n});\n</code></pre> <p>The API to interact with the UI follows the pattern: <pre><code>ui::Entity entity = ui::do_something(registry, params)\nSomeData &amp; data = registry.get&lt;SomeData&gt;(entity);\n</code></pre></p> <p>For example: <pre><code>//Loads mesh from path\nui::Entity mesh_geometry = ui::load_mesh(registry, path);\n\n//Adds the mesh to scene\nui::Entity mesh_visualization = ui::show_mesh(registry, mesh_geometry);\n\n//Retrieves Transform component of the visualized mesh\nTransform &amp; transform = registry.get&lt;Transform&gt;(mesh_visualization);\n</code></pre></p> <p>All entities and their components live in a <code>Registry</code>. To access/set/modify the entities and components, use the <code>Viewer::registry()</code>. <pre><code>auto &amp; registry = viewer.registry();\nauto entity = registry.create();\nregistry.emplace&lt;MyPositionComponent&gt;(entity, MyPositionComponent(0,0,0));\n</code></pre></p> <p>Note</p> <p>You can use <code>Viewer</code> class as an argument instead of <code>Registry</code>, e.g.: <pre><code>Viewer v;\nauto mesh_geometry = ui::load_mesh(v, path);\n</code></pre></p>"},{"location":"user/ui/overview/#further-documentation","title":"Further Documentation","text":"<p>Doxygen generated documentation</p>"},{"location":"user/ui/user-interface/","title":"User Interface","text":""},{"location":"user/ui/user-interface/#user-interface","title":"User Interface","text":""},{"location":"user/ui/user-interface/#user-interface-panels","title":"User Interface Panels","text":"<p>UI Panels are implemented also as entities. Panels have the <code>UIPanel</code> component. The <code>UIPanel</code> components describes the ImGui information (panel title, position, etc.).</p> <p>To create a new UI panel: <pre><code>auto panel_entity = ui::add_panel(registry, \"Title of the panel\",[](){\n// Do NOT call Imgui::Begin()/End()\nImgui::Text(\"Hello world\");\n});\n//or\nauto panel_entity = ui::add_panel(registry, \"Title of the panel\", [](Registry &amp;registry, Entity e){\n//Entity e is the panel_entity\n});\n</code></pre></p> <p>Example of multiple instances of a same \"type\" of panel:</p> <pre><code>struct MyPanelState { int x = 0; }\n\nauto panel_fn = [](Registry &amp;registry, Entity e){\nauto &amp; state = registry.get_or_emplace&lt;MyPanelState&gt;(e);\nImGui::InputInt(\"x\", &amp;state.x);\n};\n\nauto panel0 = ui::add_panel(registry,\"panel with x = 0\",panel_fn)\nregistry.emplace&lt;MyPanelState&gt;(panel0, MyPanelState{0})\n\nauto panel1 = ui::add_panel(registry,\"panel with x = 1\",panel_fn);\nregistry.emplace&lt;MyPanelState&gt;(panel1, MyPanelState{1})\n</code></pre>"},{"location":"user/ui/viewports/","title":"Viewports","text":""},{"location":"user/ui/viewports/#viewports","title":"Viewports","text":"<p>Viewports are implemented as entities with <code>ViewportComponent</code> component. Those referenced in <code>ViewportPanel</code> are rendered to screen, otherwise they are rendered off-screen. There is always one focused <code>ViewportPanel</code> (identified by the context variable <code>FocusedViewportPanel</code>).</p> <p>See <code>components/Viewport.h</code> and <code>utils/viewport.h</code> for utility functions related to viewport, viewport panels and cameras.</p>"},{"location":"user/ui/viewports/#entity-visibility","title":"Entity visibility","text":"<p>Each <code>ViewportComponent</code> has <code>visible_layers</code> and <code>hidden_layers</code> that control which entities can be renderer in this viewport (see <code>Layer</code> component for details).</p> <p>The default viewport shows only <code>DefaultLayers::DefaultLayer</code></p>"},{"location":"user/ui/viewports/#multi-viewport","title":"Multi viewport","text":"<p>Additional viewports can be created by calling <pre><code>ui::Entity camera_entity = add_camera(ui::Registry &amp;, ui::Camera camera);\n// or use get_focused_camera_entity(ui::Registry &amp;)  to reuse current camera\n\n// Creates an offscreen viewport with the specified camera\nui::Entity viewport_entity = add_viewport(ui::Registry &amp;, ui::Entity camera_entity)\n\n// Creates a UI panel that shows the viewport\nui::Entity viewport_entity = add_viewport_panel(ui::Registry &amp;, const std::string &amp; name, ui::Entity viewport_entity);\n</code></pre></p>"}]}
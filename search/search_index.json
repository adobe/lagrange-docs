{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Lagrange Project Lagrange is an initiative to bring the power of robust geometry processing to Adobe products. It bridges cutting edge research works with cutting edge products. Project Lagrange is built on the following design principles: Modular Design Large features should be decomposed into smaller single functionality modules that are as decoupled as possible from each other. Modular design enables unit testing, prevents small change from propagating widely in the code base, and makes adding new functionalities easy. Preconditions + Guarantees Algorithmic correctness should be rigorously enforced. This is achieved by clearly documenting and checking the precise precondition and the corresponding guarantees of each module. Algorithms relying on input-dependent parameter tuning should be avoided. Interface + Compute Engine The interface of a functionality should be decoupled from the computation algorithms. This makes swapping out an algorithm with a better algorithm possible and ideally should not require change in client codes. Large Scale Testing Large scale, empirical testing on major functionalities should be carried out periodically to ensure their correctness and robustness. Let data speak for itself.","title":"Lagrange"},{"location":"#lagrange","text":"Project Lagrange is an initiative to bring the power of robust geometry processing to Adobe products. It bridges cutting edge research works with cutting edge products. Project Lagrange is built on the following design principles:","title":"Lagrange"},{"location":"#modular-design","text":"Large features should be decomposed into smaller single functionality modules that are as decoupled as possible from each other. Modular design enables unit testing, prevents small change from propagating widely in the code base, and makes adding new functionalities easy.","title":"Modular Design"},{"location":"#preconditions-guarantees","text":"Algorithmic correctness should be rigorously enforced. This is achieved by clearly documenting and checking the precise precondition and the corresponding guarantees of each module. Algorithms relying on input-dependent parameter tuning should be avoided.","title":"Preconditions + Guarantees"},{"location":"#interface-compute-engine","text":"The interface of a functionality should be decoupled from the computation algorithms. This makes swapping out an algorithm with a better algorithm possible and ideally should not require change in client codes.","title":"Interface + Compute Engine"},{"location":"#large-scale-testing","text":"Large scale, empirical testing on major functionalities should be carried out periodically to ensure their correctness and robustness. Let data speak for itself.","title":"Large Scale Testing"},{"location":"build/","text":"Compilation Instructions Build Lagrange requires a modern C++ compiler that supports C++17 features. Lagrange data structures are compatible with Eigen matrices. Other dependencies such as libigl and imgui will be downloaded by the build system as needed. Checkout To checkout the code: git clone git@github.com:adobe/lagrange.git Compiling To build the code: cd Lagrange mkdir build cd build cmake .. -DCMAKE_BUILD_TYPE = Release You can then select the Lagrange modules to build with cmake-gui . or specify them from command line with: cmake .. -DLAGRANGE_MODULE_<name> = ON # For example, -DLAGRANGE_MODULE_UI=ON To see available CMake options, please take a look at the file LagrangeOptions.cmake.sample in the root of the Lagrange repository. Setting Up CMake Options Lagrange has a lot of CMake options that can be configured. It may not be practical to pass those options via command-line, and manually checking boxes in CMake-GUI can be tedious. To facilitate setting up CMake options for Lagrange, simply rename LagrangeOptions.cmake.sample -> LagrangeOptions.cmake and uncomment options that you wish to change. Note that since options are cached by CMake, you will need to delete your <build>/CMakeCache.txt before re-running CMake in order for a change in LagrangeOptions.cmake to take effect. Useful CMake Options LAGRANGE_UNIT_TESTS : build unit tests. LAGRANGE_PERFORMANCE_TESTS : build performance tests. LAGRANGE_EXAMPLES : build examples. LAGRANGE_USE_PCH : build with precomplied headers. LAGRANGE_WITH_ONETBB : build with oneTBB. LAGRANGE_WITH_TRACY : build with tracy profiling support. USE_SANITIZER : build with sanitizer support, options are \"Address\", \"Memory\", \"MemoryWithOrigins\", \"Undefined\", \"Thread\", \"Leak\". Finally, build with cmake --build . Compilation Issues If an issue occurs during compilation, especially after an update, try to Delete your <build>/CMakeCache.txt and re-run CMake to configure your project. The nuclear option: delete the whole <build> folder and re-run CMake to configure your project. If neither option works, please ask for help on #lib-lagrange . Unit Tests When LAGRANGE_UNIT_TESTS is ON , unit tests are built automatically. To run all unit tests, either run the special target RUN_TESTS in your Visual Studio/Xcode project, or simply run ctest in the command-line in your build folder. Further instructions on running unit tests are available on this page . Platform-Specific Steps Windows For Visual Studio, you might have to force 64-bit compilation depending on your exact compiler version, e.g.: cmake -A x64 .. cmake -G \"Visual Studio 17 2022\" -A x64 .. cmake -G \"Visual Studio 16 2019\" -A x64 .. cmake -G \"Visual Studio 15 2017 Win64\" .. cmake -G \"Visual Studio 14 2015 Win64\" .. Unix You may have to install Zenity for the file dialog window to work: sudo apt-get install zenity Run Executables are compiled into the following folders: <build>/examples for examples covering various Lagrange features. <build>/tests for unit test executables. <build>/performance for performance test executables (legacy code). Dependencies Lagrange's CMake build system will download and build any and all dependencies required by the current build setup. This includes both core dependencies (e.g., Eigen) and optional ones (e.g., tinyobjloader for the IO module). If you are using Lagrange in your project and you wish to override Lagrange dependencies, make sure they are specified as CMake targets before calling add_subdirectory(<lagrange>) .","title":"Build"},{"location":"build/#compilation-instructions","text":"","title":"Compilation Instructions"},{"location":"build/#build","text":"Lagrange requires a modern C++ compiler that supports C++17 features. Lagrange data structures are compatible with Eigen matrices. Other dependencies such as libigl and imgui will be downloaded by the build system as needed.","title":"Build"},{"location":"build/#checkout","text":"To checkout the code: git clone git@github.com:adobe/lagrange.git","title":"Checkout"},{"location":"build/#compiling","text":"To build the code: cd Lagrange mkdir build cd build cmake .. -DCMAKE_BUILD_TYPE = Release You can then select the Lagrange modules to build with cmake-gui . or specify them from command line with: cmake .. -DLAGRANGE_MODULE_<name> = ON # For example, -DLAGRANGE_MODULE_UI=ON To see available CMake options, please take a look at the file LagrangeOptions.cmake.sample in the root of the Lagrange repository. Setting Up CMake Options Lagrange has a lot of CMake options that can be configured. It may not be practical to pass those options via command-line, and manually checking boxes in CMake-GUI can be tedious. To facilitate setting up CMake options for Lagrange, simply rename LagrangeOptions.cmake.sample -> LagrangeOptions.cmake and uncomment options that you wish to change. Note that since options are cached by CMake, you will need to delete your <build>/CMakeCache.txt before re-running CMake in order for a change in LagrangeOptions.cmake to take effect. Useful CMake Options LAGRANGE_UNIT_TESTS : build unit tests. LAGRANGE_PERFORMANCE_TESTS : build performance tests. LAGRANGE_EXAMPLES : build examples. LAGRANGE_USE_PCH : build with precomplied headers. LAGRANGE_WITH_ONETBB : build with oneTBB. LAGRANGE_WITH_TRACY : build with tracy profiling support. USE_SANITIZER : build with sanitizer support, options are \"Address\", \"Memory\", \"MemoryWithOrigins\", \"Undefined\", \"Thread\", \"Leak\". Finally, build with cmake --build . Compilation Issues If an issue occurs during compilation, especially after an update, try to Delete your <build>/CMakeCache.txt and re-run CMake to configure your project. The nuclear option: delete the whole <build> folder and re-run CMake to configure your project. If neither option works, please ask for help on #lib-lagrange .","title":"Compiling"},{"location":"build/#unit-tests","text":"When LAGRANGE_UNIT_TESTS is ON , unit tests are built automatically. To run all unit tests, either run the special target RUN_TESTS in your Visual Studio/Xcode project, or simply run ctest in the command-line in your build folder. Further instructions on running unit tests are available on this page .","title":"Unit Tests"},{"location":"build/#platform-specific-steps","text":"","title":"Platform-Specific Steps"},{"location":"build/#windows","text":"For Visual Studio, you might have to force 64-bit compilation depending on your exact compiler version, e.g.: cmake -A x64 .. cmake -G \"Visual Studio 17 2022\" -A x64 .. cmake -G \"Visual Studio 16 2019\" -A x64 .. cmake -G \"Visual Studio 15 2017 Win64\" .. cmake -G \"Visual Studio 14 2015 Win64\" ..","title":"Windows"},{"location":"build/#unix","text":"You may have to install Zenity for the file dialog window to work: sudo apt-get install zenity","title":"Unix"},{"location":"build/#run","text":"Executables are compiled into the following folders: <build>/examples for examples covering various Lagrange features. <build>/tests for unit test executables. <build>/performance for performance test executables (legacy code).","title":"Run"},{"location":"build/#dependencies","text":"Lagrange's CMake build system will download and build any and all dependencies required by the current build setup. This includes both core dependencies (e.g., Eigen) and optional ones (e.g., tinyobjloader for the IO module). If you are using Lagrange in your project and you wish to override Lagrange dependencies, make sure they are specified as CMake targets before calling add_subdirectory(<lagrange>) .","title":"Dependencies"},{"location":"goals/","text":"Library Goals & Design Principles There are a lot of geometry processing libraries out there, and it might be a little confusing where Lagrange stands in the current landscape. In this page, we highlight some of the goals and key design principles that go into Lagrange. Do No Reinvent The Wheel . If a library exists that already solves a particular problem (nanoflann, embree, etc.) we will use it instead of reinventing the wheel. As such, we have libigl-style wrappers around some common third-party libraries. Note that we only use external libraries that are available under commercial friendly licenses. Please consult our dedicated page for more information. Powerful Mesh Data Structure . Our mesh data structure can represent any type of mesh (triangle mesh, quad-dominant, polygonal mesh, 2D, 3D, etc.). It is memory-efficient, support generic attributes, navigation, dynamic editing, etc. More information is available on our dedicated Mesh Class user guide. Interoperability . Our mesh data structure is designed to allow wrapping any continuous buffers as regular mesh attributes. This allows creating a Lagrange mesh from an external buffer without copying any data, as long as memory layout is compatible. Furthermore, you can export attributes to reuse our buffers after a mesh object is destroyed. And because our attributes can be viewed as Eigen matrices, our mesh data structure is directly compatible with libigl. We are planning to implement conversion functions for other mesh processing libraries in the future. Interoperability With Others Libraries Name From Lagrange Mesh To Lagrange Mesh Comment cinolib geogram Planned. geometry-central Planned. libigl (no copy) (may copy) pmp-library Clean Build System . Lagrange has a clean and polished CMake build system. Getting started with Lagrange is incredibly simple, just add 5 lines to your CMake project (no git submodule needed): include ( FetchContent ) FetchContent_Declare ( lagrange GIT_REPOSITORY <lagrange-url> GIT_TAG <sha256> ) FetchContent_MakeAvailable ( lagrange ) target_link_libraries ( my_project PUBLIC lagrange::core ) If you are not a fan of CMake, all Lagrange modules follow the same organization, so it should be easy to add them to your build system, provided you can compile the required dependencies. Ease Of Use . Lagrange meshes have a clean and well-documented API. Any mesh attribute can be viewed as a Eigen matrix, ensuring compatibility with libigl functions. Combined with our simple CMake system, Lagrange is an ideal framework for prototyping C++ applications with advanced geometry processing features. Modularity . Lagrange features are split into modules, based on specific features and dependencies. Module names are sensible and short. While lagrange::core is relatively small, bringing additional modules to your project can provide more advanced features. File Formats . Our IO module supports reading/writing a variety of standard file formats used in the industry. Rather than writing our own parsers, we leverage existing libraries such as tinyobj to provide IO functionalities. Supported File Formats Format Read Write Comment OBJ Via tinyobj/libigl VTK Custom writer PLY Via tinyply/libigl OFF Via libigl glTF Via Assimp FBX Via Assimp USD Planned HDF5 Planned Performance . Lagrange functions are written with performance in mind. We use TBB for multithreading, and avoid unnecessary heap memory allocation or data copies. Lagrange should be able to process large assets that are often encountered in the industry. If you encounter any performance limitation, please reach out to us. Advanced Viewer . We provide an advanced mesh viewer for building interactive applications with realistic shading. We use a modified ImGui that conforms to the Spectrum specification to provide a user experience more consistent with Adobe products. Viewer Key Features Support for all lagrange mesh types Customizable renderer that includes PBR Gizmos for interactive mesh and element manipulation Easy to add your own UI via ImGui Variety of visualization options - mix and match indexing/colormapping/rendered primitive/shading. Robustness/Support . Being backed by a company, Lagrange has a strong focus on correctness/being as bug free as possible. We have extensive unit testing internally, with more than 400 unit tests. Specifically, we try to ensure the following: Corner Cases . Special cases should not crash the program. Incorrect inputs may result in exceptions being thrown. Determinism . Parallel algorithms should produce the same results when called repeatedly with the same inputs. Regression Tests . We should have unit tests to ensure that algorithms produce the same output whenever code changes. Changes in algorithm behaviors should be documented. Cross-Platform . Algorithms should produce the same result on all three platforms whenever possible (macOS/Linux/Windows). This means avoiding std::default_random_engine and other platform-specific constructs. Useful Feedbacks . Being integrated into a product means we often need to provide some simple feedback mechanisms, such as logging, cancellation and progress report. Logger . We use spdlog to provide beautiful logging messages. The global logger is thread-safe, and can be turned off or redirected as needed by the client application. Cancellation . It should be possible to cancel any running function by switching a std::atomic_bool & flag. Progress Report . A simple thread-safe callback mechanism can be used in certain functions to report progress. This is useful to inform the user about the advancement of certain tasks that can be slow (e.g. mesh cleanup, etc.). Error Mechanism . We use exception throwing as the mechanism to report an error. While returning error code has certain advantages over exceptions, third-party libraries or the STL can still throw exceptions, and thus it is the user's responsibility to catch them should they occur. Documentation/Code Style . Our codebase is formatted via clang-format for consistency. We aim to provide both libigl-style tutorials to get started using Lagrange, as well as detailed API documentation written in Doxygen.","title":"Goals"},{"location":"goals/#library-goals-design-principles","text":"There are a lot of geometry processing libraries out there, and it might be a little confusing where Lagrange stands in the current landscape. In this page, we highlight some of the goals and key design principles that go into Lagrange. Do No Reinvent The Wheel . If a library exists that already solves a particular problem (nanoflann, embree, etc.) we will use it instead of reinventing the wheel. As such, we have libigl-style wrappers around some common third-party libraries. Note that we only use external libraries that are available under commercial friendly licenses. Please consult our dedicated page for more information. Powerful Mesh Data Structure . Our mesh data structure can represent any type of mesh (triangle mesh, quad-dominant, polygonal mesh, 2D, 3D, etc.). It is memory-efficient, support generic attributes, navigation, dynamic editing, etc. More information is available on our dedicated Mesh Class user guide. Interoperability . Our mesh data structure is designed to allow wrapping any continuous buffers as regular mesh attributes. This allows creating a Lagrange mesh from an external buffer without copying any data, as long as memory layout is compatible. Furthermore, you can export attributes to reuse our buffers after a mesh object is destroyed. And because our attributes can be viewed as Eigen matrices, our mesh data structure is directly compatible with libigl. We are planning to implement conversion functions for other mesh processing libraries in the future. Interoperability With Others Libraries Name From Lagrange Mesh To Lagrange Mesh Comment cinolib geogram Planned. geometry-central Planned. libigl (no copy) (may copy) pmp-library Clean Build System . Lagrange has a clean and polished CMake build system. Getting started with Lagrange is incredibly simple, just add 5 lines to your CMake project (no git submodule needed): include ( FetchContent ) FetchContent_Declare ( lagrange GIT_REPOSITORY <lagrange-url> GIT_TAG <sha256> ) FetchContent_MakeAvailable ( lagrange ) target_link_libraries ( my_project PUBLIC lagrange::core ) If you are not a fan of CMake, all Lagrange modules follow the same organization, so it should be easy to add them to your build system, provided you can compile the required dependencies. Ease Of Use . Lagrange meshes have a clean and well-documented API. Any mesh attribute can be viewed as a Eigen matrix, ensuring compatibility with libigl functions. Combined with our simple CMake system, Lagrange is an ideal framework for prototyping C++ applications with advanced geometry processing features. Modularity . Lagrange features are split into modules, based on specific features and dependencies. Module names are sensible and short. While lagrange::core is relatively small, bringing additional modules to your project can provide more advanced features. File Formats . Our IO module supports reading/writing a variety of standard file formats used in the industry. Rather than writing our own parsers, we leverage existing libraries such as tinyobj to provide IO functionalities. Supported File Formats Format Read Write Comment OBJ Via tinyobj/libigl VTK Custom writer PLY Via tinyply/libigl OFF Via libigl glTF Via Assimp FBX Via Assimp USD Planned HDF5 Planned Performance . Lagrange functions are written with performance in mind. We use TBB for multithreading, and avoid unnecessary heap memory allocation or data copies. Lagrange should be able to process large assets that are often encountered in the industry. If you encounter any performance limitation, please reach out to us. Advanced Viewer . We provide an advanced mesh viewer for building interactive applications with realistic shading. We use a modified ImGui that conforms to the Spectrum specification to provide a user experience more consistent with Adobe products. Viewer Key Features Support for all lagrange mesh types Customizable renderer that includes PBR Gizmos for interactive mesh and element manipulation Easy to add your own UI via ImGui Variety of visualization options - mix and match indexing/colormapping/rendered primitive/shading. Robustness/Support . Being backed by a company, Lagrange has a strong focus on correctness/being as bug free as possible. We have extensive unit testing internally, with more than 400 unit tests. Specifically, we try to ensure the following: Corner Cases . Special cases should not crash the program. Incorrect inputs may result in exceptions being thrown. Determinism . Parallel algorithms should produce the same results when called repeatedly with the same inputs. Regression Tests . We should have unit tests to ensure that algorithms produce the same output whenever code changes. Changes in algorithm behaviors should be documented. Cross-Platform . Algorithms should produce the same result on all three platforms whenever possible (macOS/Linux/Windows). This means avoiding std::default_random_engine and other platform-specific constructs. Useful Feedbacks . Being integrated into a product means we often need to provide some simple feedback mechanisms, such as logging, cancellation and progress report. Logger . We use spdlog to provide beautiful logging messages. The global logger is thread-safe, and can be turned off or redirected as needed by the client application. Cancellation . It should be possible to cancel any running function by switching a std::atomic_bool & flag. Progress Report . A simple thread-safe callback mechanism can be used in certain functions to report progress. This is useful to inform the user about the advancement of certain tasks that can be slow (e.g. mesh cleanup, etc.). Error Mechanism . We use exception throwing as the mechanism to report an error. While returning error code has certain advantages over exceptions, third-party libraries or the STL can still throw exceptions, and thus it is the user's responsibility to catch them should they occur. Documentation/Code Style . Our codebase is formatted via clang-format for consistency. We aim to provide both libigl-style tutorials to get started using Lagrange, as well as detailed API documentation written in Doxygen.","title":"Library Goals &amp; Design Principles"},{"location":"setup/","text":"Getting Started Compiling Lagrange How to compile Lagrange . How to run unit tests . Example project template using Lagrange. Contributing Read our contributing page . Read our code style guide .","title":"Getting Started"},{"location":"setup/#getting-started","text":"","title":"Getting Started"},{"location":"setup/#compiling-lagrange","text":"How to compile Lagrange . How to run unit tests . Example project template using Lagrange.","title":"Compiling Lagrange"},{"location":"setup/#contributing","text":"Read our contributing page . Read our code style guide .","title":"Contributing"},{"location":"third-party/","text":"External Dependencies Here is a list of third party libraries used in Lagrange. Those external dependencies will be automatically downloaded by our CMake system depending on which Lagrange module is enabled. Important This table only lists direct dependencies of various Lagrange modules. Indirect dependencies are not listed there. Library Name License Used By Assimp 1 BSD-3 IO Boost 2 Boost FS CLI11 BSD-3 Examples (Core, UI), Performance Tests (Core) Catch2 Boost Testing Dear ImGui MIT UI Eigen MPL2 Core, UI EnTT MIT UI Filesystem 3 MIT FS GLFW MIT UI ImGuizmo MIT UI JSON for Modern C++ MIT UI Libigl MPL2 Core, IO MDL SDK BSD-3 UI MshIO Apache 2 IO Portable File Dialogs WTFPL (public domain) UI Pybind11 BSD-3 Python Threading Building Blocks Apache 2 Core Tracy 4 BSD-3 Core gl3w MIT UI imgui fonts MIT UI nanoflann BSD-2 UI span-lite Boost Core spdlog MIT Core stb Public domain UI tinyobjloader MIT IO Bundled Dependencies Lagrange integrates some third-party code directly into its codebase. Those files have usually been modified to work with Eigen, and their functions wrapped into the lagrange namespace. This table summarize the list of third-party code that is directly bundled into Lagrange, as well as the appropriate licenses and files that are affected. Library Name License Used By Files CMake Scripts Apache 2 CMake Build System sanitizers.cmake , code-coverage.cmake Earcut ISC Core earcut.h Floating-point exception handling example Public domain Core fpe.cpp function_ref CC0 Core function_ref.h Geogram BSD-3 Core point_triangle_squared_distance.h , point_segment_squared_distance.h ImGui Progress Indicators MIT UI progress.h , progress.cpp scope_guard Public domain Core scope_guard.h Shewchuk's predicates Public domain Core predicates.cpp valuable MIT Core value_ptr.h Assimp is an optional dependency of the IO module. \u21a9 Boost::filesystem is an optional backend of the FS module. \u21a9 gulrak/filesystem is only needed when the IO module is compiled in C++14 mode. In C++17 mode, the IO module will defaults to std::filesystem . \u21a9 Tracy is an optional dependency of the core module. \u21a9","title":"Third Party Libraries"},{"location":"third-party/#external-dependencies","text":"Here is a list of third party libraries used in Lagrange. Those external dependencies will be automatically downloaded by our CMake system depending on which Lagrange module is enabled. Important This table only lists direct dependencies of various Lagrange modules. Indirect dependencies are not listed there. Library Name License Used By Assimp 1 BSD-3 IO Boost 2 Boost FS CLI11 BSD-3 Examples (Core, UI), Performance Tests (Core) Catch2 Boost Testing Dear ImGui MIT UI Eigen MPL2 Core, UI EnTT MIT UI Filesystem 3 MIT FS GLFW MIT UI ImGuizmo MIT UI JSON for Modern C++ MIT UI Libigl MPL2 Core, IO MDL SDK BSD-3 UI MshIO Apache 2 IO Portable File Dialogs WTFPL (public domain) UI Pybind11 BSD-3 Python Threading Building Blocks Apache 2 Core Tracy 4 BSD-3 Core gl3w MIT UI imgui fonts MIT UI nanoflann BSD-2 UI span-lite Boost Core spdlog MIT Core stb Public domain UI tinyobjloader MIT IO","title":"External Dependencies"},{"location":"third-party/#bundled-dependencies","text":"Lagrange integrates some third-party code directly into its codebase. Those files have usually been modified to work with Eigen, and their functions wrapped into the lagrange namespace. This table summarize the list of third-party code that is directly bundled into Lagrange, as well as the appropriate licenses and files that are affected. Library Name License Used By Files CMake Scripts Apache 2 CMake Build System sanitizers.cmake , code-coverage.cmake Earcut ISC Core earcut.h Floating-point exception handling example Public domain Core fpe.cpp function_ref CC0 Core function_ref.h Geogram BSD-3 Core point_triangle_squared_distance.h , point_segment_squared_distance.h ImGui Progress Indicators MIT UI progress.h , progress.cpp scope_guard Public domain Core scope_guard.h Shewchuk's predicates Public domain Core predicates.cpp valuable MIT Core value_ptr.h Assimp is an optional dependency of the IO module. \u21a9 Boost::filesystem is an optional backend of the FS module. \u21a9 gulrak/filesystem is only needed when the IO module is compiled in C++14 mode. In C++17 mode, the IO module will defaults to std::filesystem . \u21a9 Tracy is an optional dependency of the core module. \u21a9","title":"Bundled Dependencies"},{"location":"dev/clangd/","text":"Autocompletion With Clangd Are you coding in a text editor like Vim/NeoVim, VSCode, Sublime, and miss powerful IDE features such as provided by Visual Studio? The new kid in the block for intelligent autocompletion and smart code editing is clangd . Retrieve LLVM and Clangd clangd is part of the LLVM project, so it should be present on your machine if you have a local installation of llvm-clang. However, due to certain issues with header-only code completion, as of today (05-18-20) we need to compile LLVM from source and patch it manually for it to work well with Lagrange: Clone the LLVM git repository (we used 7ee479a76 as of this writing) git clone --depth 1 https://github.com/llvm/llvm-project.git cd llvm-project Download and apply patch for this issue (if still applicable) wget https://reviews.llvm.org/file/data/p524ff355qzqwqvmqoiy/PHID-FILE-agyvgty5nzpa5wvyoice/D78038.diff git apply D78038.diff Build clang and clangd: mkdir build cd build cmake -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr/local/opt/llvm-git lang -DLLVM_ENABLE_PROJECTS=\"clang;clang-tools-extra;libcxx;libcxxabi;polly;lldb;lld;compiler-rt\" ../llvm ninja ninja install You can change the install directory from /usr/local/opt/llvm-git to suit your preference. Install Editor Plugin For Clangd Please check out the clangd website for instructions on how to install the clangd plugin for your favorite editor. In this tutorial we will use VSCode. Users of Vim/NeoVim can also check out coc.vim . For the VSCode plugin, do not forget to set the clangd path to the binary compiled in the previous step: \"clangd.path\": \"/usr/local/opt/llvm-git/bin/clangd\" Also the compile_commands.json file should be in your project root folder, and the default Microsoft C/C++ plugin (Intellisense...) must be uninstalled or disabled. Configure Your Project CMake Make sure you configure your CMake project with the following options: # Generates a `compile_commands.json` that can be used for autocompletion set ( CMAKE_EXPORT_COMPILE_COMMANDS ON CACHE BOOL \"Enable/Disable output of compile commands during generation.\" ) # Use a specific C/C++ compiler, e.g. llvm-clang on macOS (so we can use clangd) set ( CMAKE_C_COMPILER \"/usr/local/opt/llvm-git/bin/clang\" CACHE STRING \"C compiler\" FORCE ) set ( CMAKE_CXX_COMPILER \"/usr/local/opt/llvm-git/bin/clang++\" CACHE STRING \"C++ compiler\" FORCE ) You can also pass those options via the command line when you first configure your project ( cmake -DCMAKE_CXX_COMPILER=<...> .. ). For Lagrange, you can put those lines in a file LagrangeOptions.cmake at the root of the repository. When configuring your own CMake project, make sure the CMAKE_CXX_COMPILER cache variable is set before the first call to project() in your CMake script. Xcode If you have an xcode project (generated by gyp or metabuild) for example, you can use xcpretty to generate the compile_commands.json (thanks to this link ). Install xcpretty sudo gem install xcpretty . Clean up your project xcodebuild clean -project /path/to/project.xcodeproj -scheme main/scheme/name Generate the compile commands xcodebuild -project /path/to/project.xcodeproj -scheme main/scheme/name | xcpretty -r json-compilation-database -o compile_commands.json Better Completion Database By default, the compile_commands.json generated by CMake only contains compilation instructions for each translation unit in your project. We will use compdb to generate a new compilation database that includes header files. Install compdb using pip: pip install --user compdb You can also install compdb via conda using the following environment: name: compdb dependencies: - python=3.7 - pip - pip: - compdb Generate a new completion database containing header files: python -m compdb -p /folder/containing/initial/compile_commands.json list > compile_commands.json This last step needs to be re-run anytime you add a new file to your project, or change any compilation options. Enjoy!","title":"Autocompletion With Clangd"},{"location":"dev/clangd/#autocompletion-with-clangd","text":"Are you coding in a text editor like Vim/NeoVim, VSCode, Sublime, and miss powerful IDE features such as provided by Visual Studio? The new kid in the block for intelligent autocompletion and smart code editing is clangd .","title":"Autocompletion With Clangd"},{"location":"dev/clangd/#retrieve-llvm-and-clangd","text":"clangd is part of the LLVM project, so it should be present on your machine if you have a local installation of llvm-clang. However, due to certain issues with header-only code completion, as of today (05-18-20) we need to compile LLVM from source and patch it manually for it to work well with Lagrange: Clone the LLVM git repository (we used 7ee479a76 as of this writing) git clone --depth 1 https://github.com/llvm/llvm-project.git cd llvm-project Download and apply patch for this issue (if still applicable) wget https://reviews.llvm.org/file/data/p524ff355qzqwqvmqoiy/PHID-FILE-agyvgty5nzpa5wvyoice/D78038.diff git apply D78038.diff Build clang and clangd: mkdir build cd build cmake -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr/local/opt/llvm-git lang -DLLVM_ENABLE_PROJECTS=\"clang;clang-tools-extra;libcxx;libcxxabi;polly;lldb;lld;compiler-rt\" ../llvm ninja ninja install You can change the install directory from /usr/local/opt/llvm-git to suit your preference.","title":"Retrieve LLVM and Clangd"},{"location":"dev/clangd/#install-editor-plugin-for-clangd","text":"Please check out the clangd website for instructions on how to install the clangd plugin for your favorite editor. In this tutorial we will use VSCode. Users of Vim/NeoVim can also check out coc.vim . For the VSCode plugin, do not forget to set the clangd path to the binary compiled in the previous step: \"clangd.path\": \"/usr/local/opt/llvm-git/bin/clangd\" Also the compile_commands.json file should be in your project root folder, and the default Microsoft C/C++ plugin (Intellisense...) must be uninstalled or disabled.","title":"Install Editor Plugin For Clangd"},{"location":"dev/clangd/#configure-your-project","text":"","title":"Configure Your Project"},{"location":"dev/clangd/#cmake","text":"Make sure you configure your CMake project with the following options: # Generates a `compile_commands.json` that can be used for autocompletion set ( CMAKE_EXPORT_COMPILE_COMMANDS ON CACHE BOOL \"Enable/Disable output of compile commands during generation.\" ) # Use a specific C/C++ compiler, e.g. llvm-clang on macOS (so we can use clangd) set ( CMAKE_C_COMPILER \"/usr/local/opt/llvm-git/bin/clang\" CACHE STRING \"C compiler\" FORCE ) set ( CMAKE_CXX_COMPILER \"/usr/local/opt/llvm-git/bin/clang++\" CACHE STRING \"C++ compiler\" FORCE ) You can also pass those options via the command line when you first configure your project ( cmake -DCMAKE_CXX_COMPILER=<...> .. ). For Lagrange, you can put those lines in a file LagrangeOptions.cmake at the root of the repository. When configuring your own CMake project, make sure the CMAKE_CXX_COMPILER cache variable is set before the first call to project() in your CMake script.","title":"CMake"},{"location":"dev/clangd/#xcode","text":"If you have an xcode project (generated by gyp or metabuild) for example, you can use xcpretty to generate the compile_commands.json (thanks to this link ). Install xcpretty sudo gem install xcpretty . Clean up your project xcodebuild clean -project /path/to/project.xcodeproj -scheme main/scheme/name Generate the compile commands xcodebuild -project /path/to/project.xcodeproj -scheme main/scheme/name | xcpretty -r json-compilation-database -o compile_commands.json","title":"Xcode"},{"location":"dev/clangd/#better-completion-database","text":"By default, the compile_commands.json generated by CMake only contains compilation instructions for each translation unit in your project. We will use compdb to generate a new compilation database that includes header files. Install compdb using pip: pip install --user compdb You can also install compdb via conda using the following environment: name: compdb dependencies: - python=3.7 - pip - pip: - compdb Generate a new completion database containing header files: python -m compdb -p /folder/containing/initial/compile_commands.json list > compile_commands.json This last step needs to be re-run anytime you add a new file to your project, or change any compilation options.","title":"Better Completion Database"},{"location":"dev/clangd/#enjoy","text":"","title":"Enjoy!"},{"location":"dev/code-style/","text":"Code Style Apply Clang Format Our code style configuration is stored in a file .clang-format at the root of the repository. It is highly recommended that you install and configure ClangFormat for your favorite editor. This will allow you to automatically format your code to adopt a consistent style with the rest of Lagrange. We follow the Google C++ Style Guide , modified for the needs of the Lagrange project. To get a quick taste of our style, here is a simple function declaration: #include <lagrange/compute_vertex_normal.h> namespace lagrange { /** * One sentence description of the function. * * More detailed description (optional). * * @param[in] input_mesh Input mesh description. * * @tparam MeshType Mesh type. */ template < typename MeshType > void process_mesh ( std :: shared_ptr < MeshType > input_mesh ) { ... compute_vertex_normal ( input_mesh ); ... } } // namespace lagrange and here is an example for class declaration: namespace lagrange { /** * One sentence description of the class. * * @tparam MeshType Mesh type. */ template < typename MeshType > class MeshProcesser { public : /** * One sentence description. * * @param[in] mesh Mesh description. */ void set_mesh ( std :: shared_ptr < MeshType > mesh ) { // Inline comment m_mesh = mesh ; } private : std :: shared_ptr < MeshType > m_mesh ; }; } // namespace lagrange Here are a few items to highlight: Indentation consists of 4 spaces . Keep each line below 100 characters long. All functions and classes should be inside of the lagrange namespace. All the code in the core module lives directly under the lagrange namespace. Individual modules use their own sub-namespace, e.g. lagrange::io . C++ namespace is not indented. Function and variable names are in snake_case while class names are in CamelCase . Member variables are prefixed with m_ . The opening bracket placement is dictated by our .clang-format : always attach braces to surrounding context, except for functions and classes, where it is placed on a newline. Commented/dead code should be removed. New code is encouraged to use Doxygen-style comments if possible, in particular for public headers. Here is an example for a function , and for a class . When in doubt, we recommend using fenced /** */ blocks for function/class descriptions, and // for inline comments. #include statement uses full path in angle brackets, for example: #include <lagrange/filename.h> The order of #include statements should be local to global, as explained in this post : Immediate .h file that this file is implementing if applicable. Lagrange headers. Third party dependency headers if any. C/C++ system headers if any. Lastly, no style guide is complete or correct all the time. Older code in Lagrange may not follow all the items described here. Use your professional judgment when necessary.","title":"Code Style"},{"location":"dev/code-style/#code-style","text":"Apply Clang Format Our code style configuration is stored in a file .clang-format at the root of the repository. It is highly recommended that you install and configure ClangFormat for your favorite editor. This will allow you to automatically format your code to adopt a consistent style with the rest of Lagrange. We follow the Google C++ Style Guide , modified for the needs of the Lagrange project. To get a quick taste of our style, here is a simple function declaration: #include <lagrange/compute_vertex_normal.h> namespace lagrange { /** * One sentence description of the function. * * More detailed description (optional). * * @param[in] input_mesh Input mesh description. * * @tparam MeshType Mesh type. */ template < typename MeshType > void process_mesh ( std :: shared_ptr < MeshType > input_mesh ) { ... compute_vertex_normal ( input_mesh ); ... } } // namespace lagrange and here is an example for class declaration: namespace lagrange { /** * One sentence description of the class. * * @tparam MeshType Mesh type. */ template < typename MeshType > class MeshProcesser { public : /** * One sentence description. * * @param[in] mesh Mesh description. */ void set_mesh ( std :: shared_ptr < MeshType > mesh ) { // Inline comment m_mesh = mesh ; } private : std :: shared_ptr < MeshType > m_mesh ; }; } // namespace lagrange Here are a few items to highlight: Indentation consists of 4 spaces . Keep each line below 100 characters long. All functions and classes should be inside of the lagrange namespace. All the code in the core module lives directly under the lagrange namespace. Individual modules use their own sub-namespace, e.g. lagrange::io . C++ namespace is not indented. Function and variable names are in snake_case while class names are in CamelCase . Member variables are prefixed with m_ . The opening bracket placement is dictated by our .clang-format : always attach braces to surrounding context, except for functions and classes, where it is placed on a newline. Commented/dead code should be removed. New code is encouraged to use Doxygen-style comments if possible, in particular for public headers. Here is an example for a function , and for a class . When in doubt, we recommend using fenced /** */ blocks for function/class descriptions, and // for inline comments. #include statement uses full path in angle brackets, for example: #include <lagrange/filename.h> The order of #include statements should be local to global, as explained in this post : Immediate .h file that this file is implementing if applicable. Lagrange headers. Third party dependency headers if any. C/C++ system headers if any. Lastly, no style guide is complete or correct all the time. Older code in Lagrange may not follow all the items described here. Use your professional judgment when necessary.","title":"Code Style"},{"location":"dev/compilation-profiling/","text":"Profiling Compilation Times Who doesn't love a slow compiling C++ project? Here are some simple tools to help you figure out which part of your project takes the cake when it comes to compilation times. Once you have a better idea of what to improve, head over to our Speeding Up Compilation page for some tips on how to improve this. Using Ninja When compiling a CMake project using Ninja instead of Make or MSBuild, one can use ninjatracing to convert ninja log files to chrome's about:tracing format: To build a project with Ninja, simply use the -G Ninja when generating the build system: mkdir build cd build cmake -G Ninja .. ninja # Or Cmake --Build . Windows & Ninja The Ninja generator is also available on Windows. Make sure you are in a x64 Visual Studio Developer Command Prompt before running cmake -G ... . Once you have build your project with Ninja, you can convert the log files with ninjatracing : ninjatracing $BUILD_DIR /.ninja_log > trace.json Open the resulting trace.json in Chrome ( about:tracing ). Incremental Compilation When incrementally compiling an existing project, only newly compiled files will appear in the trace.json file produced by ninjatracing. Using Clang + Ninja When compiling with clang, one can use the -ftime-trace flag to get detailed information on where clang spends most of its time compiling your project: cmake -G Ninja -DCMAKE_CXX_FLAGS = \"-ftime-trace\" .. ninja Then, simply add -e to the ninjatracing call: ninjatracing -e $BUILD_DIR /.ninja_log > trace.json Open the resulting trace file in Chrome: Using The Clang Build Analyzer Go to the Clang Build Analyzer repository and compile the tool, then simply follow the instructions in the README (copied below): Usage Start the build capture : ClangBuildAnalyzer --start <artifacts_folder> This will write current timestamp in a ClangBuildAnalyzerSession.txt file under the given artifacts_folder . The artifacts folder is where the compiled object files (and time trace report files) are expected to be produced by your build. Do your build . Does not matter how; an IDE build, a makefile, a shell script, whatever. As long as it invokes Clang and passes -ftime-trace flag to the compiler ( Clang 9.0 or later is required for this). Stop the build capture : ClangBuildAnalyzer --stop <artifacts_folder> <capture_file> This will load all Clang time trace compatible *.json files under the given artifacts_folder that were modified after --start step was done (Clang -ftime-trace produces one JSON file next to each object file), process them and store data file into a binary capture_file . Run the build analysis : ClangBuildAnalyzer --analyze <capture_file> This will read the capture_file produced by --stop step, calculate the slowest things and print them. If a ClangBuildAnalyzer.ini file exists in the current folder, it will be read to control how many of various things to print. Aternatively, instead of doing --start and --stop steps, you can do ClangBuildAnalyzer --all <artifacts_folder> <capture_file> after your build; that will include all the compatible *.json files for analysis, no matter when they were produced. Analysis Output The analysis output will look something like this: Analyzing build trace from 'artifacts/FullCapture.bin'... **** Time summary: Compilation (1761 times): Parsing (frontend): 5167.4 s Codegen & opts (backend): 7576.5 s **** Files that took longest to parse (compiler frontend): 19524 ms: artifacts/Modules_TLS_0.o 18046 ms: artifacts/Editor_Src_4.o 17026 ms: artifacts/Modules_Audio_Public_1.o 16581 ms: artifacts/Runtime_Camera_4.o **** Files that took longest to codegen (compiler backend): 145761 ms: artifacts/Modules_TLS_0.o 123048 ms: artifacts/Runtime_Core_Containers_1.o 56975 ms: artifacts/Runtime_Testing_3.o 52031 ms: artifacts/Tools_ShaderCompiler_1.o **** Templates that took longest to instantiate: 19006 ms: std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::... (2665 times, avg 7 ms) 12821 ms: std::__1::map<core::basic_string<char, core::StringStorageDefault<ch... (250 times, avg 51 ms) 9142 ms: std::__1::map<core::basic_string<char, core::StringStorageDefault<ch... (432 times, avg 21 ms) 8515 ms: std::__1::map<int, std::__1::pair<List<ListNode<Behaviour> > *, List... (392 times, avg 21 ms) **** Functions that took longest to compile: 8710 ms: yyparse(glslang::TParseContext*) (External/ShaderCompilers/glslang/glslang/MachineIndependent/glslang_tab.cpp) 4580 ms: LZ4HC_compress_generic_dictCtx (External/Compression/lz4/lz4hc_quarantined.c) 4011 ms: sqlite3VdbeExec (External/sqlite/sqlite3.c) 2737 ms: ProgressiveRuntimeManager::Update() (artifacts/Editor_Src_GI_Progressive_0.cpp) *** Expensive headers: 136567 ms: /BuildEnvironment/MacOSX10.14.sdk/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h (included 92 times, avg 1484 ms), included via: CocoaObjectImages.o AppKit.h (2033 ms) OSXNativeWebViewWindowHelper.o OSXNativeWebViewWindowHelper.h AppKit.h (2007 ms) RenderSurfaceMetal.o RenderSurfaceMetal.h MetalSupport.h Metal.h MTLTypes.h (2003 ms) OSXWebViewWindowPrivate.o AppKit.h (1959 ms) ... 112344 ms: Runtime/BaseClasses/BaseObject.h (included 729 times, avg 154 ms), included via: PairTests.cpp TestFixtures.h (337 ms) Stacktrace.cpp MonoManager.h GameManager.h EditorExtension.h (312 ms) PlayerPrefs.o PlayerSettings.h GameManager.h EditorExtension.h (301 ms) Animation.cpp MaterialDescription.h (299 ms) ... 103856 ms: Runtime/Threads/ReadWriteLock.h (included 478 times, avg 217 ms), included via: DownloadHandlerAssetBundle.cpp AssetBundleManager.h (486 ms) LocalizationDatabase.cpp LocalizationDatabase.h LocalizationAsset.h StringTable.h (439 ms) Runtime_BaseClasses_1.o MonoUtility.h ScriptingProfiler.h (418 ms) ...","title":"Profiling Compilation Times"},{"location":"dev/compilation-profiling/#profiling-compilation-times","text":"Who doesn't love a slow compiling C++ project? Here are some simple tools to help you figure out which part of your project takes the cake when it comes to compilation times. Once you have a better idea of what to improve, head over to our Speeding Up Compilation page for some tips on how to improve this.","title":"Profiling Compilation Times"},{"location":"dev/compilation-profiling/#using-ninja","text":"When compiling a CMake project using Ninja instead of Make or MSBuild, one can use ninjatracing to convert ninja log files to chrome's about:tracing format: To build a project with Ninja, simply use the -G Ninja when generating the build system: mkdir build cd build cmake -G Ninja .. ninja # Or Cmake --Build . Windows & Ninja The Ninja generator is also available on Windows. Make sure you are in a x64 Visual Studio Developer Command Prompt before running cmake -G ... . Once you have build your project with Ninja, you can convert the log files with ninjatracing : ninjatracing $BUILD_DIR /.ninja_log > trace.json Open the resulting trace.json in Chrome ( about:tracing ). Incremental Compilation When incrementally compiling an existing project, only newly compiled files will appear in the trace.json file produced by ninjatracing.","title":"Using Ninja"},{"location":"dev/compilation-profiling/#using-clang-ninja","text":"When compiling with clang, one can use the -ftime-trace flag to get detailed information on where clang spends most of its time compiling your project: cmake -G Ninja -DCMAKE_CXX_FLAGS = \"-ftime-trace\" .. ninja Then, simply add -e to the ninjatracing call: ninjatracing -e $BUILD_DIR /.ninja_log > trace.json Open the resulting trace file in Chrome:","title":"Using Clang + Ninja"},{"location":"dev/compilation-profiling/#using-the-clang-build-analyzer","text":"Go to the Clang Build Analyzer repository and compile the tool, then simply follow the instructions in the README (copied below):","title":"Using The Clang Build Analyzer"},{"location":"dev/compilation-profiling/#usage","text":"Start the build capture : ClangBuildAnalyzer --start <artifacts_folder> This will write current timestamp in a ClangBuildAnalyzerSession.txt file under the given artifacts_folder . The artifacts folder is where the compiled object files (and time trace report files) are expected to be produced by your build. Do your build . Does not matter how; an IDE build, a makefile, a shell script, whatever. As long as it invokes Clang and passes -ftime-trace flag to the compiler ( Clang 9.0 or later is required for this). Stop the build capture : ClangBuildAnalyzer --stop <artifacts_folder> <capture_file> This will load all Clang time trace compatible *.json files under the given artifacts_folder that were modified after --start step was done (Clang -ftime-trace produces one JSON file next to each object file), process them and store data file into a binary capture_file . Run the build analysis : ClangBuildAnalyzer --analyze <capture_file> This will read the capture_file produced by --stop step, calculate the slowest things and print them. If a ClangBuildAnalyzer.ini file exists in the current folder, it will be read to control how many of various things to print. Aternatively, instead of doing --start and --stop steps, you can do ClangBuildAnalyzer --all <artifacts_folder> <capture_file> after your build; that will include all the compatible *.json files for analysis, no matter when they were produced.","title":"Usage"},{"location":"dev/compilation-profiling/#analysis-output","text":"The analysis output will look something like this: Analyzing build trace from 'artifacts/FullCapture.bin'... **** Time summary: Compilation (1761 times): Parsing (frontend): 5167.4 s Codegen & opts (backend): 7576.5 s **** Files that took longest to parse (compiler frontend): 19524 ms: artifacts/Modules_TLS_0.o 18046 ms: artifacts/Editor_Src_4.o 17026 ms: artifacts/Modules_Audio_Public_1.o 16581 ms: artifacts/Runtime_Camera_4.o **** Files that took longest to codegen (compiler backend): 145761 ms: artifacts/Modules_TLS_0.o 123048 ms: artifacts/Runtime_Core_Containers_1.o 56975 ms: artifacts/Runtime_Testing_3.o 52031 ms: artifacts/Tools_ShaderCompiler_1.o **** Templates that took longest to instantiate: 19006 ms: std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::... (2665 times, avg 7 ms) 12821 ms: std::__1::map<core::basic_string<char, core::StringStorageDefault<ch... (250 times, avg 51 ms) 9142 ms: std::__1::map<core::basic_string<char, core::StringStorageDefault<ch... (432 times, avg 21 ms) 8515 ms: std::__1::map<int, std::__1::pair<List<ListNode<Behaviour> > *, List... (392 times, avg 21 ms) **** Functions that took longest to compile: 8710 ms: yyparse(glslang::TParseContext*) (External/ShaderCompilers/glslang/glslang/MachineIndependent/glslang_tab.cpp) 4580 ms: LZ4HC_compress_generic_dictCtx (External/Compression/lz4/lz4hc_quarantined.c) 4011 ms: sqlite3VdbeExec (External/sqlite/sqlite3.c) 2737 ms: ProgressiveRuntimeManager::Update() (artifacts/Editor_Src_GI_Progressive_0.cpp) *** Expensive headers: 136567 ms: /BuildEnvironment/MacOSX10.14.sdk/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h (included 92 times, avg 1484 ms), included via: CocoaObjectImages.o AppKit.h (2033 ms) OSXNativeWebViewWindowHelper.o OSXNativeWebViewWindowHelper.h AppKit.h (2007 ms) RenderSurfaceMetal.o RenderSurfaceMetal.h MetalSupport.h Metal.h MTLTypes.h (2003 ms) OSXWebViewWindowPrivate.o AppKit.h (1959 ms) ... 112344 ms: Runtime/BaseClasses/BaseObject.h (included 729 times, avg 154 ms), included via: PairTests.cpp TestFixtures.h (337 ms) Stacktrace.cpp MonoManager.h GameManager.h EditorExtension.h (312 ms) PlayerPrefs.o PlayerSettings.h GameManager.h EditorExtension.h (301 ms) Animation.cpp MaterialDescription.h (299 ms) ... 103856 ms: Runtime/Threads/ReadWriteLock.h (included 478 times, avg 217 ms), included via: DownloadHandlerAssetBundle.cpp AssetBundleManager.h (486 ms) LocalizationDatabase.cpp LocalizationDatabase.h LocalizationAsset.h StringTable.h (439 ms) Runtime_BaseClasses_1.o MonoUtility.h ScriptingProfiler.h (418 ms) ...","title":"Analysis Output"},{"location":"dev/contribute/","text":"Contributor Guidelines So, you want to contribute code to Lagrange? Great! Here are a few bits of information and tips: Checklist Fork the Lagrange repository in GitHub. Check our code of conduct . Check our code style + make sure .clang-format is applied. Run unit tests + upload your own unit test data to our test data repository . Push your work to a new branch in your own fork. Open a pull request on github and give it a readable title. Coding Style And Conventions Please check our coding style guide . Unfortunately, some files in Lagrange may not be following the above guide. If you change those files, feel free to fix them accordingly, or respect the existing style. Do not output a file with inconsistent code style. Try to write code that compiles without compiler warnings. Follow the general design principles . Check the mesh class for common functionality, and use similar template and type names. Use utility functions for common functionalities such as logging, timing, casting, and optionally ranges. Creating New Files Please name your new file consistently with the functionality implemented inside. Use lowercase compute_something.h for functions and Uppercase SomeNewType.h for types (classes). If your file contains more than one function, please document an overview of the contents at the top. After creating the new file, you may need to add it to the CMake build system, and run cmake .. again. Adding A New Module It is possible for your contribution to justify the creation of a new Lagrange module. This is especially encouraged for large contributions, or those that require external dependencies. To create a new module, pick an expressive and concise name, and use it consistently across CMake, folders, and C++ namespaces. Use existing modules as reference. You should add your new module to the modules directory. Each module has similar subdirectory setup: CMakeLists.cmake to specify how to build the module. include/lagrange/<module_name>/ contains the header files. src/ contains the source codes. tests/ contains unit tests specific to this module. performance/ contains performance tests. examples/ contains stand alone examples illustrating typical usage. Adding New Third-Party Code License Considerations Make sure the third-party code uses an acceptable license. Please open an issue to discuss the matter if you are unsure about it. When adding a new third-party dependency: Place the corresponding foo.cmake file in cmake/recipes following existing models. Update the ALL_THIRD_PARTIES in scripts/lagrange_ci/third_parties.py accordingly. When adding new bundled code directly into the Lagrange repository: Make sure the file header gives proper attribution to the source code origin. Update the NOTICE_LIST in scripts/lagrange_ci/notice.py . Unit Testing Please check our unit tests guide . Tests are awesome and highly encouraged. You can add your unit tests in modules/<module_name>/tests . While developing your code, you can run only your specific test case(s) by passing the name(s) as argument to the test executable. You can also tag your new tests according to your new feature, and run all of them. ./tests/test_lagrange_core \"SafeCast\" # Run SafeCast test case. ./tests/test_lagrange_core \"[mesh]\" # Run all test cases tagged with \"[mesh]\" In case you also develop a small application that uses your new feature, feel free to include that in modules/<module_name>/examples . Legacy Performance Tests Some modules have a modules/<module_name>/performance subfolder containing some \"performance\" tests. This is legacy code. New benchmarking tests should be written along with other unit tests, use Catch2's benchmarking framework , and be tagged as [!benchmark] . Pull Requests You can create a pull request (PR) at any time from the GitHub web interface. When your code is ready, request a review, and stay updated for any feedback.","title":"Contribute"},{"location":"dev/contribute/#contributor-guidelines","text":"So, you want to contribute code to Lagrange? Great! Here are a few bits of information and tips:","title":"Contributor Guidelines"},{"location":"dev/contribute/#checklist","text":"Fork the Lagrange repository in GitHub. Check our code of conduct . Check our code style + make sure .clang-format is applied. Run unit tests + upload your own unit test data to our test data repository . Push your work to a new branch in your own fork. Open a pull request on github and give it a readable title.","title":"Checklist"},{"location":"dev/contribute/#coding-style-and-conventions","text":"Please check our coding style guide . Unfortunately, some files in Lagrange may not be following the above guide. If you change those files, feel free to fix them accordingly, or respect the existing style. Do not output a file with inconsistent code style. Try to write code that compiles without compiler warnings. Follow the general design principles . Check the mesh class for common functionality, and use similar template and type names. Use utility functions for common functionalities such as logging, timing, casting, and optionally ranges.","title":"Coding Style And Conventions"},{"location":"dev/contribute/#creating-new-files","text":"Please name your new file consistently with the functionality implemented inside. Use lowercase compute_something.h for functions and Uppercase SomeNewType.h for types (classes). If your file contains more than one function, please document an overview of the contents at the top. After creating the new file, you may need to add it to the CMake build system, and run cmake .. again.","title":"Creating New Files"},{"location":"dev/contribute/#adding-a-new-module","text":"It is possible for your contribution to justify the creation of a new Lagrange module. This is especially encouraged for large contributions, or those that require external dependencies. To create a new module, pick an expressive and concise name, and use it consistently across CMake, folders, and C++ namespaces. Use existing modules as reference. You should add your new module to the modules directory. Each module has similar subdirectory setup: CMakeLists.cmake to specify how to build the module. include/lagrange/<module_name>/ contains the header files. src/ contains the source codes. tests/ contains unit tests specific to this module. performance/ contains performance tests. examples/ contains stand alone examples illustrating typical usage.","title":"Adding A New Module"},{"location":"dev/contribute/#adding-new-third-party-code","text":"License Considerations Make sure the third-party code uses an acceptable license. Please open an issue to discuss the matter if you are unsure about it. When adding a new third-party dependency: Place the corresponding foo.cmake file in cmake/recipes following existing models. Update the ALL_THIRD_PARTIES in scripts/lagrange_ci/third_parties.py accordingly. When adding new bundled code directly into the Lagrange repository: Make sure the file header gives proper attribution to the source code origin. Update the NOTICE_LIST in scripts/lagrange_ci/notice.py .","title":"Adding New Third-Party Code"},{"location":"dev/contribute/#unit-testing","text":"Please check our unit tests guide . Tests are awesome and highly encouraged. You can add your unit tests in modules/<module_name>/tests . While developing your code, you can run only your specific test case(s) by passing the name(s) as argument to the test executable. You can also tag your new tests according to your new feature, and run all of them. ./tests/test_lagrange_core \"SafeCast\" # Run SafeCast test case. ./tests/test_lagrange_core \"[mesh]\" # Run all test cases tagged with \"[mesh]\" In case you also develop a small application that uses your new feature, feel free to include that in modules/<module_name>/examples . Legacy Performance Tests Some modules have a modules/<module_name>/performance subfolder containing some \"performance\" tests. This is legacy code. New benchmarking tests should be written along with other unit tests, use Catch2's benchmarking framework , and be tagged as [!benchmark] .","title":"Unit Testing"},{"location":"dev/contribute/#pull-requests","text":"You can create a pull request (PR) at any time from the GitHub web interface. When your code is ready, request a review, and stay updated for any feedback.","title":"Pull Requests"},{"location":"dev/runtime-profiling/","text":"Runtime Profiling with Tracy Tracy is a real-time profiler using a client/server model. It is cross-platform (Windows, Linux, macOS) and support GPU (OpenGL, Vulkan, etc.). This page explains how to use Tracy with Lagrange. Enabling The Tracy Client Tracy uses a client-server model to profile applications. This means we need to inject the Tracy client (a single .cpp file) into our application to enable profiling. To enable the Tracy client with Lagrange, simply enable the CMake option LAGRANGE_WITH_TRACY in your CMake setup. Compile Options On macOs and Linux, do not forget to compile your application with -g , -fno-omit-frame-pointer , and -rdynamic (see tracy manual for explanations). When using LAGRANGE_WITH_TRACY=ON , those options will be automatically enabled by the Lagrange CMake. Instrumenting Your Code The next step will be to instrument your code. In short: Include <Tracy.hpp> in every file you are interested in profiling. Add the macro FrameMark at the end of each frame loop. Add the macro ZoneScoped as the first line of your function definitions to include them in the profile. Convenience Macros Since Tracy is an optional dependency in Lagrange, we provide a convenience header to include Tracy without having to test the TRACY_ENABLE macro: #include <lagrange/utils/tracy.h> This header provides the following alias macros for Tracy: LAGRANGE_ZONE_SCOPED for ZoneScoped LAGRANGE_FRAME_MARK for FrameMark When Tracy is disabled ( LAGRANGE_WITH_TRACY=OFF in CMake), these macros will expand to a no-op. Running The Tracy Profiler Make sure to compile the profiler (server) using the same version of Tracy as in Lagrange. The easiest way to do so is to build from the <build>/_deps/tracy-src . This folder is downloaded by CMake when building Lagrange with LAGRANGE_WITH_TRACY=ON . Windows Download the pre-built binaries corresponding to the version of Tracy used in Lagrange (see cmake/recipes/external/tracy.cmake ). Run the Tracy executable and your program. Click \"Connect\" in the Tracy profiler. macOS Install prerequisites using homebrew brew install freetype capstone gtk glfw Build the profiler (server): cd <build>/_deps/tracy-src/profiler/build/unix make release -j8 Run the profiler: ./Tracy-release Run your program, and click \"Connect\" in the Tracy profiler.","title":"Profiling Runtime With Tracy"},{"location":"dev/runtime-profiling/#runtime-profiling-with-tracy","text":"Tracy is a real-time profiler using a client/server model. It is cross-platform (Windows, Linux, macOS) and support GPU (OpenGL, Vulkan, etc.). This page explains how to use Tracy with Lagrange.","title":"Runtime Profiling with Tracy"},{"location":"dev/runtime-profiling/#enabling-the-tracy-client","text":"Tracy uses a client-server model to profile applications. This means we need to inject the Tracy client (a single .cpp file) into our application to enable profiling. To enable the Tracy client with Lagrange, simply enable the CMake option LAGRANGE_WITH_TRACY in your CMake setup. Compile Options On macOs and Linux, do not forget to compile your application with -g , -fno-omit-frame-pointer , and -rdynamic (see tracy manual for explanations). When using LAGRANGE_WITH_TRACY=ON , those options will be automatically enabled by the Lagrange CMake.","title":"Enabling The Tracy Client"},{"location":"dev/runtime-profiling/#instrumenting-your-code","text":"The next step will be to instrument your code. In short: Include <Tracy.hpp> in every file you are interested in profiling. Add the macro FrameMark at the end of each frame loop. Add the macro ZoneScoped as the first line of your function definitions to include them in the profile. Convenience Macros Since Tracy is an optional dependency in Lagrange, we provide a convenience header to include Tracy without having to test the TRACY_ENABLE macro: #include <lagrange/utils/tracy.h> This header provides the following alias macros for Tracy: LAGRANGE_ZONE_SCOPED for ZoneScoped LAGRANGE_FRAME_MARK for FrameMark When Tracy is disabled ( LAGRANGE_WITH_TRACY=OFF in CMake), these macros will expand to a no-op.","title":"Instrumenting Your Code"},{"location":"dev/runtime-profiling/#running-the-tracy-profiler","text":"Make sure to compile the profiler (server) using the same version of Tracy as in Lagrange. The easiest way to do so is to build from the <build>/_deps/tracy-src . This folder is downloaded by CMake when building Lagrange with LAGRANGE_WITH_TRACY=ON .","title":"Running The Tracy Profiler"},{"location":"dev/runtime-profiling/#windows","text":"Download the pre-built binaries corresponding to the version of Tracy used in Lagrange (see cmake/recipes/external/tracy.cmake ). Run the Tracy executable and your program. Click \"Connect\" in the Tracy profiler.","title":"Windows"},{"location":"dev/runtime-profiling/#macos","text":"Install prerequisites using homebrew brew install freetype capstone gtk glfw Build the profiler (server): cd <build>/_deps/tracy-src/profiler/build/unix make release -j8 Run the profiler: ./Tracy-release Run your program, and click \"Connect\" in the Tracy profiler.","title":"macOS"},{"location":"dev/speeding-up-compilation/","text":"Tips To Speed Up Compilation Times If your hand has reached too deep into the depth of C++ template meta-programming and header-only libraries, you might find yourself in a hot mess of slow-compiling projects and long wait-time between recompilations. Unfortunately, it is very easy to shoot oneself in the foot and blow up compilation times in a C++ project. In this page we will discuss various ways to alleviate the problem. Placebo Solutions These are some \"simple\" solutions we can use to treat the symptoms (slow compile times) without addressing the root cause (code architecture). Pre-compiled headers are pretty much a no-brainer to use with CMake, and may or may not provide some speedup in your project. On Windows, many people use IncrediBuild for distributed compilation/caching to dramatically improve compilation performance. On Linux and macOS, you can use ccache for to improve the performance of repeated builds. Combined with a shared cache database stored in a Redis server, this will provide additional performance (e.g. in a Jenkins build cluster). sccache is an alternative to ccache that also works on Windows and support cloud storage. Finally, for distributed compilation on Linux, you can also look into icecream . Use Pre-Compiled Headers The basic CMake file to enable pre-compiled headers for your project look like this: # We use an interface target to define commonly used pre-compiled headers add_library ( mylib_pch INTERFACE ) # Always define an alias in the form foo::bar to prevent silly CMake errors add_library ( mylib::pch ALIAS mylib_pch ) # Define commonly used headers here target_precompile_headers ( mylib_pch INTERFACE # C++ headers <algorithm> <chrono> <functional> # Third party libraries <Eigen/Core> # Your own library headers <mylib/common.h> <mylib/Mesh.h> <mylib/logger.h> ) # Reuse the same pre-compiled headers for both lib, executable and unit tests # (but do not make it a PUBLIC dependency of `mylib`). target_link_libraries ( mylib PRIVATE mylib::pch ) target_link_libraries ( myexecutable PRIVATE mylib::pch ) Choice of Precompiled Headers You want to add headers that are used often in the project, ideally in at least a third of the compilation units. Avoid adding a header to PCH if you are actively working on it. And that's it! Please consult the official documentation of the target_precompile_headers() function for more information. For example, one could use the REUSE_FROM syntax to reuse a list of pre-compiled headers from one target to the next, rather than using an interface target for this purpose. Using ccache Ccache can be used to speed up compilation on macOS and Linux. There are similar tools that also work on Windows, such as sscache (developed by Mozilla). First, make sure you set a cache size large enough to accommodate your C++ projects: ccache -M 100G # set max cache size ccache -s # show stats To enable ccache in a CMake project, simply set the CMAKE_CXX_COMPILER_LAUNCHER variable to the ccache executable. This simple CMake snippet will work on machines with and without ccache installed: find_program ( CCACHE_PROGRAM ccache ) if ( CCACHE_PROGRAM ) set ( CMAKE_C_COMPILER_LAUNCHER ${ CCACHE_PROGRAM } ) set ( CMAKE_CXX_COMPILER_LAUNCHER ${ CCACHE_PROGRAM } ) endif () Without any additional settings however, it is likely that you will not have as many cache hits as you would like. Here are some important settings to experiment with: CCACHE_BASEDIR : Should be set to either ${CMAKE_BINARY_DIR} or ${CMAKE_SOURCE_DIR} . CCACHE_SLOPPINESS : When using pre-compiled headers, it is important to define this to pch_defines,time_macros . Other settings may improve cache hit performance, such as include_file_mtime . CCACHE_PREFIX : Should be set when combining ccache with another compiler wrapper (such as distcc or icecc for distributed compilation, e.g. CCACHE_PREFIX=icecc ). To set those options from your CMake project, you can use the following code snippet: find_program ( CCACHE_PROGRAM ccache ) if ( CCACHE_PROGRAM ) set ( ccacheEnv CCACHE_BASEDIR= ${ CMAKE_BINARY_DIR } CCACHE_SLOPPINESS=clang_index_store,include_file_ctime,include_file_mtime,locale,pch_defines,time_macros ) foreach ( lang IN ITEMS C CXX CUDA ) set ( CMAKE_ ${ lang } _COMPILER_LAUNCHER ${ CMAKE_COMMAND } -E env ${ ccacheEnv } ${ CCACHE_PROGRAM } PARENT_SCOPE ) endforeach () endif () Real Solutions Profile Compilation Times First! Before going head-over-heel and refactor all your code, it is essential that you run some simple profiling tools to help you analyze what parts of your project are slow to compile. Accepting Trade-Offs To really reduce compile times in a C++ project, we need to re-think its architecture and accept trade-offs. Why are C++ projects slow to compile in the first place? In my experience the main culprit is often 1) long header parsing time and 2) long codegen time for templated code. The C++ syntax is incredibly complicated, and after pre-processor STL headers can expand to thousands of lines of code. Compilers need to work extra hard to parse the language correctly, a phenomenon that does not improve with new versions of the C++ standard. Secondly, templated code require the compiler to generate code at each location where a templated function is used. In a project where everything is templated, deeply nested calls to templated functions means that the compiler will basically have to compile the whole project for each translation unit. This kinda defeats the purpose of separating a project in single compilation units in the first place. Because templated code is usually header-only, pulling a complicated templated function will pull a lot of dependent headers, which will need to be parsed, and compiled, etc. The result is a big quagmire of header files that the compiler needs to go through every time, which leads to tremendously slow compilation times. To remedy this, one needs to find compromise , and refactor your code accordingly: Do you need to support generic templated types, or do you only need to support a limited number of instantiations? E.g. float and double , or dimensions 2 and 3 ? Can you get away with runtime polymorphism (virtual methods, function pointers, etc.) instead of compile time polymorphism (templates)? Yes there is an small overhead, but your development time might be more valuable than the incurred performance cost. Most of the time, I find that if you really need to support a generic type, a virtual class will do just fine. Explicit Template Instantiation The first step to sanitize a C++ project slowed down by expensive templates is to get rid of them. Seriously. Do not use templates unless you have to. If you absolutely need do use templates, consider the following: If you only need to support a limited number of types, use explicit template instantiation. Write separate files for function declaration and definition, just like you would for a regular C++ function. Before sum.h main.cpp #pragma once #include <expensive_operation> // Expensive header to parse template < typename Scalar > Scalar sum ( const std :: vector < Scalar > & pts ) { Scalar x = 0 ; for ( size_t i = 0 ; i < pts . size (); ++ i ) { x += expensive_operation ( pts [ i ]); } return x ; } // This will pull other headers, such as `expensive_operation` #include \"sum.h\" int main ( void ) { std :: vector < float > pts = { 0 , 1 , 2 , 3 }; sum ( pts ); return 0 ; } After sum.h sum.cpp main.cpp #pragma once template < typename Scalar > Scalar sum ( const std :: vector < Scalar > & pts ); #include \"sum.h\" // Now `expensive_operation` is safely hidden inside the .cpp #include <expensive_operation> template < typename Scalar > Scalar sum ( const std :: vector < Scalar > & pts ) { Scalar x = 0 ; for ( size_t i = 0 ; i < pts . size (); ++ i ) { x += expensive_operation ( pts [ i ]); } return x ; } // Explicit template instantiation template float sum ( const std :: vector < float > & pts ); template double sum ( const std :: vector < double > & pts ); // Now this header is cheap to parse #include \"sum.h\" int main ( void ) { std :: vector < float > pts = { 0 , 1 , 2 , 3 }; sum ( pts ); return 0 ; } To avoid repeating explicit template instantiations for various types, we can use a cool macro trick described at the end of this page. Definitions In Header Files One could also envision using separate header files for the declaration/definition of a templated function (as opposed to a header file + source file). But this gets tricky when nesting templated function calls and trying to instantiate them with new types. Extern Templates While extern template might seem like a good idea, they will only save time on code generation, not parsing. If your templated function only need to support a finite number of fundamental types, moving their definition into a separate source file will save you the additional parsing overhead and avoid header pollution. Limit Header Pollution Remember that a large portion of a compiler's time is spent parsing headers. STL headers in particular will have various impact on compilation times. Some headers like <type_traits> will have a minimal overhead, while <filesystem> or <regex> can take more than 200ms to parse on a powerful machine. See this website for detailed statistics on all STL headers. To limit compilation overhead due to header parsing, you can do the following: Profile your compilation times to find out which header takes the most time to parse. Separate your code between source and header files. Move header includes to the .cpp if they are not needed in the .h. Separate expensive headers from cheap-but-commonly-used ones, and only include what you need. Avoid having a all.h or common.h that include all headers from your library. This may seem convenient, but will increase compilation times for your users. Use forward declarations to avoid pulling expensive headers. Use the PIMPL idiom to hide implementation details from header files of a class. Forward Declarations And Pass-By-Value I was surprised to learn that you can declare a function taking a forward declared class as a by-value argument and as a result. I.e. this works just fine: class type ; type function ( type ); Forward Declarations And Circular Dependencies The Google C++ Style Guide cautions against using forward declarations whenever possible. Forward declaration can hide circular dependencies which should be a red flag in your code architecture. My advice would be to use them sparingly when it makes sense, and measure the performance impact on your project when possible. The PIMPL idiom TL;DR Use valuable::value_ptr<> or spimpl::impl_ptr<> . When defining a class in C++, the types of its member variables need to be known, as the compiler needs to determine the size of the object. However, sometimes we have private member variables whose type do not need to be exposed in the class header. Their type is an implementation detail, and we do not want to expose the additional dependency. The PIMPL idiom (Pointer to IMPLementation) is a technique to hide this implementation detail, such that the underlying types used in a class are not exposed in the class header. Of course there is a small price to pay. In most cases this means an extra heap allocation and pointer indirection. Oftentimes the trade-off is worth it, but this depends on your specific use case. There are several ways to implement a PIMPL in your code (from bad to good): [Bad] Use a raw T * m_foo; member variable and forward-declare T . But this is bad because there is no lifetime management (when the encapsulating class is destroyed/moved/copied, etc.). class HiddenType ; class Bar { protected : // No lifetime management = bad HiddenType * m_foo ; }; [Not Great] Use a std::unique_ptr<T> m_foo . This would work, but there are two problems with that. The std::unique_ptr<> needs to know how to destroy the object, so you need to define the encapsulating class destructor in the .cpp source file, or you would be forced to pull <HiddenType.h> in <Bar.h> . Bar.h Bar.cpp class HiddenType ; class Bar { ~ Bar (); protected : std :: unique_ptr < HiddenType > m_foo ; }; #include <HiddenType.h> // The destructor needs to know HiddenType Bar ::~ Bar () = default ; You lose value semantics on the encapsulating type. I.e. you can no longer copy the object easily, just move it. [Not Great] Use a std::shared_ptr<T> m_foo . This has the same issues as the std::unique_ptr<> solution. You lose value semantics, but you may also incur additional bugs due to the shared ownership of the hidden object (e.g. in case a copy of Bar is created). [Good] Use a thin-wrapper around std::unique_ptr<> that provides copy/value semantics. Here are some readily available single-file implementations: valuable::value_ptr<> (with accompanying blog post ). spimpl::impl_ptr<> very similar. Pointers & Const-Correctness When storing member variables that are pointers to data, you need to be very careful regarding const-correctness . #include <ExplicitType.h> class Bar { ~ Bar (); public : // Will compile, but this is NOT ok ExplicitType & get_foo_bad () const { return * m_foo ; } // Const accessors should return pointers/reference to _const_ data. const ExplicitType & get_foo_good () const { return * m_foo ; } // This is a const method, so it should return a pointer to a _const_ data. std :: shared_ptr < const ExplicitType > get_foo_ptr () const { return m_foo ; } protected : std :: shared_ptr < ExplicitType > m_foo ; }; Example An example usage of the PIMPL idiom in Lagrange is the AttributeManager class in SurfaceMesh.h . X Macro Trick For Explicit Instantiations Repeating explicit template instantiations for various types can be a tedious task. It makes code lengthy, hard to read and hard to extend when adding new types/functions to your codebase. Fortunately we can use a cool preprocessor trick known as X macros to iterate over a list of types and generate a list of explicit template instantiation for various classes/functions. While you could use the Boost Preprocessing library and macros such as BOOST_PP_SEQ_FOR_EACH , you can also roll out your own solution, which requires very little code and is easy to understand. The basic idea is as follows: Attribute.h AttributeTypes.h Attribute.cpp #pragma once #include <vector> \u200b namespace mylib { template < typename T > struct Attribute { void some_method (); std :: vector < T > m_data ; }; } // namespace mylib #pragma once // Define the X macro arguments here (= the list of types to instantiate) #define MYLIB_ATTRIBUTE_X(mode, data) \\ MYLIB_X_##mode(data, int8_t) \\ MYLIB_X_##mode(data, int16_t) \\ MYLIB_X_##mode(data, int32_t) \\ MYLIB_X_##mode(data, int64_t) \\ MYLIB_X_##mode(data, uint8_t) \\ MYLIB_X_##mode(data, uint16_t) \\ MYLIB_X_##mode(data, uint32_t) \\ MYLIB_X_##mode(data, uint64_t) \\ MYLIB_X_##mode(data, float) \\ MYLIB_X_##mode(data, double) #include <mylib/Attribute.h> namespace mylib { template < typename T > void Attribute < T >:: some_method () { // do something } // Explicit template instantiation using X macros #include <mylib/AttributeTypes.h> #define MYLIB_X_attr_class(_, T) template class Attribute<T>; MYLIB_ATTRIBUTE_X ( attr_class , 0 ) #undef MYLIB_X_attr_class } // namespace mylib Macro Cleanup There is no need to #undef MYLIB_X_attr_class at the end of Attribute.cpp , since the macro is usually defined at the end of a .cpp file. But if you are planning on doing Unity builds and are not using unique names for your macro, then it is a good idea to do so. The above solution works well for a single list of types to instantiate. But what if we are mixing functions that depend on two different types U and T ? This is where the extra parameter data comes in. You can think of it as a continuation parameter to recursively instantiate nested type lists. Here is an concrete example: Header.h Types.h Source.cpp #pragma once #include <vector> template < typename T > struct Attribute { void some_method (); std :: vector < T > m_data ; }; template < typename Scalar > struct Mesh { std :: vector < Scalar > m_vertices ; }; template < size_t Dim > struct Volume { size_t m_volume = Dim ; }; template < typename T , typename Scalar > void set_attribute ( Mesh < Scalar > & mesh , const Attribute < T > & attr ); template < typename T , typename Scalar , size_t D > void set_volume ( Mesh < Scalar > & mesh , const Attribute < T > & attr , Volume < D > & vol ); #pragma once // Define the X macro arguments for each type list #define MYLIB_ATTRIBUTE_X(mode, data) \\ MYLIB_X_##mode(data, int8_t) \\ MYLIB_X_##mode(data, int16_t) \\ MYLIB_X_##mode(data, int32_t) \\ MYLIB_X_##mode(data, int64_t) \\ MYLIB_X_##mode(data, uint8_t) \\ MYLIB_X_##mode(data, uint16_t) \\ MYLIB_X_##mode(data, uint32_t) \\ MYLIB_X_##mode(data, uint64_t) \\ MYLIB_X_##mode(data, float) \\ MYLIB_X_##mode(data, double) #define MYLIB_MESH_X(mode, data) \\ MYLIB_X_##mode(data, double) \\ MYLIB_X_##mode(data, float) #define MYLIB_VOL_X(mode, data) \\ MYLIB_X_##mode(data, 2) \\ MYLIB_X_##mode(data, 3) #include \"Header.h\" #include \"Types.h\" // Method/function definitions in the source file template < typename T > void Attribute < T >:: some_method () { // do something } \u200b template < typename T , typename Scalar > void set_attribute ( Mesh < Scalar > & mesh , const Attribute < T > & attr ) { // do something } \u200b template < typename T , typename Scalar , size_t D > void set_volume ( Mesh < Scalar > & mesh , const Attribute < T > & attr , Volume < D > & vol ) { // do something } // Explicit instantiation \u200b // 1. Simple type lists (Attribute<> and Mesh<> classes) #define MYLIB_X_attr_class(_, T) template class Attribute<T>; MYLIB_ATTRIBUTE_X ( attr_class , 0 ) \u200b #define MYLIB_X_mesh_class(_, S) template class Mesh<S>; MYLIB_MESH_X ( mesh_class , 0 ) \u200b // 2. Cartesian product with two types S x T #define MYLIB_X_attr_set(S, T) template void set_attribute(Mesh<S> &mesh, const Attribute<T> &attr); #define MYLIB_X_mesh_set(_, S) MYLIB_ATTRIBUTE_X(attr_set, S) \u200b MYLIB_MESH_X ( mesh_set , 0 ) \u200b // 3. Cartesian product with three types S x D x T. // We need to define helper macros to unpack argument tuples. #define fst(first, second) first #define snd(first, second) second #define MYLIB_X_attr_vol(SD, T) template void set_volume(Mesh<fst SD> &mesh, const Attribute<T> &attr, Volume<snd SD> &vol); #define MYLIB_X_mesh_vol(D, S) MYLIB_ATTRIBUTE_X(attr_vol, (S, D)) #define MYLIB_X_dim_vol(_, D) MYLIB_MESH_X(mesh_vol, D) \u200b MYLIB_VOL_X ( dim_vol , 0 )","title":"Speeding Up Compilation"},{"location":"dev/speeding-up-compilation/#tips-to-speed-up-compilation-times","text":"If your hand has reached too deep into the depth of C++ template meta-programming and header-only libraries, you might find yourself in a hot mess of slow-compiling projects and long wait-time between recompilations. Unfortunately, it is very easy to shoot oneself in the foot and blow up compilation times in a C++ project. In this page we will discuss various ways to alleviate the problem.","title":"Tips To Speed Up Compilation Times"},{"location":"dev/speeding-up-compilation/#placebo-solutions","text":"These are some \"simple\" solutions we can use to treat the symptoms (slow compile times) without addressing the root cause (code architecture). Pre-compiled headers are pretty much a no-brainer to use with CMake, and may or may not provide some speedup in your project. On Windows, many people use IncrediBuild for distributed compilation/caching to dramatically improve compilation performance. On Linux and macOS, you can use ccache for to improve the performance of repeated builds. Combined with a shared cache database stored in a Redis server, this will provide additional performance (e.g. in a Jenkins build cluster). sccache is an alternative to ccache that also works on Windows and support cloud storage. Finally, for distributed compilation on Linux, you can also look into icecream .","title":"Placebo Solutions"},{"location":"dev/speeding-up-compilation/#use-pre-compiled-headers","text":"The basic CMake file to enable pre-compiled headers for your project look like this: # We use an interface target to define commonly used pre-compiled headers add_library ( mylib_pch INTERFACE ) # Always define an alias in the form foo::bar to prevent silly CMake errors add_library ( mylib::pch ALIAS mylib_pch ) # Define commonly used headers here target_precompile_headers ( mylib_pch INTERFACE # C++ headers <algorithm> <chrono> <functional> # Third party libraries <Eigen/Core> # Your own library headers <mylib/common.h> <mylib/Mesh.h> <mylib/logger.h> ) # Reuse the same pre-compiled headers for both lib, executable and unit tests # (but do not make it a PUBLIC dependency of `mylib`). target_link_libraries ( mylib PRIVATE mylib::pch ) target_link_libraries ( myexecutable PRIVATE mylib::pch ) Choice of Precompiled Headers You want to add headers that are used often in the project, ideally in at least a third of the compilation units. Avoid adding a header to PCH if you are actively working on it. And that's it! Please consult the official documentation of the target_precompile_headers() function for more information. For example, one could use the REUSE_FROM syntax to reuse a list of pre-compiled headers from one target to the next, rather than using an interface target for this purpose.","title":"Use Pre-Compiled Headers"},{"location":"dev/speeding-up-compilation/#using-ccache","text":"Ccache can be used to speed up compilation on macOS and Linux. There are similar tools that also work on Windows, such as sscache (developed by Mozilla). First, make sure you set a cache size large enough to accommodate your C++ projects: ccache -M 100G # set max cache size ccache -s # show stats To enable ccache in a CMake project, simply set the CMAKE_CXX_COMPILER_LAUNCHER variable to the ccache executable. This simple CMake snippet will work on machines with and without ccache installed: find_program ( CCACHE_PROGRAM ccache ) if ( CCACHE_PROGRAM ) set ( CMAKE_C_COMPILER_LAUNCHER ${ CCACHE_PROGRAM } ) set ( CMAKE_CXX_COMPILER_LAUNCHER ${ CCACHE_PROGRAM } ) endif () Without any additional settings however, it is likely that you will not have as many cache hits as you would like. Here are some important settings to experiment with: CCACHE_BASEDIR : Should be set to either ${CMAKE_BINARY_DIR} or ${CMAKE_SOURCE_DIR} . CCACHE_SLOPPINESS : When using pre-compiled headers, it is important to define this to pch_defines,time_macros . Other settings may improve cache hit performance, such as include_file_mtime . CCACHE_PREFIX : Should be set when combining ccache with another compiler wrapper (such as distcc or icecc for distributed compilation, e.g. CCACHE_PREFIX=icecc ). To set those options from your CMake project, you can use the following code snippet: find_program ( CCACHE_PROGRAM ccache ) if ( CCACHE_PROGRAM ) set ( ccacheEnv CCACHE_BASEDIR= ${ CMAKE_BINARY_DIR } CCACHE_SLOPPINESS=clang_index_store,include_file_ctime,include_file_mtime,locale,pch_defines,time_macros ) foreach ( lang IN ITEMS C CXX CUDA ) set ( CMAKE_ ${ lang } _COMPILER_LAUNCHER ${ CMAKE_COMMAND } -E env ${ ccacheEnv } ${ CCACHE_PROGRAM } PARENT_SCOPE ) endforeach () endif ()","title":"Using ccache"},{"location":"dev/speeding-up-compilation/#real-solutions","text":"Profile Compilation Times First! Before going head-over-heel and refactor all your code, it is essential that you run some simple profiling tools to help you analyze what parts of your project are slow to compile.","title":"Real Solutions"},{"location":"dev/speeding-up-compilation/#accepting-trade-offs","text":"To really reduce compile times in a C++ project, we need to re-think its architecture and accept trade-offs. Why are C++ projects slow to compile in the first place? In my experience the main culprit is often 1) long header parsing time and 2) long codegen time for templated code. The C++ syntax is incredibly complicated, and after pre-processor STL headers can expand to thousands of lines of code. Compilers need to work extra hard to parse the language correctly, a phenomenon that does not improve with new versions of the C++ standard. Secondly, templated code require the compiler to generate code at each location where a templated function is used. In a project where everything is templated, deeply nested calls to templated functions means that the compiler will basically have to compile the whole project for each translation unit. This kinda defeats the purpose of separating a project in single compilation units in the first place. Because templated code is usually header-only, pulling a complicated templated function will pull a lot of dependent headers, which will need to be parsed, and compiled, etc. The result is a big quagmire of header files that the compiler needs to go through every time, which leads to tremendously slow compilation times. To remedy this, one needs to find compromise , and refactor your code accordingly: Do you need to support generic templated types, or do you only need to support a limited number of instantiations? E.g. float and double , or dimensions 2 and 3 ? Can you get away with runtime polymorphism (virtual methods, function pointers, etc.) instead of compile time polymorphism (templates)? Yes there is an small overhead, but your development time might be more valuable than the incurred performance cost. Most of the time, I find that if you really need to support a generic type, a virtual class will do just fine.","title":"Accepting Trade-Offs"},{"location":"dev/speeding-up-compilation/#explicit-template-instantiation","text":"The first step to sanitize a C++ project slowed down by expensive templates is to get rid of them. Seriously. Do not use templates unless you have to. If you absolutely need do use templates, consider the following: If you only need to support a limited number of types, use explicit template instantiation. Write separate files for function declaration and definition, just like you would for a regular C++ function.","title":"Explicit Template Instantiation"},{"location":"dev/speeding-up-compilation/#before","text":"sum.h main.cpp #pragma once #include <expensive_operation> // Expensive header to parse template < typename Scalar > Scalar sum ( const std :: vector < Scalar > & pts ) { Scalar x = 0 ; for ( size_t i = 0 ; i < pts . size (); ++ i ) { x += expensive_operation ( pts [ i ]); } return x ; } // This will pull other headers, such as `expensive_operation` #include \"sum.h\" int main ( void ) { std :: vector < float > pts = { 0 , 1 , 2 , 3 }; sum ( pts ); return 0 ; }","title":"Before"},{"location":"dev/speeding-up-compilation/#after","text":"sum.h sum.cpp main.cpp #pragma once template < typename Scalar > Scalar sum ( const std :: vector < Scalar > & pts ); #include \"sum.h\" // Now `expensive_operation` is safely hidden inside the .cpp #include <expensive_operation> template < typename Scalar > Scalar sum ( const std :: vector < Scalar > & pts ) { Scalar x = 0 ; for ( size_t i = 0 ; i < pts . size (); ++ i ) { x += expensive_operation ( pts [ i ]); } return x ; } // Explicit template instantiation template float sum ( const std :: vector < float > & pts ); template double sum ( const std :: vector < double > & pts ); // Now this header is cheap to parse #include \"sum.h\" int main ( void ) { std :: vector < float > pts = { 0 , 1 , 2 , 3 }; sum ( pts ); return 0 ; } To avoid repeating explicit template instantiations for various types, we can use a cool macro trick described at the end of this page. Definitions In Header Files One could also envision using separate header files for the declaration/definition of a templated function (as opposed to a header file + source file). But this gets tricky when nesting templated function calls and trying to instantiate them with new types. Extern Templates While extern template might seem like a good idea, they will only save time on code generation, not parsing. If your templated function only need to support a finite number of fundamental types, moving their definition into a separate source file will save you the additional parsing overhead and avoid header pollution.","title":"After"},{"location":"dev/speeding-up-compilation/#limit-header-pollution","text":"Remember that a large portion of a compiler's time is spent parsing headers. STL headers in particular will have various impact on compilation times. Some headers like <type_traits> will have a minimal overhead, while <filesystem> or <regex> can take more than 200ms to parse on a powerful machine. See this website for detailed statistics on all STL headers. To limit compilation overhead due to header parsing, you can do the following: Profile your compilation times to find out which header takes the most time to parse. Separate your code between source and header files. Move header includes to the .cpp if they are not needed in the .h. Separate expensive headers from cheap-but-commonly-used ones, and only include what you need. Avoid having a all.h or common.h that include all headers from your library. This may seem convenient, but will increase compilation times for your users. Use forward declarations to avoid pulling expensive headers. Use the PIMPL idiom to hide implementation details from header files of a class. Forward Declarations And Pass-By-Value I was surprised to learn that you can declare a function taking a forward declared class as a by-value argument and as a result. I.e. this works just fine: class type ; type function ( type ); Forward Declarations And Circular Dependencies The Google C++ Style Guide cautions against using forward declarations whenever possible. Forward declaration can hide circular dependencies which should be a red flag in your code architecture. My advice would be to use them sparingly when it makes sense, and measure the performance impact on your project when possible.","title":"Limit Header Pollution"},{"location":"dev/speeding-up-compilation/#the-pimpl-idiom","text":"TL;DR Use valuable::value_ptr<> or spimpl::impl_ptr<> . When defining a class in C++, the types of its member variables need to be known, as the compiler needs to determine the size of the object. However, sometimes we have private member variables whose type do not need to be exposed in the class header. Their type is an implementation detail, and we do not want to expose the additional dependency. The PIMPL idiom (Pointer to IMPLementation) is a technique to hide this implementation detail, such that the underlying types used in a class are not exposed in the class header. Of course there is a small price to pay. In most cases this means an extra heap allocation and pointer indirection. Oftentimes the trade-off is worth it, but this depends on your specific use case. There are several ways to implement a PIMPL in your code (from bad to good): [Bad] Use a raw T * m_foo; member variable and forward-declare T . But this is bad because there is no lifetime management (when the encapsulating class is destroyed/moved/copied, etc.). class HiddenType ; class Bar { protected : // No lifetime management = bad HiddenType * m_foo ; }; [Not Great] Use a std::unique_ptr<T> m_foo . This would work, but there are two problems with that. The std::unique_ptr<> needs to know how to destroy the object, so you need to define the encapsulating class destructor in the .cpp source file, or you would be forced to pull <HiddenType.h> in <Bar.h> . Bar.h Bar.cpp class HiddenType ; class Bar { ~ Bar (); protected : std :: unique_ptr < HiddenType > m_foo ; }; #include <HiddenType.h> // The destructor needs to know HiddenType Bar ::~ Bar () = default ; You lose value semantics on the encapsulating type. I.e. you can no longer copy the object easily, just move it. [Not Great] Use a std::shared_ptr<T> m_foo . This has the same issues as the std::unique_ptr<> solution. You lose value semantics, but you may also incur additional bugs due to the shared ownership of the hidden object (e.g. in case a copy of Bar is created). [Good] Use a thin-wrapper around std::unique_ptr<> that provides copy/value semantics. Here are some readily available single-file implementations: valuable::value_ptr<> (with accompanying blog post ). spimpl::impl_ptr<> very similar. Pointers & Const-Correctness When storing member variables that are pointers to data, you need to be very careful regarding const-correctness . #include <ExplicitType.h> class Bar { ~ Bar (); public : // Will compile, but this is NOT ok ExplicitType & get_foo_bad () const { return * m_foo ; } // Const accessors should return pointers/reference to _const_ data. const ExplicitType & get_foo_good () const { return * m_foo ; } // This is a const method, so it should return a pointer to a _const_ data. std :: shared_ptr < const ExplicitType > get_foo_ptr () const { return m_foo ; } protected : std :: shared_ptr < ExplicitType > m_foo ; }; Example An example usage of the PIMPL idiom in Lagrange is the AttributeManager class in SurfaceMesh.h .","title":"The PIMPL idiom"},{"location":"dev/speeding-up-compilation/#x-macro-trick-for-explicit-instantiations","text":"Repeating explicit template instantiations for various types can be a tedious task. It makes code lengthy, hard to read and hard to extend when adding new types/functions to your codebase. Fortunately we can use a cool preprocessor trick known as X macros to iterate over a list of types and generate a list of explicit template instantiation for various classes/functions. While you could use the Boost Preprocessing library and macros such as BOOST_PP_SEQ_FOR_EACH , you can also roll out your own solution, which requires very little code and is easy to understand. The basic idea is as follows: Attribute.h AttributeTypes.h Attribute.cpp #pragma once #include <vector> \u200b namespace mylib { template < typename T > struct Attribute { void some_method (); std :: vector < T > m_data ; }; } // namespace mylib #pragma once // Define the X macro arguments here (= the list of types to instantiate) #define MYLIB_ATTRIBUTE_X(mode, data) \\ MYLIB_X_##mode(data, int8_t) \\ MYLIB_X_##mode(data, int16_t) \\ MYLIB_X_##mode(data, int32_t) \\ MYLIB_X_##mode(data, int64_t) \\ MYLIB_X_##mode(data, uint8_t) \\ MYLIB_X_##mode(data, uint16_t) \\ MYLIB_X_##mode(data, uint32_t) \\ MYLIB_X_##mode(data, uint64_t) \\ MYLIB_X_##mode(data, float) \\ MYLIB_X_##mode(data, double) #include <mylib/Attribute.h> namespace mylib { template < typename T > void Attribute < T >:: some_method () { // do something } // Explicit template instantiation using X macros #include <mylib/AttributeTypes.h> #define MYLIB_X_attr_class(_, T) template class Attribute<T>; MYLIB_ATTRIBUTE_X ( attr_class , 0 ) #undef MYLIB_X_attr_class } // namespace mylib Macro Cleanup There is no need to #undef MYLIB_X_attr_class at the end of Attribute.cpp , since the macro is usually defined at the end of a .cpp file. But if you are planning on doing Unity builds and are not using unique names for your macro, then it is a good idea to do so. The above solution works well for a single list of types to instantiate. But what if we are mixing functions that depend on two different types U and T ? This is where the extra parameter data comes in. You can think of it as a continuation parameter to recursively instantiate nested type lists. Here is an concrete example: Header.h Types.h Source.cpp #pragma once #include <vector> template < typename T > struct Attribute { void some_method (); std :: vector < T > m_data ; }; template < typename Scalar > struct Mesh { std :: vector < Scalar > m_vertices ; }; template < size_t Dim > struct Volume { size_t m_volume = Dim ; }; template < typename T , typename Scalar > void set_attribute ( Mesh < Scalar > & mesh , const Attribute < T > & attr ); template < typename T , typename Scalar , size_t D > void set_volume ( Mesh < Scalar > & mesh , const Attribute < T > & attr , Volume < D > & vol ); #pragma once // Define the X macro arguments for each type list #define MYLIB_ATTRIBUTE_X(mode, data) \\ MYLIB_X_##mode(data, int8_t) \\ MYLIB_X_##mode(data, int16_t) \\ MYLIB_X_##mode(data, int32_t) \\ MYLIB_X_##mode(data, int64_t) \\ MYLIB_X_##mode(data, uint8_t) \\ MYLIB_X_##mode(data, uint16_t) \\ MYLIB_X_##mode(data, uint32_t) \\ MYLIB_X_##mode(data, uint64_t) \\ MYLIB_X_##mode(data, float) \\ MYLIB_X_##mode(data, double) #define MYLIB_MESH_X(mode, data) \\ MYLIB_X_##mode(data, double) \\ MYLIB_X_##mode(data, float) #define MYLIB_VOL_X(mode, data) \\ MYLIB_X_##mode(data, 2) \\ MYLIB_X_##mode(data, 3) #include \"Header.h\" #include \"Types.h\" // Method/function definitions in the source file template < typename T > void Attribute < T >:: some_method () { // do something } \u200b template < typename T , typename Scalar > void set_attribute ( Mesh < Scalar > & mesh , const Attribute < T > & attr ) { // do something } \u200b template < typename T , typename Scalar , size_t D > void set_volume ( Mesh < Scalar > & mesh , const Attribute < T > & attr , Volume < D > & vol ) { // do something } // Explicit instantiation \u200b // 1. Simple type lists (Attribute<> and Mesh<> classes) #define MYLIB_X_attr_class(_, T) template class Attribute<T>; MYLIB_ATTRIBUTE_X ( attr_class , 0 ) \u200b #define MYLIB_X_mesh_class(_, S) template class Mesh<S>; MYLIB_MESH_X ( mesh_class , 0 ) \u200b // 2. Cartesian product with two types S x T #define MYLIB_X_attr_set(S, T) template void set_attribute(Mesh<S> &mesh, const Attribute<T> &attr); #define MYLIB_X_mesh_set(_, S) MYLIB_ATTRIBUTE_X(attr_set, S) \u200b MYLIB_MESH_X ( mesh_set , 0 ) \u200b // 3. Cartesian product with three types S x D x T. // We need to define helper macros to unpack argument tuples. #define fst(first, second) first #define snd(first, second) second #define MYLIB_X_attr_vol(SD, T) template void set_volume(Mesh<fst SD> &mesh, const Attribute<T> &attr, Volume<snd SD> &vol); #define MYLIB_X_mesh_vol(D, S) MYLIB_ATTRIBUTE_X(attr_vol, (S, D)) #define MYLIB_X_dim_vol(_, D) MYLIB_MESH_X(mesh_vol, D) \u200b MYLIB_VOL_X ( dim_vol , 0 )","title":"X Macro Trick For Explicit Instantiations"},{"location":"dev/unit-tests/","text":"Unit Tests Running Tests When LAGRANGE_UNIT_TESTS is ON , unit tests are built automatically. Running unit tests can be done either Option 1 From the command-line in your build folder: ctest # or make test # or ninja test Option 2 From Visual Studio or Xcode, by executing the special target RUN_TESTS : Visual Studio Xcode ![unit-tests-xcode](img/unit-tests-xcode.png ``` Debugging When running unit tests through CMake/CTest, logs for the last failed tests are available under <build>/Testing/Temporary/LastTestsFailed.log You can run tests individually, all test executables are located in the tests folder, e.g.: ./tests/test_lagrange_core Some tests are tagged [.slow] and skipped by default. If you wish to run them, you need to pass [slow] as an argument, or the name of a specific test, e.g.: ./tests/test_lagrange_core \"[slow]\" Running Individual Tests You can also run only your specific test case(s) by passing the name(s) as argument to the test executable. For more details on the available command-line options, please refer to this page of the Catch2 documentation. ) ./tests/test_lagrange_core \"MeshCreation\" Writing Unit Tests Writing new unit tests should be pretty straightforward. Please refer to the Catch2 documentation to get you started. However, there are some idiosyncrasies specifics to Lagrange: Unit test data is stored in a separate data repository . Assets are downloaded by CMake, and can be loaded via the convenience function lagrange::testing::load_mesh() : TEST_CASE ( \"thicken_and_close_mesh stanford-bunny\" , \"[mesh][thicken_and_close_mesh][stanford-bunny]\" ) { auto mesh = lagrange :: testing :: load_mesh < TriangleMesh3Df > ( \"open/core/stanford-bunny.obj\" ); REQUIRE (...); } If a test may be failing, e.g., because it is a work in progress, you may use the LA_MAYFAIL_FLAG tag. Contrary to Catch2's [!mayfail] , our LA_MAYFAIL_FLAG tag expands to an empty string when Lagrange is compiled during continuous integration, in order to avoid reporting false positives. TEST_CASE ( \"Constrained Quadratic Problem 0\" , \"[decimation]\" LA_MAYFAIL_FLAG ) { // ... } Writing Benchmarks Benchmarking code should be written alongside regular unit tests, and be tagged with the special flag [!benchmark] . Please read this page for detailed instructions regarding Catch2's benchmarking macros. By default, Catch2 runs benchmarks with 100 samples to produce accurate average timings. If your benchmark takes some time to run, you might want to use fewer samples.","title":"Unit Tests"},{"location":"dev/unit-tests/#unit-tests","text":"","title":"Unit Tests"},{"location":"dev/unit-tests/#running-tests","text":"When LAGRANGE_UNIT_TESTS is ON , unit tests are built automatically. Running unit tests can be done either Option 1 From the command-line in your build folder: ctest # or make test # or ninja test Option 2 From Visual Studio or Xcode, by executing the special target RUN_TESTS : Visual Studio Xcode ![unit-tests-xcode](img/unit-tests-xcode.png ```","title":"Running Tests"},{"location":"dev/unit-tests/#debugging","text":"When running unit tests through CMake/CTest, logs for the last failed tests are available under <build>/Testing/Temporary/LastTestsFailed.log You can run tests individually, all test executables are located in the tests folder, e.g.: ./tests/test_lagrange_core Some tests are tagged [.slow] and skipped by default. If you wish to run them, you need to pass [slow] as an argument, or the name of a specific test, e.g.: ./tests/test_lagrange_core \"[slow]\" Running Individual Tests You can also run only your specific test case(s) by passing the name(s) as argument to the test executable. For more details on the available command-line options, please refer to this page of the Catch2 documentation. ) ./tests/test_lagrange_core \"MeshCreation\"","title":"Debugging"},{"location":"dev/unit-tests/#writing-unit-tests","text":"Writing new unit tests should be pretty straightforward. Please refer to the Catch2 documentation to get you started. However, there are some idiosyncrasies specifics to Lagrange: Unit test data is stored in a separate data repository . Assets are downloaded by CMake, and can be loaded via the convenience function lagrange::testing::load_mesh() : TEST_CASE ( \"thicken_and_close_mesh stanford-bunny\" , \"[mesh][thicken_and_close_mesh][stanford-bunny]\" ) { auto mesh = lagrange :: testing :: load_mesh < TriangleMesh3Df > ( \"open/core/stanford-bunny.obj\" ); REQUIRE (...); } If a test may be failing, e.g., because it is a work in progress, you may use the LA_MAYFAIL_FLAG tag. Contrary to Catch2's [!mayfail] , our LA_MAYFAIL_FLAG tag expands to an empty string when Lagrange is compiled during continuous integration, in order to avoid reporting false positives. TEST_CASE ( \"Constrained Quadratic Problem 0\" , \"[decimation]\" LA_MAYFAIL_FLAG ) { // ... }","title":"Writing Unit Tests"},{"location":"dev/unit-tests/#writing-benchmarks","text":"Benchmarking code should be written alongside regular unit tests, and be tagged with the special flag [!benchmark] . Please read this page for detailed instructions regarding Catch2's benchmarking macros. By default, Catch2 runs benchmarks with 100 samples to produce accurate average timings. If your benchmark takes some time to run, you might want to use fewer samples.","title":"Writing Benchmarks"},{"location":"dev/visualstudio-wsl/","text":"Building Lagrange with GCC Clang in Visual Studio via WSL System Preparation Install WSL (Windows Subsystem For Linux) Detailed instructions here . In short, Run Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux in PowerShell as administrator Restart computer Go to Microsoft Store, search for Ubuntu or other distro and install it. (tested Ubuntu 20 LTS) Install Unix Libraries Start Ubuntu (found in Start menu) To enable Visual Studio - WSL integration sudo apt install g++ gdb make rsync zip For clang, run also sudo apt install clang More details here . If building UI, install further dependencies sudo apt-get install libglu1-mesa-dev freeglut3-dev mesa-common-dev build-essential libgtk-3-dev xorg-dev Install CMake Visual Studio can install CMake for you automatically (a popup will appear) and it will install it into $HOME/.vs/cmake/bin/cmake However, to make sure FetchContent works with direct URL downloads, it seems you have to install CMake into Ubuntu directly via: sudo apt-get install cmake You will have to switch the CMake executable option in CMakeSettings.json (under Advanced) to /usr/bin/cmake or wherever your apt-get installs cmake . Modify Visual Studio Installation Go to Add or Remove Programs -> Visual Studio Installer -> Modify Select your installation More -> Modify Enable Linux development with C++ and update Update to latest Visual Studio version for best results. Install SSH Keys Install keychain sudo apt-get install keychain You can copy your windows id_rsa key to ~/.ssh/ or generate a new one Add this line to .bashrc: eval \\`keychain --agents ssh --eval id_rsa\\` Make sure ~/.ssh/id_rsa has chmod 0600 Build Lagrange Configuration Clone the repository Open Visual Studio -> File -> Open Folder -> Open Folder lagrange root folder Click on Open the CMake Settings Editor Click on the plus icon, select WSL-Debug or WSL-Release (this will build with GCC) Ctrl + S or save the file to run CMake In the CmakeSettings.json editor, you'll be able to select which lagrange modules to build Save the config file again to generate the project Selecting Targets Solution explorer has two views 1. File hierarchy 2. CMake Targets View Switch to CMake Targets View , navigate to target you want to build, right click Set as Startup Item and build. Controlling Configuration Step CMake will run automatically when cache is invalidated. To prevent that go to Tools -> Options -> CMake -> When cache is out of date and select your preferred option. If you want to trigger configuration step manually, in Cmake Targets View right click Lagrange Project and select Generate Cache Terminal Go to Debug -> Linux Console to see the linux terminal. Bonus: Running UI Window from WSL Note: WSL does not support GPU rendering, UI will be rendered through software driver - therefore it's quite slow. In particular, IBL generation is slow so setting Viewer::WindowOptions::default_ibl = \"\" is recommended. Download and run MobaXTerm (https://mobaxterm.mobatek.net/download.html), go to X Server -> Start X Server (other alternatives like Xming use older GLX version) To test if it works, Run export DISPLAY=:0 and then sudo apt install mesa-utils and run glxgears OpenCmakeSettings.json in the lagrange project and add this before configurations : \"environments\": [ { \"DISPLAY\": \":0\" } ], Build and run UI examples More resources Pure Virtual C++ 2020 (WSL specific session starts at 2:06:00) C++ with Visual Studio 2019 and Windows Subsystem for Linux (WSL) CMake projects in Visual Studio Launch.vs.json reference for remote projects and WSL","title":"VisualStudio and WSL"},{"location":"dev/visualstudio-wsl/#building-lagrange-with-gcc-clang-in-visual-studio-via-wsl","text":"","title":"Building Lagrange with GCC Clang in Visual Studio via WSL"},{"location":"dev/visualstudio-wsl/#system-preparation","text":"","title":"System Preparation"},{"location":"dev/visualstudio-wsl/#install-wsl-windows-subsystem-for-linux","text":"Detailed instructions here . In short, Run Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux in PowerShell as administrator Restart computer Go to Microsoft Store, search for Ubuntu or other distro and install it. (tested Ubuntu 20 LTS)","title":"Install WSL (Windows Subsystem For Linux)"},{"location":"dev/visualstudio-wsl/#install-unix-libraries","text":"Start Ubuntu (found in Start menu) To enable Visual Studio - WSL integration sudo apt install g++ gdb make rsync zip For clang, run also sudo apt install clang More details here . If building UI, install further dependencies sudo apt-get install libglu1-mesa-dev freeglut3-dev mesa-common-dev build-essential libgtk-3-dev xorg-dev","title":"Install Unix Libraries"},{"location":"dev/visualstudio-wsl/#install-cmake","text":"Visual Studio can install CMake for you automatically (a popup will appear) and it will install it into $HOME/.vs/cmake/bin/cmake However, to make sure FetchContent works with direct URL downloads, it seems you have to install CMake into Ubuntu directly via: sudo apt-get install cmake You will have to switch the CMake executable option in CMakeSettings.json (under Advanced) to /usr/bin/cmake or wherever your apt-get installs cmake .","title":"Install CMake"},{"location":"dev/visualstudio-wsl/#modify-visual-studio-installation","text":"Go to Add or Remove Programs -> Visual Studio Installer -> Modify Select your installation More -> Modify Enable Linux development with C++ and update Update to latest Visual Studio version for best results.","title":"Modify Visual Studio Installation"},{"location":"dev/visualstudio-wsl/#install-ssh-keys","text":"Install keychain sudo apt-get install keychain You can copy your windows id_rsa key to ~/.ssh/ or generate a new one Add this line to .bashrc: eval \\`keychain --agents ssh --eval id_rsa\\` Make sure ~/.ssh/id_rsa has chmod 0600","title":"Install SSH Keys"},{"location":"dev/visualstudio-wsl/#build-lagrange","text":"","title":"Build Lagrange"},{"location":"dev/visualstudio-wsl/#configuration","text":"Clone the repository Open Visual Studio -> File -> Open Folder -> Open Folder lagrange root folder Click on Open the CMake Settings Editor Click on the plus icon, select WSL-Debug or WSL-Release (this will build with GCC) Ctrl + S or save the file to run CMake In the CmakeSettings.json editor, you'll be able to select which lagrange modules to build Save the config file again to generate the project","title":"Configuration"},{"location":"dev/visualstudio-wsl/#selecting-targets","text":"Solution explorer has two views 1. File hierarchy 2. CMake Targets View Switch to CMake Targets View , navigate to target you want to build, right click Set as Startup Item and build.","title":"Selecting Targets"},{"location":"dev/visualstudio-wsl/#controlling-configuration-step","text":"CMake will run automatically when cache is invalidated. To prevent that go to Tools -> Options -> CMake -> When cache is out of date and select your preferred option. If you want to trigger configuration step manually, in Cmake Targets View right click Lagrange Project and select Generate Cache","title":"Controlling Configuration Step"},{"location":"dev/visualstudio-wsl/#terminal","text":"Go to Debug -> Linux Console to see the linux terminal.","title":"Terminal"},{"location":"dev/visualstudio-wsl/#bonus-running-ui-window-from-wsl","text":"Note: WSL does not support GPU rendering, UI will be rendered through software driver - therefore it's quite slow. In particular, IBL generation is slow so setting Viewer::WindowOptions::default_ibl = \"\" is recommended. Download and run MobaXTerm (https://mobaxterm.mobatek.net/download.html), go to X Server -> Start X Server (other alternatives like Xming use older GLX version) To test if it works, Run export DISPLAY=:0 and then sudo apt install mesa-utils and run glxgears OpenCmakeSettings.json in the lagrange project and add this before configurations : \"environments\": [ { \"DISPLAY\": \":0\" } ], Build and run UI examples","title":"Bonus: Running UI Window from WSL"},{"location":"dev/visualstudio-wsl/#more-resources","text":"Pure Virtual C++ 2020 (WSL specific session starts at 2:06:00) C++ with Visual Studio 2019 and Windows Subsystem for Linux (WSL) CMake projects in Visual Studio Launch.vs.json reference for remote projects and WSL","title":"More resources"},{"location":"dev/vscode/","text":"VSCode Tips and Tricks Recommended Extensions Syntax Highlighting C/C++ Themes CMake Python Rainbow CSV Theming VScode Icons Readability Extension Pack Better C++ Syntax Tools Clang-format CMake Tools Documentation Code Spell Checker Doxygen Documentation Generator Settings Settings Sync Sublime Text Keymap and Settings Importer","title":"VSCode Tips and Tricks"},{"location":"dev/vscode/#vscode-tips-and-tricks","text":"","title":"VSCode Tips and Tricks"},{"location":"dev/vscode/#recommended-extensions","text":"Syntax Highlighting C/C++ Themes CMake Python Rainbow CSV Theming VScode Icons Readability Extension Pack Better C++ Syntax Tools Clang-format CMake Tools Documentation Code Spell Checker Doxygen Documentation Generator Settings Settings Sync Sublime Text Keymap and Settings Importer","title":"Recommended Extensions"},{"location":"user/core/attributes/","text":"Mesh Attributes Attention Since v6.0.0, Lagrange introduced a new polygonal mesh class that is meant to replace the original mesh class used throughout Lagrange. While currently few of the Lagrange functions use this new mesh class, over time old and new features will transition to use this new data structure. Mesh attributes are buffers of data associated to a mesh element. They are characterized by the following: Name : A string that uniquely identifies the attribute in the mesh, irrespectively of which mesh element it is associated to. Id : A 32bit unsigned integer that uniquely identifies the attribute in the mesh. Ids are assigned at attribute creation and will not be invalidated if other attributes are removed/created. Value Type : Value type of the data being stored in the attribute. We only support fixed-sized integer and floating point types. Supported Value Types (Click to expand) int8_t int16_t int32_t int64_t uint8_t uint16_t uint32_t uint64_t float double Element : Type of mesh element the attribute is associated to. It can be one of the following: AttributeElement Description Vertex Attribute associated to mesh vertices (e.g., positions). Facet Attribute associated to mesh facets. Edge Attribute associated to mesh edges. Corner Attribute associated to mesh facet corners (e.g. vertex indices). Value Attribute that is not associated to any mesh element (arbitrary size). Indexed A pair of ( Corner , Value ) attributes, where the corner attribute is an index into the value attribute buffer (e.g. a UV). Automatic Resizing Vertex , Facet , Edge and Corner attributes are resized accordingly to their respective mesh element when inserting/removing vertices/facets, while a Value attribute is never resized automatically. Usage : A usage tag is an optional tag that can be used to determine how attribute values are affected by other mesh operations. See the reference documentation for a list of available usage tags. Example When applying a rigid transform \\(M\\) to a mesh, attributes with the Normal tag will be transformed according to \\(M^{-T}\\) . Similarly, when removing mesh vertices, attributes with the VertexIndex tag will be remapped accordingly. Channels : Number of channels for each mesh element in the attribute. The number of possible channels for an attribute is restricted by the attribute usage tag. Example An attribute with the VertexIndex tag must have a single channel, while attributes with the Color tag can have between 1 and 4 channels. Attribute Creation To create a new attribute and return its id: lagrange :: SurfaceMesh < Scalar , Index > mesh ; // Minimal version only requires name + element type. auto id0 = mesh . create_attribute < double > ( \"color\" , lagrange :: AttributeElement :: Corner ); // Optionally specify usage tag + num channels. auto id1 = mesh . create_attribute < float > ( \"normals\" , lagrange :: AttributeElement :: Vertex , lagrange :: AttributeUsage :: Normal , 3 ); // View attribute as a Eigen::Map<const ...> auto attr_matrix = matrix_view ( mesh . get_attribute < float > ( id1 )); Accessing Attribute Values lagrange :: SurfaceMesh < Scalar , Index > mesh ; // ... // Returns a const Attribute<T> & auto & attr = mesh . get_attribute < Scalar > ( \"normals\" ); // Alternative: use id to retrieve attr (avoids a hash map lookup) auto attr_id = mesh . get_attribute_id ( \"normals\" ); auto & attr2 = mesh . get_attribute < Scalar > ( attr_id ); // Wrap as an Eigen matrix as usual auto attr_matrix = matrix_view ( attr ); Using Attribute Ids Using the attribute id instead of its name avoids a std::string -> uint32_t lookup. Since attribute ids are guaranteed to not be invalidated, you may also store it in your application (e.g. UI menus, etc.). Disabled Implicit Copies It is important to note that implicit copies of an Attribute object is forbidden. Since Attribute buffers have value semantics (like std::vector<> ), storing the result of mesh.get_attribute<>() in a auto attr variable would lead to an implicit copy. For this reason, the following code will not compile and produce an error: // The following will NOT compile (Attribute copy is explicit) // auto attr3 = mesh.get_attribute<float>(\"normals\"); Copy-on-write handling of attribute buffers is done at the mesh level, i.e. when copying a SurfaceMesh object, or when calling methods such as SurfaceMesh::duplicate_attribute() . Iterating Over Mesh Attributes In many situation, it is desirable to iterate over existing mesh attributes to extract some information, or process existing attributes. We provide utility functions to iterate over existing mesh attributes, with additional filtering based on element types. Basic example: #include <lagrange/foreach_attribute.h> #include <lagrange/Logger.h> lagrange :: SurfaceMesh < Scalar , Index > mesh ; // ... // Iterate over each attribute sequentially seq_foreach_attribute_read ( mesh , []( auto && attr ) { lagrange :: logger (). info ( \"Attribute with {} channels\" , attr . get_num_channels ()); }); // Same, but retrieves attribute names while iterating seq_foreach_named_attribute_read ( mesh , [ & ]( std :: string_view name , auto && attr ) { lagrange :: logger (). info ( \"Attribute named '{}' with {} channels\" , name , attr . get_num_channels ()); }); Iterator functions follow the same naming convention, with variations being as follows: Variation Description seq vs par Iterate sequentially or in parallel over available mesh attributes. named vs unnamed Whether to pass attribute names to the callback function . read vs write Whether read-only or writable references to the attributes are required. See reference documentation for additional details. Inferring Value Type Since we use generic lambda to iterate over attributes of different types, it is possible to deduce the value type of the current attribute in the following manner: lagrange :: SurfaceMesh < Scalar , Index > mesh ; // ... seq_foreach_attribute_read ( mesh , []( auto && attr ) { // Retrieve the attribute value type within the lambda using AttributeType = std :: decay_t < decltype ( attr ) > ; using ValueType = typename AttributeType :: ValueType ; lagrange :: logger (). info ( \"Attribute value type size: {}\" , sizeof ( ValueType )); }); Filtering Element Types Since indexed attributes have a different interface from non-indexed attributes, it is often necessary to use two different code path when iterating over mesh attributes. Fortunately, it is possible to do so concisely thanks to C++17's if constexpr() , like so: lagrange :: SurfaceMesh < Scalar , Index > mesh ; // ... // Use compile-time if to check for indexed attributes seq_foreach_named_attribute_read ( mesh , []( std :: string_view name , auto && attr ) { using AttributeType = std :: decay_t < decltype ( attr ) > ; if constexpr ( AttributeType :: IsIndexed ) { lagrange :: logger (). info ( \"Indexed attribute '{}' with {} values\" , name , attr . values (). get_num_elements ()); } else { lagrange :: logger (). info ( \"Non-indexed attribute '{}' with {} elements\" , name , attr . get_num_elements ()); } }); Alternatively, one can provide an optional template argument to the foreach function to iterate over a specific element type: lagrange :: SurfaceMesh < Scalar , Index > mesh ; // ... // Iterate over non-indexed attributes lagrange :: seq_foreach_named_attribute_read <~ lagrange :: AttributeElement :: Indexed > ( mesh , [ & ]( std :: string_view name , auto && attr ) { lagrange :: logger (). info ( \"Attribute named '{}' with {} elements\" , name , attr . get_num_elements ()); }); // Iterate over indexed attributes only lagrange :: seq_foreach_attribute_read < lagrange :: AttributeElement :: Indexed > ( mesh , []( auto && attr ) { using AttributeType = std :: decay_t < decltype ( attr ) > ; using ValueType = typename AttributeType :: ValueType ; using Index = typename AttributeType :: Index ; lagrange :: logger (). info ( \"Indexed attribute using value type size {} and index size {}\" , sizeof ( ValueType ), sizeof ( Index )); }); Argument-Dependent Lookup With this variant, ADL no longer work, so you need to explicitly call lagrange::seq_foreach_attribute_read(mesh, ...) rather than seq_foreach_attribute_read(mesh, ...) . Finally, it is possible to combine template argument filters via bitwise boolean operations: lagrange :: SurfaceMesh < Scalar , Index > mesh ; // ... // Iterate over vertex, facet and corner attributes: lagrange :: seq_foreach_attribute_read < lagrange :: AttributeElement :: Vertex | lagrange :: AttributeElement :: Facet | lagrange :: AttributeElement :: Corner > ( mesh , [ & ]( auto && attr ) { lagrange :: logger (). info ( \"Non-indexed attribute with {} elements\" , attr . get_num_elements ()); }); A Note On Thread-Safety The following operations are safe to do in parallel: Writing to two separate mesh attributes pointing to the same buffer (a deep copy will be created). The following operations are not safe to do in parallel: Writing to an attribute while creating other mesh attributes. Adding elements to a mesh while writing to another attribute of the same mesh. From a practical standpoint, copy-on-write attributes behave as if each mesh owns its own std::vector<> for each attribute. Adding an element to a mesh would resize the corresponding mesh attributes, making concurrent writes unsafe. Creating new mesh attributes will move existing mesh attributes, making concurrent writes also unsafe. Note that if two meshes are shallow copies of each other, it is perfectly safe to add elements to each of them concurrently. The same goes for writing in parallel to mesh attributes that are duplicates of each others: each attribute behaves as if it owns its own copy of the data. Temporary Copy On Concurrent Writes While concurrent writing to mesh attributes is a thread-safe operation, note that it may sometimes create an unnecessary temporary copy of the data. To avoid this, we would need to block every write operation with a mutex, which would involve an expensive context switch . Instead, we simply rely on the atomic counter from the shared_ptr<> to decide whether to copy/acquire ownership of the data. While this is a thread-safe operation, it may create a temporary copy of the data. Wrapping External Buffers A key feature of our attribute system is the possibility to easily wrap external buffer and treat them as regular mesh attributes, avoiding any data copy. As long as the data layout is compatible, you will be able to wrap a continuous buffer as a mesh attribute and pass it around. lagrange :: SurfaceMesh < Scalar , Index > mesh ; mesh . add_vertices ( 10 ); Index num_verts = mesh . get_num_vertices (); Index num_coords = mesh . get_dimension (); // Create a flat buffer to use as external attribute data std :: vector < Scalar > normals ( num_verts * num_coords ); // Wrap external buffer as a read-write attribute mesh . wrap_as_attribute < Scalar > ( \"normals\" , lagrange :: AttributeElement :: Vertex , lagrange :: AttributeUsage :: Normal , num_coords , normals ); // Retrieves a Eigen::Map<> view of the attribute auto N = lagrange :: attribute_matrix_ref < Scalar > ( mesh , \"normals\" ); // Check that all coordinates are finite (no inf/nan). assert ( N . allFinite ()); Sometimes, it is necessary to wrap a pointer to a const buffer, to ensure the external buffer will not be be written to: // Wrap external buffer as a read-only attribute const Scalar * const_normals = normals . data (); mesh . wrap_as_const_attribute < Scalar > ( \"const_normals\" , lagrange :: AttributeElement :: Vertex , lagrange :: AttributeUsage :: Normal , num_coords , { const_normals , normals . size ()}); // Non-const methods on the normal attr will throw an error mesh . ref_attribute < Scalar > ( \"const_normals\" ). ref_all (); // --> throws an exception Non-Const Access The following code does not throw an exception: auto & attr = mesh . ref_attribute < Scalar > ( \"const_normals\" ); This is because while attr is a writable reference to the attribute \"const_normals\" , the user could decide to update the attribute itself to wrap another non-const buffer (via attr.wrap(...) ). Only methods which provide write access to the actual buffer data (such as attr.ref_all() ) will throw an exception. Alternatively, instead of implicitly converting to a span<> , you can explicitly pass a span<> object and let the compiler deduce the Scalar type template argument: // Pass a `span<>` object directly to let the compiler deduce the template value type mesh . wrap_as_const_attribute ( \"normals\" , lagrange :: AttributeElement :: Vertex , lagrange :: AttributeUsage :: Normal , num_coords , lagrange :: span < const Scalar > ( normals )); Lifetime Management Our API assumes that the external buffer remains valid for the lifetime of the mesh object wrapping the external data. We do not pass any counter, smart pointer or custom deleter function that would allow to track or keep alive the external data. This is because most of the time we just need to create a Lagrange Mesh wrapping an existing buffer, process it with Lagrange, and extract the results. If more advanced lifetime management is desirable, please let us know. Delete And Export Attributes To delete an attribute, simply call the eponymous method: lagrange :: SurfaceMesh < Scalar , Index > mesh ; // ... // Delete attribute mesh . delete_attribute ( \"normals\" ); More interestingly, the attribute itself can be exported into a std::shared_ptr<Attribute<T>> that can be handed back to the user. This allows client code to reuse the attribute data after the destruction of any mesh object that was containing the attribute: only the std::shared_ptr<Attribute<T>> needs to be kept alive. // Delete and export a std::shared_ptr<Attribute<T>> auto attr_ptr = mesh . delete_and_export_attribute < Scalar > ( \"normals\" ); // Pass a raw pointer/span to the attribute data back to client code auto data_ptr = attr_ptr -> ref_all (). data (); Reserved Attribute Names We use the convention that attribute names starting with \"$\" are reserved for internal use by the mesh class. For example, $vertex_to_position and $corner_to_vertex are used for vertex positions and facet indices respectively. The list of available internal attributes and their names is subject to future changes. Attribute Policies Policies can be used to control the behavior when manipulating attributes that wraps external buffers, creating/deleting attributes with reserved names, etc. Policies are runtime properties that need to be set for each attribute separately. They are copied over when an attribute is duplicated via our copy-on-write mechanism. Create Policy Controls the behavior when creating an attribute with a reserved name (starting with $ ). The default is to throw an exception. See reference documentation for more details. Growth Policy Controls the behavior when adding element to an attribute that wrap an external buffer. The default behavior is to throw an exception. See reference documentation for more details. Index dim = 3 ; Index num_vertices = 10 ; lagrange :: SurfaceMesh < Scalar , Index > mesh ( dim ); // Define external buffer std :: vector < Scalar > buffer ( 2 * num_vertices * dim ); // ... fill buffer with values ... // Wrap external buffer AND resize num of vertices mesh . wrap_as_vertices ( buffer , num_vertices ); // Writable reference to vertex position attribute auto & attr = mesh . ref_vertex_to_position (); // Set growth attribute policy attr . set_growth_policy ( lagrange :: AttributeGrowthPolicy :: ErrorIfExternal ); attr . set_growth_policy ( lagrange :: AttributeGrowthPolicy :: AllowWithinCapacity ); attr . set_growth_policy ( lagrange :: AttributeGrowthPolicy :: WarnAndCopy ); // Inserting more vertices might throw an error, depending on the policy mesh . add_vertices ( 5 ); Write Policy Controls the behavior when providing writable access to an attribute wrapping a const external buffer. The default behavior is to throw an exception. See reference documentation for more details. Index dim = 3 ; Index num_vertices = 10 ; lagrange :: SurfaceMesh < Scalar , Index > mesh ( dim ); // Define external buffer const size_t num_channels = 3 ; std :: vector < Scalar > buffer ( mesh . get_num_vertices () * num_channels ); // ... fill buffer with values ... // Wrap external buffer as read-only attribute auto id = mesh . wrap_as_const_attribute < Scalar > ( \"normals\" , lagrange :: AttributeElement :: Vertex , lagrange :: AttributeUsage :: Normal , num_channels , buffer ); auto & attr = mesh . ref_attribute < Scalar > ( id ); // Set write policy for read-only attributes attr . set_write_policy ( lagrange :: AttributeWritePolicy :: ErrorIfReadOnly ); attr . set_write_policy ( lagrange :: AttributeWritePolicy :: WarnAndCopy ); // Write access to the attribute might throw depending on policy attr . ref ( 0 ) = 3.14 ; Delete Policy Controls the behavior when deleting an attribute with a reserved name. The default behavior is to throw an exception. See reference documentation for more details. Export Policy Controls the behavior when exporting an attribute wrapping an external buffer. The default behavior is to create an internal copy to ensure lifetime of the data is preserved. See reference documentation for more details. Index dim = 3 ; Index num_vertices = 10 ; lagrange :: SurfaceMesh < Scalar , Index > mesh ( dim ); // Define external buffer const size_t num_channels = 3 ; std :: vector < Scalar > buffer ( mesh . get_num_vertices () * num_channels ); // ... fill buffer with values ... // Wrap external buffer as read-only attribute auto id = mesh . wrap_as_const_attribute < Scalar > ( \"normals\" , lagrange :: AttributeElement :: Vertex , lagrange :: AttributeUsage :: Normal , num_channels , buffer ); // Delete and export might create an internal copy depending on policy using namespace lagrange ; auto attr_ptr1 = mesh . delete_and_export_attribute < Scalar > ( \"normals\" , AttributeDeletePolicy :: ErrorIfReserved , AttributeExportPolicy :: CopyIfExternal ); auto attr_ptr2 = mesh . delete_and_export_attribute < Scalar > ( \"normals\" , AttributeDeletePolicy :: ErrorIfReserved , AttributeExportPolicy :: ErrorIfExternal ); auto attr_ptr3 = mesh . delete_and_export_attribute < Scalar > ( \"normals\" , AttributeDeletePolicy :: ErrorIfReserved , AttributeExportPolicy :: KeepExternalPtr );","title":"Mesh Attributes"},{"location":"user/core/attributes/#mesh-attributes","text":"Attention Since v6.0.0, Lagrange introduced a new polygonal mesh class that is meant to replace the original mesh class used throughout Lagrange. While currently few of the Lagrange functions use this new mesh class, over time old and new features will transition to use this new data structure. Mesh attributes are buffers of data associated to a mesh element. They are characterized by the following: Name : A string that uniquely identifies the attribute in the mesh, irrespectively of which mesh element it is associated to. Id : A 32bit unsigned integer that uniquely identifies the attribute in the mesh. Ids are assigned at attribute creation and will not be invalidated if other attributes are removed/created. Value Type : Value type of the data being stored in the attribute. We only support fixed-sized integer and floating point types. Supported Value Types (Click to expand) int8_t int16_t int32_t int64_t uint8_t uint16_t uint32_t uint64_t float double Element : Type of mesh element the attribute is associated to. It can be one of the following: AttributeElement Description Vertex Attribute associated to mesh vertices (e.g., positions). Facet Attribute associated to mesh facets. Edge Attribute associated to mesh edges. Corner Attribute associated to mesh facet corners (e.g. vertex indices). Value Attribute that is not associated to any mesh element (arbitrary size). Indexed A pair of ( Corner , Value ) attributes, where the corner attribute is an index into the value attribute buffer (e.g. a UV). Automatic Resizing Vertex , Facet , Edge and Corner attributes are resized accordingly to their respective mesh element when inserting/removing vertices/facets, while a Value attribute is never resized automatically. Usage : A usage tag is an optional tag that can be used to determine how attribute values are affected by other mesh operations. See the reference documentation for a list of available usage tags. Example When applying a rigid transform \\(M\\) to a mesh, attributes with the Normal tag will be transformed according to \\(M^{-T}\\) . Similarly, when removing mesh vertices, attributes with the VertexIndex tag will be remapped accordingly. Channels : Number of channels for each mesh element in the attribute. The number of possible channels for an attribute is restricted by the attribute usage tag. Example An attribute with the VertexIndex tag must have a single channel, while attributes with the Color tag can have between 1 and 4 channels.","title":"Mesh Attributes"},{"location":"user/core/attributes/#attribute-creation","text":"To create a new attribute and return its id: lagrange :: SurfaceMesh < Scalar , Index > mesh ; // Minimal version only requires name + element type. auto id0 = mesh . create_attribute < double > ( \"color\" , lagrange :: AttributeElement :: Corner ); // Optionally specify usage tag + num channels. auto id1 = mesh . create_attribute < float > ( \"normals\" , lagrange :: AttributeElement :: Vertex , lagrange :: AttributeUsage :: Normal , 3 ); // View attribute as a Eigen::Map<const ...> auto attr_matrix = matrix_view ( mesh . get_attribute < float > ( id1 ));","title":"Attribute Creation"},{"location":"user/core/attributes/#accessing-attribute-values","text":"lagrange :: SurfaceMesh < Scalar , Index > mesh ; // ... // Returns a const Attribute<T> & auto & attr = mesh . get_attribute < Scalar > ( \"normals\" ); // Alternative: use id to retrieve attr (avoids a hash map lookup) auto attr_id = mesh . get_attribute_id ( \"normals\" ); auto & attr2 = mesh . get_attribute < Scalar > ( attr_id ); // Wrap as an Eigen matrix as usual auto attr_matrix = matrix_view ( attr ); Using Attribute Ids Using the attribute id instead of its name avoids a std::string -> uint32_t lookup. Since attribute ids are guaranteed to not be invalidated, you may also store it in your application (e.g. UI menus, etc.). Disabled Implicit Copies It is important to note that implicit copies of an Attribute object is forbidden. Since Attribute buffers have value semantics (like std::vector<> ), storing the result of mesh.get_attribute<>() in a auto attr variable would lead to an implicit copy. For this reason, the following code will not compile and produce an error: // The following will NOT compile (Attribute copy is explicit) // auto attr3 = mesh.get_attribute<float>(\"normals\"); Copy-on-write handling of attribute buffers is done at the mesh level, i.e. when copying a SurfaceMesh object, or when calling methods such as SurfaceMesh::duplicate_attribute() .","title":"Accessing Attribute Values"},{"location":"user/core/attributes/#iterating-over-mesh-attributes","text":"In many situation, it is desirable to iterate over existing mesh attributes to extract some information, or process existing attributes. We provide utility functions to iterate over existing mesh attributes, with additional filtering based on element types. Basic example: #include <lagrange/foreach_attribute.h> #include <lagrange/Logger.h> lagrange :: SurfaceMesh < Scalar , Index > mesh ; // ... // Iterate over each attribute sequentially seq_foreach_attribute_read ( mesh , []( auto && attr ) { lagrange :: logger (). info ( \"Attribute with {} channels\" , attr . get_num_channels ()); }); // Same, but retrieves attribute names while iterating seq_foreach_named_attribute_read ( mesh , [ & ]( std :: string_view name , auto && attr ) { lagrange :: logger (). info ( \"Attribute named '{}' with {} channels\" , name , attr . get_num_channels ()); }); Iterator functions follow the same naming convention, with variations being as follows: Variation Description seq vs par Iterate sequentially or in parallel over available mesh attributes. named vs unnamed Whether to pass attribute names to the callback function . read vs write Whether read-only or writable references to the attributes are required. See reference documentation for additional details.","title":"Iterating Over Mesh Attributes"},{"location":"user/core/attributes/#inferring-value-type","text":"Since we use generic lambda to iterate over attributes of different types, it is possible to deduce the value type of the current attribute in the following manner: lagrange :: SurfaceMesh < Scalar , Index > mesh ; // ... seq_foreach_attribute_read ( mesh , []( auto && attr ) { // Retrieve the attribute value type within the lambda using AttributeType = std :: decay_t < decltype ( attr ) > ; using ValueType = typename AttributeType :: ValueType ; lagrange :: logger (). info ( \"Attribute value type size: {}\" , sizeof ( ValueType )); });","title":"Inferring Value Type"},{"location":"user/core/attributes/#filtering-element-types","text":"Since indexed attributes have a different interface from non-indexed attributes, it is often necessary to use two different code path when iterating over mesh attributes. Fortunately, it is possible to do so concisely thanks to C++17's if constexpr() , like so: lagrange :: SurfaceMesh < Scalar , Index > mesh ; // ... // Use compile-time if to check for indexed attributes seq_foreach_named_attribute_read ( mesh , []( std :: string_view name , auto && attr ) { using AttributeType = std :: decay_t < decltype ( attr ) > ; if constexpr ( AttributeType :: IsIndexed ) { lagrange :: logger (). info ( \"Indexed attribute '{}' with {} values\" , name , attr . values (). get_num_elements ()); } else { lagrange :: logger (). info ( \"Non-indexed attribute '{}' with {} elements\" , name , attr . get_num_elements ()); } }); Alternatively, one can provide an optional template argument to the foreach function to iterate over a specific element type: lagrange :: SurfaceMesh < Scalar , Index > mesh ; // ... // Iterate over non-indexed attributes lagrange :: seq_foreach_named_attribute_read <~ lagrange :: AttributeElement :: Indexed > ( mesh , [ & ]( std :: string_view name , auto && attr ) { lagrange :: logger (). info ( \"Attribute named '{}' with {} elements\" , name , attr . get_num_elements ()); }); // Iterate over indexed attributes only lagrange :: seq_foreach_attribute_read < lagrange :: AttributeElement :: Indexed > ( mesh , []( auto && attr ) { using AttributeType = std :: decay_t < decltype ( attr ) > ; using ValueType = typename AttributeType :: ValueType ; using Index = typename AttributeType :: Index ; lagrange :: logger (). info ( \"Indexed attribute using value type size {} and index size {}\" , sizeof ( ValueType ), sizeof ( Index )); }); Argument-Dependent Lookup With this variant, ADL no longer work, so you need to explicitly call lagrange::seq_foreach_attribute_read(mesh, ...) rather than seq_foreach_attribute_read(mesh, ...) . Finally, it is possible to combine template argument filters via bitwise boolean operations: lagrange :: SurfaceMesh < Scalar , Index > mesh ; // ... // Iterate over vertex, facet and corner attributes: lagrange :: seq_foreach_attribute_read < lagrange :: AttributeElement :: Vertex | lagrange :: AttributeElement :: Facet | lagrange :: AttributeElement :: Corner > ( mesh , [ & ]( auto && attr ) { lagrange :: logger (). info ( \"Non-indexed attribute with {} elements\" , attr . get_num_elements ()); });","title":"Filtering Element Types"},{"location":"user/core/attributes/#a-note-on-thread-safety","text":"The following operations are safe to do in parallel: Writing to two separate mesh attributes pointing to the same buffer (a deep copy will be created). The following operations are not safe to do in parallel: Writing to an attribute while creating other mesh attributes. Adding elements to a mesh while writing to another attribute of the same mesh. From a practical standpoint, copy-on-write attributes behave as if each mesh owns its own std::vector<> for each attribute. Adding an element to a mesh would resize the corresponding mesh attributes, making concurrent writes unsafe. Creating new mesh attributes will move existing mesh attributes, making concurrent writes also unsafe. Note that if two meshes are shallow copies of each other, it is perfectly safe to add elements to each of them concurrently. The same goes for writing in parallel to mesh attributes that are duplicates of each others: each attribute behaves as if it owns its own copy of the data. Temporary Copy On Concurrent Writes While concurrent writing to mesh attributes is a thread-safe operation, note that it may sometimes create an unnecessary temporary copy of the data. To avoid this, we would need to block every write operation with a mutex, which would involve an expensive context switch . Instead, we simply rely on the atomic counter from the shared_ptr<> to decide whether to copy/acquire ownership of the data. While this is a thread-safe operation, it may create a temporary copy of the data.","title":"A Note On Thread-Safety"},{"location":"user/core/attributes/#wrapping-external-buffers","text":"A key feature of our attribute system is the possibility to easily wrap external buffer and treat them as regular mesh attributes, avoiding any data copy. As long as the data layout is compatible, you will be able to wrap a continuous buffer as a mesh attribute and pass it around. lagrange :: SurfaceMesh < Scalar , Index > mesh ; mesh . add_vertices ( 10 ); Index num_verts = mesh . get_num_vertices (); Index num_coords = mesh . get_dimension (); // Create a flat buffer to use as external attribute data std :: vector < Scalar > normals ( num_verts * num_coords ); // Wrap external buffer as a read-write attribute mesh . wrap_as_attribute < Scalar > ( \"normals\" , lagrange :: AttributeElement :: Vertex , lagrange :: AttributeUsage :: Normal , num_coords , normals ); // Retrieves a Eigen::Map<> view of the attribute auto N = lagrange :: attribute_matrix_ref < Scalar > ( mesh , \"normals\" ); // Check that all coordinates are finite (no inf/nan). assert ( N . allFinite ()); Sometimes, it is necessary to wrap a pointer to a const buffer, to ensure the external buffer will not be be written to: // Wrap external buffer as a read-only attribute const Scalar * const_normals = normals . data (); mesh . wrap_as_const_attribute < Scalar > ( \"const_normals\" , lagrange :: AttributeElement :: Vertex , lagrange :: AttributeUsage :: Normal , num_coords , { const_normals , normals . size ()}); // Non-const methods on the normal attr will throw an error mesh . ref_attribute < Scalar > ( \"const_normals\" ). ref_all (); // --> throws an exception Non-Const Access The following code does not throw an exception: auto & attr = mesh . ref_attribute < Scalar > ( \"const_normals\" ); This is because while attr is a writable reference to the attribute \"const_normals\" , the user could decide to update the attribute itself to wrap another non-const buffer (via attr.wrap(...) ). Only methods which provide write access to the actual buffer data (such as attr.ref_all() ) will throw an exception. Alternatively, instead of implicitly converting to a span<> , you can explicitly pass a span<> object and let the compiler deduce the Scalar type template argument: // Pass a `span<>` object directly to let the compiler deduce the template value type mesh . wrap_as_const_attribute ( \"normals\" , lagrange :: AttributeElement :: Vertex , lagrange :: AttributeUsage :: Normal , num_coords , lagrange :: span < const Scalar > ( normals )); Lifetime Management Our API assumes that the external buffer remains valid for the lifetime of the mesh object wrapping the external data. We do not pass any counter, smart pointer or custom deleter function that would allow to track or keep alive the external data. This is because most of the time we just need to create a Lagrange Mesh wrapping an existing buffer, process it with Lagrange, and extract the results. If more advanced lifetime management is desirable, please let us know.","title":"Wrapping External Buffers"},{"location":"user/core/attributes/#delete-and-export-attributes","text":"To delete an attribute, simply call the eponymous method: lagrange :: SurfaceMesh < Scalar , Index > mesh ; // ... // Delete attribute mesh . delete_attribute ( \"normals\" ); More interestingly, the attribute itself can be exported into a std::shared_ptr<Attribute<T>> that can be handed back to the user. This allows client code to reuse the attribute data after the destruction of any mesh object that was containing the attribute: only the std::shared_ptr<Attribute<T>> needs to be kept alive. // Delete and export a std::shared_ptr<Attribute<T>> auto attr_ptr = mesh . delete_and_export_attribute < Scalar > ( \"normals\" ); // Pass a raw pointer/span to the attribute data back to client code auto data_ptr = attr_ptr -> ref_all (). data ();","title":"Delete And Export Attributes"},{"location":"user/core/attributes/#reserved-attribute-names","text":"We use the convention that attribute names starting with \"$\" are reserved for internal use by the mesh class. For example, $vertex_to_position and $corner_to_vertex are used for vertex positions and facet indices respectively. The list of available internal attributes and their names is subject to future changes.","title":"Reserved Attribute Names"},{"location":"user/core/attributes/#attribute-policies","text":"Policies can be used to control the behavior when manipulating attributes that wraps external buffers, creating/deleting attributes with reserved names, etc. Policies are runtime properties that need to be set for each attribute separately. They are copied over when an attribute is duplicated via our copy-on-write mechanism.","title":"Attribute Policies"},{"location":"user/core/attributes/#create-policy","text":"Controls the behavior when creating an attribute with a reserved name (starting with $ ). The default is to throw an exception. See reference documentation for more details.","title":"Create Policy"},{"location":"user/core/attributes/#growth-policy","text":"Controls the behavior when adding element to an attribute that wrap an external buffer. The default behavior is to throw an exception. See reference documentation for more details. Index dim = 3 ; Index num_vertices = 10 ; lagrange :: SurfaceMesh < Scalar , Index > mesh ( dim ); // Define external buffer std :: vector < Scalar > buffer ( 2 * num_vertices * dim ); // ... fill buffer with values ... // Wrap external buffer AND resize num of vertices mesh . wrap_as_vertices ( buffer , num_vertices ); // Writable reference to vertex position attribute auto & attr = mesh . ref_vertex_to_position (); // Set growth attribute policy attr . set_growth_policy ( lagrange :: AttributeGrowthPolicy :: ErrorIfExternal ); attr . set_growth_policy ( lagrange :: AttributeGrowthPolicy :: AllowWithinCapacity ); attr . set_growth_policy ( lagrange :: AttributeGrowthPolicy :: WarnAndCopy ); // Inserting more vertices might throw an error, depending on the policy mesh . add_vertices ( 5 );","title":"Growth Policy"},{"location":"user/core/attributes/#write-policy","text":"Controls the behavior when providing writable access to an attribute wrapping a const external buffer. The default behavior is to throw an exception. See reference documentation for more details. Index dim = 3 ; Index num_vertices = 10 ; lagrange :: SurfaceMesh < Scalar , Index > mesh ( dim ); // Define external buffer const size_t num_channels = 3 ; std :: vector < Scalar > buffer ( mesh . get_num_vertices () * num_channels ); // ... fill buffer with values ... // Wrap external buffer as read-only attribute auto id = mesh . wrap_as_const_attribute < Scalar > ( \"normals\" , lagrange :: AttributeElement :: Vertex , lagrange :: AttributeUsage :: Normal , num_channels , buffer ); auto & attr = mesh . ref_attribute < Scalar > ( id ); // Set write policy for read-only attributes attr . set_write_policy ( lagrange :: AttributeWritePolicy :: ErrorIfReadOnly ); attr . set_write_policy ( lagrange :: AttributeWritePolicy :: WarnAndCopy ); // Write access to the attribute might throw depending on policy attr . ref ( 0 ) = 3.14 ;","title":"Write Policy"},{"location":"user/core/attributes/#delete-policy","text":"Controls the behavior when deleting an attribute with a reserved name. The default behavior is to throw an exception. See reference documentation for more details.","title":"Delete Policy"},{"location":"user/core/attributes/#export-policy","text":"Controls the behavior when exporting an attribute wrapping an external buffer. The default behavior is to create an internal copy to ensure lifetime of the data is preserved. See reference documentation for more details. Index dim = 3 ; Index num_vertices = 10 ; lagrange :: SurfaceMesh < Scalar , Index > mesh ( dim ); // Define external buffer const size_t num_channels = 3 ; std :: vector < Scalar > buffer ( mesh . get_num_vertices () * num_channels ); // ... fill buffer with values ... // Wrap external buffer as read-only attribute auto id = mesh . wrap_as_const_attribute < Scalar > ( \"normals\" , lagrange :: AttributeElement :: Vertex , lagrange :: AttributeUsage :: Normal , num_channels , buffer ); // Delete and export might create an internal copy depending on policy using namespace lagrange ; auto attr_ptr1 = mesh . delete_and_export_attribute < Scalar > ( \"normals\" , AttributeDeletePolicy :: ErrorIfReserved , AttributeExportPolicy :: CopyIfExternal ); auto attr_ptr2 = mesh . delete_and_export_attribute < Scalar > ( \"normals\" , AttributeDeletePolicy :: ErrorIfReserved , AttributeExportPolicy :: ErrorIfExternal ); auto attr_ptr3 = mesh . delete_and_export_attribute < Scalar > ( \"normals\" , AttributeDeletePolicy :: ErrorIfReserved , AttributeExportPolicy :: KeepExternalPtr );","title":"Export Policy"},{"location":"user/core/legacy-attributes/","text":"Legacy Mesh Attributes Attention Since v6.0.0, Lagrange introduced a new polygonal mesh class that is meant to replace the original mesh class used throughout Lagrange. The old lagrange::Mesh<> class is thus deprecated , but will be kept around for a while until we can transition all our code to the new data structure. Lagrange provides functions to compute some of the commonly used mesh attributes. Vertex Attributes Normals The following snippet shows how to compute per-vertex normal : #include <lagrange/compute_vertex_normal.h> lagrange :: compute_vertex_normal ( mesh ); assert ( mesh . has_vertex_attribute ( \"normal\" )); const auto & vertex_normals = mesh . get_vertex_attribute ( \"normal\" ); assert ( vertex_normals . rows () == mesh . get_num_vertices ()); assert ( vertex_normals . cols () == 3 ); Note The resulting vertex normals are stored as a vertex attribute named \"normal\". Its size is n by 3 , where n is the number of vertices. In addition, this method only works for 3D mesh. Implementation details The per-vertex normal is computed as the angle weighted average of facet normals. Vertex Valance In graph theory, vertex valance is the number of edge incident at a vertex. #include <lagrange/compute_vertex_valance.h> lagrange :: compute_vertex_valance ( mesh ); assert ( mesh . has_vertex_attribute ( \"valance\" )); const auto & valance = mesh . get_vertex_attribute ( \"valance\" ); assert ( valance . rows () == mesh . get_num_vertices ()); assert ( valance . cols () == 1 ); Note The resulting vertex valance data is stored as a vertex attribute named \"valance\". It is an n by 1 matrix, where n is the number of vertices. Facet Attributes Normals The following snippet computes the per-facet normal: #include <lagrange/compute_triangle_normal.h> lagrange :: compute_triangle_normal ( mesh ); assert ( mesh . has_facet_attribute ( \"normal\" )); const auto & facet_normals = mesh . get_facet_attribute ( \"normal\" ); assert ( facet_normals . rows () == mesh . get_num_facets ()); assert ( facet_normals . cols () == 3 ); Note The output facet normal is stored as a m by 3 facet attribute named \"normal\", where m is the number of facets. Limitation For now, only 3D triangle normal computation is supported. Area The following snippet computes the per-facet area: #include <lagrange/compute_facet_area.h> lagrange :: compute_facet_area ( mesh ); assert ( mesh . has_facet_attribute ( \"area\" )); const auto & areas = mesh . get_facet_attribute ( \"area\" ); assert ( areas . rows () == mesh . get_num_facets ()); assert ( areas . cols () == 1 ); Note The output facet area is stored as a m by 1 facet attribute named \"area\", where m is the number of facets. Both triangle and quad facet types are supported. UV Distortion UV distortion measures the amount of skew introduced by a mesh's UV mapping . #include <lagrange/compute_uv_distortion.h> lagrange :: compute_uv_distortion ( mesh ); assert ( mesh . has_facet_attribute ( \"distortion\" )); const auto & distortion = mesh . get_facet_attribute ( \"distortion\" ); assert ( distortion . rows () == mesh . get_num_facets ()); assert ( distortion . cols () == 1 ); Note The per-facet distortion is a m by 1 facet attribute named \"distortion\", where m is the number of facets. The computation of distortion measure requires the input is triangular. Small positive values indicate low distortion, and negative values indicate inverted triangle in UV space. Implementation details This method computes the 2D conformal AMIPS energy defined in Rabinovich et al. 2017 . Edge Attributes Edge Length Edge length can be computed: #include <lagrange/compute_edge_lengths.h> lagrange :: compute_edge_lengths ( mesh ); assert ( mehs . has_edge_attribute ( \"length\" )); const auto & edge_lengths = mesh . get_edge_attribute ( \"length\" ); assert ( edge_lengths . rows () == mesh . get_num_edges ()); assert ( edge_lengths . cols () == 1 ); Note Edge lengths are stored as a e by 1 per-edge attribute named \"length\", where e is the number of undirected edges. Dihedral Angle For manifold meshes, dihedral angle is defined as the angle formed by the normals of two adjacent facets. #include <lagrange/compute_dihedral_angles.h> lagrange :: compute_dihedral_angles ( mesh ); assert ( mesh . has_edge_attribute ( \"dihedral_angle\" )); const auto & dihedral_angle = mesh . get_edge_attribute ( \"dihedral_angle\" ); assert ( dihedral_angle . rows () == mesh . get_num_edges ()); assert ( dihedral_angle . cols () == 1 ); Note The computed dihedral angles are stored as a e by 1 edge attribute named \"dihedral_angle\", where e is the number of edges. All angles are in radians. Limitation The dihedral angle is only well-defined for 3D manifold meshes.","title":"Legacy Mesh Attributes"},{"location":"user/core/legacy-attributes/#legacy-mesh-attributes","text":"Attention Since v6.0.0, Lagrange introduced a new polygonal mesh class that is meant to replace the original mesh class used throughout Lagrange. The old lagrange::Mesh<> class is thus deprecated , but will be kept around for a while until we can transition all our code to the new data structure. Lagrange provides functions to compute some of the commonly used mesh attributes.","title":"Legacy Mesh Attributes"},{"location":"user/core/legacy-attributes/#vertex-attributes","text":"","title":"Vertex Attributes"},{"location":"user/core/legacy-attributes/#normals","text":"The following snippet shows how to compute per-vertex normal : #include <lagrange/compute_vertex_normal.h> lagrange :: compute_vertex_normal ( mesh ); assert ( mesh . has_vertex_attribute ( \"normal\" )); const auto & vertex_normals = mesh . get_vertex_attribute ( \"normal\" ); assert ( vertex_normals . rows () == mesh . get_num_vertices ()); assert ( vertex_normals . cols () == 3 ); Note The resulting vertex normals are stored as a vertex attribute named \"normal\". Its size is n by 3 , where n is the number of vertices. In addition, this method only works for 3D mesh. Implementation details The per-vertex normal is computed as the angle weighted average of facet normals.","title":"Normals"},{"location":"user/core/legacy-attributes/#vertex-valance","text":"In graph theory, vertex valance is the number of edge incident at a vertex. #include <lagrange/compute_vertex_valance.h> lagrange :: compute_vertex_valance ( mesh ); assert ( mesh . has_vertex_attribute ( \"valance\" )); const auto & valance = mesh . get_vertex_attribute ( \"valance\" ); assert ( valance . rows () == mesh . get_num_vertices ()); assert ( valance . cols () == 1 ); Note The resulting vertex valance data is stored as a vertex attribute named \"valance\". It is an n by 1 matrix, where n is the number of vertices.","title":"Vertex Valance"},{"location":"user/core/legacy-attributes/#facet-attributes","text":"","title":"Facet Attributes"},{"location":"user/core/legacy-attributes/#normals_1","text":"The following snippet computes the per-facet normal: #include <lagrange/compute_triangle_normal.h> lagrange :: compute_triangle_normal ( mesh ); assert ( mesh . has_facet_attribute ( \"normal\" )); const auto & facet_normals = mesh . get_facet_attribute ( \"normal\" ); assert ( facet_normals . rows () == mesh . get_num_facets ()); assert ( facet_normals . cols () == 3 ); Note The output facet normal is stored as a m by 3 facet attribute named \"normal\", where m is the number of facets. Limitation For now, only 3D triangle normal computation is supported.","title":"Normals"},{"location":"user/core/legacy-attributes/#area","text":"The following snippet computes the per-facet area: #include <lagrange/compute_facet_area.h> lagrange :: compute_facet_area ( mesh ); assert ( mesh . has_facet_attribute ( \"area\" )); const auto & areas = mesh . get_facet_attribute ( \"area\" ); assert ( areas . rows () == mesh . get_num_facets ()); assert ( areas . cols () == 1 ); Note The output facet area is stored as a m by 1 facet attribute named \"area\", where m is the number of facets. Both triangle and quad facet types are supported.","title":"Area"},{"location":"user/core/legacy-attributes/#uv-distortion","text":"UV distortion measures the amount of skew introduced by a mesh's UV mapping . #include <lagrange/compute_uv_distortion.h> lagrange :: compute_uv_distortion ( mesh ); assert ( mesh . has_facet_attribute ( \"distortion\" )); const auto & distortion = mesh . get_facet_attribute ( \"distortion\" ); assert ( distortion . rows () == mesh . get_num_facets ()); assert ( distortion . cols () == 1 ); Note The per-facet distortion is a m by 1 facet attribute named \"distortion\", where m is the number of facets. The computation of distortion measure requires the input is triangular. Small positive values indicate low distortion, and negative values indicate inverted triangle in UV space. Implementation details This method computes the 2D conformal AMIPS energy defined in Rabinovich et al. 2017 .","title":"UV Distortion"},{"location":"user/core/legacy-attributes/#edge-attributes","text":"","title":"Edge Attributes"},{"location":"user/core/legacy-attributes/#edge-length","text":"Edge length can be computed: #include <lagrange/compute_edge_lengths.h> lagrange :: compute_edge_lengths ( mesh ); assert ( mehs . has_edge_attribute ( \"length\" )); const auto & edge_lengths = mesh . get_edge_attribute ( \"length\" ); assert ( edge_lengths . rows () == mesh . get_num_edges ()); assert ( edge_lengths . cols () == 1 ); Note Edge lengths are stored as a e by 1 per-edge attribute named \"length\", where e is the number of undirected edges.","title":"Edge Length"},{"location":"user/core/legacy-attributes/#dihedral-angle","text":"For manifold meshes, dihedral angle is defined as the angle formed by the normals of two adjacent facets. #include <lagrange/compute_dihedral_angles.h> lagrange :: compute_dihedral_angles ( mesh ); assert ( mesh . has_edge_attribute ( \"dihedral_angle\" )); const auto & dihedral_angle = mesh . get_edge_attribute ( \"dihedral_angle\" ); assert ( dihedral_angle . rows () == mesh . get_num_edges ()); assert ( dihedral_angle . cols () == 1 ); Note The computed dihedral angles are stored as a e by 1 edge attribute named \"dihedral_angle\", where e is the number of edges. All angles are in radians. Limitation The dihedral angle is only well-defined for 3D manifold meshes.","title":"Dihedral Angle"},{"location":"user/core/legacy-mesh/","text":"Legacy Mesh Class Attention Since v6.0.0, Lagrange introduced a new polygonal mesh class that is meant to replace the original mesh class used throughout Lagrange. The old lagrange::Mesh<> class is thus deprecated , but will be kept around for a while until we can transition all our code to the new data structure. The Mesh class is one of the key data structures used in Lagrange. It provides a standard representation of discretized (triangle or quad) surfaces in 2D and 3D. It is used by nearly all Lagrange functionalities. It consists of the following components Geometry : Vertices, facets, edges. Attributes : Scalar or vector field associated with vertices, faces, edges and corners (per vertex-facet pair). Connectivity : Vertex-vertex, vertex-facet, facet-facet, edge-facet adjacency matrices. Topology : Manifold/non-manifold check, boundary edge extraction. Components : Lists of facet indices that form connected components. UV : UV coordinates and indices. Matrices : Cache for discrete differential geometry matrices such as Laplacian. Terminology Throughout the documentation, we will consistently use the following terms: A vertex of a mesh is point on the surface. It is typically defined by its coordinates ( (x,y,z) in 3D and (x,y) in 2D). A facet of a mesh is an oriented polygon that represent a piece of the surface. A facet is typically either a triangle or a quad. It is defined by an ordered list of vertex indices that form its boundary ( [i,j,k] for triangle and [i,j,k,l] for quad). Template Parameters The Mesh class 's full signature is lagrange :: Mesh < VertexArray , FacetArray > ; It takes two template parameters, both are based on Eigen matrix type: VertexArray is the Eigen matrix type for representing vertex arrays. It is typically a n by dim matrix, where n is the number of vertices (or Eigen::Dynamic ) and dim is either 2 or 3 depending on the dimension of the ambient space. lagrange::Vertices2D and lagrange::Vertices3D are two possible example types for VertexArray in 2D and 3D. FacetArray : is the Eigen matrix type for representing facet arrays. It is typically a m by s matrix, where m is the number of facets (or Eigen::Dynamic ) and s is the number of vertices per facet (3 for triangle mesh and 4 for quad mesh). lagrange::Triangles and lagrange::Quads are two example types for FacetArray . In addition to VertexArray and FacetArray , two important types are inferred: Scalar is the type for representing a floating point number. Typically it is float or double . It is defined as the coefficient type of VertexArray (i.e. VertexArray::Scalar ). Index is the type for representing a index. Typically, it is int or size_t . It is defined as the coefficient type of FacetArray (i.e. FacetArray::Scalar ). Note In Lagrange, we often use the type alias MeshType to represent a specific instantiation of the Mesh class . It is equivalent to: using MeshType = Mesh < VertexArray , FacetArray > ; Naming Convention Within this doc, we use the following naming convention when referring to mesh objects: mesh is used for naming raw objects ( MeshType ). mesh_ptr is used for raw pointers ( MeshType* ). mesh_ref is used for l-value references ( MeshType& ). mesh_shared is used for shared pointers ( std::shared_ptr<MeshType> ). mesh_unique is used for shared pointers ( std::unique_ptr<MeshType> ). Creation It is easy to create a Mesh object from raw data: // Generate raw data for a single triangle. lagrange :: Vertices3D vertices ( 3 , 3 ); vertices << 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 , 0.0 , 1.0 , 0.0 ; lagrange :: Triangles facets ( 1 , 3 ); facets << 0 , 1 , 2 ; // Create a mesh object auto mesh_unique = lagrange :: create_mesh ( vertices , facets ); The return type of lagrange::create_mesh method is a unique pointer of a Mesh object. Note in this case, the matrices vertices and facets are copied into the mesh object. If we are certain these matrices will outlive the mesh object, we can avoid the copies with: auto mesh_unique = lagrange :: wrap_with_mesh ( vertices , facets ); If we want to move the data from vertices and facets to the mesh object: auto mesh_unique = lagrange :: create_mesh ( std :: move ( vertices ), std :: move ( facets )); A Mesh class object can also be loaded from a file. In this case, one needs to explicitly specify the VertexArray and FacetArray types: using VertexArray = lagrange :: Vertices3D ; using FacetArray = lagrange :: Triangles ; using MeshType = lagrange :: Mesh < VertexArray , FacetArray > ; auto mesh_unique = lagrange :: load_mesh < MeshType > ( \"filename.obj\" ); It is often necessary to convert a unique pointer to shared pointer or raw pointer to invoke Lagrange functions. It can be done easily: #include <lagrange/common.h> // Get a reference auto & mesh_ref = * mesh_unique ; // `mesh_ref` is of type `MeshType&`. // Convert to shared_ptr. auto mesh_shared = lagrange :: to_shared_ptr ( mesh_unique ); // `shared_mesh` is of type `std::shared_ptr<MeshType>` assert ( mesh_unique == nullptr ); // Get a raw pointer. // Warning: Never (!!) wrap the same raw pointer into // a new unique_ptr or shared_ptr. MeshType * mesh_ptr = mesh_shared . get (); Geometry The Mesh class provides a number of handy functions for access geometric data stored in it, for example: const auto dim = mesh . get_dim (); const auto vertex_per_facet = mesh . get_vertex_per_facet (); const auto num_vertices = mesh . get_num_vertices (); const auto num_facets = mesh . get_num_facets (); To access the raw vertex/facet matrix: const auto & vertices = mesh . get_vertices (); const auto & facets = mesh . get_facets (); Connectivity Connectivity can be optionally initialized and stored in the Mesh class as adjacency lists. For example: mesh . initialize_connectivity (); assert ( mesh . is_connectivity_initialized ()); // To get vertices adjacent to vertex v0: const auto & v0_adj_vertices = mesh . get_vertices_adjacent_to_vertex ( v0 ); // To get facets adjacent to vertex v0: const auto & v0_adj_facets = mesh . get_facets_adjacent_to_vertex ( v0 ); // To get facets adjacent to facet f0: const auto & f0_adj_facets = mesh . get_facets_adjacent_to_facet ( f0 ); // Example usage: for ( const auto fi : f0_adj_facets ) { // `fi` and `f0` are adjacent. } Note All returned values are of type MeshType::IndexList , which is an alias of std::vector<MeshType::Index> . Edge Data An edge in lagrange is an object containing two vertex indices. lagrange::EdgeType takes an Index as a template parameter (e.g. lagrange::EdgeType<int>(0, 1) ). Edge is defined in lagrange::Mesh class as an alias to lagrange::EdgeType<Index> . Note that an edge does not define a direction, and Edge(v1, v2) == Edge(v2, v1) . Never use Edge to represent a directed edge. Edge data can be initialized and stored in the Mesh class . This consists of the following data: std::vector<Edge> : A list of edges of the mesh. Edge indices indicate positions in this vector. Edge data below and edge attributes use the same indices. std::vector<std::vector<Index>> : Lists the facets adjacent to each edge. std::unordered_map<Edge, Index> : Maps each edge to its index. mesh . initialize_edge_data (); const auto num_edges = mesh . get_num_edges (); bool boundary = mesh . get_is_edge_boundary ({ v1 , v2 }); // iterate over all edges for ( const auto & edge : mesh . get_edges ()) { } // prefer using indices to avoid multiple map look-ups for ( Index e_idx = 0 ; e_idx < num_edges ; ++ e_idx ) { for ( auto Index f : mesh . get_edge_adjacent_facets ( e_idx )) { // f is an adjacent facet } } Components A mesh could contain multiple connected components. To extract connected components: mesh . initialize_components (); assert ( mesh . is_components_initialized ()); const auto num_comps = mesh . get_num_components (); const auto & comps = mesh . get_components (); assert ( num_comps == comps . size ()); // To access the first component: const auto & comp_0 = comps . front (); for ( const auto & fi : comp_0 ) { // Facet indexed by fi belongs to comp_0. } It is also possible to extract a mapping from facet indices to component indices: const auto & f_to_c_map = mesh . get_per_facet_component_ids (); assert ( f_to_c_map . size () == mesh . get_num_facets ()); const auto num_facets = mesh . get_num_facets (); for ( Index fi = 0 ; fi < num_facets ; fi ++ ) { // Facet fi belongs to component f_to_c_map[fi]. } Topology A mesh is called vertex-manifold if and only if the 1-ring neighborhood of all its vertices are topologically equivalent to a disc. Similarly, a mesh is called edge-manifold if and only if all of its edges are adjacent to at most 2 facets. Lagrange mesh has build-in supports for querying these topological properties: mesh . initialize_topology (); assert ( mesh . is_topology_initialized ()); if ( mesh . is_vertex_manifold ()) { ... } if ( mesh . is_edge_manifold ()) { ... } Note Vertex-manifold is a stronger condition. If a mesh is vertex-manifold, it is automatically implies it is also edge-manifold. UV Lagrange mesh has direct support for UV coordinates: assert ( mesh . is_uv_initialized ()); const auto & uv_coords = mesh . get_uv (); const auto & uv_indices = mesh . get_uv_indices (); The type of uv_coords is MeshType::UVArray and the type of uv_indices is MeshType::UVIndices . Both are predefined Eigen matrices using MeshType::Scalar and MeshType::Index as scalar type. The j th vertex of facet i has UV coordinates uv_coords.row(uv_indices(i,j)) . Together, uv_coords and uv_indices form a 2D mesh, which can be extracted: assert ( mesh . is_uv_initialized ()); auto uv_mesh = mesh . get_uv_mesh (); It is also possible to erase existing UV and assign a new one: mesh . clear_uv (); mesh . initialize_uv ( uv_coords , uv_indices ); Attributes It is often useful to assign spatially varying scalar field or vector over the surface of the mesh. Lagrange's Mesh class support 4 types of attributes: Per-vertex attribute: One value per vertex. Per-facet attribute: One value per facet. Per-corner attributer: One value per vertex per facet. Per-edge attribute: One value per undirected edge. All attributes has a name and are stored as MeshType::AttributeArray , which is Eigen matrix of MeshType::Scalar . For example, to create a custom per-vertex attribute: MeshType :: AttributeArray attr ( num_vertices , 1 ); // Initialize the `attr` matrix. mesh . add_vertex_attribute ( \"attr_name\" ); mesh . set_vertex_attribute ( \"attr_name\" , attr ); Attribute can be retrieved at any time from its name: if ( mesh . has_vertex_attribute ( \"attr_name\" )) { const auto & attr = mesh . get_vertex_attribute ( \"attr_name\" ); assert ( attr . rows () == mesh . get_num_vertices ()); }","title":"Legacy Mesh Class"},{"location":"user/core/legacy-mesh/#legacy-mesh-class","text":"Attention Since v6.0.0, Lagrange introduced a new polygonal mesh class that is meant to replace the original mesh class used throughout Lagrange. The old lagrange::Mesh<> class is thus deprecated , but will be kept around for a while until we can transition all our code to the new data structure. The Mesh class is one of the key data structures used in Lagrange. It provides a standard representation of discretized (triangle or quad) surfaces in 2D and 3D. It is used by nearly all Lagrange functionalities. It consists of the following components Geometry : Vertices, facets, edges. Attributes : Scalar or vector field associated with vertices, faces, edges and corners (per vertex-facet pair). Connectivity : Vertex-vertex, vertex-facet, facet-facet, edge-facet adjacency matrices. Topology : Manifold/non-manifold check, boundary edge extraction. Components : Lists of facet indices that form connected components. UV : UV coordinates and indices. Matrices : Cache for discrete differential geometry matrices such as Laplacian.","title":"Legacy Mesh Class"},{"location":"user/core/legacy-mesh/#terminology","text":"Throughout the documentation, we will consistently use the following terms: A vertex of a mesh is point on the surface. It is typically defined by its coordinates ( (x,y,z) in 3D and (x,y) in 2D). A facet of a mesh is an oriented polygon that represent a piece of the surface. A facet is typically either a triangle or a quad. It is defined by an ordered list of vertex indices that form its boundary ( [i,j,k] for triangle and [i,j,k,l] for quad).","title":"Terminology"},{"location":"user/core/legacy-mesh/#template-parameters","text":"The Mesh class 's full signature is lagrange :: Mesh < VertexArray , FacetArray > ; It takes two template parameters, both are based on Eigen matrix type: VertexArray is the Eigen matrix type for representing vertex arrays. It is typically a n by dim matrix, where n is the number of vertices (or Eigen::Dynamic ) and dim is either 2 or 3 depending on the dimension of the ambient space. lagrange::Vertices2D and lagrange::Vertices3D are two possible example types for VertexArray in 2D and 3D. FacetArray : is the Eigen matrix type for representing facet arrays. It is typically a m by s matrix, where m is the number of facets (or Eigen::Dynamic ) and s is the number of vertices per facet (3 for triangle mesh and 4 for quad mesh). lagrange::Triangles and lagrange::Quads are two example types for FacetArray . In addition to VertexArray and FacetArray , two important types are inferred: Scalar is the type for representing a floating point number. Typically it is float or double . It is defined as the coefficient type of VertexArray (i.e. VertexArray::Scalar ). Index is the type for representing a index. Typically, it is int or size_t . It is defined as the coefficient type of FacetArray (i.e. FacetArray::Scalar ). Note In Lagrange, we often use the type alias MeshType to represent a specific instantiation of the Mesh class . It is equivalent to: using MeshType = Mesh < VertexArray , FacetArray > ;","title":"Template Parameters"},{"location":"user/core/legacy-mesh/#naming-convention","text":"Within this doc, we use the following naming convention when referring to mesh objects: mesh is used for naming raw objects ( MeshType ). mesh_ptr is used for raw pointers ( MeshType* ). mesh_ref is used for l-value references ( MeshType& ). mesh_shared is used for shared pointers ( std::shared_ptr<MeshType> ). mesh_unique is used for shared pointers ( std::unique_ptr<MeshType> ).","title":"Naming Convention"},{"location":"user/core/legacy-mesh/#creation","text":"It is easy to create a Mesh object from raw data: // Generate raw data for a single triangle. lagrange :: Vertices3D vertices ( 3 , 3 ); vertices << 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 , 0.0 , 1.0 , 0.0 ; lagrange :: Triangles facets ( 1 , 3 ); facets << 0 , 1 , 2 ; // Create a mesh object auto mesh_unique = lagrange :: create_mesh ( vertices , facets ); The return type of lagrange::create_mesh method is a unique pointer of a Mesh object. Note in this case, the matrices vertices and facets are copied into the mesh object. If we are certain these matrices will outlive the mesh object, we can avoid the copies with: auto mesh_unique = lagrange :: wrap_with_mesh ( vertices , facets ); If we want to move the data from vertices and facets to the mesh object: auto mesh_unique = lagrange :: create_mesh ( std :: move ( vertices ), std :: move ( facets )); A Mesh class object can also be loaded from a file. In this case, one needs to explicitly specify the VertexArray and FacetArray types: using VertexArray = lagrange :: Vertices3D ; using FacetArray = lagrange :: Triangles ; using MeshType = lagrange :: Mesh < VertexArray , FacetArray > ; auto mesh_unique = lagrange :: load_mesh < MeshType > ( \"filename.obj\" ); It is often necessary to convert a unique pointer to shared pointer or raw pointer to invoke Lagrange functions. It can be done easily: #include <lagrange/common.h> // Get a reference auto & mesh_ref = * mesh_unique ; // `mesh_ref` is of type `MeshType&`. // Convert to shared_ptr. auto mesh_shared = lagrange :: to_shared_ptr ( mesh_unique ); // `shared_mesh` is of type `std::shared_ptr<MeshType>` assert ( mesh_unique == nullptr ); // Get a raw pointer. // Warning: Never (!!) wrap the same raw pointer into // a new unique_ptr or shared_ptr. MeshType * mesh_ptr = mesh_shared . get ();","title":"Creation"},{"location":"user/core/legacy-mesh/#geometry","text":"The Mesh class provides a number of handy functions for access geometric data stored in it, for example: const auto dim = mesh . get_dim (); const auto vertex_per_facet = mesh . get_vertex_per_facet (); const auto num_vertices = mesh . get_num_vertices (); const auto num_facets = mesh . get_num_facets (); To access the raw vertex/facet matrix: const auto & vertices = mesh . get_vertices (); const auto & facets = mesh . get_facets ();","title":"Geometry"},{"location":"user/core/legacy-mesh/#connectivity","text":"Connectivity can be optionally initialized and stored in the Mesh class as adjacency lists. For example: mesh . initialize_connectivity (); assert ( mesh . is_connectivity_initialized ()); // To get vertices adjacent to vertex v0: const auto & v0_adj_vertices = mesh . get_vertices_adjacent_to_vertex ( v0 ); // To get facets adjacent to vertex v0: const auto & v0_adj_facets = mesh . get_facets_adjacent_to_vertex ( v0 ); // To get facets adjacent to facet f0: const auto & f0_adj_facets = mesh . get_facets_adjacent_to_facet ( f0 ); // Example usage: for ( const auto fi : f0_adj_facets ) { // `fi` and `f0` are adjacent. } Note All returned values are of type MeshType::IndexList , which is an alias of std::vector<MeshType::Index> .","title":"Connectivity"},{"location":"user/core/legacy-mesh/#edge-data","text":"An edge in lagrange is an object containing two vertex indices. lagrange::EdgeType takes an Index as a template parameter (e.g. lagrange::EdgeType<int>(0, 1) ). Edge is defined in lagrange::Mesh class as an alias to lagrange::EdgeType<Index> . Note that an edge does not define a direction, and Edge(v1, v2) == Edge(v2, v1) . Never use Edge to represent a directed edge. Edge data can be initialized and stored in the Mesh class . This consists of the following data: std::vector<Edge> : A list of edges of the mesh. Edge indices indicate positions in this vector. Edge data below and edge attributes use the same indices. std::vector<std::vector<Index>> : Lists the facets adjacent to each edge. std::unordered_map<Edge, Index> : Maps each edge to its index. mesh . initialize_edge_data (); const auto num_edges = mesh . get_num_edges (); bool boundary = mesh . get_is_edge_boundary ({ v1 , v2 }); // iterate over all edges for ( const auto & edge : mesh . get_edges ()) { } // prefer using indices to avoid multiple map look-ups for ( Index e_idx = 0 ; e_idx < num_edges ; ++ e_idx ) { for ( auto Index f : mesh . get_edge_adjacent_facets ( e_idx )) { // f is an adjacent facet } }","title":"Edge Data"},{"location":"user/core/legacy-mesh/#components","text":"A mesh could contain multiple connected components. To extract connected components: mesh . initialize_components (); assert ( mesh . is_components_initialized ()); const auto num_comps = mesh . get_num_components (); const auto & comps = mesh . get_components (); assert ( num_comps == comps . size ()); // To access the first component: const auto & comp_0 = comps . front (); for ( const auto & fi : comp_0 ) { // Facet indexed by fi belongs to comp_0. } It is also possible to extract a mapping from facet indices to component indices: const auto & f_to_c_map = mesh . get_per_facet_component_ids (); assert ( f_to_c_map . size () == mesh . get_num_facets ()); const auto num_facets = mesh . get_num_facets (); for ( Index fi = 0 ; fi < num_facets ; fi ++ ) { // Facet fi belongs to component f_to_c_map[fi]. }","title":"Components"},{"location":"user/core/legacy-mesh/#topology","text":"A mesh is called vertex-manifold if and only if the 1-ring neighborhood of all its vertices are topologically equivalent to a disc. Similarly, a mesh is called edge-manifold if and only if all of its edges are adjacent to at most 2 facets. Lagrange mesh has build-in supports for querying these topological properties: mesh . initialize_topology (); assert ( mesh . is_topology_initialized ()); if ( mesh . is_vertex_manifold ()) { ... } if ( mesh . is_edge_manifold ()) { ... } Note Vertex-manifold is a stronger condition. If a mesh is vertex-manifold, it is automatically implies it is also edge-manifold.","title":"Topology"},{"location":"user/core/legacy-mesh/#uv","text":"Lagrange mesh has direct support for UV coordinates: assert ( mesh . is_uv_initialized ()); const auto & uv_coords = mesh . get_uv (); const auto & uv_indices = mesh . get_uv_indices (); The type of uv_coords is MeshType::UVArray and the type of uv_indices is MeshType::UVIndices . Both are predefined Eigen matrices using MeshType::Scalar and MeshType::Index as scalar type. The j th vertex of facet i has UV coordinates uv_coords.row(uv_indices(i,j)) . Together, uv_coords and uv_indices form a 2D mesh, which can be extracted: assert ( mesh . is_uv_initialized ()); auto uv_mesh = mesh . get_uv_mesh (); It is also possible to erase existing UV and assign a new one: mesh . clear_uv (); mesh . initialize_uv ( uv_coords , uv_indices );","title":"UV"},{"location":"user/core/legacy-mesh/#attributes","text":"It is often useful to assign spatially varying scalar field or vector over the surface of the mesh. Lagrange's Mesh class support 4 types of attributes: Per-vertex attribute: One value per vertex. Per-facet attribute: One value per facet. Per-corner attributer: One value per vertex per facet. Per-edge attribute: One value per undirected edge. All attributes has a name and are stored as MeshType::AttributeArray , which is Eigen matrix of MeshType::Scalar . For example, to create a custom per-vertex attribute: MeshType :: AttributeArray attr ( num_vertices , 1 ); // Initialize the `attr` matrix. mesh . add_vertex_attribute ( \"attr_name\" ); mesh . set_vertex_attribute ( \"attr_name\" , attr ); Attribute can be retrieved at any time from its name: if ( mesh . has_vertex_attribute ( \"attr_name\" )) { const auto & attr = mesh . get_vertex_attribute ( \"attr_name\" ); assert ( attr . rows () == mesh . get_num_vertices ()); }","title":"Attributes"},{"location":"user/core/mesh-cleanup/","text":"Mesh Cleanup Attention Documentation on this page relies on our legacy mesh data structure. Lagrange supports a number of mesh cleanup operations. Typically, a mesh cleanup operation takes an mesh object as input and creates a new Mesh object. For example, all mesh cleanup functions have the same function signature: auto out_mesh_unique = lagrange :: function_name ( in_mesh ); Therefore, it is possible to combine mesh cleanup operations by chaining them. Existing vertex/facet/corner attributes can be seamless ported from the input mesh to the output mesh. Limitation Edge attribute is not ported at the moment. Remove Isolated Vertices An isolated vertex is a vertex that is not adjacent to any facet. It can be removed with remove_isolated_vertex function: #include <lagrange/mesh_cleanup/remove_isolated_vertices.h> auto mesh2_unique = lagrange :: remove_isolated_vertices ( mesh ); Remove Duplicate Vertices Two vertices are considered duplicates if they have exactly the same coordinates. To remove duplicate vertices: #include <lagrange/mesh_cleanup/remove_duplicate_vertices.h> auto mesh_unique = lagrange :: remove_duplicate_vertices ( mesh ); It is also possible to add an extra condition when checking for vertex duplicates. By specifying a vertex attribute, two vertices are considered duplicates if they have exactly the same coordinates and attribute values. For example: #include <lagrange/mesh_cleanup/remove_duplicate_vertices.h> auto mesh2_unique = lagrange :: remove_duplicate_vertices ( mesh , \"color\" ); This call will remove all duplicate vertices that have the same coordinates and color as defined by the \"color\" vertex attribute. Remove Degenerate Triangles A triangle is called degenerate if all of its vertices are exactly collinear. Lagrange relies on exact predicates to check collinearity. #include <lagrange/mesh_cleanup/remove_degenerate_triangles.h> auto mesh2_unique = lagrange :: remove_degenerate_triangles ( mesh ); Remove Topologically Degenerate Triangles A triangle is called topologically degenerate if two or more of its vertices are the same topologically. For example, a triangle [1, 1, 2] is topologically degenerate because two of its vertices are referring to the same vertex (the vertex with index 1 ). Topological degeneracy is a special case of general degeneracy and it is possible to identify it from connectivity alone. #include <lagrange/mesh_cleanup/remove_topologically_degenerate_triangles.h> auto mesh2_unique = lagrange :: remove_topologically_degenerate_triangles ( mesh ); Remove Short Edges To remove all edges shorter than a given threshold: #include <lagrange/mesh_cleanup/remove_short_edges.h> auto mesh2_unqiue = lagrange :: remove_short_edges ( mesh , tol ); where tol is the target edge length threshold. Remove Duplicate Facets Two facets are considered duplicates of each other if they are formed by the combination of vertices. E.g. facet [1, 2, 3] is considered as duplicate of facet [3, 2, 1] . To remove all duplicate facets: #include <lagrange/mesh_cleanup/remove_duplicate_facets.h> auto mesh2_unique = lagrange :: remove_duplicate_facets ( mesh ); Note Facet orientation is not considered. Even thought facet [1, 2, 3] and [3, 2, 1] have opposite orientations, they are considered as duplicates. Split Long Edges It is often that we need to refine a triangular mesh by splitting long edges: #include <lagrange/mesh_cleanup/split_long_edges.h> auto mesh2_unique = lagrange :: split_long_edges ( mesh , sq_tol , true ); Other than the input mesh, lagrange::split_long_edges takes two more parameters: sq_tol : The target edge length squared. All edges longer than this threshold will be split. recursive : Whether to split recursively . Because edge splitting will introduce new edges and these new edges may be longer than the specified threshold. Splitting recursively will guarantee the output mesh contain no edge longer than the specified threshold. Note Only long edges are split. This is different from uniform refinement where all edges are split. Resolve Nonmanifoldness Lagrange can convert a nonmanifold mesh to a manifold mesh : #include <lagrange/mesh_cleanup/resolve_nonmanifoldness.h> auto mesh2_unique = lagrange :: resolve_nonmanifoldness ( mesh ); where nonmanifold vertices and edges are \"pulled apart\". Implementation details Here is an illustration describing how Lagrange \"pulls apart\" nonmanifold vertices and edges: Convert Quad Mesh To Triangular Mesh Lagrange also provide handy function to convert a quad to a triangular mesh: #include <lagrange/quad_to_tri.h> auto mesh2_unique = lagrange :: quad_to_tri ( mesh ); Implementation details Each quad is converted to 2 triangles by inserting one of its diagonals procedurally. Submesh Extraction It is often necessary to extract a subset of the facets from a given mesh. Such operation is supported via lagrange::extract_submesh function: #include <lagrange/extract_submesh.h> std :: vector < int > selected_facets ; // Populate selected_facets with facet indices. auto submesh_unique = lagrange :: extract_submesh ( mesh , selected_facets );","title":"Mesh Cleanup"},{"location":"user/core/mesh-cleanup/#mesh-cleanup","text":"Attention Documentation on this page relies on our legacy mesh data structure. Lagrange supports a number of mesh cleanup operations. Typically, a mesh cleanup operation takes an mesh object as input and creates a new Mesh object. For example, all mesh cleanup functions have the same function signature: auto out_mesh_unique = lagrange :: function_name ( in_mesh ); Therefore, it is possible to combine mesh cleanup operations by chaining them. Existing vertex/facet/corner attributes can be seamless ported from the input mesh to the output mesh. Limitation Edge attribute is not ported at the moment.","title":"Mesh Cleanup"},{"location":"user/core/mesh-cleanup/#remove-isolated-vertices","text":"An isolated vertex is a vertex that is not adjacent to any facet. It can be removed with remove_isolated_vertex function: #include <lagrange/mesh_cleanup/remove_isolated_vertices.h> auto mesh2_unique = lagrange :: remove_isolated_vertices ( mesh );","title":"Remove Isolated Vertices"},{"location":"user/core/mesh-cleanup/#remove-duplicate-vertices","text":"Two vertices are considered duplicates if they have exactly the same coordinates. To remove duplicate vertices: #include <lagrange/mesh_cleanup/remove_duplicate_vertices.h> auto mesh_unique = lagrange :: remove_duplicate_vertices ( mesh ); It is also possible to add an extra condition when checking for vertex duplicates. By specifying a vertex attribute, two vertices are considered duplicates if they have exactly the same coordinates and attribute values. For example: #include <lagrange/mesh_cleanup/remove_duplicate_vertices.h> auto mesh2_unique = lagrange :: remove_duplicate_vertices ( mesh , \"color\" ); This call will remove all duplicate vertices that have the same coordinates and color as defined by the \"color\" vertex attribute.","title":"Remove Duplicate Vertices"},{"location":"user/core/mesh-cleanup/#remove-degenerate-triangles","text":"A triangle is called degenerate if all of its vertices are exactly collinear. Lagrange relies on exact predicates to check collinearity. #include <lagrange/mesh_cleanup/remove_degenerate_triangles.h> auto mesh2_unique = lagrange :: remove_degenerate_triangles ( mesh );","title":"Remove Degenerate Triangles"},{"location":"user/core/mesh-cleanup/#remove-topologically-degenerate-triangles","text":"A triangle is called topologically degenerate if two or more of its vertices are the same topologically. For example, a triangle [1, 1, 2] is topologically degenerate because two of its vertices are referring to the same vertex (the vertex with index 1 ). Topological degeneracy is a special case of general degeneracy and it is possible to identify it from connectivity alone. #include <lagrange/mesh_cleanup/remove_topologically_degenerate_triangles.h> auto mesh2_unique = lagrange :: remove_topologically_degenerate_triangles ( mesh );","title":"Remove Topologically Degenerate Triangles"},{"location":"user/core/mesh-cleanup/#remove-short-edges","text":"To remove all edges shorter than a given threshold: #include <lagrange/mesh_cleanup/remove_short_edges.h> auto mesh2_unqiue = lagrange :: remove_short_edges ( mesh , tol ); where tol is the target edge length threshold.","title":"Remove Short Edges"},{"location":"user/core/mesh-cleanup/#remove-duplicate-facets","text":"Two facets are considered duplicates of each other if they are formed by the combination of vertices. E.g. facet [1, 2, 3] is considered as duplicate of facet [3, 2, 1] . To remove all duplicate facets: #include <lagrange/mesh_cleanup/remove_duplicate_facets.h> auto mesh2_unique = lagrange :: remove_duplicate_facets ( mesh ); Note Facet orientation is not considered. Even thought facet [1, 2, 3] and [3, 2, 1] have opposite orientations, they are considered as duplicates.","title":"Remove Duplicate Facets"},{"location":"user/core/mesh-cleanup/#split-long-edges","text":"It is often that we need to refine a triangular mesh by splitting long edges: #include <lagrange/mesh_cleanup/split_long_edges.h> auto mesh2_unique = lagrange :: split_long_edges ( mesh , sq_tol , true ); Other than the input mesh, lagrange::split_long_edges takes two more parameters: sq_tol : The target edge length squared. All edges longer than this threshold will be split. recursive : Whether to split recursively . Because edge splitting will introduce new edges and these new edges may be longer than the specified threshold. Splitting recursively will guarantee the output mesh contain no edge longer than the specified threshold. Note Only long edges are split. This is different from uniform refinement where all edges are split.","title":"Split Long Edges"},{"location":"user/core/mesh-cleanup/#resolve-nonmanifoldness","text":"Lagrange can convert a nonmanifold mesh to a manifold mesh : #include <lagrange/mesh_cleanup/resolve_nonmanifoldness.h> auto mesh2_unique = lagrange :: resolve_nonmanifoldness ( mesh ); where nonmanifold vertices and edges are \"pulled apart\". Implementation details Here is an illustration describing how Lagrange \"pulls apart\" nonmanifold vertices and edges:","title":"Resolve Nonmanifoldness"},{"location":"user/core/mesh-cleanup/#convert-quad-mesh-to-triangular-mesh","text":"Lagrange also provide handy function to convert a quad to a triangular mesh: #include <lagrange/quad_to_tri.h> auto mesh2_unique = lagrange :: quad_to_tri ( mesh ); Implementation details Each quad is converted to 2 triangles by inserting one of its diagonals procedurally.","title":"Convert Quad Mesh To Triangular Mesh"},{"location":"user/core/mesh-cleanup/#submesh-extraction","text":"It is often necessary to extract a subset of the facets from a given mesh. Such operation is supported via lagrange::extract_submesh function: #include <lagrange/extract_submesh.h> std :: vector < int > selected_facets ; // Populate selected_facets with facet indices. auto submesh_unique = lagrange :: extract_submesh ( mesh , selected_facets );","title":"Submesh Extraction"},{"location":"user/core/mesh/","text":"Mesh Class Attention Since v6.0.0, Lagrange introduced a new polygonal mesh class that is meant to replace the original mesh class used throughout Lagrange. While currently few of the Lagrange functions use this new mesh class, over time old and new features will transition to use this new data structure. The SurfaceMesh class is the new generic mesh class in Lagrange to represent meshes. It is a very generic class that supports triangle meshes, quad meshes, as well as quad-dominant and arbitrary polygonal meshes. This new data structure was designed with a couple of key features in mind: Generic and powerful API : A generic mesh API that works in 2D, 3D, ND with triangles/quad/hybrid meshes using the same SurfaceMesh type. A simple API based on std::span<> (pointer + size). This avoids a lot of header-only template shenanigans, while providing a low-overhead but secure interface to manipulate continuous buffers. Clean headers : The main SurfaceMesh.h header only pulls a few STL headers ( <memory> , <string_view> , <span> and <functional> -- the last one can be avoided easily). A separate header views.h allows to \"view\" mesh buffers as Eigen matrices (e.g., for easy interfacing with libigl ). A separate header foreach_attributes.h provides utility functions to iterate over mesh attributes. Efficient memory usage : Generic copy-on-write mesh attributes (per vertex, facet, edge, etc.). Efficient memory storage: a pure triangle/quad meshes only needs 2 buffers for vertex positions and facet indices, while hybrid meshes will use an additional offset buffer. Mesh attributes can wrap external buffers (including const buffers), as long as memory layout is compatible. Policies determine write/growth behavior. Mesh attributes can be exported in a std::shared_ptr<> to be transferred back to client code. Dynamic editing capabilities : Mesh vertices and facets can be dynamically inserted and removed efficiently. Powerful attribute system : Generic attribute system supporting any fixed-size integer types ( int8_t ... uint64_t ) and floating point types ( float , double ). Attributes can be attached to any mesh element (vertex, facet, edge, corner), or can indexed by a secondary buffer (e.g. UVs). Usage tag specifies how attributes are used and transformed (e.g. Color, Normals, UV, etc.). Optional edge/connectivity attributes : Mesh edges can be numbered automatically, or based on a user-provided ordering. Connectivity attributes allow efficient navigation around mesh elements (similar to half-edges). Fast compilation times 1 : Clean separation between class declaration/definition allows for faster build times. Explicit template instantiation is used to limit available types usable with our SurfaceMesh<> and Attribute<> class. X macros are used to facilitate explicit template instantiation of predetermined types (can be used by client code). Extensive documentation Complete user guide (this document) Full Doxygen API reference. Mesh Representation At the core, our mesh data structure is just a collection of mesh elements (vertices, facets, edges, corners), where each element is attached a number of attributes . Specifically, we define the following elements: Vertices : Points used to form the facets of the mesh. Typically associated with a 2D or 3D position attribute. Facets : Polygons formed by connecting mesh vertices together. In a triangle mesh, all facets are 3-gons. Edges : Edges are formed by unordered pairs of consecutive vertices in a mesh facet. The set of mesh edges is defined implicitly from the mesh facets. See Mesh Edges for more details. Corners : Facet corner elements can be used to reference vertices in a specific facet. Corners from the same facets are indexed contiguously in a flat list containing all facet corners. Our mesh data structure is very generic, and can represent any kind of polygonal mesh, non-manifold surface, mesh containing isolated vertices, point clouds, etc. Terminology Regular mesh : In the context of this documentation, a regular mesh is a mesh whose facets have the same constant size . E.g. a triangle mesh is a regular mesh (facet size = 3). So is a quad mesh (facet size = 4), a pentagonal mesh, etc. Hybrid mesh : A hybrid mesh is a mesh whose facets may have varying sizes. E.g. a quad dominant mesh is a hybrid mesh. Vertex valence : Number of facet corners pointing to a given vertex (repeated vertex indices in a degenerate facet will count multiple times towards the vertex valence). Facet size : Number of corners/vertices in a facet. Currently we require facet sizes to be > 2, but this restriction will be lifted in a future version (supporting facets of size 1 and 2). A hybrid mesh will store an additional \"offset\" attribute for each facet, to determine where each facet starts/ends in the attribute buffer storing vertex indices. Offset Indices In the following mesh, facets [f0, f1, f2] have an \"offset\" attribute of [0, 3, 7] . This means that the first corner of f0 is c0 , the first corner of f1 is c3 , etc. The size of a facet can be computed from the difference between two consecutive offsets. Adding Vertices/Facets Simple version: lagrange :: SurfaceMesh < Scalar , Index > mesh ; mesh . add_vertices ( 10 ); // adds 10 vertices with 0-initialized coordinates mesh . add_triangles ( 3 ); // adds 3 triangles with 0-initialized vertex indices mesh . add_quads ( 2 ); // adds 2 quads with 0-initialized vertex vertices Another example: lagrange :: SurfaceMesh < Scalar , Index > mesh ; mesh . add_vertex ({ 0.5 , 0.2 , 0.9 }); // adds a vertex at (0.5, 0.2, 0.9) mesh . add_triangle ( 1 , 3 , 4 ); // adds triangle (v1, v3, v3) mesh . add_quad ( 1 , 3 , 4 , 2 ); // adds quad (v1, v3, v4, v2) mesh . add_polygon ({ 1 , 3 , 4 , 2 , 5 }); // adds polygon (v1, v3, v4, v2, v5) To create a mesh from an existing buffer (with copy): std :: vector < Scalar > vertices ; // flat buffer of size N x 3 std :: vector < Index > facets ; // flat buffer of size M x 3 // ... fill up vertices/facets ... Index num_vertices = Index ( vertices . size ()) / 3 ; Index num_facets = Index ( facets . size ()) / 3 ; lagrange :: SurfaceMesh < Scalar , Index > mesh ; mesh . add_vertices ( num_vertices , vertices ); mesh . add_triangles ( num_facets , facets ); Note that any continuous buffer of the appropriate size will work. If your input buffer is of type std::vector<std::array<Scalar, 3>> , you will need to convert the pointer: std :: vector < std :: array < Scalar , 3 >> vertices ; lagrange :: SurfaceMesh < Scalar , Index > mesh ; mesh . add_vertices ( Index ( vertices . size ()), { vertices . empty () ? nullptr : vertices [ 0 ]. data (), 3 * vertices . size ()}); You can add multiple polygonal facets with different sizes in the same function call by using the add_hybrid() method. While this method can take an existing buffer as input, it may be simpler to use it via user-defined callbacks: lagrange :: SurfaceMesh < Scalar , Index > mesh ; std :: mt19937 gen ; std :: uniform_int_distribution < Index > random_facet_size ( 3 , 6 ); std :: uniform_int_distribution < Index > random_vertex_index ( 0 , 9 ); std :: uniform_real_distribution < Scalar > random_position ( 0 , 1 ); mesh . add_vertices ( 10 , [ & ]( Index , lagrange :: span < Scalar > p ) { p [ 0 ] = random_position ( gen ); p [ 1 ] = random_position ( gen ); p [ 2 ] = random_position ( gen ); }); mesh . add_hybrid ( 4 , // The first callback determines the degree of facet `f` [ & ]( Index f ) { return random_facet_size ( gen ); }, // The second callback sets the mapping corner id -> vertex id for facet `f` [ & ]( Index f , lagrange :: span < Index > t ) { for ( Index i = 0 ; i < t . size (); ++ i ) { // Assign a random vertex id to each facet corner t [ i ] = random_vertex_index ( gen ); } }); Removing Vertices/Facets Batch Removal Only Currently, we only support efficient batch removal of vertices/facets. This is because removing any mesh element will cause reindexing of all mesh attributes referencing a mesh element (e.g. vertex indices). To allow for \"lazy\" deletion, you can use an attribute to keep track of \"deleted\" vertices/facets until you actually clean them up. An element removal is a O(|V| + |F|) operation. To remove a list of vertices/facets: lagrange :: SurfaceMesh < Scalar , Index > mesh ; mesh . add_vertices ( 20 ); mesh . add_triangles ( 12 ); // Remove vertices v2, v5 and v9 mesh . remove_vertices ({ 2 , 5 , 9 }); // Remove facets v6, v2 and v8 mesh . remove_facets ({ 6 , 2 , 8 }); Alternatively, you can use a filter returning a boolean value to determine the vertices/facets to remove: lagrange :: SurfaceMesh < Scalar , Index > mesh ; mesh . add_vertices ( 20 ); mesh . add_triangles ( 12 ); // Remove vertices with even index mesh . remove_vertices ([]( Index v ) { return ( v % 2 == 0 ); }); // Remove random facets std :: mt19937 gen ; std :: uniform_int_distribution < int > flip_coin ( 0 , 1 ); mesh . remove_facets ([ & ]( Index f ) { return flip_coin ( gen ) == 1 ; }); Vertex Removal Removing a vertex will automatically remove any facet containing that vertex! Facet Removal Removing a facet will not automatically remove any incident vertex. You can end up with floating/isolated vertices after facet removal. Consider filtering them as a post-processing. Copy-On-Write All mesh data is stored in an Attribute object, including vertex positions, facet indices, etc. These mesh attributes are handled via a copy-on-write mechanism, meaning that copying a mesh is a cheap operation by default: no buffer is actually duplicated until you start writing to it. For this reason, we distinguish most accessors between getters and setters : Getters start with get_xxx() and provide read-only access to an attribute data. They will not cause any copy. Setters start with ref_xxx() and will cause an immediate buffer copy if the buffer is not uniquely owned (i.e. there are more than 1 object referencing the same buffer). Note that both getters and setters are safe to use concurrently . Please read our \"note on thread-safety\" for more information. See below for a short example: lagrange :: SurfaceMesh < Scalar , Index > mesh ; // ... Fill up mesh ... lagrange :: SurfaceMesh < Scalar , Index > copy = mesh ; // Writable reference to a vertex auto p = copy . ref_position ( 1 ); // <-- leads to a copy of the vertex buffer p [ 0 ] = 0.1 ; p [ 1 ] = 0.2 ; p [ 2 ] = 0.3 ; // Now vertices v1 are different std :: equal ( mesh . get_position ( 1 ). begin (), mesh . get_position ( 1 ). end (), copy . get_position ( 1 ). begin ()); // --> false // The pointers to the vertex positions are now different mesh . get_vertex_to_position (). get_all (). data () == copy . get_vertex_to_position (). get_all (). data (); // --> false // But the pointers to the facet indices are still the same mesh . get_corner_to_vertex (). get_all (). data () == copy . get_corner_to_vertex (). get_all (). data (); // --> true Eigen Matrix Views Mesh attributes such as positions and facet indices can be views as Eigen matrices. Specifically, we provide read-only views as Eigen::Map<const ...> : #include <lagrange/SurfaceMesh.h> #include <lagrange/views.h> #include <igl/massmatrix.h> lagrange :: SurfaceMesh < Scalar , Index > mesh ; // Fill up mesh data... // With ADL, no need to prefix by lagrange:: auto V_view = vertex_view ( mesh ); auto F_view = facet_view ( mesh ); // Call your favorite libigl function Eigen :: SparseMatrix < Scalar > M ; igl :: massmatrix ( V_view , F_view , igl :: MASSMATRIX_TYPE_VORONOI , M ); Writable reference are also available: // Writable reference, creates a copy if buffer is not uniquely owned auto V_ref = vertex_ref ( mesh ); auto F_ref = facet_ref ( mesh ); // Center mesh around vertex barycenter V_ref . rowwise () -= V_ref . colwise (). mean (); Regular Meshes Vs Hybrid Meshes On hybrid meshes, it is not possible to \"view\" facet indices as a 2D matrix. This is because each \"row\" of the matrix would have a variable width, due to the varying facet sizes. For this reason, trying to get a facet_view() on a hybrid mesh will throw a runtime exception. Mesh Edges By default, a mesh object is very lightweight, and does not compute edge ids or connectivity information. If this information is desirable, it is possible to compute it by calling the initialize_edges() method: lagrange :: SurfaceMesh < Scalar , Index > mesh ; mesh . add_vertices ( 10 ); mesh . add_triangle ( 0 , 1 , 2 ); mesh . add_quad ( 1 , 3 , 4 , 2 ); mesh . add_polygon ({ 0 , 2 , 4 , 5 , 6 }); // Let Lagrange assign an id to each edge mesh . initialize_edges (); // ... // Once edge data is no longer needed, clear related mesh attributes: mesh . clear_edges (); In practice, edge and connectivity data are stored as special mesh attributes, which can be accessed/edited like any other mesh attribute! If a specific ordering of the mesh edges is desired, provide it to the initialize_edges() method: // Explicit edge id -> vertex ids mapping const std :: vector < std :: array < Index , 2 >> edges = { { 0 , 1 }, { 1 , 3 }, { 3 , 4 }, { 4 , 5 }, { 5 , 6 }, { 6 , 0 }, { 1 , 2 }, { 2 , 0 }, { 2 , 4 }, }; // Passed to the mesh via a std::span<> mesh . initialize_edges ({ & edges [ 0 ][ 0 ], 2 * edges . size ()}); Redundant Initialization If a mesh already contains edges information, mesh.initialize_edges() will not do anything. If you want to reorder existing edges, please clear edge attributes first, and re-initialize mesh edges. Connectivity And Navigation Initializing mesh edges will also equip the mesh with connectivity information. This allows you to navigate around mesh elements such as vertices and facets. To navigate around a given element, use the foreach_xxx_around_xxx() functions: lagrange :: SurfaceMesh < Scalar , Index > mesh ; // Fill up mesh... // Compute vertex valence std :: vector < Index > vertex_valence ( mesh . get_num_vertices (), 0 ); for ( Index v = 0 ; v < mesh . get_num_vertices (); ++ v ) { mesh . foreach_facet_around_vertex ( v , [ & ]( Index f ) { ++ vertex_valence [ v ]; }); } In the example above, we could have use the method count_num_corners_around_vertex() to compute vertex valence directly. See SurfaceMesh class documentation for a full reference. Degenerate Facets If a mesh facet is degenerate, and references the same vertex several time (e.g. facet f2 = (0, 1, 1) ), then mesh.foreach_facet_around_vertex(1) will call the facet f2 twice. Edges Around A Vertex To iterate over the edges incident to a given vertex, you will notice that we only provide a single method foreach_edge_around_vertex_with_duplicates() . This method will call the callback function repeatedly for each facet which contains an incident edge to the prescribed vertex. Non-Manifold Surfaces Our mesh navigation methods support any type of non-manifold meshes. This is in contrast with some type of half-edge data structures which assume manifold surfaces. Half-Edges There is a natural correspondence between the usual half-edge notion and a facet corner (see figure below). While Lagrange currently does not offer half-edge data-structure for mesh navigation, corner indices can be used to navigate around mesh elements the same way a half-edge data structure does. Half-edges can be identified with their equivalent facet corners. Twin Half-Edge To implement the twin(h_i) operation, you can use SurfaceMesh::get_next_corner_around_edge() . In the future we may add a half-edge \"proxy\" structure to facilitate mesh navigation. Template Parameters While our SurfaceMesh<> class is templated by both a Scalar and Index type, we only actually support a finite set of template parameters. Specifically: Scalar can only be float or double . Index can only be uint32_t or uint64_t . We provide the following type aliases for convenience: Alias Actual Type SurfaceMesh32f SurfaceMesh<float, uint32_t> SurfaceMesh32d SurfaceMesh<double, uint32_t> SurfaceMesh64f SurfaceMesh<float, uint64_t> SurfaceMesh64d SurfaceMesh<double, uint64_t> Writing Functions Taking SurfaceMesh As Parameter To write a function taking a SurfaceMesh<> as a parameter, you can use our X macros to explicitly instantiate a templated function with the supported mesh types. For example, the vertex_view() function is instantiated as follows: //////////////// // In views.h // //////////////// template < typename S , typename I > ConstRowMatrixView < S > vertex_view ( const SurfaceMesh < S , I >& mesh ); ////////////////// // In views.cpp // ////////////////// template < typename S , typename I > ConstRowMatrixView < S > vertex_view ( const SurfaceMesh < S , I >& mesh ) { // Function definition return {}; } // Explicit template instantiation #define LA_X_views_mesh(_, S, I) \\ template ConstRowMatrixView<S> vertex_view(const SurfaceMesh<S, I>& mesh); LA_SURFACE_MESH_X ( views_mesh , 0 ) Note that while the new polygonal mesh class is using explicit template instantiation to facilitate compilation, at the time most of Lagrange is still header-only and relying on our legacy mesh data structure. Thus overall compilation times still have room for improvement. \u21a9","title":"Mesh Class"},{"location":"user/core/mesh/#mesh-class","text":"Attention Since v6.0.0, Lagrange introduced a new polygonal mesh class that is meant to replace the original mesh class used throughout Lagrange. While currently few of the Lagrange functions use this new mesh class, over time old and new features will transition to use this new data structure. The SurfaceMesh class is the new generic mesh class in Lagrange to represent meshes. It is a very generic class that supports triangle meshes, quad meshes, as well as quad-dominant and arbitrary polygonal meshes. This new data structure was designed with a couple of key features in mind: Generic and powerful API : A generic mesh API that works in 2D, 3D, ND with triangles/quad/hybrid meshes using the same SurfaceMesh type. A simple API based on std::span<> (pointer + size). This avoids a lot of header-only template shenanigans, while providing a low-overhead but secure interface to manipulate continuous buffers. Clean headers : The main SurfaceMesh.h header only pulls a few STL headers ( <memory> , <string_view> , <span> and <functional> -- the last one can be avoided easily). A separate header views.h allows to \"view\" mesh buffers as Eigen matrices (e.g., for easy interfacing with libigl ). A separate header foreach_attributes.h provides utility functions to iterate over mesh attributes. Efficient memory usage : Generic copy-on-write mesh attributes (per vertex, facet, edge, etc.). Efficient memory storage: a pure triangle/quad meshes only needs 2 buffers for vertex positions and facet indices, while hybrid meshes will use an additional offset buffer. Mesh attributes can wrap external buffers (including const buffers), as long as memory layout is compatible. Policies determine write/growth behavior. Mesh attributes can be exported in a std::shared_ptr<> to be transferred back to client code. Dynamic editing capabilities : Mesh vertices and facets can be dynamically inserted and removed efficiently. Powerful attribute system : Generic attribute system supporting any fixed-size integer types ( int8_t ... uint64_t ) and floating point types ( float , double ). Attributes can be attached to any mesh element (vertex, facet, edge, corner), or can indexed by a secondary buffer (e.g. UVs). Usage tag specifies how attributes are used and transformed (e.g. Color, Normals, UV, etc.). Optional edge/connectivity attributes : Mesh edges can be numbered automatically, or based on a user-provided ordering. Connectivity attributes allow efficient navigation around mesh elements (similar to half-edges). Fast compilation times 1 : Clean separation between class declaration/definition allows for faster build times. Explicit template instantiation is used to limit available types usable with our SurfaceMesh<> and Attribute<> class. X macros are used to facilitate explicit template instantiation of predetermined types (can be used by client code). Extensive documentation Complete user guide (this document) Full Doxygen API reference.","title":"Mesh Class"},{"location":"user/core/mesh/#mesh-representation","text":"At the core, our mesh data structure is just a collection of mesh elements (vertices, facets, edges, corners), where each element is attached a number of attributes . Specifically, we define the following elements: Vertices : Points used to form the facets of the mesh. Typically associated with a 2D or 3D position attribute. Facets : Polygons formed by connecting mesh vertices together. In a triangle mesh, all facets are 3-gons. Edges : Edges are formed by unordered pairs of consecutive vertices in a mesh facet. The set of mesh edges is defined implicitly from the mesh facets. See Mesh Edges for more details. Corners : Facet corner elements can be used to reference vertices in a specific facet. Corners from the same facets are indexed contiguously in a flat list containing all facet corners. Our mesh data structure is very generic, and can represent any kind of polygonal mesh, non-manifold surface, mesh containing isolated vertices, point clouds, etc.","title":"Mesh Representation"},{"location":"user/core/mesh/#terminology","text":"Regular mesh : In the context of this documentation, a regular mesh is a mesh whose facets have the same constant size . E.g. a triangle mesh is a regular mesh (facet size = 3). So is a quad mesh (facet size = 4), a pentagonal mesh, etc. Hybrid mesh : A hybrid mesh is a mesh whose facets may have varying sizes. E.g. a quad dominant mesh is a hybrid mesh. Vertex valence : Number of facet corners pointing to a given vertex (repeated vertex indices in a degenerate facet will count multiple times towards the vertex valence). Facet size : Number of corners/vertices in a facet. Currently we require facet sizes to be > 2, but this restriction will be lifted in a future version (supporting facets of size 1 and 2). A hybrid mesh will store an additional \"offset\" attribute for each facet, to determine where each facet starts/ends in the attribute buffer storing vertex indices. Offset Indices In the following mesh, facets [f0, f1, f2] have an \"offset\" attribute of [0, 3, 7] . This means that the first corner of f0 is c0 , the first corner of f1 is c3 , etc. The size of a facet can be computed from the difference between two consecutive offsets.","title":"Terminology"},{"location":"user/core/mesh/#adding-verticesfacets","text":"Simple version: lagrange :: SurfaceMesh < Scalar , Index > mesh ; mesh . add_vertices ( 10 ); // adds 10 vertices with 0-initialized coordinates mesh . add_triangles ( 3 ); // adds 3 triangles with 0-initialized vertex indices mesh . add_quads ( 2 ); // adds 2 quads with 0-initialized vertex vertices Another example: lagrange :: SurfaceMesh < Scalar , Index > mesh ; mesh . add_vertex ({ 0.5 , 0.2 , 0.9 }); // adds a vertex at (0.5, 0.2, 0.9) mesh . add_triangle ( 1 , 3 , 4 ); // adds triangle (v1, v3, v3) mesh . add_quad ( 1 , 3 , 4 , 2 ); // adds quad (v1, v3, v4, v2) mesh . add_polygon ({ 1 , 3 , 4 , 2 , 5 }); // adds polygon (v1, v3, v4, v2, v5) To create a mesh from an existing buffer (with copy): std :: vector < Scalar > vertices ; // flat buffer of size N x 3 std :: vector < Index > facets ; // flat buffer of size M x 3 // ... fill up vertices/facets ... Index num_vertices = Index ( vertices . size ()) / 3 ; Index num_facets = Index ( facets . size ()) / 3 ; lagrange :: SurfaceMesh < Scalar , Index > mesh ; mesh . add_vertices ( num_vertices , vertices ); mesh . add_triangles ( num_facets , facets ); Note that any continuous buffer of the appropriate size will work. If your input buffer is of type std::vector<std::array<Scalar, 3>> , you will need to convert the pointer: std :: vector < std :: array < Scalar , 3 >> vertices ; lagrange :: SurfaceMesh < Scalar , Index > mesh ; mesh . add_vertices ( Index ( vertices . size ()), { vertices . empty () ? nullptr : vertices [ 0 ]. data (), 3 * vertices . size ()}); You can add multiple polygonal facets with different sizes in the same function call by using the add_hybrid() method. While this method can take an existing buffer as input, it may be simpler to use it via user-defined callbacks: lagrange :: SurfaceMesh < Scalar , Index > mesh ; std :: mt19937 gen ; std :: uniform_int_distribution < Index > random_facet_size ( 3 , 6 ); std :: uniform_int_distribution < Index > random_vertex_index ( 0 , 9 ); std :: uniform_real_distribution < Scalar > random_position ( 0 , 1 ); mesh . add_vertices ( 10 , [ & ]( Index , lagrange :: span < Scalar > p ) { p [ 0 ] = random_position ( gen ); p [ 1 ] = random_position ( gen ); p [ 2 ] = random_position ( gen ); }); mesh . add_hybrid ( 4 , // The first callback determines the degree of facet `f` [ & ]( Index f ) { return random_facet_size ( gen ); }, // The second callback sets the mapping corner id -> vertex id for facet `f` [ & ]( Index f , lagrange :: span < Index > t ) { for ( Index i = 0 ; i < t . size (); ++ i ) { // Assign a random vertex id to each facet corner t [ i ] = random_vertex_index ( gen ); } });","title":"Adding Vertices/Facets"},{"location":"user/core/mesh/#removing-verticesfacets","text":"Batch Removal Only Currently, we only support efficient batch removal of vertices/facets. This is because removing any mesh element will cause reindexing of all mesh attributes referencing a mesh element (e.g. vertex indices). To allow for \"lazy\" deletion, you can use an attribute to keep track of \"deleted\" vertices/facets until you actually clean them up. An element removal is a O(|V| + |F|) operation. To remove a list of vertices/facets: lagrange :: SurfaceMesh < Scalar , Index > mesh ; mesh . add_vertices ( 20 ); mesh . add_triangles ( 12 ); // Remove vertices v2, v5 and v9 mesh . remove_vertices ({ 2 , 5 , 9 }); // Remove facets v6, v2 and v8 mesh . remove_facets ({ 6 , 2 , 8 }); Alternatively, you can use a filter returning a boolean value to determine the vertices/facets to remove: lagrange :: SurfaceMesh < Scalar , Index > mesh ; mesh . add_vertices ( 20 ); mesh . add_triangles ( 12 ); // Remove vertices with even index mesh . remove_vertices ([]( Index v ) { return ( v % 2 == 0 ); }); // Remove random facets std :: mt19937 gen ; std :: uniform_int_distribution < int > flip_coin ( 0 , 1 ); mesh . remove_facets ([ & ]( Index f ) { return flip_coin ( gen ) == 1 ; }); Vertex Removal Removing a vertex will automatically remove any facet containing that vertex! Facet Removal Removing a facet will not automatically remove any incident vertex. You can end up with floating/isolated vertices after facet removal. Consider filtering them as a post-processing.","title":"Removing Vertices/Facets"},{"location":"user/core/mesh/#copy-on-write","text":"All mesh data is stored in an Attribute object, including vertex positions, facet indices, etc. These mesh attributes are handled via a copy-on-write mechanism, meaning that copying a mesh is a cheap operation by default: no buffer is actually duplicated until you start writing to it. For this reason, we distinguish most accessors between getters and setters : Getters start with get_xxx() and provide read-only access to an attribute data. They will not cause any copy. Setters start with ref_xxx() and will cause an immediate buffer copy if the buffer is not uniquely owned (i.e. there are more than 1 object referencing the same buffer). Note that both getters and setters are safe to use concurrently . Please read our \"note on thread-safety\" for more information. See below for a short example: lagrange :: SurfaceMesh < Scalar , Index > mesh ; // ... Fill up mesh ... lagrange :: SurfaceMesh < Scalar , Index > copy = mesh ; // Writable reference to a vertex auto p = copy . ref_position ( 1 ); // <-- leads to a copy of the vertex buffer p [ 0 ] = 0.1 ; p [ 1 ] = 0.2 ; p [ 2 ] = 0.3 ; // Now vertices v1 are different std :: equal ( mesh . get_position ( 1 ). begin (), mesh . get_position ( 1 ). end (), copy . get_position ( 1 ). begin ()); // --> false // The pointers to the vertex positions are now different mesh . get_vertex_to_position (). get_all (). data () == copy . get_vertex_to_position (). get_all (). data (); // --> false // But the pointers to the facet indices are still the same mesh . get_corner_to_vertex (). get_all (). data () == copy . get_corner_to_vertex (). get_all (). data (); // --> true","title":"Copy-On-Write"},{"location":"user/core/mesh/#eigen-matrix-views","text":"Mesh attributes such as positions and facet indices can be views as Eigen matrices. Specifically, we provide read-only views as Eigen::Map<const ...> : #include <lagrange/SurfaceMesh.h> #include <lagrange/views.h> #include <igl/massmatrix.h> lagrange :: SurfaceMesh < Scalar , Index > mesh ; // Fill up mesh data... // With ADL, no need to prefix by lagrange:: auto V_view = vertex_view ( mesh ); auto F_view = facet_view ( mesh ); // Call your favorite libigl function Eigen :: SparseMatrix < Scalar > M ; igl :: massmatrix ( V_view , F_view , igl :: MASSMATRIX_TYPE_VORONOI , M ); Writable reference are also available: // Writable reference, creates a copy if buffer is not uniquely owned auto V_ref = vertex_ref ( mesh ); auto F_ref = facet_ref ( mesh ); // Center mesh around vertex barycenter V_ref . rowwise () -= V_ref . colwise (). mean (); Regular Meshes Vs Hybrid Meshes On hybrid meshes, it is not possible to \"view\" facet indices as a 2D matrix. This is because each \"row\" of the matrix would have a variable width, due to the varying facet sizes. For this reason, trying to get a facet_view() on a hybrid mesh will throw a runtime exception.","title":"Eigen Matrix Views"},{"location":"user/core/mesh/#mesh-edges","text":"By default, a mesh object is very lightweight, and does not compute edge ids or connectivity information. If this information is desirable, it is possible to compute it by calling the initialize_edges() method: lagrange :: SurfaceMesh < Scalar , Index > mesh ; mesh . add_vertices ( 10 ); mesh . add_triangle ( 0 , 1 , 2 ); mesh . add_quad ( 1 , 3 , 4 , 2 ); mesh . add_polygon ({ 0 , 2 , 4 , 5 , 6 }); // Let Lagrange assign an id to each edge mesh . initialize_edges (); // ... // Once edge data is no longer needed, clear related mesh attributes: mesh . clear_edges (); In practice, edge and connectivity data are stored as special mesh attributes, which can be accessed/edited like any other mesh attribute! If a specific ordering of the mesh edges is desired, provide it to the initialize_edges() method: // Explicit edge id -> vertex ids mapping const std :: vector < std :: array < Index , 2 >> edges = { { 0 , 1 }, { 1 , 3 }, { 3 , 4 }, { 4 , 5 }, { 5 , 6 }, { 6 , 0 }, { 1 , 2 }, { 2 , 0 }, { 2 , 4 }, }; // Passed to the mesh via a std::span<> mesh . initialize_edges ({ & edges [ 0 ][ 0 ], 2 * edges . size ()}); Redundant Initialization If a mesh already contains edges information, mesh.initialize_edges() will not do anything. If you want to reorder existing edges, please clear edge attributes first, and re-initialize mesh edges.","title":"Mesh Edges"},{"location":"user/core/mesh/#connectivity-and-navigation","text":"Initializing mesh edges will also equip the mesh with connectivity information. This allows you to navigate around mesh elements such as vertices and facets. To navigate around a given element, use the foreach_xxx_around_xxx() functions: lagrange :: SurfaceMesh < Scalar , Index > mesh ; // Fill up mesh... // Compute vertex valence std :: vector < Index > vertex_valence ( mesh . get_num_vertices (), 0 ); for ( Index v = 0 ; v < mesh . get_num_vertices (); ++ v ) { mesh . foreach_facet_around_vertex ( v , [ & ]( Index f ) { ++ vertex_valence [ v ]; }); } In the example above, we could have use the method count_num_corners_around_vertex() to compute vertex valence directly. See SurfaceMesh class documentation for a full reference. Degenerate Facets If a mesh facet is degenerate, and references the same vertex several time (e.g. facet f2 = (0, 1, 1) ), then mesh.foreach_facet_around_vertex(1) will call the facet f2 twice. Edges Around A Vertex To iterate over the edges incident to a given vertex, you will notice that we only provide a single method foreach_edge_around_vertex_with_duplicates() . This method will call the callback function repeatedly for each facet which contains an incident edge to the prescribed vertex. Non-Manifold Surfaces Our mesh navigation methods support any type of non-manifold meshes. This is in contrast with some type of half-edge data structures which assume manifold surfaces.","title":"Connectivity And Navigation"},{"location":"user/core/mesh/#half-edges","text":"There is a natural correspondence between the usual half-edge notion and a facet corner (see figure below). While Lagrange currently does not offer half-edge data-structure for mesh navigation, corner indices can be used to navigate around mesh elements the same way a half-edge data structure does. Half-edges can be identified with their equivalent facet corners. Twin Half-Edge To implement the twin(h_i) operation, you can use SurfaceMesh::get_next_corner_around_edge() . In the future we may add a half-edge \"proxy\" structure to facilitate mesh navigation.","title":"Half-Edges"},{"location":"user/core/mesh/#template-parameters","text":"While our SurfaceMesh<> class is templated by both a Scalar and Index type, we only actually support a finite set of template parameters. Specifically: Scalar can only be float or double . Index can only be uint32_t or uint64_t . We provide the following type aliases for convenience: Alias Actual Type SurfaceMesh32f SurfaceMesh<float, uint32_t> SurfaceMesh32d SurfaceMesh<double, uint32_t> SurfaceMesh64f SurfaceMesh<float, uint64_t> SurfaceMesh64d SurfaceMesh<double, uint64_t> Writing Functions Taking SurfaceMesh As Parameter To write a function taking a SurfaceMesh<> as a parameter, you can use our X macros to explicitly instantiate a templated function with the supported mesh types. For example, the vertex_view() function is instantiated as follows: //////////////// // In views.h // //////////////// template < typename S , typename I > ConstRowMatrixView < S > vertex_view ( const SurfaceMesh < S , I >& mesh ); ////////////////// // In views.cpp // ////////////////// template < typename S , typename I > ConstRowMatrixView < S > vertex_view ( const SurfaceMesh < S , I >& mesh ) { // Function definition return {}; } // Explicit template instantiation #define LA_X_views_mesh(_, S, I) \\ template ConstRowMatrixView<S> vertex_view(const SurfaceMesh<S, I>& mesh); LA_SURFACE_MESH_X ( views_mesh , 0 ) Note that while the new polygonal mesh class is using explicit template instantiation to facilitate compilation, at the time most of Lagrange is still header-only and relying on our legacy mesh data structure. Thus overall compilation times still have room for improvement. \u21a9","title":"Template Parameters"},{"location":"user/core/utility-functions/","text":"Utility Functions Logging Lagrange uses spdlog for logging purposes. Spdlog provides feature-rich formatting via the excellent fmt library. This provides several advantages over a traditional std::cout messaging: Python-like formatting syntax improves code readability 6 levels of logging: trace, debug, info, warn, error, critical Fast, thread-safe formatting Multiple sinks (file, stdout, etc.) The default Lagrange logger can be accessed as follows: #include <lagrange/Logger.h> lagrange :: logger (). debug ( \"This mesh has {} vertices and {} facets\" , v , f ); To control the logging level, or set additional sinks (e.g. to write logs to a file), please read the spdlog documentation. A common pattern we use in example applications is to set the logging level/sink via command-line arguments. E.g. using CLI11 to parse cli args: struct { std :: string log_file ; int log_level = 2 ; } args ; // Parse command-line args with CLI11 CLI :: App app { argv [ 0 ]}; app . option_defaults () -> always_capture_default (); app . add_flag ( \"-q,--quiet\" , args . quiet , \"Hide logger on stdout.\" ); app . add_option ( \"-l,--level\" , args . log_level , \"Log level (0 = most verbose, 6 = off).\" ); app . add_option ( \"-f,--log-file\" , args . log_file , \"Log file.\" ); CLI11_PARSE ( app , argc , argv ) if ( args . quiet ) { // Hide stdout default sink lagrange :: logger (). sinks (). clear (); } if ( ! args . log_file . empty ()) { // Add a new file sink lagrange :: logger (). sinks (). emplace_back ( std :: make_shared < spdlog :: sinks :: basic_file_sink_mt > ( args . log_file , true )); } // Set log level args . log_level = std :: max ( 0 , std :: min ( 6 , args . log_level )); spdlog :: set_level ( static_cast < spdlog :: level :: level_enum > ( args . log_level )); Timing Lagrange provides handy timing functions based on modern C++'s chrono package. Here is an example use case: #include <lagrange/timing.h> auto start_time = lagrange :: get_timestamp (); ... auto finish_time = lagrange :: get_timestamp (); auto duration = timestamp_diff_in_seconds ( start_time , finish_time ); lagrange :: logger (). info ( \"Duration: {}s\" , s ); Assertion Lagrange provide two types of assertion macros: Runtime assertions , using la_runtime_assert(). Those are used to check the validity of user inputs as a pre-condition to a function. For example, providing a function with an empty, or a mesh with incorrect dimension, could result in such an assertion being raised. A runtime assert is executed even in Release configuration, and indicates a problem with the function input. Debug assertions using la_debug_assert() . Those are only checked in debug code (macro NDEBUG is undefined). A debug assert is used to check internal code validity, and should not be triggered under any circumstance by client code. A failed debug assert indicates an error in the programmer's code, and should be fixed accordingly. Usage In Expressions Our assert macros behave as functions, meaning they expand to a void expression and can be used in an expression such as y = (la_debug_assert(true), x) . Our assertion macros can take either 1 or 2 arguments, the second argument being an optional error message. To conveniently format assertion messages with a printf-like syntax, use fmt::format : #include <lagrange/utils/assert.h> #include <spdlog/fmt/fmt.h> la_debug_assert ( x == 3 ); la_debug_assert ( x == 3 , \"Error message\" ); la_debug_assert ( x == 3 , fmt :: format ( \"Incorrect value of x: {}\" , x )); It is possible to have assert macros break into the debugger upon failure. To do that, enable the CMake option LAGRANGE_ASSERT_DEBUG_BREAK when compiling Lagrange into your project. Type Cast It is often necessary to cast a variable from one type to another. To ensure such cast is safe, Lagrange provides an explicit casting function: #include <lagrange/utils/safe_cast.h> // Cast variable y into variable x of type `type1` type1 x = lagrange :: safe_cast < type1 > ( y ); Implementation details: safe_cast checks for type compatibility, sign consistency and truncation error. We recommended to use code that avoids casting in the first place. Pointer Type Conversion It often necessary to convert a std::unique_ptr to std::shared_ptr . Lagrange provide a handy function that avoid repeated type specification: #include <lagrange/common.h> std :: unqiue_ptr < T > unique_val = ...; auto shared_val == lagrange :: to_shared_ptr ( unique_val ); assert ( unique_val == nullptr ); assert ( shared_val . use_count () == 1 ); Range Legacy Mesh Only The section below only applies to our legacy Mesh data structure. Lagrange provides a handy range function to enable a python-like range-based for loop: #include <lagrange/range.h> for ( auto i : lagrange :: range ( num_vertices )) { // i goes from 0 to num_vertices-1 } The advantage of using range() is that the type of the index variable i is automatically inferred from the type of num_vertices . This reduces the amount of unnecessary implicit casts and compiler warnings. Another useful function is row_range() to iterate through rows of a matrix: #include <lagrange/range.h> Eigen :: MatrixXd M ( m , n ); for ( const auto & row : row_range ( M )) { // row loops through rows of M. } Lagrange also provide range_sparse() to loop through an active subset of the range: #include <lagrange/range.h> std :: vector < Index > active_set ; // Populate active_set... (optional) for ( auto i : lagrange :: range_sparse ( N , active_set )) { // i will loop through only the active entries. } If active_set is empty, range_sparse(N, active_set) will loop from 0 to N (same behavior as range(N) ). However, if active_set is non-empty, range_sparse(N, active_set) will loop through the entries of active_set . Additional handy methods include: // Same as range(mesh->get_num_vertices()) lagrange :: range_vertices ( mesh ) // Same as range(mesh->get_num_facets()) lagrange :: range_facets ( mesh ) // Iterate active_set if non-empty. // If active_set is empty, behavior is the same as // range_vertices(mesh) or // range_facets(mesh) lagrange :: range_vertices ( mesh , active_set ) lagrange :: range_facets ( mesh , active_set )","title":"Utility Functions"},{"location":"user/core/utility-functions/#utility-functions","text":"","title":"Utility Functions"},{"location":"user/core/utility-functions/#logging","text":"Lagrange uses spdlog for logging purposes. Spdlog provides feature-rich formatting via the excellent fmt library. This provides several advantages over a traditional std::cout messaging: Python-like formatting syntax improves code readability 6 levels of logging: trace, debug, info, warn, error, critical Fast, thread-safe formatting Multiple sinks (file, stdout, etc.) The default Lagrange logger can be accessed as follows: #include <lagrange/Logger.h> lagrange :: logger (). debug ( \"This mesh has {} vertices and {} facets\" , v , f ); To control the logging level, or set additional sinks (e.g. to write logs to a file), please read the spdlog documentation. A common pattern we use in example applications is to set the logging level/sink via command-line arguments. E.g. using CLI11 to parse cli args: struct { std :: string log_file ; int log_level = 2 ; } args ; // Parse command-line args with CLI11 CLI :: App app { argv [ 0 ]}; app . option_defaults () -> always_capture_default (); app . add_flag ( \"-q,--quiet\" , args . quiet , \"Hide logger on stdout.\" ); app . add_option ( \"-l,--level\" , args . log_level , \"Log level (0 = most verbose, 6 = off).\" ); app . add_option ( \"-f,--log-file\" , args . log_file , \"Log file.\" ); CLI11_PARSE ( app , argc , argv ) if ( args . quiet ) { // Hide stdout default sink lagrange :: logger (). sinks (). clear (); } if ( ! args . log_file . empty ()) { // Add a new file sink lagrange :: logger (). sinks (). emplace_back ( std :: make_shared < spdlog :: sinks :: basic_file_sink_mt > ( args . log_file , true )); } // Set log level args . log_level = std :: max ( 0 , std :: min ( 6 , args . log_level )); spdlog :: set_level ( static_cast < spdlog :: level :: level_enum > ( args . log_level ));","title":"Logging"},{"location":"user/core/utility-functions/#timing","text":"Lagrange provides handy timing functions based on modern C++'s chrono package. Here is an example use case: #include <lagrange/timing.h> auto start_time = lagrange :: get_timestamp (); ... auto finish_time = lagrange :: get_timestamp (); auto duration = timestamp_diff_in_seconds ( start_time , finish_time ); lagrange :: logger (). info ( \"Duration: {}s\" , s );","title":"Timing"},{"location":"user/core/utility-functions/#assertion","text":"Lagrange provide two types of assertion macros: Runtime assertions , using la_runtime_assert(). Those are used to check the validity of user inputs as a pre-condition to a function. For example, providing a function with an empty, or a mesh with incorrect dimension, could result in such an assertion being raised. A runtime assert is executed even in Release configuration, and indicates a problem with the function input. Debug assertions using la_debug_assert() . Those are only checked in debug code (macro NDEBUG is undefined). A debug assert is used to check internal code validity, and should not be triggered under any circumstance by client code. A failed debug assert indicates an error in the programmer's code, and should be fixed accordingly. Usage In Expressions Our assert macros behave as functions, meaning they expand to a void expression and can be used in an expression such as y = (la_debug_assert(true), x) . Our assertion macros can take either 1 or 2 arguments, the second argument being an optional error message. To conveniently format assertion messages with a printf-like syntax, use fmt::format : #include <lagrange/utils/assert.h> #include <spdlog/fmt/fmt.h> la_debug_assert ( x == 3 ); la_debug_assert ( x == 3 , \"Error message\" ); la_debug_assert ( x == 3 , fmt :: format ( \"Incorrect value of x: {}\" , x )); It is possible to have assert macros break into the debugger upon failure. To do that, enable the CMake option LAGRANGE_ASSERT_DEBUG_BREAK when compiling Lagrange into your project.","title":"Assertion"},{"location":"user/core/utility-functions/#type-cast","text":"It is often necessary to cast a variable from one type to another. To ensure such cast is safe, Lagrange provides an explicit casting function: #include <lagrange/utils/safe_cast.h> // Cast variable y into variable x of type `type1` type1 x = lagrange :: safe_cast < type1 > ( y ); Implementation details: safe_cast checks for type compatibility, sign consistency and truncation error. We recommended to use code that avoids casting in the first place.","title":"Type Cast"},{"location":"user/core/utility-functions/#pointer-type-conversion","text":"It often necessary to convert a std::unique_ptr to std::shared_ptr . Lagrange provide a handy function that avoid repeated type specification: #include <lagrange/common.h> std :: unqiue_ptr < T > unique_val = ...; auto shared_val == lagrange :: to_shared_ptr ( unique_val ); assert ( unique_val == nullptr ); assert ( shared_val . use_count () == 1 );","title":"Pointer Type Conversion"},{"location":"user/core/utility-functions/#range","text":"Legacy Mesh Only The section below only applies to our legacy Mesh data structure. Lagrange provides a handy range function to enable a python-like range-based for loop: #include <lagrange/range.h> for ( auto i : lagrange :: range ( num_vertices )) { // i goes from 0 to num_vertices-1 } The advantage of using range() is that the type of the index variable i is automatically inferred from the type of num_vertices . This reduces the amount of unnecessary implicit casts and compiler warnings. Another useful function is row_range() to iterate through rows of a matrix: #include <lagrange/range.h> Eigen :: MatrixXd M ( m , n ); for ( const auto & row : row_range ( M )) { // row loops through rows of M. } Lagrange also provide range_sparse() to loop through an active subset of the range: #include <lagrange/range.h> std :: vector < Index > active_set ; // Populate active_set... (optional) for ( auto i : lagrange :: range_sparse ( N , active_set )) { // i will loop through only the active entries. } If active_set is empty, range_sparse(N, active_set) will loop from 0 to N (same behavior as range(N) ). However, if active_set is non-empty, range_sparse(N, active_set) will loop through the entries of active_set . Additional handy methods include: // Same as range(mesh->get_num_vertices()) lagrange :: range_vertices ( mesh ) // Same as range(mesh->get_num_facets()) lagrange :: range_facets ( mesh ) // Iterate active_set if non-empty. // If active_set is empty, behavior is the same as // range_vertices(mesh) or // range_facets(mesh) lagrange :: range_vertices ( mesh , active_set ) lagrange :: range_facets ( mesh , active_set )","title":"Range"},{"location":"user/ui/components/","text":"Components Entities can have several components that define their behavior. Here is a list of the common components used throughout Lagrange UI. Name Subclassed std::string . Acts as a display name. Will be shown in UI if it exists, otherwise a generated name will be used. Does not have to be unique. Transform Contains local and global transformations and a viewport transform. // Translates entity one unit in X direction ui :: Transform & transform = registry . get < ui :: Transform > ( e ); transform . local = Eigen :: Translation3f ( 1 , 0 , 0 ); Global transformation is recomputed after each Simulation step. Only change the local transform. Tree Defines scene tree relationship. Data is stored using parent , first_child , previous_sibling and next_sibling entity IDs. Use helper functions to query or change the tree structure, do not change directly (unless you know what you're doing). //Orphans entity and parents it under new_parent ui :: reparent ( registry , entity , new_parent ); //Applies lambda to each direct child entity of parent ui :: foreach_child ( registry , parent , []( Entity child ){ //... }); //Applies lambda to each child entity of parent, recursively ui :: foreach_child_recursive ( registry , parent , []( Entity child ){ //... }); //In-order traversal of scene tree ui :: iterate_inorder ( registry , root , []( Entity current ){ //On Enter //Return true to continue to traverse children return true ; },[]( Entity current ){ //On Exit }); // See utils/treenode.h for more details MeshGeometry Contains reference to geometry entity MeshGeometry mg ; mg . entity = .. Hovered and Selected These components acts as flags whether the entity is hovered or selected respectively. Useful helper functions bool is_selected ( Registry & registry , Entity e ); bool is_hovered ( Registry & registry , Entity e ); bool select ( Registry & registry , Entity e ); bool deselect ( Registry & registry , Entity e ); std :: vector < Entity > collect_selected ( const Registry & registry ); std :: vector < Entity > collect_hovered ( const Registry & registry ); //See `utils/selection.h` for details Layer There are 256 layers an entity can belong to. The Layer component specifies which layers the entity belongs to. Entity can belong to several layers at once. There are several default layers: ui::DefaultLayers::Default - everything belongs to it by default ui::DefaultLayers::Selection - selected entities ui::DefaultLayers::Hover - hovered entities Default constructed Layer component belongs to ui::DefaultLayers::Default . You can register your own layer by calling ui :: LayerIndex layer_index = ui :: register_layer_name ( r , \"my layer name\" ); There are several utility functions for working with layers: void add_to_layer ( Registry & , Entity e , LayerIndex index ); void remove_from_layer ( Registry & , Entity e , LayerIndex index ); bool is_in_layer ( Registry & , Entity e , LayerIndex index ); bool is_in_any_layers ( Registry & , Entity e , Layer layers_bitset ); bool is_visible_in ( const Registry & , Entity e , const Layer & visible_layers , const Layer & hidden_layers ); UIPanel See User Interface page . ViewportComponent See Viewports page","title":"Components"},{"location":"user/ui/components/#components","text":"Entities can have several components that define their behavior. Here is a list of the common components used throughout Lagrange UI.","title":"Components"},{"location":"user/ui/components/#name","text":"Subclassed std::string . Acts as a display name. Will be shown in UI if it exists, otherwise a generated name will be used. Does not have to be unique.","title":"Name"},{"location":"user/ui/components/#transform","text":"Contains local and global transformations and a viewport transform. // Translates entity one unit in X direction ui :: Transform & transform = registry . get < ui :: Transform > ( e ); transform . local = Eigen :: Translation3f ( 1 , 0 , 0 ); Global transformation is recomputed after each Simulation step. Only change the local transform.","title":"Transform"},{"location":"user/ui/components/#tree","text":"Defines scene tree relationship. Data is stored using parent , first_child , previous_sibling and next_sibling entity IDs. Use helper functions to query or change the tree structure, do not change directly (unless you know what you're doing). //Orphans entity and parents it under new_parent ui :: reparent ( registry , entity , new_parent ); //Applies lambda to each direct child entity of parent ui :: foreach_child ( registry , parent , []( Entity child ){ //... }); //Applies lambda to each child entity of parent, recursively ui :: foreach_child_recursive ( registry , parent , []( Entity child ){ //... }); //In-order traversal of scene tree ui :: iterate_inorder ( registry , root , []( Entity current ){ //On Enter //Return true to continue to traverse children return true ; },[]( Entity current ){ //On Exit }); // See utils/treenode.h for more details","title":"Tree"},{"location":"user/ui/components/#meshgeometry","text":"Contains reference to geometry entity MeshGeometry mg ; mg . entity = ..","title":"MeshGeometry"},{"location":"user/ui/components/#hovered-and-selected","text":"These components acts as flags whether the entity is hovered or selected respectively. Useful helper functions bool is_selected ( Registry & registry , Entity e ); bool is_hovered ( Registry & registry , Entity e ); bool select ( Registry & registry , Entity e ); bool deselect ( Registry & registry , Entity e ); std :: vector < Entity > collect_selected ( const Registry & registry ); std :: vector < Entity > collect_hovered ( const Registry & registry ); //See `utils/selection.h` for details","title":"Hovered and Selected"},{"location":"user/ui/components/#layer","text":"There are 256 layers an entity can belong to. The Layer component specifies which layers the entity belongs to. Entity can belong to several layers at once. There are several default layers: ui::DefaultLayers::Default - everything belongs to it by default ui::DefaultLayers::Selection - selected entities ui::DefaultLayers::Hover - hovered entities Default constructed Layer component belongs to ui::DefaultLayers::Default . You can register your own layer by calling ui :: LayerIndex layer_index = ui :: register_layer_name ( r , \"my layer name\" ); There are several utility functions for working with layers: void add_to_layer ( Registry & , Entity e , LayerIndex index ); void remove_from_layer ( Registry & , Entity e , LayerIndex index ); bool is_in_layer ( Registry & , Entity e , LayerIndex index ); bool is_in_any_layers ( Registry & , Entity e , Layer layers_bitset ); bool is_visible_in ( const Registry & , Entity e , const Layer & visible_layers , const Layer & hidden_layers );","title":"Layer"},{"location":"user/ui/components/#uipanel","text":"See User Interface page .","title":"UIPanel"},{"location":"user/ui/components/#viewportcomponent","text":"See Viewports page","title":"ViewportComponent"},{"location":"user/ui/customizing/","text":"Customizing Lagrange UI Warning This page is under construction In the meantime, refer to files named default_{} to see how the UI registers the default types and functionality. Components You may add any time of component using registry.emplace<ComponentType>(entity) . However to enable more advanced features, you may register the components in the UI: register_component<T> - enables reflection - enables runtime add/clone/move of com ponents register_component_widget<T> - defines ImGui code to render - enables drag-and-drop Tools TBD register_element_type<E> (Object/Facet/Edge/Vertex/...) register_tool<E,T> (Select/Translate/Rotate/Scale/...) Geometry Lagrange meshes must be registered to work. By default, only the TriangleMesh3Df and TriangleMesh3D are registered. ui::register_mesh_type<MeshType>() Rendering Shader and Material properties Material properties can be defined in the shader using the following syntax: #pragma property NAME \"DISPLAY NAME\" TYPE(DEFAULT VALUE AND/OR RANGE) [TAG1, TAG2] For example: //Defines a 2D texture property with the default value of rgba(0.7,0.7,0.7,1) if no texture is bound #pragma property material_base_color \"Base Color\" Texture2D(0.7,0.7,0.7,1) //Defines a 2D texture property with the default value of red=0.4 if no texture is bound #pragma property material_roughness \"Roughness\" Texture2D(0.4) //Defines a 2D texture property with the default value of red=0.1 if no texture is bound #pragma property material_metallic \"Metallic\" Texture2D(0.1) //Defines a 2D texture property that is to be interpreted as normal texture #pragma property material_normal \"Normal\" Texture2D [normal] //Defines a float property, with the default value of 1 and range 0,1 #pragma property material_opacity \"Opacity\" float(1,0,1) The pragmas are parsed whenever a shader is loaded and replaced with: uniform TYPE NAME = DEFAULT_VALUE In case of Texture2D , these uniforms are generated: uniform sampler2D NAME ; uniform bool NAME_texture_bound = false ; uniform VEC_TYPE NAME_default_value = DEFAULT_VALUE ;","title":"Customizing Lagrange UI"},{"location":"user/ui/customizing/#customizing-lagrange-ui","text":"Warning This page is under construction In the meantime, refer to files named default_{} to see how the UI registers the default types and functionality.","title":"Customizing Lagrange UI"},{"location":"user/ui/customizing/#components","text":"You may add any time of component using registry.emplace<ComponentType>(entity) . However to enable more advanced features, you may register the components in the UI: register_component<T> - enables reflection - enables runtime add/clone/move of com ponents register_component_widget<T> - defines ImGui code to render - enables drag-and-drop","title":"Components"},{"location":"user/ui/customizing/#tools","text":"TBD register_element_type<E> (Object/Facet/Edge/Vertex/...) register_tool<E,T> (Select/Translate/Rotate/Scale/...)","title":"Tools"},{"location":"user/ui/customizing/#geometry","text":"Lagrange meshes must be registered to work. By default, only the TriangleMesh3Df and TriangleMesh3D are registered. ui::register_mesh_type<MeshType>()","title":"Geometry"},{"location":"user/ui/customizing/#rendering","text":"","title":"Rendering"},{"location":"user/ui/customizing/#shader-and-material-properties","text":"Material properties can be defined in the shader using the following syntax: #pragma property NAME \"DISPLAY NAME\" TYPE(DEFAULT VALUE AND/OR RANGE) [TAG1, TAG2] For example: //Defines a 2D texture property with the default value of rgba(0.7,0.7,0.7,1) if no texture is bound #pragma property material_base_color \"Base Color\" Texture2D(0.7,0.7,0.7,1) //Defines a 2D texture property with the default value of red=0.4 if no texture is bound #pragma property material_roughness \"Roughness\" Texture2D(0.4) //Defines a 2D texture property with the default value of red=0.1 if no texture is bound #pragma property material_metallic \"Metallic\" Texture2D(0.1) //Defines a 2D texture property that is to be interpreted as normal texture #pragma property material_normal \"Normal\" Texture2D [normal] //Defines a float property, with the default value of 1 and range 0,1 #pragma property material_opacity \"Opacity\" float(1,0,1) The pragmas are parsed whenever a shader is loaded and replaced with: uniform TYPE NAME = DEFAULT_VALUE In case of Texture2D , these uniforms are generated: uniform sampler2D NAME ; uniform bool NAME_texture_bound = false ; uniform VEC_TYPE NAME_default_value = DEFAULT_VALUE ;","title":"Shader and Material properties"},{"location":"user/ui/ecs/","text":"Entity Component System (Ecs) For more information about the ECS architecture, see: What you need to know about ECS for quick overview Overwatch Gameplay Architecture - GDC Talk for a good example of usage and design considerations. entt Crash Course for overview of the underlying entt library ECS Back and Forth for more details about ECS design, in particular hierarchies Unity ECS documentation for Unity's version of ECS Registry The Viewer uses a Registry (alias for entt::registry ) to store all entities and their data. To manipulate entities and their components directly, use the object: auto & registry = viewer . registry (); Viewer class exposes API that simplifies interaction with the Registry , e.g. Viewer::show_mesh . Entity Unique identifier - it's just that. It's used to identify a unique \"object\" or \"entity\". Lagrange UI defines a Entity alias. Internally implemented as std::uint32_t . To create a new entity, use: Entity new_entity = registry . create (); To destroy: registry . destroy ( entity ); Components Any data that is attached to an Entity . Uniquely identified by template typename <T> and Entity . Components don't have logic, that means no code . They only store data and implicitly define behavior. Ideally, the components should be structs with no functions. However, it may be beneficial to have setters/getters as member functions in some cases. To attach a component of type MyComponent to an entity : // When it doesn't exist registry . emplace < MyComponent > ( entity , MyComponent ( 42 )) // When it might exist already registry . emplace_or_replace < MyComponent > ( entity , MyComponent ( 42 )) To retrieve a component: // If it exists already MyComponent & c = registry . get < MyComponent > ( entity ); // If you're not sure it exists MyComponent * c = registry . try_get < MyComponent > ( entity ); //or if ( registry . has < MyComponent > ()){ MyComponent & c = registry . get < MyComponent > ( entity ); } Tag Components \"Empty\" components may be used to tag entities, e.g. Selected , Hovered , etc. These types however must have non-zero size: struct Hidden { bool dummy ; } Systems Systems are the logic of the application. They are defined as functions that iterate over entities that have specified components only. For example, running this system: registry . view < Velocity , Position > (). each ([]( Entity e , Velocity & velocity , Transform & transform ){ transform . local = Eigen :: Translation3f ( velocity ) * transform . local ; }); will iterate over all entities that have both Velocity and Transform and apply the velocity vector to the transform. Lagrange UI defines System as alias to std::function<void(Registry&)> , that is, a function that does something with the Registry . Typically these will be defined as: System my_system = []( Registry & w ){ w . view < Component1 , Component2 , ... > . each ([]( Entity e , Component1 & c1 , Component2 & c2 , ...){ // }); }; Context Variables Systems do not have data . However, it's often useful to have some state associated with a given system, e.g. for caching. Sometimes it's useful that this state be shared among several systems. Instead of storing this state in some single instance of a component, we can use context variables. These can be thought of as singleton components - only one instance of a Type can exist at a given time. InputState is such a singleton component. At the beginning of the frame, it is filled with key/mouse information, including last mouse position, mouse delta, active keybinds, etc.: void update_input_system ( Registry & registry ){ InputState & input_state = registry . ctx_or_set < InputState > (); input_state . mouse_pos = ... input_state . mouse_delta = ... input_state . keybinds . update (...); } It can then be used by any other system down the line: void print_mouse_position ( Registry & registry ){ const auto & input_state = registry . ctx < InputState > (); lagrange :: logger (). info ( \"Mouse position: {}\" , input_state . mouse_pos ); } Design Considerations Rules to follow when designing components and systems: Components have no functions, only data Systems have no data State associated with systems is stored as context variable ( registry.ctx<T>() )","title":"Entity Component System"},{"location":"user/ui/ecs/#entity-component-system-ecs","text":"For more information about the ECS architecture, see: What you need to know about ECS for quick overview Overwatch Gameplay Architecture - GDC Talk for a good example of usage and design considerations. entt Crash Course for overview of the underlying entt library ECS Back and Forth for more details about ECS design, in particular hierarchies Unity ECS documentation for Unity's version of ECS","title":"Entity Component System (Ecs)"},{"location":"user/ui/ecs/#registry","text":"The Viewer uses a Registry (alias for entt::registry ) to store all entities and their data. To manipulate entities and their components directly, use the object: auto & registry = viewer . registry (); Viewer class exposes API that simplifies interaction with the Registry , e.g. Viewer::show_mesh .","title":"Registry"},{"location":"user/ui/ecs/#entity","text":"Unique identifier - it's just that. It's used to identify a unique \"object\" or \"entity\". Lagrange UI defines a Entity alias. Internally implemented as std::uint32_t . To create a new entity, use: Entity new_entity = registry . create (); To destroy: registry . destroy ( entity );","title":"Entity"},{"location":"user/ui/ecs/#components","text":"Any data that is attached to an Entity . Uniquely identified by template typename <T> and Entity . Components don't have logic, that means no code . They only store data and implicitly define behavior. Ideally, the components should be structs with no functions. However, it may be beneficial to have setters/getters as member functions in some cases. To attach a component of type MyComponent to an entity : // When it doesn't exist registry . emplace < MyComponent > ( entity , MyComponent ( 42 )) // When it might exist already registry . emplace_or_replace < MyComponent > ( entity , MyComponent ( 42 )) To retrieve a component: // If it exists already MyComponent & c = registry . get < MyComponent > ( entity ); // If you're not sure it exists MyComponent * c = registry . try_get < MyComponent > ( entity ); //or if ( registry . has < MyComponent > ()){ MyComponent & c = registry . get < MyComponent > ( entity ); }","title":"Components"},{"location":"user/ui/ecs/#tag-components","text":"\"Empty\" components may be used to tag entities, e.g. Selected , Hovered , etc. These types however must have non-zero size: struct Hidden { bool dummy ; }","title":"Tag Components"},{"location":"user/ui/ecs/#systems","text":"Systems are the logic of the application. They are defined as functions that iterate over entities that have specified components only. For example, running this system: registry . view < Velocity , Position > (). each ([]( Entity e , Velocity & velocity , Transform & transform ){ transform . local = Eigen :: Translation3f ( velocity ) * transform . local ; }); will iterate over all entities that have both Velocity and Transform and apply the velocity vector to the transform. Lagrange UI defines System as alias to std::function<void(Registry&)> , that is, a function that does something with the Registry . Typically these will be defined as: System my_system = []( Registry & w ){ w . view < Component1 , Component2 , ... > . each ([]( Entity e , Component1 & c1 , Component2 & c2 , ...){ // }); };","title":"Systems"},{"location":"user/ui/ecs/#context-variables","text":"Systems do not have data . However, it's often useful to have some state associated with a given system, e.g. for caching. Sometimes it's useful that this state be shared among several systems. Instead of storing this state in some single instance of a component, we can use context variables. These can be thought of as singleton components - only one instance of a Type can exist at a given time. InputState is such a singleton component. At the beginning of the frame, it is filled with key/mouse information, including last mouse position, mouse delta, active keybinds, etc.: void update_input_system ( Registry & registry ){ InputState & input_state = registry . ctx_or_set < InputState > (); input_state . mouse_pos = ... input_state . mouse_delta = ... input_state . keybinds . update (...); } It can then be used by any other system down the line: void print_mouse_position ( Registry & registry ){ const auto & input_state = registry . ctx < InputState > (); lagrange :: logger (). info ( \"Mouse position: {}\" , input_state . mouse_pos ); }","title":"Context Variables"},{"location":"user/ui/ecs/#design-considerations","text":"Rules to follow when designing components and systems: Components have no functions, only data Systems have no data State associated with systems is stored as context variable ( registry.ctx<T>() )","title":"Design Considerations"},{"location":"user/ui/examples/","text":"Examples Refer to modules/ui/examples . Build Lagrange with -DLAGRANGE_EXAMPLES=On .","title":"Examples"},{"location":"user/ui/examples/#examples","text":"Refer to modules/ui/examples . Build Lagrange with -DLAGRANGE_EXAMPLES=On .","title":"Examples"},{"location":"user/ui/lights/","text":"Lights Image Based Lighting Refer to ui/utils/ibl.h for all IBL utility functions and ui/components/IBL.h for the IBL component. Loading/Generating IBL //From disk file ui :: IBL ibl = ui :: generate_ibl ( \"path.hdr\" ); //From texture std :: shared_ptr < ui :: Texture > texture ; ui :: IBL ibl = ui :: generate_ibl ( texture ); Adding IBL to scene ui :: IBL ibl = ...; Entity ibl_entity = ui :: add_ibl ( registry , ibl ); Changing IBL options //Get IBL (if there are multiple, the first one is returned) ui :: IBL & ibl = * ui :: get_ibl ( registry ); // Blur the IBL (number corresponds to mip map level) ibl . blur = 2.0f ; // Disable rendering of the IBL image in the background // The IBL is still used for shading objects. ibl . show_skybox = false ; Analytic Lights Refer to ui/utils/lights.h for all light utility functions and ui/components/Light.h. for the Light component: // Omni-directional point light source Entity point_light = add_point_light ( registry , intensity , position ); // Directional light source at infinite distance Entity point_light = add_directional_light ( registry , intensity , direction ); // Light in a cone Entity spot_lighj = add_spot_light ( registry , intensity , position , direction , cone_angle_radians );","title":"Lights"},{"location":"user/ui/lights/#lights","text":"","title":"Lights"},{"location":"user/ui/lights/#image-based-lighting","text":"Refer to ui/utils/ibl.h for all IBL utility functions and ui/components/IBL.h for the IBL component.","title":"Image Based Lighting"},{"location":"user/ui/lights/#loadinggenerating-ibl","text":"//From disk file ui :: IBL ibl = ui :: generate_ibl ( \"path.hdr\" ); //From texture std :: shared_ptr < ui :: Texture > texture ; ui :: IBL ibl = ui :: generate_ibl ( texture );","title":"Loading/Generating IBL"},{"location":"user/ui/lights/#adding-ibl-to-scene","text":"ui :: IBL ibl = ...; Entity ibl_entity = ui :: add_ibl ( registry , ibl );","title":"Adding IBL to scene"},{"location":"user/ui/lights/#changing-ibl-options","text":"//Get IBL (if there are multiple, the first one is returned) ui :: IBL & ibl = * ui :: get_ibl ( registry ); // Blur the IBL (number corresponds to mip map level) ibl . blur = 2.0f ; // Disable rendering of the IBL image in the background // The IBL is still used for shading objects. ibl . show_skybox = false ;","title":"Changing IBL options"},{"location":"user/ui/lights/#analytic-lights","text":"Refer to ui/utils/lights.h for all light utility functions and ui/components/Light.h. for the Light component: // Omni-directional point light source Entity point_light = add_point_light ( registry , intensity , position ); // Directional light source at infinite distance Entity point_light = add_directional_light ( registry , intensity , direction ); // Light in a cone Entity spot_lighj = add_spot_light ( registry , intensity , position , direction , cone_angle_radians );","title":"Analytic Lights"},{"location":"user/ui/mesh-visualization/","text":"Mesh Visualization Geometry loading and registration Loading mesh Creates and entity that represents the mesh. This entity is only a resource - it is not rendered. It can be referenced by components that need this geometry for rendering/picking/etc. These entities have MeshData component attached that contains a lagrange::MeshBase pointer. ui :: Entity mesh_from_disk = ui :: load_mesh ( registry , path ); ui :: Entity mesh_from_memory = ui :: register_mesh ( registry , lagrange :: create_sphere ()); Retrieving and interacting with the mesh To retrieve a mesh: MeshType & mesh = ui :: get_mesh < MeshType > ( registry , mesh_entity ); There are several methods that do not require the knowledge of the mesh type. These may however incur copy and conversion costs. RowMajorMatrixXf get_mesh_vertices ( const MeshData & d ); RowMajorMatrixXf get_mesh_facets ( const MeshData & d ); bool has_mesh_vertex_attribute ( const MeshData & d , const std :: string & name ); bool has_mesh_facet_attribute ( const MeshData & d , const std :: string & name ); ... RowMajorMatrixXf get_mesh_vertex_attribute ( const MeshData & d , const std :: string & name ); RowMajorMatrixXf get_mesh_facet_attribute ( const MeshData & d , const std :: string & name ); ... std :: optional < RayFacetHit > intersect_ray ( const MeshData & d , const Eigen :: Vector3f & origin , const Eigen :: Vector3f & dir ); ... Loading scene Loads a scene using Assimp. Creates a hierarchy of entities and loads meshes, materials and textures. Returns the top-level entity. ui :: Entity root = ui :: load_scene ( registry , path ); To iterate over the scene, see the Tree component . Adding geometry to scene Default Physically Based Render (PBR) Adds previously registered mesh geometry to the scene. This mesh will be rendered using PBR. ui :: Entity scene_object = ui :: show_mesh ( registry , mesh_entity ); Uses DefaultShaders::PBR shader. See Materials section to see how to control the appearance. Mesh visualizations Adds a visualization of a mesh. auto vertex_viz_entity = ui :: show_vertex_attribute ( registry , mesh_entity , attribute_name , glyph_type ); auto facet_viz_entity = ui :: show_facet_attribute ( registry , mesh_entity , attribute_name , glyph_type ); auto corner_viz_entity = ui :: show_corner_attribute ( registry , mesh_entity , attribute_name , glyph_type ); auto edge_viz_entity = ui :: show_edge_attribute ( registry , mesh_entity , attribute_name , glyph_type ); These functions will create a new scene object and render the supplied attribute using the selected glyph type. GlyphType::Surface Renders unshaded surface with color mapped from the supplied attribute. Supports attributes of dimension: 1, 2, 3, and 4. Normalization : The attribute value is automatically remapped to (0,1) range. To change the range, use ui::set_colormap_range Colormapping : By default, the attribute is interpreted as R, RG, RGB or RGBA value. To use different mapping, refer to Colormaps section. Colormaps If the glyph or shader supports colormapping, use the following function to set the colormap: To use on of the default colormaps: ui :: set_colormap ( registry , entity , ui :: generate_colormap ( ui :: colormap_magma )) Or generate your own ui :: set_colormap ( registry , entity , ui :: generate_colormap ([]( float t ){ return Color ( //... function of t from 0 to 1 ); })); Default colormaps: colormap_viridis colormap_magma colormap_plasma colormap_inferno colormap_turbo colormap_coolwarm Materials Any entity with MeshRender component has a Material associated with it ( MeshRender::material ). To get a reference to entity's material, use: std :: shared_ptr < Material > material_ptr = ui :: get_material ( r , entity_with_meshrender ); Similarly, you may set a new material: ui :: set_material ( r , entity_with_mesh_render , std :: make_shared < ui :: Material > ( r , DefaultShaders :: PBR ); Color/Texture Material Properties You may set colors and textures of materials using the following API: auto & material = * ui :: get_material ( r , entity_with_meshrender ); //Sets \"property name\" to a red color material . set_color ( \"property name\" , ui :: Color ( 1 , 0 , 0 )); //Sets \"texture name\" to texture loaded from file material . set_texture ( \"texture name\" , ui :: load_texture ( \"texture.jpg\" )); PBRMaterial For the default PBRMaterial , you may use aliases for the property names: //Uniform rgba color material . set_color ( PBRMaterial :: BaseColor , ui :: Color ( 1 , 0 , 0 , 1 )); //RGB(A) color/albedo texture material . set_texture ( PBRMaterial :: BaseColor , ui :: load_texture ( \"color.jpg\" )); //Normal texture (and texture only) material . set_texture ( PBRMaterial :: Normal , ui :: load_texture ( \"normal.jpg\" )); //Uniform roughness material . set_float ( PBRMaterial :: Roughness , 0.75f ); //Roughness texture material . set_texture ( PBRMaterial :: Roughness , ui :: load_texture ( \"metallic.jpg\" )); //Uniform roughness material . set_float ( PBRMaterial :: Metallic , 0.75f ); //Metallic texture material . set_texture ( PBRMaterial :: Metallic , ui :: load_texture ( \"metallic.jpg\" )); //Uniform opacity material . set_float ( PBRMaterial :: Opacity , 1.0f ); //Opacity texture material . set_texture ( PBRMaterial :: Opacity , ui :: load_texture ( \"opacity.jpg\" )); Rasterizer Properties To control OpenGl properties, you may following syntax: material . set_int ( RasterizerOptions :: PolygonMode , GL_LINE ); material . set_float ( RasterizerOptions :: PointSize , PointSize ); See <lagrange/ui/Shader.h> for a list of supported RasterizerOptions ; Custom Shader Properties You may set arbitrary int or float or Color or Texture to the material. It will be set as a shader uniform if it exists in the shader, otherwise there will be no effect.","title":"Mesh Visualization"},{"location":"user/ui/mesh-visualization/#mesh-visualization","text":"","title":"Mesh Visualization"},{"location":"user/ui/mesh-visualization/#geometry-loading-and-registration","text":"","title":"Geometry loading and registration"},{"location":"user/ui/mesh-visualization/#loading-mesh","text":"Creates and entity that represents the mesh. This entity is only a resource - it is not rendered. It can be referenced by components that need this geometry for rendering/picking/etc. These entities have MeshData component attached that contains a lagrange::MeshBase pointer. ui :: Entity mesh_from_disk = ui :: load_mesh ( registry , path ); ui :: Entity mesh_from_memory = ui :: register_mesh ( registry , lagrange :: create_sphere ());","title":"Loading mesh"},{"location":"user/ui/mesh-visualization/#retrieving-and-interacting-with-the-mesh","text":"To retrieve a mesh: MeshType & mesh = ui :: get_mesh < MeshType > ( registry , mesh_entity ); There are several methods that do not require the knowledge of the mesh type. These may however incur copy and conversion costs. RowMajorMatrixXf get_mesh_vertices ( const MeshData & d ); RowMajorMatrixXf get_mesh_facets ( const MeshData & d ); bool has_mesh_vertex_attribute ( const MeshData & d , const std :: string & name ); bool has_mesh_facet_attribute ( const MeshData & d , const std :: string & name ); ... RowMajorMatrixXf get_mesh_vertex_attribute ( const MeshData & d , const std :: string & name ); RowMajorMatrixXf get_mesh_facet_attribute ( const MeshData & d , const std :: string & name ); ... std :: optional < RayFacetHit > intersect_ray ( const MeshData & d , const Eigen :: Vector3f & origin , const Eigen :: Vector3f & dir ); ...","title":"Retrieving and interacting with the mesh"},{"location":"user/ui/mesh-visualization/#loading-scene","text":"Loads a scene using Assimp. Creates a hierarchy of entities and loads meshes, materials and textures. Returns the top-level entity. ui :: Entity root = ui :: load_scene ( registry , path ); To iterate over the scene, see the Tree component .","title":"Loading scene"},{"location":"user/ui/mesh-visualization/#adding-geometry-to-scene","text":"","title":"Adding geometry to scene"},{"location":"user/ui/mesh-visualization/#default-physically-based-render-pbr","text":"Adds previously registered mesh geometry to the scene. This mesh will be rendered using PBR. ui :: Entity scene_object = ui :: show_mesh ( registry , mesh_entity ); Uses DefaultShaders::PBR shader. See Materials section to see how to control the appearance.","title":"Default Physically Based Render (PBR)"},{"location":"user/ui/mesh-visualization/#mesh-visualizations","text":"Adds a visualization of a mesh. auto vertex_viz_entity = ui :: show_vertex_attribute ( registry , mesh_entity , attribute_name , glyph_type ); auto facet_viz_entity = ui :: show_facet_attribute ( registry , mesh_entity , attribute_name , glyph_type ); auto corner_viz_entity = ui :: show_corner_attribute ( registry , mesh_entity , attribute_name , glyph_type ); auto edge_viz_entity = ui :: show_edge_attribute ( registry , mesh_entity , attribute_name , glyph_type ); These functions will create a new scene object and render the supplied attribute using the selected glyph type.","title":"Mesh visualizations"},{"location":"user/ui/mesh-visualization/#glyphtypesurface","text":"Renders unshaded surface with color mapped from the supplied attribute. Supports attributes of dimension: 1, 2, 3, and 4. Normalization : The attribute value is automatically remapped to (0,1) range. To change the range, use ui::set_colormap_range Colormapping : By default, the attribute is interpreted as R, RG, RGB or RGBA value. To use different mapping, refer to Colormaps section.","title":"GlyphType::Surface"},{"location":"user/ui/mesh-visualization/#colormaps","text":"If the glyph or shader supports colormapping, use the following function to set the colormap: To use on of the default colormaps: ui :: set_colormap ( registry , entity , ui :: generate_colormap ( ui :: colormap_magma )) Or generate your own ui :: set_colormap ( registry , entity , ui :: generate_colormap ([]( float t ){ return Color ( //... function of t from 0 to 1 ); })); Default colormaps: colormap_viridis colormap_magma colormap_plasma colormap_inferno colormap_turbo colormap_coolwarm","title":"Colormaps"},{"location":"user/ui/mesh-visualization/#materials","text":"Any entity with MeshRender component has a Material associated with it ( MeshRender::material ). To get a reference to entity's material, use: std :: shared_ptr < Material > material_ptr = ui :: get_material ( r , entity_with_meshrender ); Similarly, you may set a new material: ui :: set_material ( r , entity_with_mesh_render , std :: make_shared < ui :: Material > ( r , DefaultShaders :: PBR );","title":"Materials"},{"location":"user/ui/mesh-visualization/#colortexture-material-properties","text":"You may set colors and textures of materials using the following API: auto & material = * ui :: get_material ( r , entity_with_meshrender ); //Sets \"property name\" to a red color material . set_color ( \"property name\" , ui :: Color ( 1 , 0 , 0 )); //Sets \"texture name\" to texture loaded from file material . set_texture ( \"texture name\" , ui :: load_texture ( \"texture.jpg\" ));","title":"Color/Texture Material Properties"},{"location":"user/ui/mesh-visualization/#pbrmaterial","text":"For the default PBRMaterial , you may use aliases for the property names: //Uniform rgba color material . set_color ( PBRMaterial :: BaseColor , ui :: Color ( 1 , 0 , 0 , 1 )); //RGB(A) color/albedo texture material . set_texture ( PBRMaterial :: BaseColor , ui :: load_texture ( \"color.jpg\" )); //Normal texture (and texture only) material . set_texture ( PBRMaterial :: Normal , ui :: load_texture ( \"normal.jpg\" )); //Uniform roughness material . set_float ( PBRMaterial :: Roughness , 0.75f ); //Roughness texture material . set_texture ( PBRMaterial :: Roughness , ui :: load_texture ( \"metallic.jpg\" )); //Uniform roughness material . set_float ( PBRMaterial :: Metallic , 0.75f ); //Metallic texture material . set_texture ( PBRMaterial :: Metallic , ui :: load_texture ( \"metallic.jpg\" )); //Uniform opacity material . set_float ( PBRMaterial :: Opacity , 1.0f ); //Opacity texture material . set_texture ( PBRMaterial :: Opacity , ui :: load_texture ( \"opacity.jpg\" ));","title":"PBRMaterial"},{"location":"user/ui/mesh-visualization/#rasterizer-properties","text":"To control OpenGl properties, you may following syntax: material . set_int ( RasterizerOptions :: PolygonMode , GL_LINE ); material . set_float ( RasterizerOptions :: PointSize , PointSize ); See <lagrange/ui/Shader.h> for a list of supported RasterizerOptions ;","title":"Rasterizer Properties"},{"location":"user/ui/mesh-visualization/#custom-shader-properties","text":"You may set arbitrary int or float or Color or Texture to the material. It will be set as a shader uniform if it exists in the shader, otherwise there will be no effect.","title":"Custom Shader Properties"},{"location":"user/ui/overview/","text":"UI Module Lagrange UI module is a mini 3D engine C++ library built on top of EnTT . Prerequistes Must have OpenGL 3.3 capable drivers and a windowing system (headless is not supported). To use the library, enable LAGRANGE_MODULE_UI in CMake and #include <lagrange/ui/UI.h> namespace ui = lagrange :: ui ; Overview Lagrange UI uses an Entity-Component-System (ECS) architecture: Entity is a unique identifier Components define data and behavior (but no logic) Systems define logic (but no data). See ECS implementation section for more information about ECS and how it's implemented in Lagrange UI. The underlying library for ECS is EnTT . The entry point to the library is the Viewer class. It instantiates a window and owns a Registry instance and Systems instance. Registry contains all the data (entities and components) and Systems contain all the behavior (sequence of functions that is called every frame). To start the UI: ui :: Viewer viewer ; viewer . run ([](){ //Main loop code }); //Or viewer . run ([]( ui :: Registry & r ){ //Main loop code return should_continue_running ; }); The API to interact with the UI follows the pattern: ui :: Entity entity = ui :: do_something ( registry , params ) SomeData & data = registry . get < SomeData > ( entity ); For example: //Loads mesh from path ui :: Entity mesh_geometry = ui :: load_mesh ( registry , path ); //Adds the mesh to scene ui :: Entity mesh_visualization = ui :: show_mesh ( registry , mesh_geometry ); //Retrieves Transform component of the visualized mesh Transform & transform = registry . get < Transform > ( mesh_visualization ); All entities and their components live in a Registry . To access/set/modify the entities and components, use the Viewer::registry() . auto & registry = viewer . registry (); auto entity = registry . create (); registry . emplace < MyPositionComponent > ( entity , MyPositionComponent ( 0 , 0 , 0 )); Note You can use Viewer class as an argument instead of Registry , e.g.: Viewer v ; auto mesh_geometry = ui :: load_mesh ( v , path ); Further Documentation Doxygen generated documentation","title":"Overview"},{"location":"user/ui/overview/#ui-module","text":"Lagrange UI module is a mini 3D engine C++ library built on top of EnTT .","title":"UI Module"},{"location":"user/ui/overview/#prerequistes","text":"Must have OpenGL 3.3 capable drivers and a windowing system (headless is not supported). To use the library, enable LAGRANGE_MODULE_UI in CMake and #include <lagrange/ui/UI.h> namespace ui = lagrange :: ui ;","title":"Prerequistes"},{"location":"user/ui/overview/#overview","text":"Lagrange UI uses an Entity-Component-System (ECS) architecture: Entity is a unique identifier Components define data and behavior (but no logic) Systems define logic (but no data). See ECS implementation section for more information about ECS and how it's implemented in Lagrange UI. The underlying library for ECS is EnTT . The entry point to the library is the Viewer class. It instantiates a window and owns a Registry instance and Systems instance. Registry contains all the data (entities and components) and Systems contain all the behavior (sequence of functions that is called every frame). To start the UI: ui :: Viewer viewer ; viewer . run ([](){ //Main loop code }); //Or viewer . run ([]( ui :: Registry & r ){ //Main loop code return should_continue_running ; }); The API to interact with the UI follows the pattern: ui :: Entity entity = ui :: do_something ( registry , params ) SomeData & data = registry . get < SomeData > ( entity ); For example: //Loads mesh from path ui :: Entity mesh_geometry = ui :: load_mesh ( registry , path ); //Adds the mesh to scene ui :: Entity mesh_visualization = ui :: show_mesh ( registry , mesh_geometry ); //Retrieves Transform component of the visualized mesh Transform & transform = registry . get < Transform > ( mesh_visualization ); All entities and their components live in a Registry . To access/set/modify the entities and components, use the Viewer::registry() . auto & registry = viewer . registry (); auto entity = registry . create (); registry . emplace < MyPositionComponent > ( entity , MyPositionComponent ( 0 , 0 , 0 )); Note You can use Viewer class as an argument instead of Registry , e.g.: Viewer v ; auto mesh_geometry = ui :: load_mesh ( v , path );","title":"Overview"},{"location":"user/ui/overview/#further-documentation","text":"Doxygen generated documentation","title":"Further Documentation"},{"location":"user/ui/user-interface/","text":"User Interface User Interface Panels UI Panels are implemented also as entities. Panels have the UIPanel component. The UIPanel components describes the ImGui information (panel title, position, etc.). To create a new UI panel: auto panel_entity = ui :: add_panel ( registry , \"Title of the panel\" ,[](){ // Do NOT call Imgui::Begin()/End() Imgui :: Text ( \"Hello world\" ); }); //or auto panel_entity = ui :: add_panel ( registry , \"Title of the panel\" , []( Registry & registry , Entity e ){ //Entity e is the panel_entity }); Example of multiple instances of a same \"type\" of panel: struct MyPanelState { int x = 0 ; } auto panel_fn = []( Registry & registry , Entity e ){ auto & state = registry . get_or_emplace < MyPanelState > ( e ); ImGui :: InputInt ( \"x\" , & state . x ); }; auto panel0 = ui :: add_panel ( registry , \"panel with x = 0\" , panel_fn ) registry . emplace < MyPanelState > ( panel0 , MyPanelState { 0 }) auto panel1 = ui :: add_panel ( registry , \"panel with x = 1\" , panel_fn ); registry . emplace < MyPanelState > ( panel1 , MyPanelState { 1 })","title":"User Interface"},{"location":"user/ui/user-interface/#user-interface","text":"","title":"User Interface"},{"location":"user/ui/user-interface/#user-interface-panels","text":"UI Panels are implemented also as entities. Panels have the UIPanel component. The UIPanel components describes the ImGui information (panel title, position, etc.). To create a new UI panel: auto panel_entity = ui :: add_panel ( registry , \"Title of the panel\" ,[](){ // Do NOT call Imgui::Begin()/End() Imgui :: Text ( \"Hello world\" ); }); //or auto panel_entity = ui :: add_panel ( registry , \"Title of the panel\" , []( Registry & registry , Entity e ){ //Entity e is the panel_entity }); Example of multiple instances of a same \"type\" of panel: struct MyPanelState { int x = 0 ; } auto panel_fn = []( Registry & registry , Entity e ){ auto & state = registry . get_or_emplace < MyPanelState > ( e ); ImGui :: InputInt ( \"x\" , & state . x ); }; auto panel0 = ui :: add_panel ( registry , \"panel with x = 0\" , panel_fn ) registry . emplace < MyPanelState > ( panel0 , MyPanelState { 0 }) auto panel1 = ui :: add_panel ( registry , \"panel with x = 1\" , panel_fn ); registry . emplace < MyPanelState > ( panel1 , MyPanelState { 1 })","title":"User Interface Panels"},{"location":"user/ui/viewports/","text":"Viewports Viewports are implemented as entities with ViewportComponent component. Those referenced in ViewportPanel are rendered to screen, otherwise they are rendered off-screen. There is always one focused ViewportPanel (identified by the context variable FocusedViewportPanel ). See components/Viewport.h and utils/viewport.h for utility functions related to viewport, viewport panels and cameras. Entity visibility Each ViewportComponent has visible_layers and hidden_layers that control which entities can be renderer in this viewport (see Layer component for details). The default viewport shows only DefaultLayers::DefaultLayer Multi viewport Additional viewports can be created by calling ui :: Entity camera_entity = add_camera ( ui :: Registry & , ui :: Camera camera ); // or use get_focused_camera_entity(ui::Registry &) to reuse current camera // Creates an offscreen viewport with the specified camera ui :: Entity viewport_entity = add_viewport ( ui :: Registry & , ui :: Entity camera_entity ) // Creates a UI panel that shows the viewport ui :: Entity viewport_entity = add_viewport_panel ( ui :: Registry & , const std :: string & name , ui :: Entity viewport_entity );","title":"Viewports"},{"location":"user/ui/viewports/#viewports","text":"Viewports are implemented as entities with ViewportComponent component. Those referenced in ViewportPanel are rendered to screen, otherwise they are rendered off-screen. There is always one focused ViewportPanel (identified by the context variable FocusedViewportPanel ). See components/Viewport.h and utils/viewport.h for utility functions related to viewport, viewport panels and cameras.","title":"Viewports"},{"location":"user/ui/viewports/#entity-visibility","text":"Each ViewportComponent has visible_layers and hidden_layers that control which entities can be renderer in this viewport (see Layer component for details). The default viewport shows only DefaultLayers::DefaultLayer","title":"Entity visibility"},{"location":"user/ui/viewports/#multi-viewport","text":"Additional viewports can be created by calling ui :: Entity camera_entity = add_camera ( ui :: Registry & , ui :: Camera camera ); // or use get_focused_camera_entity(ui::Registry &) to reuse current camera // Creates an offscreen viewport with the specified camera ui :: Entity viewport_entity = add_viewport ( ui :: Registry & , ui :: Entity camera_entity ) // Creates a UI panel that shows the viewport ui :: Entity viewport_entity = add_viewport_panel ( ui :: Registry & , const std :: string & name , ui :: Entity viewport_entity );","title":"Multi viewport"}]}
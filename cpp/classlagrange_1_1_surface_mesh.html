<!-- HTML header for doxygen 1.9.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lagrange: SurfaceMesh&lt; Scalar_, Index_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Lagrange
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classlagrange_1_1_surface_mesh.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classlagrange_1_1_surface_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SurfaceMesh&lt; Scalar_, Index_ &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__module-core.html">Core Module</a> &raquo; <a class="el" href="group__group-surfacemesh.html">SurfaceMesh</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A general purpose polygonal mesh class.  
 <a href="classlagrange_1_1_surface_mesh.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_surface_mesh_8h_source.html">lagrange/SurfaceMesh.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_surface_mesh_1_1_bare_mesh_tag.html">BareMeshTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload tag.  <a href="structlagrange_1_1_surface_mesh_1_1_bare_mesh_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_surface_mesh_1_1_reserved_attribute_ids.html">ReservedAttributeIds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserved attribute ids.  <a href="structlagrange_1_1_surface_mesh_1_1_reserved_attribute_ids.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6e7ee8ed1fabd5e89d353a7e9596009e"><td class="memItemLeft" align="right" valign="top"><a id="a6e7ee8ed1fabd5e89d353a7e9596009e" name="a6e7ee8ed1fabd5e89d353a7e9596009e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Scalar</b> = Scalar_</td></tr>
<tr class="memdesc:a6e7ee8ed1fabd5e89d353a7e9596009e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh scalar type, used for vertex coordinates. <br /></td></tr>
<tr class="separator:a6e7ee8ed1fabd5e89d353a7e9596009e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726cb631080e40f5e472e0c3f6e59eda"><td class="memItemLeft" align="right" valign="top"><a id="a726cb631080e40f5e472e0c3f6e59eda" name="a726cb631080e40f5e472e0c3f6e59eda"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Index</b> = Index_</td></tr>
<tr class="memdesc:a726cb631080e40f5e472e0c3f6e59eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh index type, used for facet indices. <br /></td></tr>
<tr class="separator:a726cb631080e40f5e472e0c3f6e59eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423755e96078d85e91c2a579dfa884a8"><td class="memItemLeft" align="right" valign="top"><a id="a423755e96078d85e91c2a579dfa884a8" name="a423755e96078d85e91c2a579dfa884a8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SignedIndex</b> = std::make_signed_t&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;</td></tr>
<tr class="memdesc:a423755e96078d85e91c2a579dfa884a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed index type corresponding to the mesh index type. <br /></td></tr>
<tr class="separator:a423755e96078d85e91c2a579dfa884a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a827e540de32adfb1615731db4bdc4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ad1a827e540de32adfb1615731db4bdc4">SetVertexCoordinatesFunction</a> = <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt; p)&gt;</td></tr>
<tr class="memdesc:ad1a827e540de32adfb1615731db4bdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function to set vertex coordinates.  <a href="classlagrange_1_1_surface_mesh.html#ad1a827e540de32adfb1615731db4bdc4">More...</a><br /></td></tr>
<tr class="separator:ad1a827e540de32adfb1615731db4bdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c4a35e4a6fdc126381b1d87fb4f925"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#af7c4a35e4a6fdc126381b1d87fb4f925">SetSingleFacetIndicesFunction</a> = <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; t)&gt;</td></tr>
<tr class="memdesc:af7c4a35e4a6fdc126381b1d87fb4f925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function to set indices of a single facet.  <a href="classlagrange_1_1_surface_mesh.html#af7c4a35e4a6fdc126381b1d87fb4f925">More...</a><br /></td></tr>
<tr class="separator:af7c4a35e4a6fdc126381b1d87fb4f925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110ca5c4b8ccc87ba99cb515e8dcf159"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a110ca5c4b8ccc87ba99cb515e8dcf159">SetMultiFacetsIndicesFunction</a> = <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> f, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; t)&gt;</td></tr>
<tr class="memdesc:a110ca5c4b8ccc87ba99cb515e8dcf159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function to set indices of a multiple facets.  <a href="classlagrange_1_1_surface_mesh.html#a110ca5c4b8ccc87ba99cb515e8dcf159">More...</a><br /></td></tr>
<tr class="separator:a110ca5c4b8ccc87ba99cb515e8dcf159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170c2bfbae529972c9db5de7025ab581"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a170c2bfbae529972c9db5de7025ab581">GetFacetsSizeFunction</a> = <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> f)&gt;</td></tr>
<tr class="memdesc:a170c2bfbae529972c9db5de7025ab581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function to get a facet size (number of vertices in the facet).  <a href="classlagrange_1_1_surface_mesh.html#a170c2bfbae529972c9db5de7025ab581">More...</a><br /></td></tr>
<tr class="separator:a170c2bfbae529972c9db5de7025ab581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0099ac3b79b3ecddccca10409e576f8f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a0099ac3b79b3ecddccca10409e576f8f">GetEdgeVertices</a> = <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; std::array&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>, 2 &gt;(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> e)&gt;</td></tr>
<tr class="memdesc:a0099ac3b79b3ecddccca10409e576f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function to get the vertex indices of an edge endpoints in a user-provided ordering of a mesh edges.  <a href="classlagrange_1_1_surface_mesh.html#a0099ac3b79b3ecddccca10409e576f8f">More...</a><br /></td></tr>
<tr class="separator:a0099ac3b79b3ecddccca10409e576f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a5b2d74a290276396c4528c5498f3ac"><td class="memTemplParams" colspan="2"><a id="a4a5b2d74a290276396c4528c5498f3ac" name="a4a5b2d74a290276396c4528c5498f3ac"></a>
template&lt;typename SourceScalar , typename SourceIndex &gt; </td></tr>
<tr class="memitem:a4a5b2d74a290276396c4528c5498f3ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; TargetScalar, TargetIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stripped_copy</b> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; SourceScalar, SourceIndex &gt; &amp;source_mesh)</td></tr>
<tr class="separator:a4a5b2d74a290276396c4528c5498f3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8ef940d2f665f3ccf5d03a3e7fd721"><td class="memTemplParams" colspan="2"><a id="a6e8ef940d2f665f3ccf5d03a3e7fd721" name="a6e8ef940d2f665f3ccf5d03a3e7fd721"></a>
template&lt;typename SourceScalar , typename SourceIndex &gt; </td></tr>
<tr class="memitem:a6e8ef940d2f665f3ccf5d03a3e7fd721"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; TargetScalar, TargetIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stripped_move</b> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; SourceScalar, SourceIndex &gt; &amp;&amp;source_mesh)</td></tr>
<tr class="separator:a6e8ef940d2f665f3ccf5d03a3e7fd721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mesh accessors</div></td></tr>
<tr class="memitem:a9cede937c41f63448522e8522f7d65a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a9cede937c41f63448522e8522f7d65a5">is_triangle_mesh</a> () const</td></tr>
<tr class="memdesc:a9cede937c41f63448522e8522f7d65a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the mesh <em>must</em> only contain triangular facets.  <a href="classlagrange_1_1_surface_mesh.html#a9cede937c41f63448522e8522f7d65a5">More...</a><br /></td></tr>
<tr class="separator:a9cede937c41f63448522e8522f7d65a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a85b726b7fde45bfec81127fc85c042"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a0a85b726b7fde45bfec81127fc85c042">is_quad_mesh</a> () const</td></tr>
<tr class="memdesc:a0a85b726b7fde45bfec81127fc85c042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the mesh <em>must</em> only contains quadrilateral facets.  <a href="classlagrange_1_1_surface_mesh.html#a0a85b726b7fde45bfec81127fc85c042">More...</a><br /></td></tr>
<tr class="separator:a0a85b726b7fde45bfec81127fc85c042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fe6c77afa1adfe15669fd0e1a492a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a83fe6c77afa1adfe15669fd0e1a492a4">is_regular</a> () const</td></tr>
<tr class="memdesc:a83fe6c77afa1adfe15669fd0e1a492a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the mesh <em>must</em> only contains facets of equal sizes.  <a href="classlagrange_1_1_surface_mesh.html#a83fe6c77afa1adfe15669fd0e1a492a4">More...</a><br /></td></tr>
<tr class="separator:a83fe6c77afa1adfe15669fd0e1a492a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab428865a842b8f10664c5ef5c6fb5bb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ab428865a842b8f10664c5ef5c6fb5bb8">is_hybrid</a> () const</td></tr>
<tr class="memdesc:ab428865a842b8f10664c5ef5c6fb5bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the mesh <em>may</em> contain facets of different sizes.  <a href="classlagrange_1_1_surface_mesh.html#ab428865a842b8f10664c5ef5c6fb5bb8">More...</a><br /></td></tr>
<tr class="separator:ab428865a842b8f10664c5ef5c6fb5bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf4bf7fff25304bc12204359cd593f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a2cf4bf7fff25304bc12204359cd593f8">get_dimension</a> () const</td></tr>
<tr class="memdesc:a2cf4bf7fff25304bc12204359cd593f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the dimension of the mesh vertices.  <a href="classlagrange_1_1_surface_mesh.html#a2cf4bf7fff25304bc12204359cd593f8">More...</a><br /></td></tr>
<tr class="separator:a2cf4bf7fff25304bc12204359cd593f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd39a328d5689f8b05c3f871079d77ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#abd39a328d5689f8b05c3f871079d77ce">get_vertex_per_facet</a> () const</td></tr>
<tr class="memdesc:abd39a328d5689f8b05c3f871079d77ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of vertex per facet in a regular mesh.  <a href="classlagrange_1_1_surface_mesh.html#abd39a328d5689f8b05c3f871079d77ce">More...</a><br /></td></tr>
<tr class="separator:abd39a328d5689f8b05c3f871079d77ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed57c732bcdb304ed7033147f5d9002"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a1ed57c732bcdb304ed7033147f5d9002">get_num_vertices</a> () const</td></tr>
<tr class="memdesc:a1ed57c732bcdb304ed7033147f5d9002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of vertices.  <a href="classlagrange_1_1_surface_mesh.html#a1ed57c732bcdb304ed7033147f5d9002">More...</a><br /></td></tr>
<tr class="separator:a1ed57c732bcdb304ed7033147f5d9002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf8a67369f4ebda946306ae39673d4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#abcf8a67369f4ebda946306ae39673d4a">get_num_facets</a> () const</td></tr>
<tr class="memdesc:abcf8a67369f4ebda946306ae39673d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of facets.  <a href="classlagrange_1_1_surface_mesh.html#abcf8a67369f4ebda946306ae39673d4a">More...</a><br /></td></tr>
<tr class="separator:abcf8a67369f4ebda946306ae39673d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4c8dc375784713f55d92df922f9f05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#afe4c8dc375784713f55d92df922f9f05">get_num_corners</a> () const</td></tr>
<tr class="memdesc:afe4c8dc375784713f55d92df922f9f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of corners.  <a href="classlagrange_1_1_surface_mesh.html#afe4c8dc375784713f55d92df922f9f05">More...</a><br /></td></tr>
<tr class="separator:afe4c8dc375784713f55d92df922f9f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b72663d159f5e5280c524fab4cebc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ab4b72663d159f5e5280c524fab4cebc3">get_num_edges</a> () const</td></tr>
<tr class="memdesc:ab4b72663d159f5e5280c524fab4cebc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of edges.  <a href="classlagrange_1_1_surface_mesh.html#ab4b72663d159f5e5280c524fab4cebc3">More...</a><br /></td></tr>
<tr class="separator:ab4b72663d159f5e5280c524fab4cebc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3c7ed82d37bd216c497a3aff3e6f3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#aff3c7ed82d37bd216c497a3aff3e6f3f">get_position</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v) const</td></tr>
<tr class="memdesc:aff3c7ed82d37bd216c497a3aff3e6f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a read-only pointer to a vertex coordinates.  <a href="classlagrange_1_1_surface_mesh.html#aff3c7ed82d37bd216c497a3aff3e6f3f">More...</a><br /></td></tr>
<tr class="separator:aff3c7ed82d37bd216c497a3aff3e6f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf830eab5e349aff1947a5f6f1c7bb5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#abf830eab5e349aff1947a5f6f1c7bb5c">ref_position</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v)</td></tr>
<tr class="memdesc:abf830eab5e349aff1947a5f6f1c7bb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a writeable pointer to a vertex coordinates.  <a href="classlagrange_1_1_surface_mesh.html#abf830eab5e349aff1947a5f6f1c7bb5c">More...</a><br /></td></tr>
<tr class="separator:abf830eab5e349aff1947a5f6f1c7bb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08dee4f91c8d35b17755d5020b11f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#af08dee4f91c8d35b17755d5020b11f70">get_facet_size</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> f) const</td></tr>
<tr class="memdesc:af08dee4f91c8d35b17755d5020b11f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of vertices in the facet.  <a href="classlagrange_1_1_surface_mesh.html#af08dee4f91c8d35b17755d5020b11f70">More...</a><br /></td></tr>
<tr class="separator:af08dee4f91c8d35b17755d5020b11f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aaa0edcdd05e7062a6e50b35d00ac53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a9aaa0edcdd05e7062a6e50b35d00ac53">get_facet_vertex</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> f, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> lv) const</td></tr>
<tr class="memdesc:a9aaa0edcdd05e7062a6e50b35d00ac53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of a vertex given from a facet + local index.  <a href="classlagrange_1_1_surface_mesh.html#a9aaa0edcdd05e7062a6e50b35d00ac53">More...</a><br /></td></tr>
<tr class="separator:a9aaa0edcdd05e7062a6e50b35d00ac53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d307d406c30a019e11e4bc4ae25fdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a62d307d406c30a019e11e4bc4ae25fdb">get_facet_corner_begin</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> f) const</td></tr>
<tr class="memdesc:a62d307d406c30a019e11e4bc4ae25fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">First corner around the facet.  <a href="classlagrange_1_1_surface_mesh.html#a62d307d406c30a019e11e4bc4ae25fdb">More...</a><br /></td></tr>
<tr class="separator:a62d307d406c30a019e11e4bc4ae25fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b66afb06f58353045a125bfacde0ed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a0b66afb06f58353045a125bfacde0ed3">get_facet_corner_end</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> f) const</td></tr>
<tr class="memdesc:a0b66afb06f58353045a125bfacde0ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index past the last corner around the facet.  <a href="classlagrange_1_1_surface_mesh.html#a0b66afb06f58353045a125bfacde0ed3">More...</a><br /></td></tr>
<tr class="separator:a0b66afb06f58353045a125bfacde0ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ece031d61939757b93e1e40098309b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a9ece031d61939757b93e1e40098309b8">get_corner_vertex</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> c) const</td></tr>
<tr class="memdesc:a9ece031d61939757b93e1e40098309b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the index of a vertex given its corner index.  <a href="classlagrange_1_1_surface_mesh.html#a9ece031d61939757b93e1e40098309b8">More...</a><br /></td></tr>
<tr class="separator:a9ece031d61939757b93e1e40098309b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b0cbb93871714a74f5177ddfdf089b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#aa9b0cbb93871714a74f5177ddfdf089b">get_corner_facet</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> c) const</td></tr>
<tr class="memdesc:aa9b0cbb93871714a74f5177ddfdf089b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the index of a facet given its corner index.  <a href="classlagrange_1_1_surface_mesh.html#aa9b0cbb93871714a74f5177ddfdf089b">More...</a><br /></td></tr>
<tr class="separator:aa9b0cbb93871714a74f5177ddfdf089b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae46ecc7ee5bfd74ed48a4666496d915"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#aae46ecc7ee5bfd74ed48a4666496d915">get_facet_vertices</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> f) const</td></tr>
<tr class="memdesc:aae46ecc7ee5bfd74ed48a4666496d915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a read-only pointer to a facet indices.  <a href="classlagrange_1_1_surface_mesh.html#aae46ecc7ee5bfd74ed48a4666496d915">More...</a><br /></td></tr>
<tr class="separator:aae46ecc7ee5bfd74ed48a4666496d915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2119d5a1f0b8196beff748b6768caf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a4c2119d5a1f0b8196beff748b6768caf">ref_facet_vertices</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> f)</td></tr>
<tr class="memdesc:a4c2119d5a1f0b8196beff748b6768caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a writable pointer to a facet indices.  <a href="classlagrange_1_1_surface_mesh.html#a4c2119d5a1f0b8196beff748b6768caf">More...</a><br /></td></tr>
<tr class="separator:a4c2119d5a1f0b8196beff748b6768caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Attribute construction</div></td></tr>
<tr class="memitem:a3e504cec2bcd421abd9b687024c35e11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a3e504cec2bcd421abd9b687024c35e11">get_attribute_id</a> (std::string_view name) const</td></tr>
<tr class="memdesc:a3e504cec2bcd421abd9b687024c35e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an attribute id given its name.  <a href="classlagrange_1_1_surface_mesh.html#a3e504cec2bcd421abd9b687024c35e11">More...</a><br /></td></tr>
<tr class="separator:a3e504cec2bcd421abd9b687024c35e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa87b8195ea787f9117193eb16a43f6"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a0aa87b8195ea787f9117193eb16a43f6">get_attribute_name</a> (<a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id) const</td></tr>
<tr class="memdesc:a0aa87b8195ea787f9117193eb16a43f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve attribute name from its id.  <a href="classlagrange_1_1_surface_mesh.html#a0aa87b8195ea787f9117193eb16a43f6">More...</a><br /></td></tr>
<tr class="separator:a0aa87b8195ea787f9117193eb16a43f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378678c13a2ce7be484f3f0034fd1100"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a378678c13a2ce7be484f3f0034fd1100"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a378678c13a2ce7be484f3f0034fd1100">create_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> element, size_t num_channels=1, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> usage=<a class="el" href="group__group-surfacemesh-attr.html#gga5a2f28c8b9e2f8fce6e70b2418c46e45a57dea6f5039281b7fee517fc43bf3110">AttributeUsage::Vector</a>, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const ValueType &gt; initial_values={}, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; initial_indices={}, <a class="el" href="group__group-surfacemesh-attr.html#ga809dfcec94612491ec5be8bb8614ceab">AttributeCreatePolicy</a> policy=<a class="el" href="group__group-surfacemesh-attr.html#gga809dfcec94612491ec5be8bb8614ceabafc443f72fcb562a73b40af34ddb599a3">AttributeCreatePolicy::ErrorIfReserved</a>)</td></tr>
<tr class="memdesc:a378678c13a2ce7be484f3f0034fd1100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new attribute and return the newly created attribute id.  <a href="classlagrange_1_1_surface_mesh.html#a378678c13a2ce7be484f3f0034fd1100">More...</a><br /></td></tr>
<tr class="separator:a378678c13a2ce7be484f3f0034fd1100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e44dd1284b49329da5d51a4db74cbbb"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a4e44dd1284b49329da5d51a4db74cbbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a4e44dd1284b49329da5d51a4db74cbbb">create_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> element, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> usage, size_t num_channels=1, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const ValueType &gt; initial_values={}, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; initial_indices={}, <a class="el" href="group__group-surfacemesh-attr.html#ga809dfcec94612491ec5be8bb8614ceab">AttributeCreatePolicy</a> policy=<a class="el" href="group__group-surfacemesh-attr.html#gga809dfcec94612491ec5be8bb8614ceabafc443f72fcb562a73b40af34ddb599a3">AttributeCreatePolicy::ErrorIfReserved</a>)</td></tr>
<tr class="memdesc:a4e44dd1284b49329da5d51a4db74cbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.Create a new attribute and return the newly created attribute id.  <a href="classlagrange_1_1_surface_mesh.html#a4e44dd1284b49329da5d51a4db74cbbb">More...</a><br /></td></tr>
<tr class="separator:a4e44dd1284b49329da5d51a4db74cbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae3cb86e951fb27826bc12d8018d03c"><td class="memTemplParams" colspan="2">template&lt;typename OtherScalar , typename OtherIndex &gt; </td></tr>
<tr class="memitem:a6ae3cb86e951fb27826bc12d8018d03c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a6ae3cb86e951fb27826bc12d8018d03c">create_attribute_from</a> (std::string_view name, const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; OtherScalar, OtherIndex &gt; &amp;source_mesh, std::string_view source_name={})</td></tr>
<tr class="memdesc:a6ae3cb86e951fb27826bc12d8018d03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an new attribute by creating a shallow copy of another mesh's attribute.  <a href="classlagrange_1_1_surface_mesh.html#a6ae3cb86e951fb27826bc12d8018d03c">More...</a><br /></td></tr>
<tr class="separator:a6ae3cb86e951fb27826bc12d8018d03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f51c7ce47c56fdd44ac7960044c277"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ad3f51c7ce47c56fdd44ac7960044c277"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ad3f51c7ce47c56fdd44ac7960044c277">wrap_as_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> element, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> usage, size_t num_channels, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; ValueType &gt; values_view)</td></tr>
<tr class="memdesc:ad3f51c7ce47c56fdd44ac7960044c277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a writable external buffer as a mesh attribute.  <a href="classlagrange_1_1_surface_mesh.html#ad3f51c7ce47c56fdd44ac7960044c277">More...</a><br /></td></tr>
<tr class="separator:ad3f51c7ce47c56fdd44ac7960044c277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48a4e34be13288053df2eda15989395"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ab48a4e34be13288053df2eda15989395"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ab48a4e34be13288053df2eda15989395">wrap_as_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> element, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> usage, size_t num_channels, <a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; ValueType &gt; shared_values)</td></tr>
<tr class="memdesc:ab48a4e34be13288053df2eda15989395"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classlagrange_1_1_surface_mesh.html#ab48a4e34be13288053df2eda15989395">More...</a><br /></td></tr>
<tr class="separator:ab48a4e34be13288053df2eda15989395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4273659a074810181638f86fbe4373c"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ab4273659a074810181638f86fbe4373c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ab4273659a074810181638f86fbe4373c">wrap_as_const_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> element, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> usage, size_t num_channels, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const ValueType &gt; values_view)</td></tr>
<tr class="memdesc:ab4273659a074810181638f86fbe4373c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a read-only external buffer as a mesh attribute.  <a href="classlagrange_1_1_surface_mesh.html#ab4273659a074810181638f86fbe4373c">More...</a><br /></td></tr>
<tr class="separator:ab4273659a074810181638f86fbe4373c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2305d56cb409f81da2e013d5d238cde9"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a2305d56cb409f81da2e013d5d238cde9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a2305d56cb409f81da2e013d5d238cde9">wrap_as_const_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> element, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> usage, size_t num_channels, <a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const ValueType &gt; shared_values)</td></tr>
<tr class="memdesc:a2305d56cb409f81da2e013d5d238cde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classlagrange_1_1_surface_mesh.html#a2305d56cb409f81da2e013d5d238cde9">More...</a><br /></td></tr>
<tr class="separator:a2305d56cb409f81da2e013d5d238cde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cb4ae7ef9528cff1f5baca53711e84"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ac0cb4ae7ef9528cff1f5baca53711e84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ac0cb4ae7ef9528cff1f5baca53711e84">wrap_as_indexed_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> usage, size_t num_values, size_t num_channels, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; ValueType &gt; values_view, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; indices_view)</td></tr>
<tr class="memdesc:ac0cb4ae7ef9528cff1f5baca53711e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a writable external buffer as a mesh attribute.  <a href="classlagrange_1_1_surface_mesh.html#ac0cb4ae7ef9528cff1f5baca53711e84">More...</a><br /></td></tr>
<tr class="separator:ac0cb4ae7ef9528cff1f5baca53711e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9436711cfb248b5dd05afdcaaa68bd"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a6d9436711cfb248b5dd05afdcaaa68bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a6d9436711cfb248b5dd05afdcaaa68bd">wrap_as_indexed_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> usage, size_t num_values, size_t num_channels, <a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; ValueType &gt; shared_values, <a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; shared_indices)</td></tr>
<tr class="memdesc:a6d9436711cfb248b5dd05afdcaaa68bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classlagrange_1_1_surface_mesh.html#a6d9436711cfb248b5dd05afdcaaa68bd">More...</a><br /></td></tr>
<tr class="separator:a6d9436711cfb248b5dd05afdcaaa68bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a6ea183121c7418e92814b6837f89a"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a85a6ea183121c7418e92814b6837f89a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a85a6ea183121c7418e92814b6837f89a">wrap_as_indexed_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> usage, size_t num_values, size_t num_channels, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; ValueType &gt; values_view, <a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; shared_indices)</td></tr>
<tr class="memdesc:a85a6ea183121c7418e92814b6837f89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classlagrange_1_1_surface_mesh.html#a85a6ea183121c7418e92814b6837f89a">More...</a><br /></td></tr>
<tr class="separator:a85a6ea183121c7418e92814b6837f89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e332144b414cb2964a7cc7d48ea485"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a75e332144b414cb2964a7cc7d48ea485"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a75e332144b414cb2964a7cc7d48ea485">wrap_as_indexed_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> usage, size_t num_values, size_t num_channels, <a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; ValueType &gt; shared_values, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; indices_view)</td></tr>
<tr class="memdesc:a75e332144b414cb2964a7cc7d48ea485"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classlagrange_1_1_surface_mesh.html#a75e332144b414cb2964a7cc7d48ea485">More...</a><br /></td></tr>
<tr class="separator:a75e332144b414cb2964a7cc7d48ea485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5334d560ab700341d3deec635520057d"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a5334d560ab700341d3deec635520057d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a5334d560ab700341d3deec635520057d">wrap_as_const_indexed_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> usage, size_t num_values, size_t num_channels, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const ValueType &gt; values_view, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; indices_view)</td></tr>
<tr class="memdesc:a5334d560ab700341d3deec635520057d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a read-only external buffer as a mesh attribute.  <a href="classlagrange_1_1_surface_mesh.html#a5334d560ab700341d3deec635520057d">More...</a><br /></td></tr>
<tr class="separator:a5334d560ab700341d3deec635520057d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067454a184b992240f45d8006095d8d3"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a067454a184b992240f45d8006095d8d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a067454a184b992240f45d8006095d8d3">wrap_as_const_indexed_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> usage, size_t num_values, size_t num_channels, <a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const ValueType &gt; shared_values, <a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; shared_indices)</td></tr>
<tr class="memdesc:a067454a184b992240f45d8006095d8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classlagrange_1_1_surface_mesh.html#a067454a184b992240f45d8006095d8d3">More...</a><br /></td></tr>
<tr class="separator:a067454a184b992240f45d8006095d8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb2dd6cc67c86e3a1ba0813b8152e53"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a2fb2dd6cc67c86e3a1ba0813b8152e53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a2fb2dd6cc67c86e3a1ba0813b8152e53">wrap_as_const_indexed_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> usage, size_t num_values, size_t num_channels, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const ValueType &gt; values_view, <a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; shared_indices)</td></tr>
<tr class="memdesc:a2fb2dd6cc67c86e3a1ba0813b8152e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classlagrange_1_1_surface_mesh.html#a2fb2dd6cc67c86e3a1ba0813b8152e53">More...</a><br /></td></tr>
<tr class="separator:a2fb2dd6cc67c86e3a1ba0813b8152e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076065d5ad8d9f55d2202bc6d24c2c44"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a076065d5ad8d9f55d2202bc6d24c2c44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a076065d5ad8d9f55d2202bc6d24c2c44">wrap_as_const_indexed_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> usage, size_t num_values, size_t num_channels, <a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const ValueType &gt; shared_values, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; indices_view)</td></tr>
<tr class="memdesc:a076065d5ad8d9f55d2202bc6d24c2c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classlagrange_1_1_surface_mesh.html#a076065d5ad8d9f55d2202bc6d24c2c44">More...</a><br /></td></tr>
<tr class="separator:a076065d5ad8d9f55d2202bc6d24c2c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c6f796ec0588302d42ff96970f1bc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ab8c6f796ec0588302d42ff96970f1bc5">wrap_as_vertices</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt; vertices_view, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_vertices)</td></tr>
<tr class="memdesc:ab8c6f796ec0588302d42ff96970f1bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a writable external buffer as mesh vertices coordinates.  <a href="classlagrange_1_1_surface_mesh.html#ab8c6f796ec0588302d42ff96970f1bc5">More...</a><br /></td></tr>
<tr class="separator:ab8c6f796ec0588302d42ff96970f1bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adc9389ef36d420240e577577a11a52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a4adc9389ef36d420240e577577a11a52">wrap_as_vertices</a> (<a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt; shared_vertices, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_vertices)</td></tr>
<tr class="memdesc:a4adc9389ef36d420240e577577a11a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classlagrange_1_1_surface_mesh.html#a4adc9389ef36d420240e577577a11a52">More...</a><br /></td></tr>
<tr class="separator:a4adc9389ef36d420240e577577a11a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9990f194f65dc11e3a36c687864d8976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a9990f194f65dc11e3a36c687864d8976">wrap_as_const_vertices</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt; vertices_view, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_vertices)</td></tr>
<tr class="memdesc:a9990f194f65dc11e3a36c687864d8976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a read-only external buffer as mesh vertices coordinates.  <a href="classlagrange_1_1_surface_mesh.html#a9990f194f65dc11e3a36c687864d8976">More...</a><br /></td></tr>
<tr class="separator:a9990f194f65dc11e3a36c687864d8976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7452ff5d1a16457fa73ac93fa960cb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#af7452ff5d1a16457fa73ac93fa960cb7">wrap_as_const_vertices</a> (<a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt; shared_vertices, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_vertices)</td></tr>
<tr class="memdesc:af7452ff5d1a16457fa73ac93fa960cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classlagrange_1_1_surface_mesh.html#af7452ff5d1a16457fa73ac93fa960cb7">More...</a><br /></td></tr>
<tr class="separator:af7452ff5d1a16457fa73ac93fa960cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70fd65a58e6c322cc359577bdf31712"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ae70fd65a58e6c322cc359577bdf31712">wrap_as_facets</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facets_view, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> vertex_per_facet)</td></tr>
<tr class="memdesc:ae70fd65a58e6c322cc359577bdf31712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a writable external buffer as mesh facets for a regular mesh.  <a href="classlagrange_1_1_surface_mesh.html#ae70fd65a58e6c322cc359577bdf31712">More...</a><br /></td></tr>
<tr class="separator:ae70fd65a58e6c322cc359577bdf31712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b5e5cb618233cdbc97a19927e39ea5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a58b5e5cb618233cdbc97a19927e39ea5">wrap_as_facets</a> (<a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; shared_facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> vertex_per_facet)</td></tr>
<tr class="memdesc:a58b5e5cb618233cdbc97a19927e39ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classlagrange_1_1_surface_mesh.html#a58b5e5cb618233cdbc97a19927e39ea5">More...</a><br /></td></tr>
<tr class="separator:a58b5e5cb618233cdbc97a19927e39ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4345e9a203bea515b2290275a5faac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a9b4345e9a203bea515b2290275a5faac">wrap_as_const_facets</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facets_view, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> vertex_per_facet)</td></tr>
<tr class="memdesc:a9b4345e9a203bea515b2290275a5faac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a read-only external buffer as mesh facets for a regular mesh.  <a href="classlagrange_1_1_surface_mesh.html#a9b4345e9a203bea515b2290275a5faac">More...</a><br /></td></tr>
<tr class="separator:a9b4345e9a203bea515b2290275a5faac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50dffcd12ebdbbdbd73cdbac3a35f29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#af50dffcd12ebdbbdbd73cdbac3a35f29">wrap_as_const_facets</a> (<a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; shared_facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> vertex_per_facet)</td></tr>
<tr class="memdesc:af50dffcd12ebdbbdbd73cdbac3a35f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classlagrange_1_1_surface_mesh.html#af50dffcd12ebdbbdbd73cdbac3a35f29">More...</a><br /></td></tr>
<tr class="separator:af50dffcd12ebdbbdbd73cdbac3a35f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b89a6d10eee2400c2ca3d1c32dcf01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a52b89a6d10eee2400c2ca3d1c32dcf01">wrap_as_facets</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; offsets_view, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facets_view, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_corners)</td></tr>
<tr class="memdesc:a52b89a6d10eee2400c2ca3d1c32dcf01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps writable external buffers as mesh facets for a hybrid mesh.  <a href="classlagrange_1_1_surface_mesh.html#a52b89a6d10eee2400c2ca3d1c32dcf01">More...</a><br /></td></tr>
<tr class="separator:a52b89a6d10eee2400c2ca3d1c32dcf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba338fbe4d6ec3c973080baad9b1ba86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#aba338fbe4d6ec3c973080baad9b1ba86">wrap_as_facets</a> (<a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; shared_offsets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; shared_facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_corners)</td></tr>
<tr class="memdesc:aba338fbe4d6ec3c973080baad9b1ba86"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classlagrange_1_1_surface_mesh.html#aba338fbe4d6ec3c973080baad9b1ba86">More...</a><br /></td></tr>
<tr class="separator:aba338fbe4d6ec3c973080baad9b1ba86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877f2c797f61f515586135e619335de3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a877f2c797f61f515586135e619335de3">wrap_as_facets</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; offsets_view, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; shared_facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_corners)</td></tr>
<tr class="memdesc:a877f2c797f61f515586135e619335de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classlagrange_1_1_surface_mesh.html#a877f2c797f61f515586135e619335de3">More...</a><br /></td></tr>
<tr class="separator:a877f2c797f61f515586135e619335de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbb1f8298d02454712f2afcd4147b2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a2cbb1f8298d02454712f2afcd4147b2a">wrap_as_facets</a> (<a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; shared_offsets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facets_view, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_corners)</td></tr>
<tr class="memdesc:a2cbb1f8298d02454712f2afcd4147b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classlagrange_1_1_surface_mesh.html#a2cbb1f8298d02454712f2afcd4147b2a">More...</a><br /></td></tr>
<tr class="separator:a2cbb1f8298d02454712f2afcd4147b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579faf1a71ae048baabbd5faf8eb6331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a579faf1a71ae048baabbd5faf8eb6331">wrap_as_const_facets</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; offsets_view, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facets_view, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_corners)</td></tr>
<tr class="memdesc:a579faf1a71ae048baabbd5faf8eb6331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps read-only external buffers as mesh facets for a hybrid mesh.  <a href="classlagrange_1_1_surface_mesh.html#a579faf1a71ae048baabbd5faf8eb6331">More...</a><br /></td></tr>
<tr class="separator:a579faf1a71ae048baabbd5faf8eb6331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd17fbbc2c114c5d04c5f0b072ed80f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#abdd17fbbc2c114c5d04c5f0b072ed80f">wrap_as_const_facets</a> (<a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; shared_offsets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; shared_facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_corners)</td></tr>
<tr class="memdesc:abdd17fbbc2c114c5d04c5f0b072ed80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classlagrange_1_1_surface_mesh.html#abdd17fbbc2c114c5d04c5f0b072ed80f">More...</a><br /></td></tr>
<tr class="separator:abdd17fbbc2c114c5d04c5f0b072ed80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5194c18f3ea1a7ae2fdb45bc0f9938"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#aaa5194c18f3ea1a7ae2fdb45bc0f9938">wrap_as_const_facets</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; offsets_view, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; shared_facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_corners)</td></tr>
<tr class="memdesc:aaa5194c18f3ea1a7ae2fdb45bc0f9938"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classlagrange_1_1_surface_mesh.html#aaa5194c18f3ea1a7ae2fdb45bc0f9938">More...</a><br /></td></tr>
<tr class="separator:aaa5194c18f3ea1a7ae2fdb45bc0f9938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a5afd620a5769f3e21eb62e9624774"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a52a5afd620a5769f3e21eb62e9624774">wrap_as_const_facets</a> (<a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; shared_offsets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facets_view, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_corners)</td></tr>
<tr class="memdesc:a52a5afd620a5769f3e21eb62e9624774"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classlagrange_1_1_surface_mesh.html#a52a5afd620a5769f3e21eb62e9624774">More...</a><br /></td></tr>
<tr class="separator:a52a5afd620a5769f3e21eb62e9624774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac105eafb5fa2eab8e87215d26ebb21c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ac105eafb5fa2eab8e87215d26ebb21c0">duplicate_attribute</a> (std::string_view old_name, std::string_view new_name)</td></tr>
<tr class="memdesc:ac105eafb5fa2eab8e87215d26ebb21c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates an attribute.  <a href="classlagrange_1_1_surface_mesh.html#ac105eafb5fa2eab8e87215d26ebb21c0">More...</a><br /></td></tr>
<tr class="separator:ac105eafb5fa2eab8e87215d26ebb21c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2d780919768c503a50a0947a21e856"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#aeb2d780919768c503a50a0947a21e856">rename_attribute</a> (std::string_view old_name, std::string_view new_name)</td></tr>
<tr class="memdesc:aeb2d780919768c503a50a0947a21e856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename an existing attribute.  <a href="classlagrange_1_1_surface_mesh.html#aeb2d780919768c503a50a0947a21e856">More...</a><br /></td></tr>
<tr class="separator:aeb2d780919768c503a50a0947a21e856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d338472b33656740632fd6d58dfc9a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a1d338472b33656740632fd6d58dfc9a7">delete_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#gad17b213b11e78aeb807ad3ece7e67e84">AttributeDeletePolicy</a> policy=<a class="el" href="group__group-surfacemesh-attr.html#ggad17b213b11e78aeb807ad3ece7e67e84afc443f72fcb562a73b40af34ddb599a3">AttributeDeletePolicy::ErrorIfReserved</a>)</td></tr>
<tr class="memdesc:a1d338472b33656740632fd6d58dfc9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an attribute given by name.  <a href="classlagrange_1_1_surface_mesh.html#a1d338472b33656740632fd6d58dfc9a7">More...</a><br /></td></tr>
<tr class="separator:a1d338472b33656740632fd6d58dfc9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d0478f3b515915db6dede4b645966c"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a28d0478f3b515915db6dede4b645966c"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a28d0478f3b515915db6dede4b645966c">delete_and_export_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#gad17b213b11e78aeb807ad3ece7e67e84">AttributeDeletePolicy</a> delete_policy=<a class="el" href="group__group-surfacemesh-attr.html#ggad17b213b11e78aeb807ad3ece7e67e84afc443f72fcb562a73b40af34ddb599a3">AttributeDeletePolicy::ErrorIfReserved</a>, <a class="el" href="group__group-surfacemesh-attr.html#gade3ae5b7e72e9d4f92f29c6563551c10">AttributeExportPolicy</a> export_policy=<a class="el" href="group__group-surfacemesh-attr.html#ggade3ae5b7e72e9d4f92f29c6563551c10afe72de1001d465db9eb6ce5cb874c2cb">AttributeExportPolicy::CopyIfExternal</a>)</td></tr>
<tr class="memdesc:a28d0478f3b515915db6dede4b645966c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an attribute and export its content in a writable shared_ptr.  <a href="classlagrange_1_1_surface_mesh.html#a28d0478f3b515915db6dede4b645966c">More...</a><br /></td></tr>
<tr class="separator:a28d0478f3b515915db6dede4b645966c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545ec348c92a85cc38a6c6d3f5277535"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a545ec348c92a85cc38a6c6d3f5277535"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a545ec348c92a85cc38a6c6d3f5277535">delete_and_export_const_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#gad17b213b11e78aeb807ad3ece7e67e84">AttributeDeletePolicy</a> delete_policy=<a class="el" href="group__group-surfacemesh-attr.html#ggad17b213b11e78aeb807ad3ece7e67e84afc443f72fcb562a73b40af34ddb599a3">AttributeDeletePolicy::ErrorIfReserved</a>, <a class="el" href="group__group-surfacemesh-attr.html#gade3ae5b7e72e9d4f92f29c6563551c10">AttributeExportPolicy</a> export_policy=<a class="el" href="group__group-surfacemesh-attr.html#ggade3ae5b7e72e9d4f92f29c6563551c10afe72de1001d465db9eb6ce5cb874c2cb">AttributeExportPolicy::CopyIfExternal</a>)</td></tr>
<tr class="memdesc:a545ec348c92a85cc38a6c6d3f5277535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an attribute and export its content in a read-only shared_ptr.  <a href="classlagrange_1_1_surface_mesh.html#a545ec348c92a85cc38a6c6d3f5277535">More...</a><br /></td></tr>
<tr class="separator:a545ec348c92a85cc38a6c6d3f5277535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb851b667e316033ab311cb13ed0241"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:aacb851b667e316033ab311cb13ed0241"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#aacb851b667e316033ab311cb13ed0241">delete_and_export_indexed_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#gade3ae5b7e72e9d4f92f29c6563551c10">AttributeExportPolicy</a> policy=<a class="el" href="group__group-surfacemesh-attr.html#ggade3ae5b7e72e9d4f92f29c6563551c10afe72de1001d465db9eb6ce5cb874c2cb">AttributeExportPolicy::CopyIfExternal</a>) -&gt; std::shared_ptr&lt; <a class="el" href="classlagrange_1_1_indexed_attribute.html">IndexedAttribute</a>&lt; ValueType, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; &gt;</td></tr>
<tr class="memdesc:aacb851b667e316033ab311cb13ed0241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an indexed attribute and export its content in a writable shared_ptr.  <a href="classlagrange_1_1_surface_mesh.html#aacb851b667e316033ab311cb13ed0241">More...</a><br /></td></tr>
<tr class="separator:aacb851b667e316033ab311cb13ed0241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e377cd17d586686cb6dcd2293c587b"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:af5e377cd17d586686cb6dcd2293c587b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#af5e377cd17d586686cb6dcd2293c587b">delete_and_export_const_indexed_attribute</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#gade3ae5b7e72e9d4f92f29c6563551c10">AttributeExportPolicy</a> policy=<a class="el" href="group__group-surfacemesh-attr.html#ggade3ae5b7e72e9d4f92f29c6563551c10afe72de1001d465db9eb6ce5cb874c2cb">AttributeExportPolicy::CopyIfExternal</a>) -&gt; std::shared_ptr&lt; const <a class="el" href="classlagrange_1_1_indexed_attribute.html">IndexedAttribute</a>&lt; ValueType, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; &gt;</td></tr>
<tr class="memdesc:af5e377cd17d586686cb6dcd2293c587b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an indexed attribute and export its content in a read-only shared_ptr.  <a href="classlagrange_1_1_surface_mesh.html#af5e377cd17d586686cb6dcd2293c587b">More...</a><br /></td></tr>
<tr class="separator:af5e377cd17d586686cb6dcd2293c587b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Attribute accessors</div></td></tr>
<tr class="memitem:a50303aab396d555e2ad0e6fa1f7d4b58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a50303aab396d555e2ad0e6fa1f7d4b58">has_attribute</a> (std::string_view name) const</td></tr>
<tr class="memdesc:a50303aab396d555e2ad0e6fa1f7d4b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an attribute of a given name is attached to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a50303aab396d555e2ad0e6fa1f7d4b58">More...</a><br /></td></tr>
<tr class="separator:a50303aab396d555e2ad0e6fa1f7d4b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0ea2006d431b6ec0b29ce05fce1da9"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a3d0ea2006d431b6ec0b29ce05fce1da9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a3d0ea2006d431b6ec0b29ce05fce1da9">is_attribute_type</a> (std::string_view name) const</td></tr>
<tr class="memdesc:a3d0ea2006d431b6ec0b29ce05fce1da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the specified attribute is of a given type.  <a href="classlagrange_1_1_surface_mesh.html#a3d0ea2006d431b6ec0b29ce05fce1da9">More...</a><br /></td></tr>
<tr class="separator:a3d0ea2006d431b6ec0b29ce05fce1da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1d061d46d76ce93cd0f1194e5df01a"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a1a1d061d46d76ce93cd0f1194e5df01a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a1a1d061d46d76ce93cd0f1194e5df01a">is_attribute_type</a> (<a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id) const</td></tr>
<tr class="memdesc:a1a1d061d46d76ce93cd0f1194e5df01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the specified attribute is of a given type.  <a href="classlagrange_1_1_surface_mesh.html#a1a1d061d46d76ce93cd0f1194e5df01a">More...</a><br /></td></tr>
<tr class="separator:a1a1d061d46d76ce93cd0f1194e5df01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8957ea4b91cd0a8462521eb27ecf13ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a8957ea4b91cd0a8462521eb27ecf13ee">is_attribute_indexed</a> (std::string_view name) const</td></tr>
<tr class="memdesc:a8957ea4b91cd0a8462521eb27ecf13ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified attribute is indexed.  <a href="classlagrange_1_1_surface_mesh.html#a8957ea4b91cd0a8462521eb27ecf13ee">More...</a><br /></td></tr>
<tr class="separator:a8957ea4b91cd0a8462521eb27ecf13ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e4ae976a96f26d966babe95fdb589c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a57e4ae976a96f26d966babe95fdb589c">is_attribute_indexed</a> (<a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id) const</td></tr>
<tr class="memdesc:a57e4ae976a96f26d966babe95fdb589c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified attribute is indexed.  <a href="classlagrange_1_1_surface_mesh.html#a57e4ae976a96f26d966babe95fdb589c">More...</a><br /></td></tr>
<tr class="separator:a57e4ae976a96f26d966babe95fdb589c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affeb2a94afa3e342e3adf7f5351c4e5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#affeb2a94afa3e342e3adf7f5351c4e5f">seq_foreach_attribute_id</a> (<a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>)&gt; func) const</td></tr>
<tr class="memdesc:affeb2a94afa3e342e3adf7f5351c4e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over all attribute ids sequentially.  <a href="classlagrange_1_1_surface_mesh.html#affeb2a94afa3e342e3adf7f5351c4e5f">More...</a><br /></td></tr>
<tr class="separator:affeb2a94afa3e342e3adf7f5351c4e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761f0a6b5579be53f4e6d6d232dce22c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a761f0a6b5579be53f4e6d6d232dce22c">seq_foreach_attribute_id</a> (<a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(std::string_view, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>)&gt; func) const</td></tr>
<tr class="memdesc:a761f0a6b5579be53f4e6d6d232dce22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over all pairs of attribute names x ids sequentially.  <a href="classlagrange_1_1_surface_mesh.html#a761f0a6b5579be53f4e6d6d232dce22c">More...</a><br /></td></tr>
<tr class="separator:a761f0a6b5579be53f4e6d6d232dce22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09be8d43ffe0507de31bccd15143f928"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a09be8d43ffe0507de31bccd15143f928">par_foreach_attribute_id</a> (<a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>)&gt; func) const</td></tr>
<tr class="memdesc:a09be8d43ffe0507de31bccd15143f928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over all attribute ids in parallel.  <a href="classlagrange_1_1_surface_mesh.html#a09be8d43ffe0507de31bccd15143f928">More...</a><br /></td></tr>
<tr class="separator:a09be8d43ffe0507de31bccd15143f928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ab5e6343f4b3c85288a7c35d2261c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a91ab5e6343f4b3c85288a7c35d2261c8">par_foreach_attribute_id</a> (<a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(std::string_view, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>)&gt; func) const</td></tr>
<tr class="memdesc:a91ab5e6343f4b3c85288a7c35d2261c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over all pairs of attribute names x ids in parallel.  <a href="classlagrange_1_1_surface_mesh.html#a91ab5e6343f4b3c85288a7c35d2261c8">More...</a><br /></td></tr>
<tr class="separator:a91ab5e6343f4b3c85288a7c35d2261c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70acd5189ef3b33e3e272a16215a6ed1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlagrange_1_1_attribute_base.html">AttributeBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a70acd5189ef3b33e3e272a16215a6ed1">get_attribute_base</a> (std::string_view name) const</td></tr>
<tr class="memdesc:a70acd5189ef3b33e3e272a16215a6ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a read-only reference to the base class of attribute given its name.  <a href="classlagrange_1_1_surface_mesh.html#a70acd5189ef3b33e3e272a16215a6ed1">More...</a><br /></td></tr>
<tr class="separator:a70acd5189ef3b33e3e272a16215a6ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fc1c7d6ff27a9a400dbe4382aefbf7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlagrange_1_1_attribute_base.html">AttributeBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ad5fc1c7d6ff27a9a400dbe4382aefbf7">get_attribute_base</a> (<a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id) const</td></tr>
<tr class="memdesc:ad5fc1c7d6ff27a9a400dbe4382aefbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a read-only reference to an attribute given its id.  <a href="classlagrange_1_1_surface_mesh.html#ad5fc1c7d6ff27a9a400dbe4382aefbf7">More...</a><br /></td></tr>
<tr class="separator:ad5fc1c7d6ff27a9a400dbe4382aefbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c11c467637dffa99eafca4ed7c016ea"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a1c11c467637dffa99eafca4ed7c016ea"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a1c11c467637dffa99eafca4ed7c016ea">get_attribute</a> (std::string_view name) const</td></tr>
<tr class="memdesc:a1c11c467637dffa99eafca4ed7c016ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a read-only reference to an attribute given its name.  <a href="classlagrange_1_1_surface_mesh.html#a1c11c467637dffa99eafca4ed7c016ea">More...</a><br /></td></tr>
<tr class="separator:a1c11c467637dffa99eafca4ed7c016ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528f884aabf3d710335c1be13b6f63ee"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a528f884aabf3d710335c1be13b6f63ee"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a528f884aabf3d710335c1be13b6f63ee">get_attribute</a> (<a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id) const</td></tr>
<tr class="memdesc:a528f884aabf3d710335c1be13b6f63ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a read-only reference to an attribute given its id.  <a href="classlagrange_1_1_surface_mesh.html#a528f884aabf3d710335c1be13b6f63ee">More...</a><br /></td></tr>
<tr class="separator:a528f884aabf3d710335c1be13b6f63ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91a0b5497bef4a9ce6b18a7b2830426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1internal_1_1weak__ptr.html">::lagrange::internal::weak_ptr</a>&lt; const <a class="el" href="classlagrange_1_1_attribute_base.html">AttributeBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#af91a0b5497bef4a9ce6b18a7b2830426">_get_attribute_ptr</a> (std::string_view name) const</td></tr>
<tr class="memdesc:af91a0b5497bef4a9ce6b18a7b2830426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a read-only weak pointer to the base attribute object.  <a href="classlagrange_1_1_surface_mesh.html#af91a0b5497bef4a9ce6b18a7b2830426">More...</a><br /></td></tr>
<tr class="separator:af91a0b5497bef4a9ce6b18a7b2830426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319531657219ef88187c329cedf33127"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1internal_1_1weak__ptr.html">::lagrange::internal::weak_ptr</a>&lt; const <a class="el" href="classlagrange_1_1_attribute_base.html">AttributeBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a319531657219ef88187c329cedf33127">_get_attribute_ptr</a> (<a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id) const</td></tr>
<tr class="memdesc:a319531657219ef88187c329cedf33127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a read-only weak pointer to the base attribute object.  <a href="classlagrange_1_1_surface_mesh.html#a319531657219ef88187c329cedf33127">More...</a><br /></td></tr>
<tr class="separator:a319531657219ef88187c329cedf33127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e64c208726bc382b5093d804b9629e1"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a7e64c208726bc382b5093d804b9629e1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a7e64c208726bc382b5093d804b9629e1">get_indexed_attribute</a> (std::string_view name) const -&gt; const <a class="el" href="classlagrange_1_1_indexed_attribute.html">IndexedAttribute</a>&lt; ValueType, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; &amp;</td></tr>
<tr class="memdesc:a7e64c208726bc382b5093d804b9629e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a read-only reference to an indexed attribute given its name.  <a href="classlagrange_1_1_surface_mesh.html#a7e64c208726bc382b5093d804b9629e1">More...</a><br /></td></tr>
<tr class="separator:a7e64c208726bc382b5093d804b9629e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb3d0d2b824b62c139b6a7e9ea9eadc"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:afdb3d0d2b824b62c139b6a7e9ea9eadc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#afdb3d0d2b824b62c139b6a7e9ea9eadc">get_indexed_attribute</a> (<a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id) const -&gt; const <a class="el" href="classlagrange_1_1_indexed_attribute.html">IndexedAttribute</a>&lt; ValueType, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; &amp;</td></tr>
<tr class="memdesc:afdb3d0d2b824b62c139b6a7e9ea9eadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a read-only reference to an indexed attribute given its id.  <a href="classlagrange_1_1_surface_mesh.html#afdb3d0d2b824b62c139b6a7e9ea9eadc">More...</a><br /></td></tr>
<tr class="separator:afdb3d0d2b824b62c139b6a7e9ea9eadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2226b6b1921c3a5a7f674a9c94e83be5"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a2226b6b1921c3a5a7f674a9c94e83be5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a2226b6b1921c3a5a7f674a9c94e83be5">ref_attribute</a> (std::string_view name)</td></tr>
<tr class="memdesc:a2226b6b1921c3a5a7f674a9c94e83be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a writable reference to an attribute given its name.  <a href="classlagrange_1_1_surface_mesh.html#a2226b6b1921c3a5a7f674a9c94e83be5">More...</a><br /></td></tr>
<tr class="separator:a2226b6b1921c3a5a7f674a9c94e83be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cad0812ac7257b36854a35647de611"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a80cad0812ac7257b36854a35647de611"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a80cad0812ac7257b36854a35647de611">ref_attribute</a> (<a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id)</td></tr>
<tr class="memdesc:a80cad0812ac7257b36854a35647de611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a writable reference to an attribute given its id.  <a href="classlagrange_1_1_surface_mesh.html#a80cad0812ac7257b36854a35647de611">More...</a><br /></td></tr>
<tr class="separator:a80cad0812ac7257b36854a35647de611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8e34ca37c4ed40045c8b904453c6bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1internal_1_1weak__ptr.html">::lagrange::internal::weak_ptr</a>&lt; <a class="el" href="classlagrange_1_1_attribute_base.html">AttributeBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a6e8e34ca37c4ed40045c8b904453c6bd">_ref_attribute_ptr</a> (std::string_view name)</td></tr>
<tr class="memdesc:a6e8e34ca37c4ed40045c8b904453c6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a weak pointer to the base attribute object.  <a href="classlagrange_1_1_surface_mesh.html#a6e8e34ca37c4ed40045c8b904453c6bd">More...</a><br /></td></tr>
<tr class="separator:a6e8e34ca37c4ed40045c8b904453c6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66aaa7f8cee5a1c5d5d3680592e1fac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1internal_1_1weak__ptr.html">::lagrange::internal::weak_ptr</a>&lt; <a class="el" href="classlagrange_1_1_attribute_base.html">AttributeBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a66aaa7f8cee5a1c5d5d3680592e1fac0">_ref_attribute_ptr</a> (<a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id)</td></tr>
<tr class="memdesc:a66aaa7f8cee5a1c5d5d3680592e1fac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a weak pointer to the base attribute object.  <a href="classlagrange_1_1_surface_mesh.html#a66aaa7f8cee5a1c5d5d3680592e1fac0">More...</a><br /></td></tr>
<tr class="separator:a66aaa7f8cee5a1c5d5d3680592e1fac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37a6116db014729e9613238a94e2a8c"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ab37a6116db014729e9613238a94e2a8c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ab37a6116db014729e9613238a94e2a8c">ref_indexed_attribute</a> (std::string_view name) -&gt; <a class="el" href="classlagrange_1_1_indexed_attribute.html">IndexedAttribute</a>&lt; ValueType, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; &amp;</td></tr>
<tr class="memdesc:ab37a6116db014729e9613238a94e2a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a writable reference to an indexed attribute given its name.  <a href="classlagrange_1_1_surface_mesh.html#ab37a6116db014729e9613238a94e2a8c">More...</a><br /></td></tr>
<tr class="separator:ab37a6116db014729e9613238a94e2a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c07782acefabc48e9af535ef09f04f3"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a5c07782acefabc48e9af535ef09f04f3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a5c07782acefabc48e9af535ef09f04f3">ref_indexed_attribute</a> (<a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id) -&gt; <a class="el" href="classlagrange_1_1_indexed_attribute.html">IndexedAttribute</a>&lt; ValueType, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; &amp;</td></tr>
<tr class="memdesc:a5c07782acefabc48e9af535ef09f04f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a writable reference to an indexed attribute given its id.  <a href="classlagrange_1_1_surface_mesh.html#a5c07782acefabc48e9af535ef09f04f3">More...</a><br /></td></tr>
<tr class="separator:a5c07782acefabc48e9af535ef09f04f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3a373ed58ff8f9908b54ff36a0921b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#aee3a373ed58ff8f9908b54ff36a0921b">get_vertex_to_position</a> () const</td></tr>
<tr class="memdesc:aee3a373ed58ff8f9908b54ff36a0921b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a read-only reference to the vertex -&gt; positions attribute.  <a href="classlagrange_1_1_surface_mesh.html#aee3a373ed58ff8f9908b54ff36a0921b">More...</a><br /></td></tr>
<tr class="separator:aee3a373ed58ff8f9908b54ff36a0921b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8e21c22801c3e1b32392c15c4c9e05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a0b8e21c22801c3e1b32392c15c4c9e05">ref_vertex_to_position</a> ()</td></tr>
<tr class="memdesc:a0b8e21c22801c3e1b32392c15c4c9e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a writable reference to the vertex -&gt; positions attribute.  <a href="classlagrange_1_1_surface_mesh.html#a0b8e21c22801c3e1b32392c15c4c9e05">More...</a><br /></td></tr>
<tr class="separator:a0b8e21c22801c3e1b32392c15c4c9e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4de76f0e87a0509babc2bd81c0abaf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a8a4de76f0e87a0509babc2bd81c0abaf">get_corner_to_vertex</a> () const</td></tr>
<tr class="memdesc:a8a4de76f0e87a0509babc2bd81c0abaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a read-only reference to the corner -&gt; vertex id attribute.  <a href="classlagrange_1_1_surface_mesh.html#a8a4de76f0e87a0509babc2bd81c0abaf">More...</a><br /></td></tr>
<tr class="separator:a8a4de76f0e87a0509babc2bd81c0abaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3cd66ddb6e7a1f1023d197653a9d02e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ad3cd66ddb6e7a1f1023d197653a9d02e">ref_corner_to_vertex</a> ()</td></tr>
<tr class="memdesc:ad3cd66ddb6e7a1f1023d197653a9d02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a writable reference to the corner -&gt; vertex id attribute.  <a href="classlagrange_1_1_surface_mesh.html#ad3cd66ddb6e7a1f1023d197653a9d02e">More...</a><br /></td></tr>
<tr class="separator:ad3cd66ddb6e7a1f1023d197653a9d02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mesh edges and connectivity</div></td></tr>
<tr class="memitem:acf3519681c8bdac36dbb106499192c51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#acf3519681c8bdac36dbb106499192c51">initialize_edges</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; edges={})</td></tr>
<tr class="memdesc:acf3519681c8bdac36dbb106499192c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes attributes associated to mesh edges and connectivity.  <a href="classlagrange_1_1_surface_mesh.html#acf3519681c8bdac36dbb106499192c51">More...</a><br /></td></tr>
<tr class="separator:acf3519681c8bdac36dbb106499192c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b80acc32b1c4c2f26edbe86df49ed0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a83b80acc32b1c4c2f26edbe86df49ed0">initialize_edges</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_user_edges, <a class="el" href="classlagrange_1_1_surface_mesh.html#a0099ac3b79b3ecddccca10409e576f8f">GetEdgeVertices</a> get_user_edge)</td></tr>
<tr class="memdesc:a83b80acc32b1c4c2f26edbe86df49ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes attributes associated to mesh edges and connectivity.  <a href="classlagrange_1_1_surface_mesh.html#a83b80acc32b1c4c2f26edbe86df49ed0">More...</a><br /></td></tr>
<tr class="separator:a83b80acc32b1c4c2f26edbe86df49ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccbe860cb7c1faa679cbb72f69e0a15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a0ccbe860cb7c1faa679cbb72f69e0a15">clear_edges</a> ()</td></tr>
<tr class="memdesc:a0ccbe860cb7c1faa679cbb72f69e0a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears attributes related to mesh edges and connectivity:  <a href="classlagrange_1_1_surface_mesh.html#a0ccbe860cb7c1faa679cbb72f69e0a15">More...</a><br /></td></tr>
<tr class="separator:a0ccbe860cb7c1faa679cbb72f69e0a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b58744bd298398b70869f693b21f35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#aa9b58744bd298398b70869f693b21f35">has_edges</a> () const</td></tr>
<tr class="memdesc:aa9b58744bd298398b70869f693b21f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the attributes associated to mesh edges and connectivity have been initialized.  <a href="classlagrange_1_1_surface_mesh.html#aa9b58744bd298398b70869f693b21f35">More...</a><br /></td></tr>
<tr class="separator:aa9b58744bd298398b70869f693b21f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe4f82c25a5b076fdfcc5c4d78fd7fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a2fe4f82c25a5b076fdfcc5c4d78fd7fe">get_edge</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> f, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> lv) const</td></tr>
<tr class="memdesc:a2fe4f82c25a5b076fdfcc5c4d78fd7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the edge index corresponding to (f, lv) &ndash; (f, lv+1).  <a href="classlagrange_1_1_surface_mesh.html#a2fe4f82c25a5b076fdfcc5c4d78fd7fe">More...</a><br /></td></tr>
<tr class="separator:a2fe4f82c25a5b076fdfcc5c4d78fd7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24975f9d8e5adf7f621c29f2f75b7fdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a24975f9d8e5adf7f621c29f2f75b7fdd">get_corner_edge</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> c) const</td></tr>
<tr class="memdesc:a24975f9d8e5adf7f621c29f2f75b7fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the edge index corresponding to a corner index.  <a href="classlagrange_1_1_surface_mesh.html#a24975f9d8e5adf7f621c29f2f75b7fdd">More...</a><br /></td></tr>
<tr class="separator:a24975f9d8e5adf7f621c29f2f75b7fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491ff4636c29460975186cac5cdccaf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a491ff4636c29460975186cac5cdccaf4">get_edge_from_corner</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> c) const</td></tr>
<tr class="memdesc:a491ff4636c29460975186cac5cdccaf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the edge index corresponding to a corner index.  <a href="classlagrange_1_1_surface_mesh.html#a491ff4636c29460975186cac5cdccaf4">More...</a><br /></td></tr>
<tr class="separator:a491ff4636c29460975186cac5cdccaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29302efd8dd0d5b7c28f28f901b62d36"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a29302efd8dd0d5b7c28f28f901b62d36">get_edge_vertices</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> e) const</td></tr>
<tr class="memdesc:a29302efd8dd0d5b7c28f28f901b62d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve edge endpoints.  <a href="classlagrange_1_1_surface_mesh.html#a29302efd8dd0d5b7c28f28f901b62d36">More...</a><br /></td></tr>
<tr class="separator:a29302efd8dd0d5b7c28f28f901b62d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032a198e720a57c9e22327a8dc2ad1b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a032a198e720a57c9e22327a8dc2ad1b9">find_edge_from_vertices</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v0, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v1) const</td></tr>
<tr class="memdesc:a032a198e720a57c9e22327a8dc2ad1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the edge index cooresponding to (v0, v1).  <a href="classlagrange_1_1_surface_mesh.html#a032a198e720a57c9e22327a8dc2ad1b9">More...</a><br /></td></tr>
<tr class="separator:a032a198e720a57c9e22327a8dc2ad1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757f13e26354a83f93e1ac0b276a55a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a757f13e26354a83f93e1ac0b276a55a6">get_first_corner_around_edge</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> e) const</td></tr>
<tr class="memdesc:a757f13e26354a83f93e1ac0b276a55a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the first corner around a given edge.  <a href="classlagrange_1_1_surface_mesh.html#a757f13e26354a83f93e1ac0b276a55a6">More...</a><br /></td></tr>
<tr class="separator:a757f13e26354a83f93e1ac0b276a55a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ea64462a4c107f838ae2758e178bda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a42ea64462a4c107f838ae2758e178bda">get_next_corner_around_edge</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> c) const</td></tr>
<tr class="memdesc:a42ea64462a4c107f838ae2758e178bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next corner around the edge associated to a corner.  <a href="classlagrange_1_1_surface_mesh.html#a42ea64462a4c107f838ae2758e178bda">More...</a><br /></td></tr>
<tr class="separator:a42ea64462a4c107f838ae2758e178bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a57db26b350768afb4ff0a7c7802c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a86a57db26b350768afb4ff0a7c7802c5">get_first_corner_around_vertex</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v) const</td></tr>
<tr class="memdesc:a86a57db26b350768afb4ff0a7c7802c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the first corner around a given vertex.  <a href="classlagrange_1_1_surface_mesh.html#a86a57db26b350768afb4ff0a7c7802c5">More...</a><br /></td></tr>
<tr class="separator:a86a57db26b350768afb4ff0a7c7802c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99be021c68cc72fabb5850b9d9e7a5d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a99be021c68cc72fabb5850b9d9e7a5d9">get_next_corner_around_vertex</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> c) const</td></tr>
<tr class="memdesc:a99be021c68cc72fabb5850b9d9e7a5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next corner around the vertex associated to a corner.  <a href="classlagrange_1_1_surface_mesh.html#a99be021c68cc72fabb5850b9d9e7a5d9">More...</a><br /></td></tr>
<tr class="separator:a99be021c68cc72fabb5850b9d9e7a5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfe0dcf037021676afc0efe217e615b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a1dfe0dcf037021676afc0efe217e615b">count_num_corners_around_edge</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> e) const</td></tr>
<tr class="memdesc:a1dfe0dcf037021676afc0efe217e615b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of corners incident to a given edge.  <a href="classlagrange_1_1_surface_mesh.html#a1dfe0dcf037021676afc0efe217e615b">More...</a><br /></td></tr>
<tr class="separator:a1dfe0dcf037021676afc0efe217e615b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f8387b06510534118da4d657d46f38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a56f8387b06510534118da4d657d46f38">count_num_corners_around_vertex</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v) const</td></tr>
<tr class="memdesc:a56f8387b06510534118da4d657d46f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of corners incident to a given vertex.  <a href="classlagrange_1_1_surface_mesh.html#a56f8387b06510534118da4d657d46f38">More...</a><br /></td></tr>
<tr class="separator:a56f8387b06510534118da4d657d46f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7565dd42a97331fbf4fbbe34b1cd7e73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a7565dd42a97331fbf4fbbe34b1cd7e73">get_one_facet_around_edge</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> e) const</td></tr>
<tr class="memdesc:a7565dd42a97331fbf4fbbe34b1cd7e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of one facet around a given edge.  <a href="classlagrange_1_1_surface_mesh.html#a7565dd42a97331fbf4fbbe34b1cd7e73">More...</a><br /></td></tr>
<tr class="separator:a7565dd42a97331fbf4fbbe34b1cd7e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5d255c7768b0fe3ec34c035ac9a8cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#abb5d255c7768b0fe3ec34c035ac9a8cd">get_one_corner_around_edge</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> e) const</td></tr>
<tr class="memdesc:abb5d255c7768b0fe3ec34c035ac9a8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of one corner around a given edge.  <a href="classlagrange_1_1_surface_mesh.html#abb5d255c7768b0fe3ec34c035ac9a8cd">More...</a><br /></td></tr>
<tr class="separator:abb5d255c7768b0fe3ec34c035ac9a8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61700e476c5ca368f8a0c2a75f01fe22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a61700e476c5ca368f8a0c2a75f01fe22">get_one_corner_around_vertex</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v) const</td></tr>
<tr class="memdesc:a61700e476c5ca368f8a0c2a75f01fe22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of one corner around a given vertex.  <a href="classlagrange_1_1_surface_mesh.html#a61700e476c5ca368f8a0c2a75f01fe22">More...</a><br /></td></tr>
<tr class="separator:a61700e476c5ca368f8a0c2a75f01fe22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2c302edb050ad26ee7bd0b163ce049"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a0b2c302edb050ad26ee7bd0b163ce049">is_boundary_edge</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> e) const</td></tr>
<tr class="memdesc:a0b2c302edb050ad26ee7bd0b163ce049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified edge e is a boundary edge.  <a href="classlagrange_1_1_surface_mesh.html#a0b2c302edb050ad26ee7bd0b163ce049">More...</a><br /></td></tr>
<tr class="separator:a0b2c302edb050ad26ee7bd0b163ce049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09026c81eebf650ab207431db9534b11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a09026c81eebf650ab207431db9534b11">foreach_facet_around_edge</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> e, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>)&gt; func) const</td></tr>
<tr class="memdesc:a09026c81eebf650ab207431db9534b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to each facet around a prescribed edge.  <a href="classlagrange_1_1_surface_mesh.html#a09026c81eebf650ab207431db9534b11">More...</a><br /></td></tr>
<tr class="separator:a09026c81eebf650ab207431db9534b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d41ed1c1f040e437e96b2d4510cb70c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a4d41ed1c1f040e437e96b2d4510cb70c">foreach_facet_around_vertex</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>)&gt; func) const</td></tr>
<tr class="memdesc:a4d41ed1c1f040e437e96b2d4510cb70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to each facet around a prescribed vertex.  <a href="classlagrange_1_1_surface_mesh.html#a4d41ed1c1f040e437e96b2d4510cb70c">More...</a><br /></td></tr>
<tr class="separator:a4d41ed1c1f040e437e96b2d4510cb70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2d4b3e2b0b9b3fba297a8f6eea0981"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#aeb2d4b3e2b0b9b3fba297a8f6eea0981">foreach_corner_around_edge</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> e, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>)&gt; func) const</td></tr>
<tr class="memdesc:aeb2d4b3e2b0b9b3fba297a8f6eea0981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to each corner around a prescribed edge.  <a href="classlagrange_1_1_surface_mesh.html#aeb2d4b3e2b0b9b3fba297a8f6eea0981">More...</a><br /></td></tr>
<tr class="separator:aeb2d4b3e2b0b9b3fba297a8f6eea0981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05d65af8327fbb7ff6d57a53f0b812f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#aa05d65af8327fbb7ff6d57a53f0b812f">foreach_corner_around_vertex</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>)&gt; func) const</td></tr>
<tr class="memdesc:aa05d65af8327fbb7ff6d57a53f0b812f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to each corner around a prescribed vertex.  <a href="classlagrange_1_1_surface_mesh.html#aa05d65af8327fbb7ff6d57a53f0b812f">More...</a><br /></td></tr>
<tr class="separator:aa05d65af8327fbb7ff6d57a53f0b812f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032c58cae0d331473ecaec9a1c1ed079"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a032c58cae0d331473ecaec9a1c1ed079">foreach_edge_around_vertex_with_duplicates</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>)&gt; func) const</td></tr>
<tr class="memdesc:a032c58cae0d331473ecaec9a1c1ed079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to each edge around a prescribed vertex.  <a href="classlagrange_1_1_surface_mesh.html#a032c58cae0d331473ecaec9a1c1ed079">More...</a><br /></td></tr>
<tr class="separator:a032c58cae0d331473ecaec9a1c1ed079"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:afcce031cac2089eb461de50514ce32d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#afcce031cac2089eb461de50514ce32d3">SurfaceMesh</a> (<a class="el" href="structlagrange_1_1_surface_mesh_1_1_bare_mesh_tag.html">BareMeshTag</a> tag)</td></tr>
<tr class="memdesc:afcce031cac2089eb461de50514ce32d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal constructor.  <a href="classlagrange_1_1_surface_mesh.html#afcce031cac2089eb461de50514ce32d3">More...</a><br /></td></tr>
<tr class="separator:afcce031cac2089eb461de50514ce32d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7571bd240cda6e24eebbba8e3069059"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ab7571bd240cda6e24eebbba8e3069059"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ab7571bd240cda6e24eebbba8e3069059">create_attribute_internal</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> element, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> usage=<a class="el" href="group__group-surfacemesh-attr.html#gga5a2f28c8b9e2f8fce6e70b2418c46e45a57dea6f5039281b7fee517fc43bf3110">AttributeUsage::Vector</a>, size_t num_channels=1, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const ValueType &gt; initial_values={}, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; initial_indices={})</td></tr>
<tr class="memdesc:ab7571bd240cda6e24eebbba8e3069059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as create_attribute, but allows creation of reserved attributes.  <a href="classlagrange_1_1_surface_mesh.html#ab7571bd240cda6e24eebbba8e3069059">More...</a><br /></td></tr>
<tr class="separator:ab7571bd240cda6e24eebbba8e3069059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ace702355c3de9c126c3c1a267f1a98"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a1ace702355c3de9c126c3c1a267f1a98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a1ace702355c3de9c126c3c1a267f1a98">set_attribute_default_internal</a> (std::string_view name)</td></tr>
<tr class="memdesc:a1ace702355c3de9c126c3c1a267f1a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set attribute default value for known internal attributes.  <a href="classlagrange_1_1_surface_mesh.html#a1ace702355c3de9c126c3c1a267f1a98">More...</a><br /></td></tr>
<tr class="separator:a1ace702355c3de9c126c3c1a267f1a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1f0451ae94715d799631b79d098299"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#aea1f0451ae94715d799631b79d098299">reindex_vertices_internal</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; old_to_new)</td></tr>
<tr class="memdesc:aea1f0451ae94715d799631b79d098299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reindex mesh vertices according to the given mapping.  <a href="classlagrange_1_1_surface_mesh.html#aea1f0451ae94715d799631b79d098299">More...</a><br /></td></tr>
<tr class="separator:aea1f0451ae94715d799631b79d098299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabaf85396713373a0328ce1d01696e65"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#aabaf85396713373a0328ce1d01696e65">reindex_facets_internal</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; old_to_new)</td></tr>
<tr class="memdesc:aabaf85396713373a0328ce1d01696e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reindex mesh facets according to the given mapping.  <a href="classlagrange_1_1_surface_mesh.html#aabaf85396713373a0328ce1d01696e65">More...</a><br /></td></tr>
<tr class="separator:aabaf85396713373a0328ce1d01696e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83667a37a14859de5d28036398cf5089"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> element&gt; </td></tr>
<tr class="memitem:a83667a37a14859de5d28036398cf5089"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a83667a37a14859de5d28036398cf5089">resize_elements_internal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_elements)</td></tr>
<tr class="memdesc:a83667a37a14859de5d28036398cf5089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the buffers associated to a specific element type in the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a83667a37a14859de5d28036398cf5089">More...</a><br /></td></tr>
<tr class="separator:a83667a37a14859de5d28036398cf5089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffcdb24287c1b3de2d64721b20547ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a4ffcdb24287c1b3de2d64721b20547ff">resize_vertices_internal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_vertices)</td></tr>
<tr class="memdesc:a4ffcdb24287c1b3de2d64721b20547ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the buffers associated to mesh vertices and their attributes.  <a href="classlagrange_1_1_surface_mesh.html#a4ffcdb24287c1b3de2d64721b20547ff">More...</a><br /></td></tr>
<tr class="separator:a4ffcdb24287c1b3de2d64721b20547ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f115ee59c274a6ec785007793b9d093"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a1f115ee59c274a6ec785007793b9d093">resize_facets_internal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets)</td></tr>
<tr class="memdesc:a1f115ee59c274a6ec785007793b9d093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the buffers associated to mesh facets and their attributes.  <a href="classlagrange_1_1_surface_mesh.html#a1f115ee59c274a6ec785007793b9d093">More...</a><br /></td></tr>
<tr class="separator:a1f115ee59c274a6ec785007793b9d093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71dad57d3c6a420665c94f0d6d488943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a71dad57d3c6a420665c94f0d6d488943">resize_corners_internal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_corners)</td></tr>
<tr class="memdesc:a71dad57d3c6a420665c94f0d6d488943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the buffers associated to mesh corners and their attributes.  <a href="classlagrange_1_1_surface_mesh.html#a71dad57d3c6a420665c94f0d6d488943">More...</a><br /></td></tr>
<tr class="separator:a71dad57d3c6a420665c94f0d6d488943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ab6cab6408ce9e8f7cfb463d0e3239"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#aa1ab6cab6408ce9e8f7cfb463d0e3239">resize_edges_internal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_edges)</td></tr>
<tr class="memdesc:aa1ab6cab6408ce9e8f7cfb463d0e3239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the buffers associated to mesh edges and their attributes.  <a href="classlagrange_1_1_surface_mesh.html#aa1ab6cab6408ce9e8f7cfb463d0e3239">More...</a><br /></td></tr>
<tr class="separator:aa1ab6cab6408ce9e8f7cfb463d0e3239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dc899155af8a6a73076bcf62210cdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a03dc899155af8a6a73076bcf62210cdb">reserve_indices_internal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> facet_size)</td></tr>
<tr class="memdesc:a03dc899155af8a6a73076bcf62210cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve index buffer for multiple facets of a given size.  <a href="classlagrange_1_1_surface_mesh.html#a03dc899155af8a6a73076bcf62210cdb">More...</a><br /></td></tr>
<tr class="separator:a03dc899155af8a6a73076bcf62210cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeced0acd223fc3b2c198bdff67199dea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#aeced0acd223fc3b2c198bdff67199dea">reserve_indices_internal</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facet_sizes)</td></tr>
<tr class="memdesc:aeced0acd223fc3b2c198bdff67199dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve index buffer for multiple facets of a given size.  <a href="classlagrange_1_1_surface_mesh.html#aeced0acd223fc3b2c198bdff67199dea">More...</a><br /></td></tr>
<tr class="separator:aeced0acd223fc3b2c198bdff67199dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750df16a145f96f1a9ccbc409e96637b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a750df16a145f96f1a9ccbc409e96637b">reserve_indices_internal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a170c2bfbae529972c9db5de7025ab581">GetFacetsSizeFunction</a> get_facets_size)</td></tr>
<tr class="memdesc:a750df16a145f96f1a9ccbc409e96637b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve index buffer for multiple facets of a given size.  <a href="classlagrange_1_1_surface_mesh.html#a750df16a145f96f1a9ccbc409e96637b">More...</a><br /></td></tr>
<tr class="separator:a750df16a145f96f1a9ccbc409e96637b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd14a2e9f34e21802ba9488082088da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a7bd14a2e9f34e21802ba9488082088da">compute_corner_to_facet_internal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> facet_begin, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> facet_end)</td></tr>
<tr class="memdesc:a7bd14a2e9f34e21802ba9488082088da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute inverse mapping corner -&gt; facet index for a specific range of facets.  <a href="classlagrange_1_1_surface_mesh.html#a7bd14a2e9f34e21802ba9488082088da">More...</a><br /></td></tr>
<tr class="separator:a7bd14a2e9f34e21802ba9488082088da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e58c6b801afb40e39301667d674e34b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a7e58c6b801afb40e39301667d674e34b">initialize_edges_internal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_user_edges=0, <a class="el" href="classlagrange_1_1_surface_mesh.html#a0099ac3b79b3ecddccca10409e576f8f">GetEdgeVertices</a> *get_user_edge_ptr=nullptr)</td></tr>
<tr class="memdesc:a7e58c6b801afb40e39301667d674e34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes attributes associated to mesh edges and connectivity.  <a href="classlagrange_1_1_surface_mesh.html#a7e58c6b801afb40e39301667d674e34b">More...</a><br /></td></tr>
<tr class="separator:a7e58c6b801afb40e39301667d674e34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ee1e1e55612c564e7d8e6014004688"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a12ee1e1e55612c564e7d8e6014004688">update_edges_range_internal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> facet_begin, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> facet_end, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_user_edges=0, <a class="el" href="classlagrange_1_1_surface_mesh.html#a0099ac3b79b3ecddccca10409e576f8f">GetEdgeVertices</a> *get_user_edge_ptr=nullptr)</td></tr>
<tr class="memdesc:a12ee1e1e55612c564e7d8e6014004688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update attributes associated to mesh edges and connectivity for a specific range of facets.  <a href="classlagrange_1_1_surface_mesh.html#a12ee1e1e55612c564e7d8e6014004688">More...</a><br /></td></tr>
<tr class="separator:a12ee1e1e55612c564e7d8e6014004688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905d978584e7aaccf4ff04fdbf488d1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a905d978584e7aaccf4ff04fdbf488d1c">update_edges_last_internal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> count, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_user_edges=0, <a class="el" href="classlagrange_1_1_surface_mesh.html#a0099ac3b79b3ecddccca10409e576f8f">GetEdgeVertices</a> *get_user_edge_ptr=nullptr)</td></tr>
<tr class="memdesc:a905d978584e7aaccf4ff04fdbf488d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as update_edges_range_internal, but operate on the last count facets in the mesh instead.  <a href="classlagrange_1_1_surface_mesh.html#a905d978584e7aaccf4ff04fdbf488d1c">More...</a><br /></td></tr>
<tr class="separator:a905d978584e7aaccf4ff04fdbf488d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6993d164e45277c2f73997d57d3ec7e4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a6993d164e45277c2f73997d57d3ec7e4">get_num_elements_internal</a> (<a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> element) const</td></tr>
<tr class="memdesc:a6993d164e45277c2f73997d57d3ec7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of mesh elements, based on an element type.  <a href="classlagrange_1_1_surface_mesh.html#a6993d164e45277c2f73997d57d3ec7e4">More...</a><br /></td></tr>
<tr class="separator:a6993d164e45277c2f73997d57d3ec7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e87cb0c6d68efd943c2e9c97d4df630"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a9e87cb0c6d68efd943c2e9c97d4df630"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a9e87cb0c6d68efd943c2e9c97d4df630">wrap_as_attribute_internal</a> (<a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; std::decay_t&lt; ValueType &gt; &gt; &amp;attr, size_t num_values, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; ValueType &gt; values_view)</td></tr>
<tr class="memdesc:a9e87cb0c6d68efd943c2e9c97d4df630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a span in an attribute.  <a href="classlagrange_1_1_surface_mesh.html#a9e87cb0c6d68efd943c2e9c97d4df630">More...</a><br /></td></tr>
<tr class="separator:a9e87cb0c6d68efd943c2e9c97d4df630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346bba81c64f5cf24324103e348f2417"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a346bba81c64f5cf24324103e348f2417"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a346bba81c64f5cf24324103e348f2417">wrap_as_attribute_internal</a> (<a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; std::decay_t&lt; ValueType &gt; &gt; &amp;attr, size_t num_values, <a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; ValueType &gt; shared_values)</td></tr>
<tr class="memdesc:a346bba81c64f5cf24324103e348f2417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a shared span in an attribute.  <a href="classlagrange_1_1_surface_mesh.html#a346bba81c64f5cf24324103e348f2417">More...</a><br /></td></tr>
<tr class="separator:a346bba81c64f5cf24324103e348f2417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c13e7459875ddd222a3841959f627c0"><td class="memTemplParams" colspan="2">template&lt;typename OffsetSpan , typename FacetSpan &gt; </td></tr>
<tr class="memitem:a5c13e7459875ddd222a3841959f627c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a5c13e7459875ddd222a3841959f627c0">wrap_as_facets_internal</a> (OffsetSpan offsets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, FacetSpan facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_corners)</td></tr>
<tr class="memdesc:a5c13e7459875ddd222a3841959f627c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap shared spans as offsets and facets.  <a href="classlagrange_1_1_surface_mesh.html#a5c13e7459875ddd222a3841959f627c0">More...</a><br /></td></tr>
<tr class="separator:a5c13e7459875ddd222a3841959f627c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc50bde3a18f6bd4f9a1db85f8a0daa6"><td class="memTemplParams" colspan="2">template&lt;typename ValueSpan , typename IndexSpan  = span&lt;Index&gt;&gt; </td></tr>
<tr class="memitem:acc50bde3a18f6bd4f9a1db85f8a0daa6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#acc50bde3a18f6bd4f9a1db85f8a0daa6">wrap_as_attribute_internal</a> (std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> element, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> usage, size_t num_values, size_t num_channels, ValueSpan values, IndexSpan indices={})</td></tr>
<tr class="memdesc:acc50bde3a18f6bd4f9a1db85f8a0daa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most generic way of creating an attribute wrapped around external buffers.  <a href="classlagrange_1_1_surface_mesh.html#acc50bde3a18f6bd4f9a1db85f8a0daa6">More...</a><br /></td></tr>
<tr class="separator:acc50bde3a18f6bd4f9a1db85f8a0daa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3d8d10df9aa6182d07aa7e9edac1113a"><td class="memItemLeft" align="right" valign="top"><a id="a3d8d10df9aa6182d07aa7e9edac1113a" name="a3d8d10df9aa6182d07aa7e9edac1113a"></a>
<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_num_vertices</b> = <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>(0)</td></tr>
<tr class="memdesc:a3d8d10df9aa6182d07aa7e9edac1113a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of vertices. <br /></td></tr>
<tr class="separator:a3d8d10df9aa6182d07aa7e9edac1113a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c480cac4c527159e86f652629937bcc"><td class="memItemLeft" align="right" valign="top"><a id="a1c480cac4c527159e86f652629937bcc" name="a1c480cac4c527159e86f652629937bcc"></a>
<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_num_facets</b> = <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>(0)</td></tr>
<tr class="memdesc:a1c480cac4c527159e86f652629937bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of facets. <br /></td></tr>
<tr class="separator:a1c480cac4c527159e86f652629937bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894c72d5c613b6d7b01938760c4463e2"><td class="memItemLeft" align="right" valign="top"><a id="a894c72d5c613b6d7b01938760c4463e2" name="a894c72d5c613b6d7b01938760c4463e2"></a>
<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_num_corners</b> = <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>(0)</td></tr>
<tr class="memdesc:a894c72d5c613b6d7b01938760c4463e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of corners. <br /></td></tr>
<tr class="separator:a894c72d5c613b6d7b01938760c4463e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36a6efbaaf333de19eddd8f994b73fb"><td class="memItemLeft" align="right" valign="top"><a id="af36a6efbaaf333de19eddd8f994b73fb" name="af36a6efbaaf333de19eddd8f994b73fb"></a>
<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_num_edges</b> = <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>(0)</td></tr>
<tr class="memdesc:af36a6efbaaf333de19eddd8f994b73fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of edges. <br /></td></tr>
<tr class="separator:af36a6efbaaf333de19eddd8f994b73fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7623669a52f06362e2d6c394e72ca8"><td class="memItemLeft" align="right" valign="top"><a id="acd7623669a52f06362e2d6c394e72ca8" name="acd7623669a52f06362e2d6c394e72ca8"></a>
<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_dimension</b> = <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>(3)</td></tr>
<tr class="memdesc:acd7623669a52f06362e2d6c394e72ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex dimension. <br /></td></tr>
<tr class="separator:acd7623669a52f06362e2d6c394e72ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cac9ba2ec56d46630bb3990de78881"><td class="memItemLeft" align="right" valign="top"><a id="a33cac9ba2ec56d46630bb3990de78881" name="a33cac9ba2ec56d46630bb3990de78881"></a>
<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_vertex_per_facet</b> = <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>(0)</td></tr>
<tr class="memdesc:a33cac9ba2ec56d46630bb3990de78881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of vertices per facet. Either constant (&gt; 0) or variable (= 0). <br /></td></tr>
<tr class="separator:a33cac9ba2ec56d46630bb3990de78881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584adfdcc5cb904c7f2699b82e2be777"><td class="memItemLeft" align="right" valign="top"><a id="a584adfdcc5cb904c7f2699b82e2be777" name="a584adfdcc5cb904c7f2699b82e2be777"></a>
<a class="el" href="classlagrange_1_1value__ptr.html">value_ptr</a>&lt; AttributeManager &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_attributes</b></td></tr>
<tr class="memdesc:a584adfdcc5cb904c7f2699b82e2be777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute manager. Hidden implementation. <br /></td></tr>
<tr class="separator:a584adfdcc5cb904c7f2699b82e2be777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45fdca06b7599d347cc463e486f5ef0"><td class="memItemLeft" align="right" valign="top"><a id="ac45fdca06b7599d347cc463e486f5ef0" name="ac45fdca06b7599d347cc463e486f5ef0"></a>
struct <a class="el" href="structlagrange_1_1_surface_mesh_1_1_reserved_attribute_ids.html">lagrange::SurfaceMesh::ReservedAttributeIds</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_reserved_ids</b></td></tr>
<tr class="separator:ac45fdca06b7599d347cc463e486f5ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:accf87ae53a38d4aeac8c146062a1186a"><td class="memItemLeft" ><a id="accf87ae53a38d4aeac8c146062a1186a" name="accf87ae53a38d4aeac8c146062a1186a"></a>
struct {</td></tr>
<tr class="memitem:a2722b88a19f12a9e1bef59e8f530ab51"><td class="memItemLeft" >&#160;&#160;&#160;std::string_view&#160;&#160;&#160;<a class="el" href="classlagrange_1_1_surface_mesh.html#a2722b88a19f12a9e1bef59e8f530ab51">items</a> [9]</td></tr>
<tr class="separator:a2722b88a19f12a9e1bef59e8f530ab51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf87ae53a38d4aeac8c146062a1186a"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><b>s_reserved_names</b> = {}</td></tr>
<tr class="memdesc:accf87ae53a38d4aeac8c146062a1186a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserved attribute names. <br /></td></tr>
<tr class="separator:accf87ae53a38d4aeac8c146062a1186a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Mesh construction</h2></td></tr>
<tr class="memitem:a690cbdbb73863039c0a9efd804f17060"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a690cbdbb73863039c0a9efd804f17060">SurfaceMesh</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> dimension=3)</td></tr>
<tr class="memdesc:a690cbdbb73863039c0a9efd804f17060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classlagrange_1_1_surface_mesh.html#a690cbdbb73863039c0a9efd804f17060">More...</a><br /></td></tr>
<tr class="separator:a690cbdbb73863039c0a9efd804f17060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80462de7e77a5231315f0e93e69fc1d2"><td class="memItemLeft" align="right" valign="top"><a id="a80462de7e77a5231315f0e93e69fc1d2" name="a80462de7e77a5231315f0e93e69fc1d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~SurfaceMesh</b> ()</td></tr>
<tr class="memdesc:a80462de7e77a5231315f0e93e69fc1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a80462de7e77a5231315f0e93e69fc1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5f3271851e9674d6854d3be68b028c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#aab5f3271851e9674d6854d3be68b028c">SurfaceMesh</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:aab5f3271851e9674d6854d3be68b028c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classlagrange_1_1_surface_mesh.html#aab5f3271851e9674d6854d3be68b028c">More...</a><br /></td></tr>
<tr class="separator:aab5f3271851e9674d6854d3be68b028c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92946ffa35c6d3863f9784b858575cd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a92946ffa35c6d3863f9784b858575cd9">operator=</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a92946ffa35c6d3863f9784b858575cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment move operator.  <a href="classlagrange_1_1_surface_mesh.html#a92946ffa35c6d3863f9784b858575cd9">More...</a><br /></td></tr>
<tr class="separator:a92946ffa35c6d3863f9784b858575cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe79736e3cd24cd01a150f9024122a97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#abe79736e3cd24cd01a150f9024122a97">SurfaceMesh</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a> &amp;other)</td></tr>
<tr class="memdesc:abe79736e3cd24cd01a150f9024122a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classlagrange_1_1_surface_mesh.html#abe79736e3cd24cd01a150f9024122a97">More...</a><br /></td></tr>
<tr class="separator:abe79736e3cd24cd01a150f9024122a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6282f62f8ac4dc937bd7881bc6e93a92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a6282f62f8ac4dc937bd7881bc6e93a92">operator=</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a> &amp;other)</td></tr>
<tr class="memdesc:a6282f62f8ac4dc937bd7881bc6e93a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment copy operator.  <a href="classlagrange_1_1_surface_mesh.html#a6282f62f8ac4dc937bd7881bc6e93a92">More...</a><br /></td></tr>
<tr class="separator:a6282f62f8ac4dc937bd7881bc6e93a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676e602bf7c9e51e79980dabd1ade6e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a676e602bf7c9e51e79980dabd1ade6e5">add_vertex</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt; p)</td></tr>
<tr class="memdesc:a676e602bf7c9e51e79980dabd1ade6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vertex to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a676e602bf7c9e51e79980dabd1ade6e5">More...</a><br /></td></tr>
<tr class="separator:a676e602bf7c9e51e79980dabd1ade6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ec8cbd868fc184a69efa0233ea67fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a11ec8cbd868fc184a69efa0233ea67fc">add_vertex</a> (std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt; p)</td></tr>
<tr class="memdesc:a11ec8cbd868fc184a69efa0233ea67fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vertex to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a11ec8cbd868fc184a69efa0233ea67fc">More...</a><br /></td></tr>
<tr class="separator:a11ec8cbd868fc184a69efa0233ea67fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411b43e769d84e48162e5a138576461e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a411b43e769d84e48162e5a138576461e">add_vertices</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_vertices, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt; coordinates={})</td></tr>
<tr class="memdesc:a411b43e769d84e48162e5a138576461e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple vertices to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a411b43e769d84e48162e5a138576461e">More...</a><br /></td></tr>
<tr class="separator:a411b43e769d84e48162e5a138576461e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fdea9415859dcf2dd667ff793654e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a29fdea9415859dcf2dd667ff793654e0">add_vertices</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_vertices, std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt; coordinates)</td></tr>
<tr class="memdesc:a29fdea9415859dcf2dd667ff793654e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple vertices to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a29fdea9415859dcf2dd667ff793654e0">More...</a><br /></td></tr>
<tr class="separator:a29fdea9415859dcf2dd667ff793654e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba0a28b5617e1bb44a7ec3afdf2ce05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#aaba0a28b5617e1bb44a7ec3afdf2ce05">add_vertices</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_vertices, <a class="el" href="classlagrange_1_1_surface_mesh.html#ad1a827e540de32adfb1615731db4bdc4">SetVertexCoordinatesFunction</a> set_vertex_coordinates)</td></tr>
<tr class="memdesc:aaba0a28b5617e1bb44a7ec3afdf2ce05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple vertices to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#aaba0a28b5617e1bb44a7ec3afdf2ce05">More...</a><br /></td></tr>
<tr class="separator:aaba0a28b5617e1bb44a7ec3afdf2ce05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7260f42ee2a672a47f03a9f7d4222e86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a7260f42ee2a672a47f03a9f7d4222e86">add_triangle</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v0, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v1, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v2)</td></tr>
<tr class="memdesc:a7260f42ee2a672a47f03a9f7d4222e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a triangular facet to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a7260f42ee2a672a47f03a9f7d4222e86">More...</a><br /></td></tr>
<tr class="separator:a7260f42ee2a672a47f03a9f7d4222e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfdace2787040a67ac3c70549f6bc96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a7bfdace2787040a67ac3c70549f6bc96">add_triangles</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facet_indices={})</td></tr>
<tr class="memdesc:a7bfdace2787040a67ac3c70549f6bc96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple triangular facets to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a7bfdace2787040a67ac3c70549f6bc96">More...</a><br /></td></tr>
<tr class="separator:a7bfdace2787040a67ac3c70549f6bc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76db110558443cd81542e5d86c2eb3ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a76db110558443cd81542e5d86c2eb3ee">add_triangles</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facet_indices)</td></tr>
<tr class="memdesc:a76db110558443cd81542e5d86c2eb3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple triangular facets to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a76db110558443cd81542e5d86c2eb3ee">More...</a><br /></td></tr>
<tr class="separator:a76db110558443cd81542e5d86c2eb3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f0192a971c23d318f6d242d1021c5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a49f0192a971c23d318f6d242d1021c5e">add_triangles</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a110ca5c4b8ccc87ba99cb515e8dcf159">SetMultiFacetsIndicesFunction</a> set_facets_indices)</td></tr>
<tr class="memdesc:a49f0192a971c23d318f6d242d1021c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple triangular facets to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a49f0192a971c23d318f6d242d1021c5e">More...</a><br /></td></tr>
<tr class="separator:a49f0192a971c23d318f6d242d1021c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59058cae85488a247f116f9acbdbe026"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a59058cae85488a247f116f9acbdbe026">add_quad</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v0, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v1, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v2, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v3)</td></tr>
<tr class="memdesc:a59058cae85488a247f116f9acbdbe026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a quadrilateral facet to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a59058cae85488a247f116f9acbdbe026">More...</a><br /></td></tr>
<tr class="separator:a59058cae85488a247f116f9acbdbe026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057ba271be050a99a0d6ed57b5ba4fbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a057ba271be050a99a0d6ed57b5ba4fbd">add_quads</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facet_indices={})</td></tr>
<tr class="memdesc:a057ba271be050a99a0d6ed57b5ba4fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple quadrilateral facets to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a057ba271be050a99a0d6ed57b5ba4fbd">More...</a><br /></td></tr>
<tr class="separator:a057ba271be050a99a0d6ed57b5ba4fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddacc6569fa170e0bd2e8ce29216462"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a2ddacc6569fa170e0bd2e8ce29216462">add_quads</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facet_indices)</td></tr>
<tr class="memdesc:a2ddacc6569fa170e0bd2e8ce29216462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple quadrilateral facets to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a2ddacc6569fa170e0bd2e8ce29216462">More...</a><br /></td></tr>
<tr class="separator:a2ddacc6569fa170e0bd2e8ce29216462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af8af91d5f216f96046f12cf4b66aff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a0af8af91d5f216f96046f12cf4b66aff">add_quads</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a110ca5c4b8ccc87ba99cb515e8dcf159">SetMultiFacetsIndicesFunction</a> set_facets_indices)</td></tr>
<tr class="memdesc:a0af8af91d5f216f96046f12cf4b66aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple quadrilateral facets to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a0af8af91d5f216f96046f12cf4b66aff">More...</a><br /></td></tr>
<tr class="separator:a0af8af91d5f216f96046f12cf4b66aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b293b572411c9c95744b5b720c36466"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a5b293b572411c9c95744b5b720c36466">add_polygon</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> facet_size)</td></tr>
<tr class="memdesc:a5b293b572411c9c95744b5b720c36466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a single (uninitialized) polygonal facet to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a5b293b572411c9c95744b5b720c36466">More...</a><br /></td></tr>
<tr class="separator:a5b293b572411c9c95744b5b720c36466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4cc8868c8cc2a8cf4078b06e2cc9fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ade4cc8868c8cc2a8cf4078b06e2cc9fe">add_polygon</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facet_indices)</td></tr>
<tr class="memdesc:ade4cc8868c8cc2a8cf4078b06e2cc9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a single polygonal facet to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#ade4cc8868c8cc2a8cf4078b06e2cc9fe">More...</a><br /></td></tr>
<tr class="separator:ade4cc8868c8cc2a8cf4078b06e2cc9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c487626cb4ce3304c5449f81fa6214a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a7c487626cb4ce3304c5449f81fa6214a">add_polygon</a> (std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facet_indices)</td></tr>
<tr class="memdesc:a7c487626cb4ce3304c5449f81fa6214a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a single polygonal facet to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a7c487626cb4ce3304c5449f81fa6214a">More...</a><br /></td></tr>
<tr class="separator:a7c487626cb4ce3304c5449f81fa6214a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd57ef1e8c1b66caad4e4cfd142b851"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a1bd57ef1e8c1b66caad4e4cfd142b851">add_polygon</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> facet_size, <a class="el" href="classlagrange_1_1_surface_mesh.html#af7c4a35e4a6fdc126381b1d87fb4f925">SetSingleFacetIndicesFunction</a> set_facet_indices)</td></tr>
<tr class="memdesc:a1bd57ef1e8c1b66caad4e4cfd142b851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a single polygonal facet to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a1bd57ef1e8c1b66caad4e4cfd142b851">More...</a><br /></td></tr>
<tr class="separator:a1bd57ef1e8c1b66caad4e4cfd142b851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fe8ccea4a8bb761b9a914e7098e8e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#af7fe8ccea4a8bb761b9a914e7098e8e7">add_polygons</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> facet_size, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facet_indices={})</td></tr>
<tr class="memdesc:af7fe8ccea4a8bb761b9a914e7098e8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple polygonal facets of the same size to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#af7fe8ccea4a8bb761b9a914e7098e8e7">More...</a><br /></td></tr>
<tr class="separator:af7fe8ccea4a8bb761b9a914e7098e8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7a2d46fa8f07cad0a085e6166496a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a6d7a2d46fa8f07cad0a085e6166496a4">add_polygons</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> facet_size, std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facet_indices)</td></tr>
<tr class="memdesc:a6d7a2d46fa8f07cad0a085e6166496a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple polygonal facets of the same size to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a6d7a2d46fa8f07cad0a085e6166496a4">More...</a><br /></td></tr>
<tr class="separator:a6d7a2d46fa8f07cad0a085e6166496a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada20815c5104580b91eb5a733548a746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ada20815c5104580b91eb5a733548a746">add_polygons</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> facet_size, <a class="el" href="classlagrange_1_1_surface_mesh.html#a110ca5c4b8ccc87ba99cb515e8dcf159">SetMultiFacetsIndicesFunction</a> set_facets_indices)</td></tr>
<tr class="memdesc:ada20815c5104580b91eb5a733548a746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple polygonal facets of the same size to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#ada20815c5104580b91eb5a733548a746">More...</a><br /></td></tr>
<tr class="separator:ada20815c5104580b91eb5a733548a746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ab7b86186dd296975156b85a69c044"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a01ab7b86186dd296975156b85a69c044">add_hybrid</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facet_sizes, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facet_indices={})</td></tr>
<tr class="memdesc:a01ab7b86186dd296975156b85a69c044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple polygonal facets of different sizes to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a01ab7b86186dd296975156b85a69c044">More...</a><br /></td></tr>
<tr class="separator:a01ab7b86186dd296975156b85a69c044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728c35f41e1c6d97b283cc4b55bc2a0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a728c35f41e1c6d97b283cc4b55bc2a0b">add_hybrid</a> (std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facet_sizes, std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facet_indices)</td></tr>
<tr class="memdesc:a728c35f41e1c6d97b283cc4b55bc2a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple polygonal facets of different sizes to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a728c35f41e1c6d97b283cc4b55bc2a0b">More...</a><br /></td></tr>
<tr class="separator:a728c35f41e1c6d97b283cc4b55bc2a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b78f6c00b851f3edc3676f357c383bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a2b78f6c00b851f3edc3676f357c383bc">add_hybrid</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> num_facets, <a class="el" href="classlagrange_1_1_surface_mesh.html#a170c2bfbae529972c9db5de7025ab581">GetFacetsSizeFunction</a> facet_sizes, <a class="el" href="classlagrange_1_1_surface_mesh.html#a110ca5c4b8ccc87ba99cb515e8dcf159">SetMultiFacetsIndicesFunction</a> set_facets_indices)</td></tr>
<tr class="memdesc:a2b78f6c00b851f3edc3676f357c383bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple polygonal facets of different sizes to the mesh.  <a href="classlagrange_1_1_surface_mesh.html#a2b78f6c00b851f3edc3676f357c383bc">More...</a><br /></td></tr>
<tr class="separator:a2b78f6c00b851f3edc3676f357c383bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e81913baaac39a48f35de9127a5bb6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a4e81913baaac39a48f35de9127a5bb6d">remove_vertices</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; vertices_to_remove)</td></tr>
<tr class="memdesc:a4e81913baaac39a48f35de9127a5bb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a list of vertices.  <a href="classlagrange_1_1_surface_mesh.html#a4e81913baaac39a48f35de9127a5bb6d">More...</a><br /></td></tr>
<tr class="separator:a4e81913baaac39a48f35de9127a5bb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8eb6bcf31295d0facec46d411844ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a2c8eb6bcf31295d0facec46d411844ae">remove_vertices</a> (std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; vertices_to_remove)</td></tr>
<tr class="memdesc:a2c8eb6bcf31295d0facec46d411844ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a list of vertices.  <a href="classlagrange_1_1_surface_mesh.html#a2c8eb6bcf31295d0facec46d411844ae">More...</a><br /></td></tr>
<tr class="separator:a2c8eb6bcf31295d0facec46d411844ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2fb6f223bb81c84ab9242bf05593bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#acc2fb6f223bb81c84ab9242bf05593bc">remove_vertices</a> (<a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; bool(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>)&gt; should_remove_func)</td></tr>
<tr class="memdesc:acc2fb6f223bb81c84ab9242bf05593bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a list of vertices, defined by a predicate function.  <a href="classlagrange_1_1_surface_mesh.html#acc2fb6f223bb81c84ab9242bf05593bc">More...</a><br /></td></tr>
<tr class="separator:acc2fb6f223bb81c84ab9242bf05593bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e921adc62dec46ff115047e8dca3709"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a4e921adc62dec46ff115047e8dca3709">remove_facets</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facets_to_remove)</td></tr>
<tr class="memdesc:a4e921adc62dec46ff115047e8dca3709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a list of facets.  <a href="classlagrange_1_1_surface_mesh.html#a4e921adc62dec46ff115047e8dca3709">More...</a><br /></td></tr>
<tr class="separator:a4e921adc62dec46ff115047e8dca3709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798b6c85ec6dce3c87a964a97ebfbee9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a798b6c85ec6dce3c87a964a97ebfbee9">remove_facets</a> (std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; facets_to_remove)</td></tr>
<tr class="memdesc:a798b6c85ec6dce3c87a964a97ebfbee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a list of facets.  <a href="classlagrange_1_1_surface_mesh.html#a798b6c85ec6dce3c87a964a97ebfbee9">More...</a><br /></td></tr>
<tr class="separator:a798b6c85ec6dce3c87a964a97ebfbee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26dd0d4194157564a2a8bc5c4a75838"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#af26dd0d4194157564a2a8bc5c4a75838">remove_facets</a> (<a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; bool(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>)&gt; should_remove_func)</td></tr>
<tr class="memdesc:af26dd0d4194157564a2a8bc5c4a75838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a list of facets, defined by a predicate function.  <a href="classlagrange_1_1_surface_mesh.html#af26dd0d4194157564a2a8bc5c4a75838">More...</a><br /></td></tr>
<tr class="separator:af26dd0d4194157564a2a8bc5c4a75838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f06c8c0c8232a40cd409d2c2cd0797"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#af3f06c8c0c8232a40cd409d2c2cd0797">clear_vertices</a> ()</td></tr>
<tr class="memdesc:af3f06c8c0c8232a40cd409d2c2cd0797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear buffer for mesh vertices and other vertex attributes.  <a href="classlagrange_1_1_surface_mesh.html#af3f06c8c0c8232a40cd409d2c2cd0797">More...</a><br /></td></tr>
<tr class="separator:af3f06c8c0c8232a40cd409d2c2cd0797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f80448a8d74d0063352c3a049e05db0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a5f80448a8d74d0063352c3a049e05db0">clear_facets</a> ()</td></tr>
<tr class="memdesc:a5f80448a8d74d0063352c3a049e05db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear buffer for mesh facets and other facet/corner attributes.  <a href="classlagrange_1_1_surface_mesh.html#a5f80448a8d74d0063352c3a049e05db0">More...</a><br /></td></tr>
<tr class="separator:a5f80448a8d74d0063352c3a049e05db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f16304f80b6fb253c7b0ead3e16dd18"><td class="memItemLeft" align="right" valign="top"><a id="a5f16304f80b6fb253c7b0ead3e16dd18" name="a5f16304f80b6fb253c7b0ead3e16dd18"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shrink_to_fit</b> ()</td></tr>
<tr class="memdesc:a5f16304f80b6fb253c7b0ead3e16dd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrink buffer capacities to fit current mesh attributes, deallocating any extra capacity. <br /></td></tr>
<tr class="separator:a5f16304f80b6fb253c7b0ead3e16dd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb3b1a40e1f2b467d5831ec86540610"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a9cb3b1a40e1f2b467d5831ec86540610">compress_if_regular</a> ()</td></tr>
<tr class="memdesc:a9cb3b1a40e1f2b467d5831ec86540610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress mesh storage if the mesh is regular.  <a href="classlagrange_1_1_surface_mesh.html#a9cb3b1a40e1f2b467d5831ec86540610">More...</a><br /></td></tr>
<tr class="separator:a9cb3b1a40e1f2b467d5831ec86540610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18650836a79106f33671d373b1390899"><td class="memTemplParams" colspan="2">template&lt;typename OtherScalar , typename OtherIndex &gt; </td></tr>
<tr class="memitem:a18650836a79106f33671d373b1390899"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a18650836a79106f33671d373b1390899">stripped_copy</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; OtherScalar, OtherIndex &gt; &amp;other)</td></tr>
<tr class="memdesc:a18650836a79106f33671d373b1390899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor stripping away non-reserved attributes.  <a href="classlagrange_1_1_surface_mesh.html#a18650836a79106f33671d373b1390899">More...</a><br /></td></tr>
<tr class="separator:a18650836a79106f33671d373b1390899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06ed49eb2f3d1b565a6b9a9cc701101"><td class="memTemplParams" colspan="2">template&lt;typename OtherScalar , typename OtherIndex &gt; </td></tr>
<tr class="memitem:ae06ed49eb2f3d1b565a6b9a9cc701101"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ae06ed49eb2f3d1b565a6b9a9cc701101">stripped_move</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; OtherScalar, OtherIndex &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:ae06ed49eb2f3d1b565a6b9a9cc701101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor stripping away non-reserved attributes.  <a href="classlagrange_1_1_surface_mesh.html#ae06ed49eb2f3d1b565a6b9a9cc701101">More...</a><br /></td></tr>
<tr class="separator:ae06ed49eb2f3d1b565a6b9a9cc701101"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Reserved attribute names and ids</h2></td></tr>
<tr class="memitem:a0453afe84f040b43f9c7cfa670065d4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a0453afe84f040b43f9c7cfa670065d4d">attr_id_vertex_to_position</a> () const</td></tr>
<tr class="memdesc:a0453afe84f040b43f9c7cfa670065d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute id for vertex -&gt; positions.  <a href="classlagrange_1_1_surface_mesh.html#a0453afe84f040b43f9c7cfa670065d4d">More...</a><br /></td></tr>
<tr class="separator:a0453afe84f040b43f9c7cfa670065d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1d893c997417a38024fd08c22fe42b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a5f1d893c997417a38024fd08c22fe42b">attr_id_vertex_to_positions</a> () const</td></tr>
<tr class="memdesc:a5f1d893c997417a38024fd08c22fe42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute id for vertex -&gt; positions.  <a href="classlagrange_1_1_surface_mesh.html#a5f1d893c997417a38024fd08c22fe42b">More...</a><br /></td></tr>
<tr class="separator:a5f1d893c997417a38024fd08c22fe42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2c966fb4632c7ed1f17c24cab22393"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a3c2c966fb4632c7ed1f17c24cab22393">attr_id_corner_to_vertex</a> () const</td></tr>
<tr class="memdesc:a3c2c966fb4632c7ed1f17c24cab22393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute id for corner -&gt; vertex indices.  <a href="classlagrange_1_1_surface_mesh.html#a3c2c966fb4632c7ed1f17c24cab22393">More...</a><br /></td></tr>
<tr class="separator:a3c2c966fb4632c7ed1f17c24cab22393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288fb4645b935efb8651c99c4e491844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a288fb4645b935efb8651c99c4e491844">attr_id_facet_to_first_corner</a> () const</td></tr>
<tr class="memdesc:a288fb4645b935efb8651c99c4e491844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute id for facet -&gt; first corner index.  <a href="classlagrange_1_1_surface_mesh.html#a288fb4645b935efb8651c99c4e491844">More...</a><br /></td></tr>
<tr class="separator:a288fb4645b935efb8651c99c4e491844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add807d4ec4699aba67e2e2857599b50f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#add807d4ec4699aba67e2e2857599b50f">attr_id_corner_to_facet</a> () const</td></tr>
<tr class="memdesc:add807d4ec4699aba67e2e2857599b50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute id for corner -&gt; facet index.  <a href="classlagrange_1_1_surface_mesh.html#add807d4ec4699aba67e2e2857599b50f">More...</a><br /></td></tr>
<tr class="separator:add807d4ec4699aba67e2e2857599b50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17dfdc570c834fffb6b6ab06c91a2de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a17dfdc570c834fffb6b6ab06c91a2de0">attr_id_corner_to_edge</a> () const</td></tr>
<tr class="memdesc:a17dfdc570c834fffb6b6ab06c91a2de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute id for corner -&gt; edge indices.  <a href="classlagrange_1_1_surface_mesh.html#a17dfdc570c834fffb6b6ab06c91a2de0">More...</a><br /></td></tr>
<tr class="separator:a17dfdc570c834fffb6b6ab06c91a2de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00984b25c6bccdc8f6e4d8f17db7dc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ac00984b25c6bccdc8f6e4d8f17db7dc0">attr_id_edge_to_first_corner</a> () const</td></tr>
<tr class="memdesc:ac00984b25c6bccdc8f6e4d8f17db7dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute id for edge -&gt; first corner index.  <a href="classlagrange_1_1_surface_mesh.html#ac00984b25c6bccdc8f6e4d8f17db7dc0">More...</a><br /></td></tr>
<tr class="separator:ac00984b25c6bccdc8f6e4d8f17db7dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f7ca12f43a1d3f7e90b1cf7e01175a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a84f7ca12f43a1d3f7e90b1cf7e01175a">attr_id_next_corner_around_edge</a> () const</td></tr>
<tr class="memdesc:a84f7ca12f43a1d3f7e90b1cf7e01175a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute id for corner -&gt; next corner around edge.  <a href="classlagrange_1_1_surface_mesh.html#a84f7ca12f43a1d3f7e90b1cf7e01175a">More...</a><br /></td></tr>
<tr class="separator:a84f7ca12f43a1d3f7e90b1cf7e01175a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c48e37ccf44cab6c87a79ed630430d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a6c48e37ccf44cab6c87a79ed630430d8">attr_id_vertex_to_first_corner</a> () const</td></tr>
<tr class="memdesc:a6c48e37ccf44cab6c87a79ed630430d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute id for vertex -&gt; first corner index.  <a href="classlagrange_1_1_surface_mesh.html#a6c48e37ccf44cab6c87a79ed630430d8">More...</a><br /></td></tr>
<tr class="separator:a6c48e37ccf44cab6c87a79ed630430d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd19aedf26eaea675129e658993c2f96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#acd19aedf26eaea675129e658993c2f96">attr_id_next_corner_around_vertex</a> () const</td></tr>
<tr class="memdesc:acd19aedf26eaea675129e658993c2f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute id for corner -&gt; next corner around vertex.  <a href="classlagrange_1_1_surface_mesh.html#acd19aedf26eaea675129e658993c2f96">More...</a><br /></td></tr>
<tr class="separator:acd19aedf26eaea675129e658993c2f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc357ca433a43f66b93de4407ef73a15"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#afc357ca433a43f66b93de4407ef73a15">attr_name_is_reserved</a> (std::string_view name)</td></tr>
<tr class="memdesc:afc357ca433a43f66b93de4407ef73a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the given name corresponds to a reserved attribute.  <a href="classlagrange_1_1_surface_mesh.html#afc357ca433a43f66b93de4407ef73a15">More...</a><br /></td></tr>
<tr class="separator:afc357ca433a43f66b93de4407ef73a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1609392d5977b255613678a98a71c5fe"><td class="memItemLeft" align="right" valign="top">static constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a1609392d5977b255613678a98a71c5fe">attr_name_vertex_to_position</a> ()</td></tr>
<tr class="memdesc:a1609392d5977b255613678a98a71c5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute name for vertex -&gt; position.  <a href="classlagrange_1_1_surface_mesh.html#a1609392d5977b255613678a98a71c5fe">More...</a><br /></td></tr>
<tr class="separator:a1609392d5977b255613678a98a71c5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1786eeaff1dbaa59f64eb7ccb0a3b388"><td class="memItemLeft" align="right" valign="top">static constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a1786eeaff1dbaa59f64eb7ccb0a3b388">attr_name_corner_to_vertex</a> ()</td></tr>
<tr class="memdesc:a1786eeaff1dbaa59f64eb7ccb0a3b388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute name for corner -&gt; vertex indices.  <a href="classlagrange_1_1_surface_mesh.html#a1786eeaff1dbaa59f64eb7ccb0a3b388">More...</a><br /></td></tr>
<tr class="separator:a1786eeaff1dbaa59f64eb7ccb0a3b388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0717232890d2663c40919a3d6b6f9a4a"><td class="memItemLeft" align="right" valign="top">static constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a0717232890d2663c40919a3d6b6f9a4a">attr_name_facet_to_first_corner</a> ()</td></tr>
<tr class="memdesc:a0717232890d2663c40919a3d6b6f9a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute name for facet -&gt; first corner index.  <a href="classlagrange_1_1_surface_mesh.html#a0717232890d2663c40919a3d6b6f9a4a">More...</a><br /></td></tr>
<tr class="separator:a0717232890d2663c40919a3d6b6f9a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386bf2fb3a6963e967394c9fcebb5378"><td class="memItemLeft" align="right" valign="top">static constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a386bf2fb3a6963e967394c9fcebb5378">attr_name_corner_to_facet</a> ()</td></tr>
<tr class="memdesc:a386bf2fb3a6963e967394c9fcebb5378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute name for corner -&gt; facet index.  <a href="classlagrange_1_1_surface_mesh.html#a386bf2fb3a6963e967394c9fcebb5378">More...</a><br /></td></tr>
<tr class="separator:a386bf2fb3a6963e967394c9fcebb5378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27165df42355e7f82c6704707820e4b"><td class="memItemLeft" align="right" valign="top">static constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ad27165df42355e7f82c6704707820e4b">attr_name_corner_to_edge</a> ()</td></tr>
<tr class="memdesc:ad27165df42355e7f82c6704707820e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute name for corner -&gt; edge indices.  <a href="classlagrange_1_1_surface_mesh.html#ad27165df42355e7f82c6704707820e4b">More...</a><br /></td></tr>
<tr class="separator:ad27165df42355e7f82c6704707820e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7ddb64928477b169d2fa818f8e8535"><td class="memItemLeft" align="right" valign="top">static constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#aaf7ddb64928477b169d2fa818f8e8535">attr_name_edge_to_first_corner</a> ()</td></tr>
<tr class="memdesc:aaf7ddb64928477b169d2fa818f8e8535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute name for edge -&gt; first corner index.  <a href="classlagrange_1_1_surface_mesh.html#aaf7ddb64928477b169d2fa818f8e8535">More...</a><br /></td></tr>
<tr class="separator:aaf7ddb64928477b169d2fa818f8e8535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0577250bef3d4ca3153187814aa02d"><td class="memItemLeft" align="right" valign="top">static constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#afa0577250bef3d4ca3153187814aa02d">attr_name_next_corner_around_edge</a> ()</td></tr>
<tr class="memdesc:afa0577250bef3d4ca3153187814aa02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute name for corner -&gt; next corner around edge.  <a href="classlagrange_1_1_surface_mesh.html#afa0577250bef3d4ca3153187814aa02d">More...</a><br /></td></tr>
<tr class="separator:afa0577250bef3d4ca3153187814aa02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e433d78196b31d1b5618822e3f6b0c"><td class="memItemLeft" align="right" valign="top">static constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#ac3e433d78196b31d1b5618822e3f6b0c">attr_name_vertex_to_first_corner</a> ()</td></tr>
<tr class="memdesc:ac3e433d78196b31d1b5618822e3f6b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute name for vertex -&gt; first corner index.  <a href="classlagrange_1_1_surface_mesh.html#ac3e433d78196b31d1b5618822e3f6b0c">More...</a><br /></td></tr>
<tr class="separator:ac3e433d78196b31d1b5618822e3f6b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d8fe2868a3c568d58b7b449ef88772"><td class="memItemLeft" align="right" valign="top">static constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html#a15d8fe2868a3c568d58b7b449ef88772">attr_name_next_corner_around_vertex</a> ()</td></tr>
<tr class="memdesc:a15d8fe2868a3c568d58b7b449ef88772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute name for corner -&gt; next corner around vertex.  <a href="classlagrange_1_1_surface_mesh.html#a15d8fe2868a3c568d58b7b449ef88772">More...</a><br /></td></tr>
<tr class="separator:a15d8fe2868a3c568d58b7b449ef88772"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Scalar_, typename Index_&gt;<br />
class lagrange::SurfaceMesh&lt; Scalar_, Index_ &gt;</div><p >A general purpose polygonal mesh class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar_</td><td>Mesh scalar type. </td></tr>
    <tr><td class="paramname">Index_</td><td>Mesh index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div> Related documentation:</div></dd></dl>
<ul>
<li><div><a class="el" href="group__group-surfacemesh-attr.html">Manipulating mesh attributes</a></div></li>
<li><div><a class="el" href="group__group-surfacemesh-utils.html">Mesh utility functions</a></div></li>
<li><div><a class="el" href="group__group-surfacemesh-attr-utils.html">Attribute utility functions</a></div></li>
<li><div><a class="el" href="group__group-surfacemesh-iterate.html">Attribute iterators</a></div></li>
<li><div><a class="el" href="group__group-surfacemesh-views.html">Eigen matrix view of mesh attributes</a></div></li>
</ul>
<div>Related headers:</div><div><ul>
<li><code>#include &lt;<a class="el" href="_attribute_8h_source.html">lagrange/Attribute.h</a>&gt;</code> for manipulating non-indexed mesh attributes (e.g. vertex colors or facet normals).</li>
<li><code>#include &lt;<a class="el" href="_indexed_attribute_8h_source.html">lagrange/IndexedAttribute.h</a>&gt;</code> for manipulating indexed mesh attributes (e.g. UVs).</li>
<li><code>#include &lt;<a class="el" href="views_8h_source.html">lagrange/views.h</a>&gt;</code> for Eigen matrix views over mesh attributes.</li>
<li><code>#include &lt;<a class="el" href="foreach__attribute_8h_source.html">lagrange/foreach_attribute.h</a>&gt;</code> for iterating over mesh attributes.</li>
<li><code>#include &lt;<a class="el" href="core_2include_2lagrange_2cast_8h_source.html">lagrange/cast.h</a>&gt;</code> for casting between Scalar/Index types.</li>
<li><code>#include &lt;<a class="el" href="map__attribute_8h_source.html">lagrange/map_attribute.h</a>&gt;</code> for converting attributes between mesh element types (e.g. vertex -&gt; facet).  </li>
</ul>
</div></div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad1a827e540de32adfb1615731db4bdc4" name="ad1a827e540de32adfb1615731db4bdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a827e540de32adfb1615731db4bdc4">&#9670;&nbsp;</a></span>SetVertexCoordinatesFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlagrange_1_1_surface_mesh.html#ad1a827e540de32adfb1615731db4bdc4">SetVertexCoordinatesFunction</a> =  <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt;void(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> v, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt;<a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a>&gt; p)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function to set vertex coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Index of the vertex to set coordinates for (relative to the newly inserted vertices, i.e. starts at 0). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Output coordinate buffer to write to. The output array will contain K elements to write to, where K is the dimension of the mesh (3 by default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlagrange_1_1_surface_mesh.html#a411b43e769d84e48162e5a138576461e" title="Adds multiple vertices to the mesh.">add_vertices</a> </dd></dl>

</div>
</div>
<a id="af7c4a35e4a6fdc126381b1d87fb4f925" name="af7c4a35e4a6fdc126381b1d87fb4f925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c4a35e4a6fdc126381b1d87fb4f925">&#9670;&nbsp;</a></span>SetSingleFacetIndicesFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlagrange_1_1_surface_mesh.html#af7c4a35e4a6fdc126381b1d87fb4f925">SetSingleFacetIndicesFunction</a> =  <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt;void(<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt;<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&gt; t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function to set indices of a single facet. </p>
<p >The facet size is fixed and known in advance by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">t</td><td>Output index buffer to write to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlagrange_1_1_surface_mesh.html#a5b293b572411c9c95744b5b720c36466" title="Adds a single (uninitialized) polygonal facet to the mesh.">add_polygon</a> </dd></dl>

</div>
</div>
<a id="a110ca5c4b8ccc87ba99cb515e8dcf159" name="a110ca5c4b8ccc87ba99cb515e8dcf159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110ca5c4b8ccc87ba99cb515e8dcf159">&#9670;&nbsp;</a></span>SetMultiFacetsIndicesFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlagrange_1_1_surface_mesh.html#a110ca5c4b8ccc87ba99cb515e8dcf159">SetMultiFacetsIndicesFunction</a> =  <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt;void(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> f, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt;<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&gt; t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function to set indices of a multiple facets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Index of the facet whose size to compute (relative to the newly inserted facets, starting with 0). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">t</td><td>Output index buffer to write to. You can query the size of the current output facet by calling t.size().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlagrange_1_1_surface_mesh.html#a7bfdace2787040a67ac3c70549f6bc96" title="Adds multiple triangular facets to the mesh.">add_triangles</a>, <a class="el" href="classlagrange_1_1_surface_mesh.html#a057ba271be050a99a0d6ed57b5ba4fbd" title="Adds multiple quadrilateral facets to the mesh.">add_quads</a>, <a class="el" href="classlagrange_1_1_surface_mesh.html#af7fe8ccea4a8bb761b9a914e7098e8e7" title="Adds multiple polygonal facets of the same size to the mesh.">add_polygons</a>, <a class="el" href="classlagrange_1_1_surface_mesh.html#a01ab7b86186dd296975156b85a69c044" title="Adds multiple polygonal facets of different sizes to the mesh.">add_hybrid</a> </dd></dl>

</div>
</div>
<a id="a170c2bfbae529972c9db5de7025ab581" name="a170c2bfbae529972c9db5de7025ab581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170c2bfbae529972c9db5de7025ab581">&#9670;&nbsp;</a></span>GetFacetsSizeFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlagrange_1_1_surface_mesh.html#a170c2bfbae529972c9db5de7025ab581">GetFacetsSizeFunction</a> =  <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt;<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> f)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function to get a facet size (number of vertices in the facet). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Index of the facet whose size to compute (relative to the newly inserted facets, starting with 0).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlagrange_1_1_surface_mesh.html#a01ab7b86186dd296975156b85a69c044" title="Adds multiple polygonal facets of different sizes to the mesh.">add_hybrid</a> </dd></dl>

</div>
</div>
<a id="a0099ac3b79b3ecddccca10409e576f8f" name="a0099ac3b79b3ecddccca10409e576f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0099ac3b79b3ecddccca10409e576f8f">&#9670;&nbsp;</a></span>GetEdgeVertices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlagrange_1_1_surface_mesh.html#a0099ac3b79b3ecddccca10409e576f8f">GetEdgeVertices</a> =  <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt;std::array&lt;<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>, 2&gt;(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> e)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function to get the vertex indices of an edge endpoints in a user-provided ordering of a mesh edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Index of the edge being queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of indices for the vertex endpoints. </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a690cbdbb73863039c0a9efd804f17060" name="a690cbdbb73863039c0a9efd804f17060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690cbdbb73863039c0a9efd804f17060">&#9670;&nbsp;</a></span>SurfaceMesh() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>dimension</em> = <code>3</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dimension</td><td>Vertex dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab5f3271851e9674d6854d3be68b028c" name="aab5f3271851e9674d6854d3be68b028c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5f3271851e9674d6854d3be68b028c">&#9670;&nbsp;</a></span>SurfaceMesh() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar_, Index_ &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Instance to move from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe79736e3cd24cd01a150f9024122a97" name="abe79736e3cd24cd01a150f9024122a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe79736e3cd24cd01a150f9024122a97">&#9670;&nbsp;</a></span>SurfaceMesh() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar_, Index_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Instance to copy from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcce031cac2089eb461de50514ce32d3" name="afcce031cac2089eb461de50514ce32d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcce031cac2089eb461de50514ce32d3">&#9670;&nbsp;</a></span>SurfaceMesh() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlagrange_1_1_surface_mesh_1_1_bare_mesh_tag.html">BareMeshTag</a>&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Tag to distinguish from the public constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a92946ffa35c6d3863f9784b858575cd9" name="a92946ffa35c6d3863f9784b858575cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92946ffa35c6d3863f9784b858575cd9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a>, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar_, Index_ &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment move operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Instance to move from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the assignment. </dd></dl>

</div>
</div>
<a id="a6282f62f8ac4dc937bd7881bc6e93a92" name="a6282f62f8ac4dc937bd7881bc6e93a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6282f62f8ac4dc937bd7881bc6e93a92">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a>, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt; &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar_, Index_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment copy operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Instance to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the copy. </dd></dl>

</div>
</div>
<a id="a18650836a79106f33671d373b1390899" name="a18650836a79106f33671d373b1390899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18650836a79106f33671d373b1390899">&#9670;&nbsp;</a></span>stripped_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a> stripped_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; OtherScalar, OtherIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor stripping away non-reserved attributes. </p>
<p >Will internally cast the scalar and index type to the desired type. This static constructor is used internally to implement the more high-level <code>cast</code> and <code>filter_attribute</code> function.</p>
<dl class="section note"><dt>Note</dt><dd>Should this function take an optional list of attribute ids to preserve, and/or provide stable attribute ids?</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Instance to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherScalar</td><td>Other mesh scalar type. </td></tr>
    <tr><td class="paramname">OtherIndex</td><td>Other mesh index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the copy.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group-surfacemesh-utils.html#gab7596be540e8db5808abc8c322fd7460" title="Cast a mesh to a mesh of different scalar and/or index type.">cast</a> </dd>
<dd>
<a class="el" href="group__group-surfacemesh-utils.html#gac94fc907068f80f41ede4fabca362289" title="Filters the attributes of mesh according to user specifications.">filter_attributes</a> </dd></dl>

</div>
</div>
<a id="ae06ed49eb2f3d1b565a6b9a9cc701101" name="ae06ed49eb2f3d1b565a6b9a9cc701101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06ed49eb2f3d1b565a6b9a9cc701101">&#9670;&nbsp;</a></span>stripped_move()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a> stripped_move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; OtherScalar, OtherIndex &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor stripping away non-reserved attributes. </p>
<p >Will internally cast the scalar and index type to the desired type. This static constructor is used internally to implement the more high-level <code>cast</code> and <code>filter_attribute</code> function.</p>
<dl class="section note"><dt>Note</dt><dd>Should this function take an optional list of attribute ids to preserve, and/or provide stable attribute ids?</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Instance to move from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherScalar</td><td>Other mesh scalar type. </td></tr>
    <tr><td class="paramname">OtherIndex</td><td>Other mesh index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the move.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group-surfacemesh-utils.html#gab7596be540e8db5808abc8c322fd7460" title="Cast a mesh to a mesh of different scalar and/or index type.">cast</a> </dd>
<dd>
<a class="el" href="group__group-surfacemesh-utils.html#gac94fc907068f80f41ede4fabca362289" title="Filters the attributes of mesh according to user specifications.">filter_attributes</a> </dd></dl>

</div>
</div>
<a id="a676e602bf7c9e51e79980dabd1ade6e5" name="a676e602bf7c9e51e79980dabd1ade6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676e602bf7c9e51e79980dabd1ade6e5">&#9670;&nbsp;</a></span>add_vertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a vertex to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Vertex coordinates with the same dimensionality as the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11ec8cbd868fc184a69efa0233ea67fc" name="a11ec8cbd868fc184a69efa0233ea67fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ec8cbd868fc184a69efa0233ea67fc">&#9670;&nbsp;</a></span>add_vertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_vertex </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a vertex to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Vertex coordinates with the same dimensionality as the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a411b43e769d84e48162e5a138576461e" name="a411b43e769d84e48162e5a138576461e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411b43e769d84e48162e5a138576461e">&#9670;&nbsp;</a></span>add_vertices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt;&#160;</td>
          <td class="paramname"><em>coordinates</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple vertices to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_vertices</td><td>Number of vertices to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coordinates</td><td>A contiguous array of point coordinates (num_vertices x dimension). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29fdea9415859dcf2dd667ff793654e0" name="a29fdea9415859dcf2dd667ff793654e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29fdea9415859dcf2dd667ff793654e0">&#9670;&nbsp;</a></span>add_vertices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt;&#160;</td>
          <td class="paramname"><em>coordinates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple vertices to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_vertices</td><td>Number of vertices to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coordinates</td><td>A contiguous array of point coordinates (num_vertices x dimension). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaba0a28b5617e1bb44a7ec3afdf2ce05" name="aaba0a28b5617e1bb44a7ec3afdf2ce05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba0a28b5617e1bb44a7ec3afdf2ce05">&#9670;&nbsp;</a></span>add_vertices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#ad1a827e540de32adfb1615731db4bdc4">SetVertexCoordinatesFunction</a>&#160;</td>
          <td class="paramname"><em>set_vertex_coordinates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple vertices to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_vertices</td><td>Number of vertices to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">set_vertex_coordinates</td><td>Function to set point coordinates of a given vertex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7260f42ee2a672a47f03a9f7d4222e86" name="a7260f42ee2a672a47f03a9f7d4222e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7260f42ee2a672a47f03a9f7d4222e86">&#9670;&nbsp;</a></span>add_triangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_triangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a triangular facet to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v0</td><td>Index of the first vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>Index of the second vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>Index of the third vertex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bfdace2787040a67ac3c70549f6bc96" name="a7bfdace2787040a67ac3c70549f6bc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfdace2787040a67ac3c70549f6bc96">&#9670;&nbsp;</a></span>add_triangles() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_triangles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facet_indices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple triangular facets to the mesh. </p>
<dl class="section warning"><dt>Warning</dt><dd>If the mesh contains edge/connectivity attributes, this function will throw an exception if you pass an empty buffer of facet indices. This is because it is impossible to update edge/connectivity information if the facet buffer is directly modified by the user. Instead, the correct facet indices must be provided when the facet is constructed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_facets</td><td>Number of facets to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_indices</td><td>A contiguous array of corner indices, where facet_indices[3*i+k] is the index of the k-th corner of the i-th facet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76db110558443cd81542e5d86c2eb3ee" name="a76db110558443cd81542e5d86c2eb3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76db110558443cd81542e5d86c2eb3ee">&#9670;&nbsp;</a></span>add_triangles() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_triangles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facet_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple triangular facets to the mesh. </p>
<dl class="section warning"><dt>Warning</dt><dd>If the mesh contains edge/connectivity attributes, this function will throw an exception if you pass an empty buffer of facet indices. This is because it is impossible to update edge/connectivity information if the facet buffer is directly modified by the user. Instead, the correct facet indices must be provided when the facet is constructed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_facets</td><td>Number of facets to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_indices</td><td>A contiguous array of corner indices, where facet_indices[3*i+k] is the index of the k-th corner of the i-th facet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49f0192a971c23d318f6d242d1021c5e" name="a49f0192a971c23d318f6d242d1021c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f0192a971c23d318f6d242d1021c5e">&#9670;&nbsp;</a></span>add_triangles() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_triangles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a110ca5c4b8ccc87ba99cb515e8dcf159">SetMultiFacetsIndicesFunction</a>&#160;</td>
          <td class="paramname"><em>set_facets_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple triangular facets to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_facets</td><td>Number of facets to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">set_facets_indices</td><td>Callable function to set vertex indices of a given facet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59058cae85488a247f116f9acbdbe026" name="a59058cae85488a247f116f9acbdbe026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59058cae85488a247f116f9acbdbe026">&#9670;&nbsp;</a></span>add_quad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_quad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a quadrilateral facet to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v0</td><td>Index of the first vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>Index of the second vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>Index of the third vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v3</td><td>Index of the fourth vertex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a057ba271be050a99a0d6ed57b5ba4fbd" name="a057ba271be050a99a0d6ed57b5ba4fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057ba271be050a99a0d6ed57b5ba4fbd">&#9670;&nbsp;</a></span>add_quads() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_quads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facet_indices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple quadrilateral facets to the mesh. </p>
<dl class="section warning"><dt>Warning</dt><dd>If the mesh contains edge/connectivity attributes, this function will throw an exception if you pass an empty buffer of facet indices. This is because it is impossible to update edge/connectivity information if the facet buffer is directly modified by the user. Instead, the correct facet indices must be provided when the facet is constructed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_facets</td><td>Number of facets to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_indices</td><td>A contiguous array of corner indices, where facet_indices[4*i+k] is the index of the k-th corner of the i-th facet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ddacc6569fa170e0bd2e8ce29216462" name="a2ddacc6569fa170e0bd2e8ce29216462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddacc6569fa170e0bd2e8ce29216462">&#9670;&nbsp;</a></span>add_quads() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_quads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facet_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple quadrilateral facets to the mesh. </p>
<dl class="section warning"><dt>Warning</dt><dd>If the mesh contains edge/connectivity attributes, this function will throw an exception if you pass an empty buffer of facet indices. This is because it is impossible to update edge/connectivity information if the facet buffer is directly modified by the user. Instead, the correct facet indices must be provided when the facet is constructed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_facets</td><td>Number of facets to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_indices</td><td>A contiguous array of corner indices, where facet_indices[4*i+k] is the index of the k-th corner of the i-th facet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0af8af91d5f216f96046f12cf4b66aff" name="a0af8af91d5f216f96046f12cf4b66aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af8af91d5f216f96046f12cf4b66aff">&#9670;&nbsp;</a></span>add_quads() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_quads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a110ca5c4b8ccc87ba99cb515e8dcf159">SetMultiFacetsIndicesFunction</a>&#160;</td>
          <td class="paramname"><em>set_facets_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple quadrilateral facets to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_facets</td><td>Number of facets to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">set_facets_indices</td><td>Callable function to set vertex indices of a given facet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b293b572411c9c95744b5b720c36466" name="a5b293b572411c9c95744b5b720c36466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b293b572411c9c95744b5b720c36466">&#9670;&nbsp;</a></span>add_polygon() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_polygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>facet_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a single (uninitialized) polygonal facet to the mesh. </p>
<p >Facet indices are set to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_size</td><td>Number of vertices in the facet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade4cc8868c8cc2a8cf4078b06e2cc9fe" name="ade4cc8868c8cc2a8cf4078b06e2cc9fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4cc8868c8cc2a8cf4078b06e2cc9fe">&#9670;&nbsp;</a></span>add_polygon() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_polygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facet_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a single polygonal facet to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_indices</td><td>A contiguous array of vertex indices in the facet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c487626cb4ce3304c5449f81fa6214a" name="a7c487626cb4ce3304c5449f81fa6214a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c487626cb4ce3304c5449f81fa6214a">&#9670;&nbsp;</a></span>add_polygon() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_polygon </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facet_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a single polygonal facet to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_indices</td><td>A contiguous array of vertex indices in the facet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bd57ef1e8c1b66caad4e4cfd142b851" name="a1bd57ef1e8c1b66caad4e4cfd142b851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd57ef1e8c1b66caad4e4cfd142b851">&#9670;&nbsp;</a></span>add_polygon() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_polygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>facet_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#af7c4a35e4a6fdc126381b1d87fb4f925">SetSingleFacetIndicesFunction</a>&#160;</td>
          <td class="paramname"><em>set_facet_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a single polygonal facet to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_size</td><td>Number of vertices in the facet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">set_facet_indices</td><td>Callable function to retrieve facet indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7fe8ccea4a8bb761b9a914e7098e8e7" name="af7fe8ccea4a8bb761b9a914e7098e8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fe8ccea4a8bb761b9a914e7098e8e7">&#9670;&nbsp;</a></span>add_polygons() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_polygons </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>facet_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facet_indices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple polygonal facets of the same size to the mesh. </p>
<dl class="section warning"><dt>Warning</dt><dd>If the mesh contains edge/connectivity attributes, this function will throw an exception if you pass an empty buffer of facet indices. This is because it is impossible to update edge/connectivity information if the facet buffer is directly modified by the user. Instead, the correct facet indices must be provided when the facet is constructed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_facets</td><td>Number of facets to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_size</td><td>Size of each facet to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_indices</td><td>A contiguous array of corner indices, where facet_indices[facet_size*i+k] is the index of the k-th corner of the i-th facet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d7a2d46fa8f07cad0a085e6166496a4" name="a6d7a2d46fa8f07cad0a085e6166496a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7a2d46fa8f07cad0a085e6166496a4">&#9670;&nbsp;</a></span>add_polygons() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_polygons </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>facet_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facet_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple polygonal facets of the same size to the mesh. </p>
<dl class="section warning"><dt>Warning</dt><dd>If the mesh contains edge/connectivity attributes, this function will throw an exception if you pass an empty buffer of facet indices. This is because it is impossible to update edge/connectivity information if the facet buffer is directly modified by the user. Instead, the correct facet indices must be provided when the facet is constructed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_facets</td><td>Number of facets to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_size</td><td>Size of each facet to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_indices</td><td>A contiguous array of corner indices, where facet_indices[facet_size*i+k] is the index of the k-th corner of the i-th facet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada20815c5104580b91eb5a733548a746" name="ada20815c5104580b91eb5a733548a746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada20815c5104580b91eb5a733548a746">&#9670;&nbsp;</a></span>add_polygons() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_polygons </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>facet_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a110ca5c4b8ccc87ba99cb515e8dcf159">SetMultiFacetsIndicesFunction</a>&#160;</td>
          <td class="paramname"><em>set_facets_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple polygonal facets of the same size to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_facets</td><td>Number of facets to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_size</td><td>Size of each facet to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">set_facets_indices</td><td>Callable function to set vertex indices of a given facet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01ab7b86186dd296975156b85a69c044" name="a01ab7b86186dd296975156b85a69c044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ab7b86186dd296975156b85a69c044">&#9670;&nbsp;</a></span>add_hybrid() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_hybrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facet_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facet_indices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple polygonal facets of different sizes to the mesh. </p>
<dl class="section warning"><dt>Warning</dt><dd>If the mesh contains edge/connectivity attributes, this function will throw an exception if you pass an empty buffer of facet indices. This is because it is impossible to update edge/connectivity information if the facet buffer is directly modified by the user. Instead, the correct facet indices must be provided when the facet is constructed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_sizes</td><td>A contiguous array representing the size of each facet to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_indices</td><td>A contiguous array of corner indices, where facet_indices[sum(facet_sizes(j), j&lt;=i) + k] is the index of the k-th corner of the i-th facet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a728c35f41e1c6d97b283cc4b55bc2a0b" name="a728c35f41e1c6d97b283cc4b55bc2a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728c35f41e1c6d97b283cc4b55bc2a0b">&#9670;&nbsp;</a></span>add_hybrid() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_hybrid </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facet_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facet_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple polygonal facets of different sizes to the mesh. </p>
<dl class="section warning"><dt>Warning</dt><dd>If the mesh contains edge/connectivity attributes, this function will throw an exception if you pass an empty buffer of facet indices. This is because it is impossible to update edge/connectivity information if the facet buffer is directly modified by the user. Instead, the correct facet indices must be provided when the facet is constructed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_sizes</td><td>A contiguous array representing the size of each facet to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_indices</td><td>A contiguous array of corner indices, where facet_indices[sum(facet_sizes(j), j&lt;=i) + k] is the index of the k-th corner of the i-th facet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b78f6c00b851f3edc3676f357c383bc" name="a2b78f6c00b851f3edc3676f357c383bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b78f6c00b851f3edc3676f357c383bc">&#9670;&nbsp;</a></span>add_hybrid() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_hybrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a170c2bfbae529972c9db5de7025ab581">GetFacetsSizeFunction</a>&#160;</td>
          <td class="paramname"><em>facet_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a110ca5c4b8ccc87ba99cb515e8dcf159">SetMultiFacetsIndicesFunction</a>&#160;</td>
          <td class="paramname"><em>set_facets_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple polygonal facets of different sizes to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_facets</td><td>Number of facets to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_sizes</td><td>Callable function to retrieve the size of each facet to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">set_facets_indices</td><td>Callable function to set vertex indices of a given facet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e81913baaac39a48f35de9127a5bb6d" name="a4e81913baaac39a48f35de9127a5bb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e81913baaac39a48f35de9127a5bb6d">&#9670;&nbsp;</a></span>remove_vertices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>vertices_to_remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a list of vertices. </p>
<p >The set of vertices should be provided as a sorted list, otherwise an exception is raised.</p>
<dl class="section note"><dt>Note</dt><dd>This function will remove any facet incident to a removed vertex.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices_to_remove</td><td>The vertices to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c8eb6bcf31295d0facec46d411844ae" name="a2c8eb6bcf31295d0facec46d411844ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8eb6bcf31295d0facec46d411844ae">&#9670;&nbsp;</a></span>remove_vertices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_vertices </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>vertices_to_remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a list of vertices. </p>
<p >The set of vertices should be provided as a sorted list, otherwise an exception is raised.</p>
<dl class="section note"><dt>Note</dt><dd>This function will remove any facet incident to a removed vertex.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices_to_remove</td><td>The vertices to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc2fb6f223bb81c84ab9242bf05593bc" name="acc2fb6f223bb81c84ab9242bf05593bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2fb6f223bb81c84ab9242bf05593bc">&#9670;&nbsp;</a></span>remove_vertices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; bool(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>)&gt;&#160;</td>
          <td class="paramname"><em>should_remove_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a list of vertices, defined by a predicate function. </p>
<dl class="section note"><dt>Note</dt><dd>This function will remove any facet incident to a removed vertex.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">should_remove_func</td><td>Function to determine if a vertex of a particular index should be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e921adc62dec46ff115047e8dca3709" name="a4e921adc62dec46ff115047e8dca3709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e921adc62dec46ff115047e8dca3709">&#9670;&nbsp;</a></span>remove_facets() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facets_to_remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a list of facets. </p>
<p >The set of facets should be provided as a sorted list, otherwise an exception is raised.</p>
<dl class="section note"><dt>Note</dt><dd>This function does <em>not</em> remove any isolated vertex that occurs due to facet removal.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">facets_to_remove</td><td>The facets to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a798b6c85ec6dce3c87a964a97ebfbee9" name="a798b6c85ec6dce3c87a964a97ebfbee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798b6c85ec6dce3c87a964a97ebfbee9">&#9670;&nbsp;</a></span>remove_facets() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_facets </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facets_to_remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a list of facets. </p>
<p >The set of facets should be provided as a sorted list, otherwise an exception is raised.</p>
<dl class="section note"><dt>Note</dt><dd>This function does <em>not</em> remove any isolated vertex that occurs due to facet removal.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">facets_to_remove</td><td>The facets to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af26dd0d4194157564a2a8bc5c4a75838" name="af26dd0d4194157564a2a8bc5c4a75838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26dd0d4194157564a2a8bc5c4a75838">&#9670;&nbsp;</a></span>remove_facets() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; bool(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>)&gt;&#160;</td>
          <td class="paramname"><em>should_remove_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a list of facets, defined by a predicate function. </p>
<dl class="section note"><dt>Note</dt><dd>This function does <em>not</em> remove any isolated vertex that occurs due to facet removal.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">should_remove_func</td><td>Function to determine if a facet of a particular index should be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3f06c8c0c8232a40cd409d2c2cd0797" name="af3f06c8c0c8232a40cd409d2c2cd0797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f06c8c0c8232a40cd409d2c2cd0797">&#9670;&nbsp;</a></span>clear_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear_vertices</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear buffer for mesh vertices and other vertex attributes. </p>
<p >Since this function also removes any invalid facet, the entire mesh will be cleared. </p>

</div>
</div>
<a id="a5f80448a8d74d0063352c3a049e05db0" name="a5f80448a8d74d0063352c3a049e05db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f80448a8d74d0063352c3a049e05db0">&#9670;&nbsp;</a></span>clear_facets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear_facets</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear buffer for mesh facets and other facet/corner attributes. </p>
<p >The resulting mesh will be a point cloud made of isolated vertices. </p>

</div>
</div>
<a id="a9cb3b1a40e1f2b467d5831ec86540610" name="a9cb3b1a40e1f2b467d5831ec86540610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb3b1a40e1f2b467d5831ec86540610">&#9670;&nbsp;</a></span>compress_if_regular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compress_if_regular</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compress mesh storage if the mesh is regular. </p>
<p >This iterates over all facets to check if the mesh is regular. If so the following attributes are removed:</p>
<ul>
<li>"$facet_to_first_corner"</li>
<li>"$corner_to_facet" </li>
</ul>

</div>
</div>
<a id="a9cede937c41f63448522e8522f7d65a5" name="a9cede937c41f63448522e8522f7d65a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cede937c41f63448522e8522f7d65a5">&#9670;&nbsp;</a></span>is_triangle_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_triangle_mesh</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the mesh <em>must</em> only contain triangular facets. </p>
<p >Accessors.</p>
<p >A mesh with no facet is considered a triangle mesh.</p>
<dl class="section note"><dt>Note</dt><dd>A mesh with hybrid storage <em>may</em> still be a triangle mesh, which this method does not check.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if triangle mesh, False otherwise. </dd></dl>

</div>
</div>
<a id="a0a85b726b7fde45bfec81127fc85c042" name="a0a85b726b7fde45bfec81127fc85c042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a85b726b7fde45bfec81127fc85c042">&#9670;&nbsp;</a></span>is_quad_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_quad_mesh</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the mesh <em>must</em> only contains quadrilateral facets. </p>
<p >A mesh with no facet is considered a quad mesh.</p>
<dl class="section note"><dt>Note</dt><dd>A mesh with hybrid storage <em>may</em> still be a quad mesh, which this method does not check.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if quad mesh, False otherwise. </dd></dl>

</div>
</div>
<a id="a83fe6c77afa1adfe15669fd0e1a492a4" name="a83fe6c77afa1adfe15669fd0e1a492a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83fe6c77afa1adfe15669fd0e1a492a4">&#9670;&nbsp;</a></span>is_regular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_regular</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the mesh <em>must</em> only contains facets of equal sizes. </p>
<p >A mesh with no facet is considered regular.</p>
<dl class="section note"><dt>Note</dt><dd>A mesh with hybrid storage <em>may</em> still be have regular facet sizes, which this method does not check.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if regular, False otherwise. </dd></dl>

</div>
</div>
<a id="ab428865a842b8f10664c5ef5c6fb5bb8" name="ab428865a842b8f10664c5ef5c6fb5bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab428865a842b8f10664c5ef5c6fb5bb8">&#9670;&nbsp;</a></span>is_hybrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_hybrid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the mesh <em>may</em> contain facets of different sizes. </p>
<p >This is the opposite of is_regular (an empty mesh is <em>not</em> considered hybrid).</p>
<dl class="section note"><dt>Note</dt><dd>A mesh with hybrid storage <em>may</em> still have all its facet be the same size, which this method does not check.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if hybrid, False otherwise. </dd></dl>

</div>
</div>
<a id="a2cf4bf7fff25304bc12204359cd593f8" name="a2cf4bf7fff25304bc12204359cd593f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf4bf7fff25304bc12204359cd593f8">&#9670;&nbsp;</a></span>get_dimension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> get_dimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the dimension of the mesh vertices. </p>
<dl class="section return"><dt>Returns</dt><dd>The mesh dimension. </dd></dl>

</div>
</div>
<a id="abd39a328d5689f8b05c3f871079d77ce" name="abd39a328d5689f8b05c3f871079d77ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd39a328d5689f8b05c3f871079d77ce">&#9670;&nbsp;</a></span>get_vertex_per_facet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_vertex_per_facet</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the number of vertex per facet in a regular mesh. </p>
<p >If the mesh is a hybrid mesh, an exception is thrown.s</p>
<dl class="section return"><dt>Returns</dt><dd>The number of vertices per facet. </dd></dl>

</div>
</div>
<a id="a1ed57c732bcdb304ed7033147f5d9002" name="a1ed57c732bcdb304ed7033147f5d9002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed57c732bcdb304ed7033147f5d9002">&#9670;&nbsp;</a></span>get_num_vertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> get_num_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the number of vertices. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of vertices. </dd></dl>

</div>
</div>
<a id="abcf8a67369f4ebda946306ae39673d4a" name="abcf8a67369f4ebda946306ae39673d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf8a67369f4ebda946306ae39673d4a">&#9670;&nbsp;</a></span>get_num_facets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> get_num_facets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the number of facets. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of facets. </dd></dl>

</div>
</div>
<a id="afe4c8dc375784713f55d92df922f9f05" name="afe4c8dc375784713f55d92df922f9f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4c8dc375784713f55d92df922f9f05">&#9670;&nbsp;</a></span>get_num_corners()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> get_num_corners </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the number of corners. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of corners. </dd></dl>

</div>
</div>
<a id="ab4b72663d159f5e5280c524fab4cebc3" name="ab4b72663d159f5e5280c524fab4cebc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b72663d159f5e5280c524fab4cebc3">&#9670;&nbsp;</a></span>get_num_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> get_num_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the number of edges. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of edges. </dd></dl>

</div>
</div>
<a id="aff3c7ed82d37bd216c497a3aff3e6f3f" name="aff3c7ed82d37bd216c497a3aff3e6f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3c7ed82d37bd216c497a3aff3e6f3f">&#9670;&nbsp;</a></span>get_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a read-only pointer to a vertex coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Vertex index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Point coordinates of the queried vertex. </dd></dl>

</div>
</div>
<a id="abf830eab5e349aff1947a5f6f1c7bb5c" name="abf830eab5e349aff1947a5f6f1c7bb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf830eab5e349aff1947a5f6f1c7bb5c">&#9670;&nbsp;</a></span>ref_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto ref_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a writeable pointer to a vertex coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Vertex index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Point coordinates of the queried vertex. </dd></dl>

</div>
</div>
<a id="af08dee4f91c8d35b17755d5020b11f70" name="af08dee4f91c8d35b17755d5020b11f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08dee4f91c8d35b17755d5020b11f70">&#9670;&nbsp;</a></span>get_facet_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> get_facet_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of vertices in the facet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Facet index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of vertices in the queried facet. </dd></dl>

</div>
</div>
<a id="a9aaa0edcdd05e7062a6e50b35d00ac53" name="a9aaa0edcdd05e7062a6e50b35d00ac53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aaa0edcdd05e7062a6e50b35d00ac53">&#9670;&nbsp;</a></span>get_facet_vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> get_facet_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>lv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of a vertex given from a facet + local index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Facet index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lv</td><td>Local vertex index inside the facet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the vertex in the mesh. </dd></dl>

</div>
</div>
<a id="a62d307d406c30a019e11e4bc4ae25fdb" name="a62d307d406c30a019e11e4bc4ae25fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d307d406c30a019e11e4bc4ae25fdb">&#9670;&nbsp;</a></span>get_facet_corner_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_facet_corner_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>First corner around the facet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Facet index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>First corner index for the queried facet. </dd></dl>

</div>
</div>
<a id="a0b66afb06f58353045a125bfacde0ed3" name="a0b66afb06f58353045a125bfacde0ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b66afb06f58353045a125bfacde0ed3">&#9670;&nbsp;</a></span>get_facet_corner_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_facet_corner_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index past the last corner around the facet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Facet index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index past the last corner index for the queried facet. </dd></dl>

</div>
</div>
<a id="a9ece031d61939757b93e1e40098309b8" name="a9ece031d61939757b93e1e40098309b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ece031d61939757b93e1e40098309b8">&#9670;&nbsp;</a></span>get_corner_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_corner_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the index of a vertex given its corner index. </p>
<p >E.g. this can be used in conjunction with get_facet_corner_begin and get_facet_corner_end to iterate over the vertices of a facet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Corner index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the vertex in the mesh. </dd></dl>

</div>
</div>
<a id="aa9b0cbb93871714a74f5177ddfdf089b" name="aa9b0cbb93871714a74f5177ddfdf089b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b0cbb93871714a74f5177ddfdf089b">&#9670;&nbsp;</a></span>get_corner_facet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_corner_facet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the index of a facet given its corner index. </p>
<p >If the mesh is regular, this is simply the corner index / num of vertex per facet. If the mesh is a hybrid polygonal mesh, this mapping is stored in a reserved attribute.s</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Corner index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the facet containing this corner. </dd></dl>

</div>
</div>
<a id="aae46ecc7ee5bfd74ed48a4666496d915" name="aae46ecc7ee5bfd74ed48a4666496d915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae46ecc7ee5bfd74ed48a4666496d915">&#9670;&nbsp;</a></span>get_facet_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_facet_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a read-only pointer to a facet indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Facet index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the facet vertices. </dd></dl>

</div>
</div>
<a id="a4c2119d5a1f0b8196beff748b6768caf" name="a4c2119d5a1f0b8196beff748b6768caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2119d5a1f0b8196beff748b6768caf">&#9670;&nbsp;</a></span>ref_facet_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto ref_facet_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a writable pointer to a facet indices. </p>
<dl class="section warning"><dt>Warning</dt><dd>If the mesh contains edge/connectivity attributes, this function will throw an exception. This is because it is impossible to update edge/connectivity information if the facet buffer is directly modified by the user. Instead, the correct facet indices must be provided when the facet is constructed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Facet index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the facet vertices. </dd></dl>

</div>
</div>
<a id="a3e504cec2bcd421abd9b687024c35e11" name="a3e504cec2bcd421abd9b687024c35e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e504cec2bcd421abd9b687024c35e11">&#9670;&nbsp;</a></span>get_attribute_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> get_attribute_id </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an attribute id given its name. </p>
<p >If the attribute doesn't exist, <a class="el" href="group__group-surfacemesh-attr.html#gaaf6e674ed673001dca1c6390bc0e0fc9" title="Invalid attribute id.">invalid_attribute_id()</a> is returned instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute identifier. </dd></dl>

</div>
</div>
<a id="a0aa87b8195ea787f9117193eb16a43f6" name="a0aa87b8195ea787f9117193eb16a43f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa87b8195ea787f9117193eb16a43f6">&#9670;&nbsp;</a></span>get_attribute_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view get_attribute_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve attribute name from its id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Attribute id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Attribute's name.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception</td><td>if id is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a378678c13a2ce7be484f3f0034fd1100" name="a378678c13a2ce7be484f3f0034fd1100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378678c13a2ce7be484f3f0034fd1100">&#9670;&nbsp;</a></span>create_attribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> create_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a>&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_channels</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em> = <code><a class="el" href="group__group-surfacemesh-attr.html#gga5a2f28c8b9e2f8fce6e70b2418c46e45a57dea6f5039281b7fee517fc43bf3110">AttributeUsage::Vector</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const ValueType &gt;&#160;</td>
          <td class="paramname"><em>initial_values</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>initial_indices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga809dfcec94612491ec5be8bb8614ceab">AttributeCreatePolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="group__group-surfacemesh-attr.html#gga809dfcec94612491ec5be8bb8614ceabafc443f72fcb562a73b40af34ddb599a3">AttributeCreatePolicy::ErrorIfReserved</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new attribute and return the newly created attribute id. </p>
<p >A mesh attribute is stored as a row-major R x C matrix. The number of rows (R) is determined by the number of elements in the mesh that the attribute is attached to. The number of columns (C) is determined by the user when the attribute is created (num_channels), and cannot be modified afterwards. Note that the attribute tag determines how many channels are acceptable for certain types of attributes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>Mesh element to which the attribute is attached to (Vertex, Facet, etc.). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_channels</td><td>The number of channels for the attribute. Cannot be modified once the attribute has been created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usage</td><td>Tag to indicate how the values are modified under rigid transformation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initial_values</td><td>A span of initial values to populate the attribute values with. The data is copied into the attribute. If the span is provided, it must have the right dimension (number of elements x number of channels). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initial_indices</td><td>A span of initial values to populate the attribute indices with. If the attribute element type is not Indexed, providing a non-empty value for this argument will result in a runtime error. The data is copied into the attribute. If the span is provided, it must have the right dimension (number of corners). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">policy</td><td>Attribute creation policy. By default using a reserved attribute name (starting with a "$") will throw an exception.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Value type for the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute identifier.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45" title="Usage tag indicating how the attribute should behave under mesh transformations.">AttributeUsage</a> </dd></dl>

</div>
</div>
<a id="a4e44dd1284b49329da5d51a4db74cbbb" name="a4e44dd1284b49329da5d51a4db74cbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e44dd1284b49329da5d51a4db74cbbb">&#9670;&nbsp;</a></span>create_attribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> create_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a>&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_channels</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const ValueType &gt;&#160;</td>
          <td class="paramname"><em>initial_values</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>initial_indices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga809dfcec94612491ec5be8bb8614ceab">AttributeCreatePolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="group__group-surfacemesh-attr.html#gga809dfcec94612491ec5be8bb8614ceabafc443f72fcb562a73b40af34ddb599a3">AttributeCreatePolicy::ErrorIfReserved</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.Create a new attribute and return the newly created attribute id. </p>
<p >A mesh attribute is stored as a row-major R x C matrix. The number of rows (R) is determined by the number of elements in the mesh that the attribute is attached to. The number of columns (C) is determined by the user when the attribute is created (num_channels), and cannot be modified afterwards. Note that the attribute tag determines how many channels are acceptable for certain types of attributes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>Mesh element to which the attribute is attached to (Vertex, Facet, etc.). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usage</td><td>Tag to indicate how the values are modified under rigid transformation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_channels</td><td>The number of channels for the attribute. Cannot be modified once the attribute has been created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initial_values</td><td>A span of initial values to populate the attribute values with. The data is copied into the attribute. If the span is provided, it must have the right dimension (number of elements x number of channels). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initial_indices</td><td>A span of initial values to populate the attribute indices with. If the attribute element type is not Indexed, providing a non-empty value for this argument will result in a runtime error. The data is copied into the attribute. If the span is provided, it must have the right dimension (number of corners). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">policy</td><td>Attribute creation policy. By default using a reserved attribute name (starting with a "$") will throw an exception.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Value type for the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute identifier.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45" title="Usage tag indicating how the attribute should behave under mesh transformations.">AttributeUsage</a> </dd></dl>

</div>
</div>
<a id="a6ae3cb86e951fb27826bc12d8018d03c" name="a6ae3cb86e951fb27826bc12d8018d03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae3cb86e951fb27826bc12d8018d03c">&#9670;&nbsp;</a></span>create_attribute_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> create_attribute_from </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; OtherScalar, OtherIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>source_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>source_name</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an new attribute by creating a shallow copy of another mesh's attribute. </p>
<p >The mesh can reference itself. This only performs a shallow copy, sharing the underlying data buffer. If either meshes performs a write operation, a deep copy will be performed (the modifications are not shared). Note that if the number of elements differs between the source and target meshes, an exception is raised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source_mesh</td><td>Source mesh from which to copy the attribute from. The mesh can reference itself. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source_name</td><td><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> name to copy from. If left empty, the target attribute name will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherScalar</td><td>Source mesh scalar type. </td></tr>
    <tr><td class="paramname">OtherIndex</td><td>Source mesh index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute identifier. </dd></dl>

</div>
</div>
<a id="ad3f51c7ce47c56fdd44ac7960044c277" name="ad3f51c7ce47c56fdd44ac7960044c277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f51c7ce47c56fdd44ac7960044c277">&#9670;&nbsp;</a></span>wrap_as_attribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a>&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; ValueType &gt;&#160;</td>
          <td class="paramname"><em>values_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a writable external buffer as a mesh attribute. </p>
<p >The buffer must remain valid during the lifetime of the mesh object (and any derived meshes that might have been copied from it).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>Mesh element to which the attribute is attached to (Vertex, Facet, etc.). The element type must not be Indexed. Please use wrap_as_indexed_attribute for that. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usage</td><td>Tag to indicate how the values are modified under rigid transformation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_channels</td><td>The number of channels for the attribute. Cannot be modified once the attribute has been created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values_view</td><td>A span of the external buffer to use as storage for the attribute values. The provided span must have enough capacity to hold (number of elements x number of channels) items. It is ok to provide a span with a larger capacity than needed, which will allow for the mesh to grow.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Value type for the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute identifier. </dd></dl>

</div>
</div>
<a id="ab48a4e34be13288053df2eda15989395" name="ab48a4e34be13288053df2eda15989395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48a4e34be13288053df2eda15989395">&#9670;&nbsp;</a></span>wrap_as_attribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a>&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; ValueType &gt;&#160;</td>
          <td class="paramname"><em>shared_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This function differs from the prevous version by participating in shared ownership management of the buffer referred by <code>shared_values</code>. </dd></dl>

</div>
</div>
<a id="ab4273659a074810181638f86fbe4373c" name="ab4273659a074810181638f86fbe4373c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4273659a074810181638f86fbe4373c">&#9670;&nbsp;</a></span>wrap_as_const_attribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_const_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a>&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const ValueType &gt;&#160;</td>
          <td class="paramname"><em>values_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a read-only external buffer as a mesh attribute. </p>
<p >The buffer must remain valid during the lifetime of the mesh object (and any derived meshes that might have been copied from it). Any operation that attempts to write data to the attribute will throw a runtime exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>Mesh element to which the attribute is attached to (Vertex, Facet, etc.). The element type must not be Indexed. Please use wrap_as_indexed_attribute for that. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usage</td><td>Tag to indicate how the values are modified under rigid transformation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_channels</td><td>The number of channels for the attribute. Cannot be modified once the attribute has been created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values_view</td><td>A span of the external buffer to use as storage for the attribute values. The provided span must have a size &gt;= (number of elements x number of channels) items. It is ok to provide a span with a larger capacity than needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Value type for the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute identifier. </dd></dl>

</div>
</div>
<a id="a2305d56cb409f81da2e013d5d238cde9" name="a2305d56cb409f81da2e013d5d238cde9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2305d56cb409f81da2e013d5d238cde9">&#9670;&nbsp;</a></span>wrap_as_const_attribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_const_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a>&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const ValueType &gt;&#160;</td>
          <td class="paramname"><em>shared_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This function differs from the prevous version by participating in shared ownership management of the buffer referred by <code>shared_values</code>. </dd></dl>

</div>
</div>
<a id="ac0cb4ae7ef9528cff1f5baca53711e84" name="ac0cb4ae7ef9528cff1f5baca53711e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cb4ae7ef9528cff1f5baca53711e84">&#9670;&nbsp;</a></span>wrap_as_indexed_attribute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_indexed_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; ValueType &gt;&#160;</td>
          <td class="paramname"><em>values_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a writable external buffer as a mesh attribute. </p>
<p >The buffer must remain valid during the lifetime of the mesh object (and any derived meshes that might have been copied from it).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usage</td><td>Tag to indicate how the values are modified under rigid transformation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_values</td><td>Initial number of rows in the value buffer for the attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_channels</td><td>The number of channels for the attribute. Cannot be modified once the attribute has been created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values_view</td><td>A span of the external buffer to use as storage for the attribute values. The provided span must have enough capacity to hold (number of values x number of channels) items. It is ok to provide a span with a larger capacity than needed, which will allow for the attribute to grow. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices_view</td><td>A span of the external buffer to use as storage for the attribute indices. The provided span must have enough capacity to hold (number of corners) items. It is ok to provide a span with a larger capacity than needed, which will allow for the attribute to grow.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Value type for the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute identifier. </dd></dl>

</div>
</div>
<a id="a6d9436711cfb248b5dd05afdcaaa68bd" name="a6d9436711cfb248b5dd05afdcaaa68bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9436711cfb248b5dd05afdcaaa68bd">&#9670;&nbsp;</a></span>wrap_as_indexed_attribute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_indexed_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; ValueType &gt;&#160;</td>
          <td class="paramname"><em>shared_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>shared_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This function differs from the prevous version by participating in shared ownership management of the buffer referred by <code>shared_values</code> and <code>shared_indices</code>. </dd></dl>

</div>
</div>
<a id="a85a6ea183121c7418e92814b6837f89a" name="a85a6ea183121c7418e92814b6837f89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a6ea183121c7418e92814b6837f89a">&#9670;&nbsp;</a></span>wrap_as_indexed_attribute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_indexed_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; ValueType &gt;&#160;</td>
          <td class="paramname"><em>values_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>shared_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This function differs from the prevous version by participating in shared ownership management of the buffer referred by <code>shared_indices</code>. </dd></dl>

</div>
</div>
<a id="a75e332144b414cb2964a7cc7d48ea485" name="a75e332144b414cb2964a7cc7d48ea485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e332144b414cb2964a7cc7d48ea485">&#9670;&nbsp;</a></span>wrap_as_indexed_attribute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_indexed_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; ValueType &gt;&#160;</td>
          <td class="paramname"><em>shared_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This function differs from the prevous version by participating in shared ownership management of the buffer referred by <code>shared_values</code>. </dd></dl>

</div>
</div>
<a id="a5334d560ab700341d3deec635520057d" name="a5334d560ab700341d3deec635520057d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5334d560ab700341d3deec635520057d">&#9670;&nbsp;</a></span>wrap_as_const_indexed_attribute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_const_indexed_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const ValueType &gt;&#160;</td>
          <td class="paramname"><em>values_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a read-only external buffer as a mesh attribute. </p>
<p >The buffer must remain valid during the lifetime of the mesh object (and any derived meshes that might have been copied from it). Any operation that attempts to write data to the attribute will throw a runtime exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usage</td><td>Tag to indicate how the values are modified under rigid transformation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_values</td><td>Initial number of rows in the value buffer for the attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_channels</td><td>The number of channels for the attribute. Cannot be modified once the attribute has been created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values_view</td><td>A span of the external buffer to use as storage for the attribute values. The provided span must have enough capacity to hold (number of values x number of channels) items. It is ok to provide a span with a larger capacity than needed, which will allow for the attribute to grow. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices_view</td><td>A span of the external buffer to use as storage for the attribute indices. The provided span must have enough capacity to hold (number of corners) items. It is ok to provide a span with a larger capacity than needed, which will allow for the attribute to grow.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Value type for the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute identifier. </dd></dl>

</div>
</div>
<a id="a067454a184b992240f45d8006095d8d3" name="a067454a184b992240f45d8006095d8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067454a184b992240f45d8006095d8d3">&#9670;&nbsp;</a></span>wrap_as_const_indexed_attribute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_const_indexed_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const ValueType &gt;&#160;</td>
          <td class="paramname"><em>shared_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>shared_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This function differs from the prevous version by participating in shared ownership management of the buffers referred by <code>shared_values</code> and <code>shared_indices</code>. </dd></dl>

</div>
</div>
<a id="a2fb2dd6cc67c86e3a1ba0813b8152e53" name="a2fb2dd6cc67c86e3a1ba0813b8152e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb2dd6cc67c86e3a1ba0813b8152e53">&#9670;&nbsp;</a></span>wrap_as_const_indexed_attribute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_const_indexed_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const ValueType &gt;&#160;</td>
          <td class="paramname"><em>values_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>shared_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This function differs from the prevous version by participating in shared ownership management of the buffer referred by <code>shared_indices</code>. </dd></dl>

</div>
</div>
<a id="a076065d5ad8d9f55d2202bc6d24c2c44" name="a076065d5ad8d9f55d2202bc6d24c2c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076065d5ad8d9f55d2202bc6d24c2c44">&#9670;&nbsp;</a></span>wrap_as_const_indexed_attribute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_const_indexed_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const ValueType &gt;&#160;</td>
          <td class="paramname"><em>shared_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>indices_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This function differs from the prevous version by participating in shared ownership management of the buffer referred by <code>shared_values</code>. </dd></dl>

</div>
</div>
<a id="ab8c6f796ec0588302d42ff96970f1bc5" name="ab8c6f796ec0588302d42ff96970f1bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c6f796ec0588302d42ff96970f1bc5">&#9670;&nbsp;</a></span>wrap_as_vertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt;&#160;</td>
          <td class="paramname"><em>vertices_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a writable external buffer as mesh vertices coordinates. </p>
<p >The buffer must remain valid during the lifetime of the mesh object (and any derived meshes that might have been copied from it). The user must provide the new number of vertices to resize the mesh with.</p>
<dl class="section note"><dt>Note</dt><dd>The mesh dimension cannot be changed, and is determined by the mesh constructor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices_view</td><td>A span of the external buffer to use as storage for mesh vertices. The provided span must have a size &gt;= (num vertices x mesh dimension). It is ok to provide a span larger than needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_vertices</td><td>Number of vertices to resize the mesh with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute identifier. </dd></dl>

</div>
</div>
<a id="a4adc9389ef36d420240e577577a11a52" name="a4adc9389ef36d420240e577577a11a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4adc9389ef36d420240e577577a11a52">&#9670;&nbsp;</a></span>wrap_as_vertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt;&#160;</td>
          <td class="paramname"><em>shared_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This function differs from the prevous version by participating in shared ownership management of the buffer referred by <code>shared_vertices</code>. </dd></dl>

</div>
</div>
<a id="a9990f194f65dc11e3a36c687864d8976" name="a9990f194f65dc11e3a36c687864d8976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9990f194f65dc11e3a36c687864d8976">&#9670;&nbsp;</a></span>wrap_as_const_vertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_const_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt;&#160;</td>
          <td class="paramname"><em>vertices_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a read-only external buffer as mesh vertices coordinates. </p>
<p >The buffer must remain valid during the lifetime of the mesh object (and any derived meshes that might have been copied from it). The user must provide the new number of vertices to resize the mesh with. Any operation that attempts to write to mesh vertices will throw a runtime exception.</p>
<dl class="section note"><dt>Note</dt><dd>The mesh dimension cannot be changed, and is determined by the mesh constructor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices_view</td><td>A span of the external buffer to use as storage for mesh vertices. The provided span must have a size &gt;= (num vertices x mesh dimension). It is ok to provide a span larger than needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_vertices</td><td>Number of vertices to resize the mesh with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute identifier. </dd></dl>

</div>
</div>
<a id="af7452ff5d1a16457fa73ac93fa960cb7" name="af7452ff5d1a16457fa73ac93fa960cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7452ff5d1a16457fa73ac93fa960cb7">&#9670;&nbsp;</a></span>wrap_as_const_vertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_const_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a6e7ee8ed1fabd5e89d353a7e9596009e">Scalar</a> &gt;&#160;</td>
          <td class="paramname"><em>shared_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This function differs from the prevous version by participating in shared ownership management of the buffer referred by <code>shared_vertices</code>. </dd></dl>

</div>
</div>
<a id="ae70fd65a58e6c322cc359577bdf31712" name="ae70fd65a58e6c322cc359577bdf31712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70fd65a58e6c322cc359577bdf31712">&#9670;&nbsp;</a></span>wrap_as_facets() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facets_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>vertex_per_facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a writable external buffer as mesh facets for a regular mesh. </p>
<p >The buffer must remain valid during the lifetime of the mesh object (and any derived meshes that might have been copied from it). The user must provide the new number of facets to resize the mesh with.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">facets_view</td><td>A span of the external buffer to use as storage for mesh facet indices. The provided span must have a size &gt;= (num_facets x vertex_per_facet). It is ok to provide a span larger than needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_facets</td><td>Number of facets to resize the mesh with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_per_facet</td><td>Number of vertices per facet in the provided span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute identifier. </dd></dl>

</div>
</div>
<a id="a58b5e5cb618233cdbc97a19927e39ea5" name="a58b5e5cb618233cdbc97a19927e39ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b5e5cb618233cdbc97a19927e39ea5">&#9670;&nbsp;</a></span>wrap_as_facets() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>shared_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>vertex_per_facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This function differs from the prevous version by participating in shared ownership management of the buffer referred by <code>shared_facets</code>. </dd></dl>

</div>
</div>
<a id="a9b4345e9a203bea515b2290275a5faac" name="a9b4345e9a203bea515b2290275a5faac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4345e9a203bea515b2290275a5faac">&#9670;&nbsp;</a></span>wrap_as_const_facets() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_const_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facets_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>vertex_per_facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a read-only external buffer as mesh facets for a regular mesh. </p>
<p >The buffer must remain valid during the lifetime of the mesh object (and any derived meshes that might have been copied from it). The user must provide the new number of facets to resize the mesh with. Any operation that attempts to write to mesh facets will throw a runtime exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">facets_view</td><td>A span of the external buffer to use as storage for mesh facet indices. The provided span must have a size &gt;= (num_facets x vertex_per_facet). It is ok to provide a span larger than needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_facets</td><td>Number of facets to resize the mesh with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_per_facet</td><td>Number of vertices per facet in the provided span.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute identifier. </dd></dl>

</div>
</div>
<a id="af50dffcd12ebdbbdbd73cdbac3a35f29" name="af50dffcd12ebdbbdbd73cdbac3a35f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50dffcd12ebdbbdbd73cdbac3a35f29">&#9670;&nbsp;</a></span>wrap_as_const_facets() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_const_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>shared_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>vertex_per_facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This function differs from the prevous version by participating in shared ownership management of the buffer referred by <code>shared_facets</code>. </dd></dl>

</div>
</div>
<a id="a52b89a6d10eee2400c2ca3d1c32dcf01" name="a52b89a6d10eee2400c2ca3d1c32dcf01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b89a6d10eee2400c2ca3d1c32dcf01">&#9670;&nbsp;</a></span>wrap_as_facets() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>offsets_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facets_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_corners</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps writable external buffers as mesh facets for a hybrid mesh. </p>
<p >The buffer must remain valid during the lifetime of the mesh object (and any derived meshes that might have been copied from it). The user must provide the new number of facets to resize the mesh with.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets_view</td><td>A span of the external buffer to use as storage for mesh offset indices (facet -&gt; first corner index). The provided span must have a size &gt;= num_facets. It is ok to provide a span larger than needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_facets</td><td>Number of facets to resize the mesh with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facets_view</td><td>A span of the external buffer to use as storage for mesh facet indices (corner -&gt; vertex index). The provided span must have a size &gt;= num_corners. It is ok to provide a span larger than needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_corners</td><td>Total number of facet corners in the resized mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute identifier. </dd></dl>

</div>
</div>
<a id="aba338fbe4d6ec3c973080baad9b1ba86" name="aba338fbe4d6ec3c973080baad9b1ba86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba338fbe4d6ec3c973080baad9b1ba86">&#9670;&nbsp;</a></span>wrap_as_facets() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>shared_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>shared_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_corners</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This function differs from the prevous version by participating in shared ownership management of the buffers referred by <code>shared_offsets</code> and <code>shared_facets</code>. </dd></dl>

</div>
</div>
<a id="a877f2c797f61f515586135e619335de3" name="a877f2c797f61f515586135e619335de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877f2c797f61f515586135e619335de3">&#9670;&nbsp;</a></span>wrap_as_facets() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>offsets_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>shared_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_corners</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This function differs from the prevous version by participating in shared ownership management of the buffer referred by <code>shared_facets</code>. </dd></dl>

</div>
</div>
<a id="a2cbb1f8298d02454712f2afcd4147b2a" name="a2cbb1f8298d02454712f2afcd4147b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbb1f8298d02454712f2afcd4147b2a">&#9670;&nbsp;</a></span>wrap_as_facets() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>shared_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facets_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_corners</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This function differs from the prevous version by participating in shared ownership management of the buffer referred by <code>shared_offsets</code>. </dd></dl>

</div>
</div>
<a id="a579faf1a71ae048baabbd5faf8eb6331" name="a579faf1a71ae048baabbd5faf8eb6331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579faf1a71ae048baabbd5faf8eb6331">&#9670;&nbsp;</a></span>wrap_as_const_facets() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_const_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>offsets_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facets_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_corners</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps read-only external buffers as mesh facets for a hybrid mesh. </p>
<p >The buffer must remain valid during the lifetime of the mesh object (and any derived meshes that might have been copied from it). The user must provide the new number of facets to resize the mesh with. Any operation that attempts to write to mesh facets will throw a runtime exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets_view</td><td>A span of the external buffer to use as storage for mesh offset indices (facet -&gt; first corner index). The provided span must have a size &gt;= num_facets. It is ok to provide a span larger than needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_facets</td><td>Number of facets to resize the mesh with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facets_view</td><td>A span of the external buffer to use as storage for mesh facet indices (corner -&gt; vertex index). The provided span must have a size &gt;= num_corners. It is ok to provide a span larger than needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_corners</td><td>Total number of facet corners in the resized mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute identifier. </dd></dl>

</div>
</div>
<a id="abdd17fbbc2c114c5d04c5f0b072ed80f" name="abdd17fbbc2c114c5d04c5f0b072ed80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd17fbbc2c114c5d04c5f0b072ed80f">&#9670;&nbsp;</a></span>wrap_as_const_facets() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_const_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>shared_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>shared_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_corners</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This function differs from the prevous version by participating in shared ownership management of the buffers referred by <code>shared_offsets</code> and <code>shared_facets</code>. </dd></dl>

</div>
</div>
<a id="aaa5194c18f3ea1a7ae2fdb45bc0f9938" name="aaa5194c18f3ea1a7ae2fdb45bc0f9938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5194c18f3ea1a7ae2fdb45bc0f9938">&#9670;&nbsp;</a></span>wrap_as_const_facets() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_const_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>offsets_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>shared_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_corners</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This function differs from the prevous version by participating in shared ownership management of the buffer referred by <code>shared_facets</code>. </dd></dl>

</div>
</div>
<a id="a52a5afd620a5769f3e21eb62e9624774" name="a52a5afd620a5769f3e21eb62e9624774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a5afd620a5769f3e21eb62e9624774">&#9670;&nbsp;</a></span>wrap_as_const_facets() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_const_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>shared_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facets_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_corners</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This function differs from the prevous version by participating in shared ownership management of the buffer referred by <code>shared_offsets</code>. </dd></dl>

</div>
</div>
<a id="ac105eafb5fa2eab8e87215d26ebb21c0" name="ac105eafb5fa2eab8e87215d26ebb21c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac105eafb5fa2eab8e87215d26ebb21c0">&#9670;&nbsp;</a></span>duplicate_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> duplicate_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>new_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicates an attribute. </p>
<p >This creates a shallow copy of the data, until a write operation occurs on either attribute. The new name must not belong to an existing attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">old_name</td><td>Old attribute name to duplicate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_name</td><td>New attribute name to create.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute identifier for the new attribute. </dd></dl>

</div>
</div>
<a id="aeb2d780919768c503a50a0947a21e856" name="aeb2d780919768c503a50a0947a21e856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2d780919768c503a50a0947a21e856">&#9670;&nbsp;</a></span>rename_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rename_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>new_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename an existing attribute. </p>
<p >Attribute id remains unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">old_name</td><td>Old attribute name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_name</td><td>New attribute name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d338472b33656740632fd6d58dfc9a7" name="a1d338472b33656740632fd6d58dfc9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d338472b33656740632fd6d58dfc9a7">&#9670;&nbsp;</a></span>delete_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#gad17b213b11e78aeb807ad3ece7e67e84">AttributeDeletePolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="group__group-surfacemesh-attr.html#ggad17b213b11e78aeb807ad3ece7e67e84afc443f72fcb562a73b40af34ddb599a3">AttributeDeletePolicy::ErrorIfReserved</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an attribute given by name. </p>
<p >The attribute must exist. If the attribute is a reserved name (starts with a "$"), then you must specify force=true to delete the attribute.</p>
<dl class="section note"><dt>Note</dt><dd>There is no performance benefit in deleting an attribute given by id only, as we would need to free its name from the list of existing attributes anyway.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">policy</td><td>Delete policy for reserved attribute names. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28d0478f3b515915db6dede4b645966c" name="a28d0478f3b515915db6dede4b645966c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d0478f3b515915db6dede4b645966c">&#9670;&nbsp;</a></span>delete_and_export_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &gt; delete_and_export_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#gad17b213b11e78aeb807ad3ece7e67e84">AttributeDeletePolicy</a>&#160;</td>
          <td class="paramname"><em>delete_policy</em> = <code><a class="el" href="group__group-surfacemesh-attr.html#ggad17b213b11e78aeb807ad3ece7e67e84afc443f72fcb562a73b40af34ddb599a3">AttributeDeletePolicy::ErrorIfReserved</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#gade3ae5b7e72e9d4f92f29c6563551c10">AttributeExportPolicy</a>&#160;</td>
          <td class="paramname"><em>export_policy</em> = <code><a class="el" href="group__group-surfacemesh-attr.html#ggade3ae5b7e72e9d4f92f29c6563551c10afe72de1001d465db9eb6ce5cb874c2cb">AttributeExportPolicy::CopyIfExternal</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an attribute and export its content in a writable shared_ptr. </p>
<p >The attribute must exist.</p><ul>
<li>If the content is managed by the mesh:<ol type="1">
<li>If it is uniquely owned, no copy is performed.</li>
<li>If ownership is shared, a copy is performed (just like any other copy-on-write operation).</li>
</ol>
</li>
<li>If the content points to an external buffer, a policy flag determines what happens.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delete_policy</td><td>Delete policy for reserved attribute names. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">export_policy</td><td>Export policy for non-owned buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Value type for the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer holding the attribute data. </dd></dl>

</div>
</div>
<a id="a545ec348c92a85cc38a6c6d3f5277535" name="a545ec348c92a85cc38a6c6d3f5277535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545ec348c92a85cc38a6c6d3f5277535">&#9670;&nbsp;</a></span>delete_and_export_const_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &gt; delete_and_export_const_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#gad17b213b11e78aeb807ad3ece7e67e84">AttributeDeletePolicy</a>&#160;</td>
          <td class="paramname"><em>delete_policy</em> = <code><a class="el" href="group__group-surfacemesh-attr.html#ggad17b213b11e78aeb807ad3ece7e67e84afc443f72fcb562a73b40af34ddb599a3">AttributeDeletePolicy::ErrorIfReserved</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#gade3ae5b7e72e9d4f92f29c6563551c10">AttributeExportPolicy</a>&#160;</td>
          <td class="paramname"><em>export_policy</em> = <code><a class="el" href="group__group-surfacemesh-attr.html#ggade3ae5b7e72e9d4f92f29c6563551c10afe72de1001d465db9eb6ce5cb874c2cb">AttributeExportPolicy::CopyIfExternal</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an attribute and export its content in a read-only shared_ptr. </p>
<p >The attribute must exist.</p><ul>
<li>If the content is managed by the mesh:<ol type="1">
<li>If it is uniquely owned, no copy is performed.</li>
<li>If ownership is shared, a copy is performed (just like any other copy-on-write operation).</li>
</ol>
</li>
<li>If the content points to an external buffer, a policy flag determines what happens.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delete_policy</td><td>Delete policy for reserved attribute names. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">export_policy</td><td>Export policy for non-owned buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Value type for the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer holding the attribute data. </dd></dl>

</div>
</div>
<a id="aacb851b667e316033ab311cb13ed0241" name="aacb851b667e316033ab311cb13ed0241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb851b667e316033ab311cb13ed0241">&#9670;&nbsp;</a></span>delete_and_export_indexed_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto delete_and_export_indexed_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#gade3ae5b7e72e9d4f92f29c6563551c10">AttributeExportPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="group__group-surfacemesh-attr.html#ggade3ae5b7e72e9d4f92f29c6563551c10afe72de1001d465db9eb6ce5cb874c2cb">AttributeExportPolicy::CopyIfExternal</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::shared_ptr&lt;<a class="el" href="classlagrange_1_1_indexed_attribute.html">IndexedAttribute</a>&lt;ValueType, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an indexed attribute and export its content in a writable shared_ptr. </p>
<p >The attribute must exist.</p><ul>
<li>If the content is managed by the mesh:<ol type="1">
<li>If it is uniquely owned, no copy is performed.</li>
<li>If ownership is shared, a copy is performed (just like any other copy-on-write operation).</li>
</ol>
</li>
<li>If the content points to an external buffer, a policy flag determines what happens.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">policy</td><td>Export policy for non-owned buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Value type for the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer holding the attribute data. </dd></dl>

</div>
</div>
<a id="af5e377cd17d586686cb6dcd2293c587b" name="af5e377cd17d586686cb6dcd2293c587b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e377cd17d586686cb6dcd2293c587b">&#9670;&nbsp;</a></span>delete_and_export_const_indexed_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto delete_and_export_const_indexed_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#gade3ae5b7e72e9d4f92f29c6563551c10">AttributeExportPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="group__group-surfacemesh-attr.html#ggade3ae5b7e72e9d4f92f29c6563551c10afe72de1001d465db9eb6ce5cb874c2cb">AttributeExportPolicy::CopyIfExternal</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::shared_ptr&lt;const <a class="el" href="classlagrange_1_1_indexed_attribute.html">IndexedAttribute</a>&lt;ValueType, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an indexed attribute and export its content in a read-only shared_ptr. </p>
<p >The attribute must exist.</p><ul>
<li>If the content is managed by the mesh:<ol type="1">
<li>If it is uniquely owned, no copy is performed.</li>
<li>If ownership is shared, a copy is performed (just like any other copy-on-write operation).</li>
</ol>
</li>
<li>If the content points to an external buffer, a policy flag determines what happens.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">policy</td><td>Export policy for non-owned buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Value type for the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer holding the attribute data. </dd></dl>

</div>
</div>
<a id="a50303aab396d555e2ad0e6fa1f7d4b58" name="a50303aab396d555e2ad0e6fa1f7d4b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50303aab396d555e2ad0e6fa1f7d4b58">&#9670;&nbsp;</a></span>has_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool has_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an attribute of a given name is attached to the mesh. </p>
<dl class="section note"><dt>Note</dt><dd>Attribute ids can be reused after deletion, so it does not make sense to test if an attribute exist based on an attribute id.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the attribute exists, False otherwise. </dd></dl>

</div>
</div>
<a id="a3d0ea2006d431b6ec0b29ce05fce1da9" name="a3d0ea2006d431b6ec0b29ce05fce1da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0ea2006d431b6ec0b29ce05fce1da9">&#9670;&nbsp;</a></span>is_attribute_type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_attribute_type </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the specified attribute is of a given type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the attribute to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Attribute type to test against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified attribute has the given type, False otherwise. </dd></dl>

</div>
</div>
<a id="a1a1d061d46d76ce93cd0f1194e5df01a" name="a1a1d061d46d76ce93cd0f1194e5df01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a1d061d46d76ce93cd0f1194e5df01a">&#9670;&nbsp;</a></span>is_attribute_type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_attribute_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the specified attribute is of a given type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Id of the attribute to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Attribute type to test against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified attribute has the given type, False otherwise. </dd></dl>

</div>
</div>
<a id="a8957ea4b91cd0a8462521eb27ecf13ee" name="a8957ea4b91cd0a8462521eb27ecf13ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8957ea4b91cd0a8462521eb27ecf13ee">&#9670;&nbsp;</a></span>is_attribute_indexed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_attribute_indexed </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the specified attribute is indexed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the attribute to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified attribute is indexed, False otherwise. </dd></dl>

</div>
</div>
<a id="a57e4ae976a96f26d966babe95fdb589c" name="a57e4ae976a96f26d966babe95fdb589c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e4ae976a96f26d966babe95fdb589c">&#9670;&nbsp;</a></span>is_attribute_indexed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_attribute_indexed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the specified attribute is indexed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Id of the attribute to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified attribute is indexed, False otherwise. </dd></dl>

</div>
</div>
<a id="affeb2a94afa3e342e3adf7f5351c4e5f" name="affeb2a94afa3e342e3adf7f5351c4e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affeb2a94afa3e342e3adf7f5351c4e5f">&#9670;&nbsp;</a></span>seq_foreach_attribute_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seq_foreach_attribute_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterates over all attribute ids sequentially. </p>
<p >This function is intended to be a low-level operator. For convenience functions to visit mesh attributes. See <a class="el" href="foreach__attribute_8h_source.html">foreach_attribute.h</a> for more information.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="foreach__attribute_8h_source.html">foreach_attribute.h</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Function to iterate over attributes ids. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a761f0a6b5579be53f4e6d6d232dce22c" name="a761f0a6b5579be53f4e6d6d232dce22c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761f0a6b5579be53f4e6d6d232dce22c">&#9670;&nbsp;</a></span>seq_foreach_attribute_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seq_foreach_attribute_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(std::string_view, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterates over all pairs of attribute names x ids sequentially. </p>
<p >This function is intended to be a low-level operator. For convenience functions to visit mesh attributes. See <a class="el" href="foreach__attribute_8h_source.html">foreach_attribute.h</a> for more information.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="foreach__attribute_8h_source.html">foreach_attribute.h</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Function to iterate over attributes names x ids. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09be8d43ffe0507de31bccd15143f928" name="a09be8d43ffe0507de31bccd15143f928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09be8d43ffe0507de31bccd15143f928">&#9670;&nbsp;</a></span>par_foreach_attribute_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void par_foreach_attribute_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterates over all attribute ids in parallel. </p>
<p >This function is intended to be a low-level operator. For convenience functions to visit mesh attributes. See <a class="el" href="foreach__attribute_8h_source.html">foreach_attribute.h</a> for more information.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="foreach__attribute_8h_source.html">foreach_attribute.h</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Function to iterate over attributes ids. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91ab5e6343f4b3c85288a7c35d2261c8" name="a91ab5e6343f4b3c85288a7c35d2261c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ab5e6343f4b3c85288a7c35d2261c8">&#9670;&nbsp;</a></span>par_foreach_attribute_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void par_foreach_attribute_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(std::string_view, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterates over all pairs of attribute names x ids in parallel. </p>
<p >This function is intended to be a low-level operator. For convenience functions to visit mesh attributes. See <a class="el" href="foreach__attribute_8h_source.html">foreach_attribute.h</a> for more information.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="foreach__attribute_8h_source.html">foreach_attribute.h</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Function to iterate over attributes names x ids. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70acd5189ef3b33e3e272a16215a6ed1" name="a70acd5189ef3b33e3e272a16215a6ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70acd5189ef3b33e3e272a16215a6ed1">&#9670;&nbsp;</a></span>get_attribute_base() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlagrange_1_1_attribute_base.html">AttributeBase</a> &amp; get_attribute_base </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a read-only reference to the base class of attribute given its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute reference. </dd></dl>

</div>
</div>
<a id="ad5fc1c7d6ff27a9a400dbe4382aefbf7" name="ad5fc1c7d6ff27a9a400dbe4382aefbf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fc1c7d6ff27a9a400dbe4382aefbf7">&#9670;&nbsp;</a></span>get_attribute_base() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlagrange_1_1_attribute_base.html">AttributeBase</a> &amp; get_attribute_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a read-only reference to an attribute given its id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Attribute id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute reference. </dd></dl>

</div>
</div>
<a id="a1c11c467637dffa99eafca4ed7c016ea" name="a1c11c467637dffa99eafca4ed7c016ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c11c467637dffa99eafca4ed7c016ea">&#9670;&nbsp;</a></span>get_attribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp; get_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a read-only reference to an attribute given its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Scalar type stored in the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute reference. </dd></dl>

</div>
</div>
<a id="a528f884aabf3d710335c1be13b6f63ee" name="a528f884aabf3d710335c1be13b6f63ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528f884aabf3d710335c1be13b6f63ee">&#9670;&nbsp;</a></span>get_attribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp; get_attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a read-only reference to an attribute given its id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Attribute id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Scalar type stored in the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute reference. </dd></dl>

</div>
</div>
<a id="af91a0b5497bef4a9ce6b18a7b2830426" name="af91a0b5497bef4a9ce6b18a7b2830426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af91a0b5497bef4a9ce6b18a7b2830426">&#9670;&nbsp;</a></span>_get_attribute_ptr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1internal_1_1weak__ptr.html">internal::weak_ptr</a>&lt; const <a class="el" href="classlagrange_1_1_attribute_base.html">AttributeBase</a> &gt; _get_attribute_ptr </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a read-only weak pointer to the base attribute object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A weak ptr to the base attribute object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is for tracking the life span of the attribute object. </dd></dl>

</div>
</div>
<a id="a319531657219ef88187c329cedf33127" name="a319531657219ef88187c329cedf33127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319531657219ef88187c329cedf33127">&#9670;&nbsp;</a></span>_get_attribute_ptr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1internal_1_1weak__ptr.html">internal::weak_ptr</a>&lt; const <a class="el" href="classlagrange_1_1_attribute_base.html">AttributeBase</a> &gt; _get_attribute_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a read-only weak pointer to the base attribute object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Attribute id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A weak ptr to the base attribute object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is for tracking the life span of the attribute object. </dd></dl>

</div>
</div>
<a id="a7e64c208726bc382b5093d804b9629e1" name="a7e64c208726bc382b5093d804b9629e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e64c208726bc382b5093d804b9629e1">&#9670;&nbsp;</a></span>get_indexed_attribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_indexed_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const -&gt; const <a class="el" href="classlagrange_1_1_indexed_attribute.html">IndexedAttribute</a>&lt;ValueType, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&gt;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a read-only reference to an indexed attribute given its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Scalar type stored in the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute reference. </dd></dl>

</div>
</div>
<a id="afdb3d0d2b824b62c139b6a7e9ea9eadc" name="afdb3d0d2b824b62c139b6a7e9ea9eadc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb3d0d2b824b62c139b6a7e9ea9eadc">&#9670;&nbsp;</a></span>get_indexed_attribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_indexed_attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const -&gt; const <a class="el" href="classlagrange_1_1_indexed_attribute.html">IndexedAttribute</a>&lt;ValueType, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&gt;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a read-only reference to an indexed attribute given its id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Attribute id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Scalar type stored in the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute reference. </dd></dl>

</div>
</div>
<a id="a2226b6b1921c3a5a7f674a9c94e83be5" name="a2226b6b1921c3a5a7f674a9c94e83be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2226b6b1921c3a5a7f674a9c94e83be5">&#9670;&nbsp;</a></span>ref_attribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp; ref_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a writable reference to an attribute given its name. </p>
<p >If the attribute is a shallow copy with shared ownership, calling this function will result in a copy of the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Scalar type stored in the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute reference. </dd></dl>

</div>
</div>
<a id="a80cad0812ac7257b36854a35647de611" name="a80cad0812ac7257b36854a35647de611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cad0812ac7257b36854a35647de611">&#9670;&nbsp;</a></span>ref_attribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp; ref_attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a writable reference to an attribute given its id. </p>
<p >If the attribute is a shallow copy with shared ownership, calling this function will result in a copy of the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Attribute id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Scalar type stored in the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute reference. </dd></dl>

</div>
</div>
<a id="a6e8e34ca37c4ed40045c8b904453c6bd" name="a6e8e34ca37c4ed40045c8b904453c6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8e34ca37c4ed40045c8b904453c6bd">&#9670;&nbsp;</a></span>_ref_attribute_ptr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1internal_1_1weak__ptr.html">internal::weak_ptr</a>&lt; <a class="el" href="classlagrange_1_1_attribute_base.html">AttributeBase</a> &gt; _ref_attribute_ptr </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a weak pointer to the base attribute object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A weak ptr to the base attribute object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is for tracking the life span of the attribute object. </dd></dl>

</div>
</div>
<a id="a66aaa7f8cee5a1c5d5d3680592e1fac0" name="a66aaa7f8cee5a1c5d5d3680592e1fac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66aaa7f8cee5a1c5d5d3680592e1fac0">&#9670;&nbsp;</a></span>_ref_attribute_ptr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1internal_1_1weak__ptr.html">internal::weak_ptr</a>&lt; <a class="el" href="classlagrange_1_1_attribute_base.html">AttributeBase</a> &gt; _ref_attribute_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a weak pointer to the base attribute object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Attribute id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A weak ptr to the base attribute object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is for tracking the life span of the attribute object. </dd></dl>

</div>
</div>
<a id="ab37a6116db014729e9613238a94e2a8c" name="ab37a6116db014729e9613238a94e2a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37a6116db014729e9613238a94e2a8c">&#9670;&nbsp;</a></span>ref_indexed_attribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto ref_indexed_attribute </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classlagrange_1_1_indexed_attribute.html">IndexedAttribute</a>&lt;ValueType, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&gt;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a writable reference to an indexed attribute given its name. </p>
<p >If the attribute is a shallow copy with shared ownership, calling this function will result in a copy of the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Scalar type stored in the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute reference. </dd></dl>

</div>
</div>
<a id="a5c07782acefabc48e9af535ef09f04f3" name="a5c07782acefabc48e9af535ef09f04f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c07782acefabc48e9af535ef09f04f3">&#9670;&nbsp;</a></span>ref_indexed_attribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto ref_indexed_attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classlagrange_1_1_indexed_attribute.html">IndexedAttribute</a>&lt;ValueType, <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&gt;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a writable reference to an indexed attribute given its id. </p>
<p >If the attribute is a shallow copy with shared ownership, calling this function will result in a copy of the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Attribute id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Scalar type stored in the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute reference. </dd></dl>

</div>
</div>
<a id="aee3a373ed58ff8f9908b54ff36a0921b" name="aee3a373ed58ff8f9908b54ff36a0921b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3a373ed58ff8f9908b54ff36a0921b">&#9670;&nbsp;</a></span>get_vertex_to_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_vertex_to_position</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a read-only reference to the vertex -&gt; positions attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the attribute. </dd></dl>

</div>
</div>
<a id="a0b8e21c22801c3e1b32392c15c4c9e05" name="a0b8e21c22801c3e1b32392c15c4c9e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8e21c22801c3e1b32392c15c4c9e05">&#9670;&nbsp;</a></span>ref_vertex_to_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto ref_vertex_to_position</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a writable reference to the vertex -&gt; positions attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the attribute. </dd></dl>

</div>
</div>
<a id="a8a4de76f0e87a0509babc2bd81c0abaf" name="a8a4de76f0e87a0509babc2bd81c0abaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4de76f0e87a0509babc2bd81c0abaf">&#9670;&nbsp;</a></span>get_corner_to_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_corner_to_vertex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a read-only reference to the corner -&gt; vertex id attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Vertex indices attribute. </dd></dl>

</div>
</div>
<a id="ad3cd66ddb6e7a1f1023d197653a9d02e" name="ad3cd66ddb6e7a1f1023d197653a9d02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3cd66ddb6e7a1f1023d197653a9d02e">&#9670;&nbsp;</a></span>ref_corner_to_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto ref_corner_to_vertex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a writable reference to the corner -&gt; vertex id attribute. </p>
<dl class="section warning"><dt>Warning</dt><dd>If the mesh contains edge/connectivity attributes, this function will throw an exception. This is because it is impossible to update edge/connectivity information if the facet buffer is directly modified by the user. Instead, the correct facet indices must be provided when the facet is constructed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Vertex indices attribute. </dd></dl>

</div>
</div>
<a id="afc357ca433a43f66b93de4407ef73a15" name="afc357ca433a43f66b93de4407ef73a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc357ca433a43f66b93de4407ef73a15">&#9670;&nbsp;</a></span>attr_name_is_reserved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool attr_name_is_reserved </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the given name corresponds to a reserved attribute. </p>
<p >Reserved attributes are attributes whose name starts with a "$".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this is the name of a reserved attribute, false otherwise. </dd></dl>

</div>
</div>
<a id="a1609392d5977b255613678a98a71c5fe" name="a1609392d5977b255613678a98a71c5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1609392d5977b255613678a98a71c5fe">&#9670;&nbsp;</a></span>attr_name_vertex_to_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::string_view attr_name_vertex_to_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute name for vertex -&gt; position. </p>
<dl class="section return"><dt>Returns</dt><dd>Attribute name. </dd></dl>

</div>
</div>
<a id="a1786eeaff1dbaa59f64eb7ccb0a3b388" name="a1786eeaff1dbaa59f64eb7ccb0a3b388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1786eeaff1dbaa59f64eb7ccb0a3b388">&#9670;&nbsp;</a></span>attr_name_corner_to_vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::string_view attr_name_corner_to_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute name for corner -&gt; vertex indices. </p>
<dl class="section return"><dt>Returns</dt><dd>Attribute name. </dd></dl>

</div>
</div>
<a id="a0717232890d2663c40919a3d6b6f9a4a" name="a0717232890d2663c40919a3d6b6f9a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0717232890d2663c40919a3d6b6f9a4a">&#9670;&nbsp;</a></span>attr_name_facet_to_first_corner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::string_view attr_name_facet_to_first_corner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute name for facet -&gt; first corner index. </p>
<dl class="section return"><dt>Returns</dt><dd>Attribute name. </dd></dl>

</div>
</div>
<a id="a386bf2fb3a6963e967394c9fcebb5378" name="a386bf2fb3a6963e967394c9fcebb5378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386bf2fb3a6963e967394c9fcebb5378">&#9670;&nbsp;</a></span>attr_name_corner_to_facet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::string_view attr_name_corner_to_facet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute name for corner -&gt; facet index. </p>
<dl class="section return"><dt>Returns</dt><dd>Attribute name. </dd></dl>

</div>
</div>
<a id="ad27165df42355e7f82c6704707820e4b" name="ad27165df42355e7f82c6704707820e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27165df42355e7f82c6704707820e4b">&#9670;&nbsp;</a></span>attr_name_corner_to_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::string_view attr_name_corner_to_edge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute name for corner -&gt; edge indices. </p>
<dl class="section return"><dt>Returns</dt><dd>Attribute name. </dd></dl>

</div>
</div>
<a id="aaf7ddb64928477b169d2fa818f8e8535" name="aaf7ddb64928477b169d2fa818f8e8535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7ddb64928477b169d2fa818f8e8535">&#9670;&nbsp;</a></span>attr_name_edge_to_first_corner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::string_view attr_name_edge_to_first_corner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute name for edge -&gt; first corner index. </p>
<dl class="section return"><dt>Returns</dt><dd>Attribute name. </dd></dl>

</div>
</div>
<a id="afa0577250bef3d4ca3153187814aa02d" name="afa0577250bef3d4ca3153187814aa02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0577250bef3d4ca3153187814aa02d">&#9670;&nbsp;</a></span>attr_name_next_corner_around_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::string_view attr_name_next_corner_around_edge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute name for corner -&gt; next corner around edge. </p>
<dl class="section return"><dt>Returns</dt><dd>Attribute name. </dd></dl>

</div>
</div>
<a id="ac3e433d78196b31d1b5618822e3f6b0c" name="ac3e433d78196b31d1b5618822e3f6b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e433d78196b31d1b5618822e3f6b0c">&#9670;&nbsp;</a></span>attr_name_vertex_to_first_corner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::string_view attr_name_vertex_to_first_corner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute name for vertex -&gt; first corner index. </p>
<dl class="section return"><dt>Returns</dt><dd>Attribute name. </dd></dl>

</div>
</div>
<a id="a15d8fe2868a3c568d58b7b449ef88772" name="a15d8fe2868a3c568d58b7b449ef88772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d8fe2868a3c568d58b7b449ef88772">&#9670;&nbsp;</a></span>attr_name_next_corner_around_vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::string_view attr_name_next_corner_around_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute name for corner -&gt; next corner around vertex. </p>
<dl class="section return"><dt>Returns</dt><dd>Attribute name. </dd></dl>

</div>
</div>
<a id="a0453afe84f040b43f9c7cfa670065d4d" name="a0453afe84f040b43f9c7cfa670065d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0453afe84f040b43f9c7cfa670065d4d">&#9670;&nbsp;</a></span>attr_id_vertex_to_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> attr_id_vertex_to_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute id for vertex -&gt; positions. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> id. </dd></dl>

</div>
</div>
<a id="a5f1d893c997417a38024fd08c22fe42b" name="a5f1d893c997417a38024fd08c22fe42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1d893c997417a38024fd08c22fe42b">&#9670;&nbsp;</a></span>attr_id_vertex_to_positions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> attr_id_vertex_to_positions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute id for vertex -&gt; positions. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> id. </dd></dl>

</div>
</div>
<a id="a3c2c966fb4632c7ed1f17c24cab22393" name="a3c2c966fb4632c7ed1f17c24cab22393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2c966fb4632c7ed1f17c24cab22393">&#9670;&nbsp;</a></span>attr_id_corner_to_vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> attr_id_corner_to_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute id for corner -&gt; vertex indices. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> id. </dd></dl>

</div>
</div>
<a id="a288fb4645b935efb8651c99c4e491844" name="a288fb4645b935efb8651c99c4e491844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288fb4645b935efb8651c99c4e491844">&#9670;&nbsp;</a></span>attr_id_facet_to_first_corner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> attr_id_facet_to_first_corner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute id for facet -&gt; first corner index. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> id. </dd></dl>

</div>
</div>
<a id="add807d4ec4699aba67e2e2857599b50f" name="add807d4ec4699aba67e2e2857599b50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add807d4ec4699aba67e2e2857599b50f">&#9670;&nbsp;</a></span>attr_id_corner_to_facet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> attr_id_corner_to_facet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute id for corner -&gt; facet index. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> id. </dd></dl>

</div>
</div>
<a id="a17dfdc570c834fffb6b6ab06c91a2de0" name="a17dfdc570c834fffb6b6ab06c91a2de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17dfdc570c834fffb6b6ab06c91a2de0">&#9670;&nbsp;</a></span>attr_id_corner_to_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> attr_id_corner_to_edge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute id for corner -&gt; edge indices. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> id. </dd></dl>

</div>
</div>
<a id="ac00984b25c6bccdc8f6e4d8f17db7dc0" name="ac00984b25c6bccdc8f6e4d8f17db7dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00984b25c6bccdc8f6e4d8f17db7dc0">&#9670;&nbsp;</a></span>attr_id_edge_to_first_corner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> attr_id_edge_to_first_corner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute id for edge -&gt; first corner index. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> id. </dd></dl>

</div>
</div>
<a id="a84f7ca12f43a1d3f7e90b1cf7e01175a" name="a84f7ca12f43a1d3f7e90b1cf7e01175a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f7ca12f43a1d3f7e90b1cf7e01175a">&#9670;&nbsp;</a></span>attr_id_next_corner_around_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> attr_id_next_corner_around_edge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute id for corner -&gt; next corner around edge. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> id. </dd></dl>

</div>
</div>
<a id="a6c48e37ccf44cab6c87a79ed630430d8" name="a6c48e37ccf44cab6c87a79ed630430d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c48e37ccf44cab6c87a79ed630430d8">&#9670;&nbsp;</a></span>attr_id_vertex_to_first_corner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> attr_id_vertex_to_first_corner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute id for vertex -&gt; first corner index. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> id. </dd></dl>

</div>
</div>
<a id="acd19aedf26eaea675129e658993c2f96" name="acd19aedf26eaea675129e658993c2f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd19aedf26eaea675129e658993c2f96">&#9670;&nbsp;</a></span>attr_id_next_corner_around_vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> attr_id_next_corner_around_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attribute id for corner -&gt; next corner around vertex. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> id. </dd></dl>

</div>
</div>
<a id="acf3519681c8bdac36dbb106499192c51" name="acf3519681c8bdac36dbb106499192c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3519681c8bdac36dbb106499192c51">&#9670;&nbsp;</a></span>initialize_edges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>edges</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes attributes associated to mesh edges and connectivity. </p>
<p ><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> edges and connectivity.</p>
<p >If a user-defined ordering of the mesh edges is provided, it must be a valid indexing (all edges should appear in the provided array).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>M x 2 continuous array of mapping edge -&gt; vertices, where M is the number of edges in the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83b80acc32b1c4c2f26edbe86df49ed0" name="a83b80acc32b1c4c2f26edbe86df49ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b80acc32b1c4c2f26edbe86df49ed0">&#9670;&nbsp;</a></span>initialize_edges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_user_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a0099ac3b79b3ecddccca10409e576f8f">GetEdgeVertices</a>&#160;</td>
          <td class="paramname"><em>get_user_edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes attributes associated to mesh edges and connectivity. </p>
<p >In this overload, a user-defined ordering of the mesh edges is provided via a function callback. The user-provided ordering must be a valid indexing (all edges should appear exactly once).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_user_edges</td><td>Number of edges in the user-provided ordering. If it does not match the actual number of mesh edges after initialization, an exception is raised. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">get_user_edge</td><td>Callback function to retrieve the vertices endpoints of an edge given its user-provided index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ccbe860cb7c1faa679cbb72f69e0a15" name="a0ccbe860cb7c1faa679cbb72f69e0a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccbe860cb7c1faa679cbb72f69e0a15">&#9670;&nbsp;</a></span>clear_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear_edges</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears attributes related to mesh edges and connectivity: </p>
<ul>
<li>"$corner_to_edge"</li>
<li>"$vertex_to_first_corner"</li>
<li>"$next_corner_around_vertex"</li>
<li>"$edge_to_first_corner"</li>
<li>"$next_corner_around_edge"</li>
</ul>
<p >This method also sets the number of mesh edges to 0, effectively resizing all user-defined edge attributes to 0. </p>

</div>
</div>
<a id="aa9b58744bd298398b70869f693b21f35" name="aa9b58744bd298398b70869f693b21f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b58744bd298398b70869f693b21f35">&#9670;&nbsp;</a></span>has_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool has_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the attributes associated to mesh edges and connectivity have been initialized. </p>
<dl class="section return"><dt>Returns</dt><dd>True if attributes have been initialized, False otherwise. </dd></dl>

</div>
</div>
<a id="a2fe4f82c25a5b076fdfcc5c4d78fd7fe" name="a2fe4f82c25a5b076fdfcc5c4d78fd7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe4f82c25a5b076fdfcc5c4d78fd7fe">&#9670;&nbsp;</a></span>get_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>lv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the edge index corresponding to (f, lv) &ndash; (f, lv+1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Facet index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lv</td><td>Local vertex index [0, <a class="el" href="classlagrange_1_1_surface_mesh.html#abd39a328d5689f8b05c3f871079d77ce" title="Retrieves the number of vertex per facet in a regular mesh.">get_vertex_per_facet()</a>[.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Edge index. </dd></dl>

</div>
</div>
<a id="a24975f9d8e5adf7f621c29f2f75b7fdd" name="a24975f9d8e5adf7f621c29f2f75b7fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24975f9d8e5adf7f621c29f2f75b7fdd">&#9670;&nbsp;</a></span>get_corner_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_corner_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the edge index corresponding to a corner index. </p>
<p >Given a face (v0, ..., vk) with associated corners (c0, ..., ck), the edge associated to corner ci is the edge between (vi, vi+1), as determined by the corner_to_edge_mapping function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Corner index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Edge index. </dd></dl>

</div>
</div>
<a id="a491ff4636c29460975186cac5cdccaf4" name="a491ff4636c29460975186cac5cdccaf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491ff4636c29460975186cac5cdccaf4">&#9670;&nbsp;</a></span>get_edge_from_corner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_edge_from_corner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the edge index corresponding to a corner index. </p>
<p >Given a face (v0, ..., vk) with associated corners (c0, ..., ck), the edge associated to corner ci is the edge between (vi, vi+1), as determined by the corner_to_edge_mapping function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Corner index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Edge index.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use get_corner_edge instead. </dd></dl>

</div>
</div>
<a id="a29302efd8dd0d5b7c28f28f901b62d36" name="a29302efd8dd0d5b7c28f28f901b62d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29302efd8dd0d5b7c28f28f901b62d36">&#9670;&nbsp;</a></span>get_edge_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_edge_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve edge endpoints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Queried edge index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of vertex ids at the edge endpoints. </dd></dl>

</div>
</div>
<a id="a032a198e720a57c9e22327a8dc2ad1b9" name="a032a198e720a57c9e22327a8dc2ad1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032a198e720a57c9e22327a8dc2ad1b9">&#9670;&nbsp;</a></span>find_edge_from_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> find_edge_from_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the edge index cooresponding to (v0, v1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v0,v1</td><td>The vertex indices for edge end points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edge index if found, otherwise <code>invalid&lt;Index&gt;()</code>. </dd></dl>

</div>
</div>
<a id="a757f13e26354a83f93e1ac0b276a55a6" name="a757f13e26354a83f93e1ac0b276a55a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757f13e26354a83f93e1ac0b276a55a6">&#9670;&nbsp;</a></span>get_first_corner_around_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_first_corner_around_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the first corner around a given edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Queried edge index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the first corner around the queried edge. </dd></dl>

</div>
</div>
<a id="a42ea64462a4c107f838ae2758e178bda" name="a42ea64462a4c107f838ae2758e178bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ea64462a4c107f838ae2758e178bda">&#9670;&nbsp;</a></span>get_next_corner_around_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_next_corner_around_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the next corner around the edge associated to a corner. </p>
<p >If the corner is the last one in the chain, this function returns INVALID&lt;Index&gt;.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Corner index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next corner around the edge. </dd></dl>

</div>
</div>
<a id="a86a57db26b350768afb4ff0a7c7802c5" name="a86a57db26b350768afb4ff0a7c7802c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a57db26b350768afb4ff0a7c7802c5">&#9670;&nbsp;</a></span>get_first_corner_around_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_first_corner_around_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the first corner around a given vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Queried vertex index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the first corner around the queried vertex. </dd></dl>

</div>
</div>
<a id="a99be021c68cc72fabb5850b9d9e7a5d9" name="a99be021c68cc72fabb5850b9d9e7a5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99be021c68cc72fabb5850b9d9e7a5d9">&#9670;&nbsp;</a></span>get_next_corner_around_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_next_corner_around_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the next corner around the vertex associated to a corner. </p>
<p >If the corner is the last one in the chain, this function returns INVALID&lt;Index&gt;.</p>
<dl class="section note"><dt>Note</dt><dd>The sequence of corners around a vertex defined by this function has no geometric meaning. I.e. the current corner and its next corner may not be adjacent to the same edge.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Corner index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next corner around the vertex. </dd></dl>

</div>
</div>
<a id="a1dfe0dcf037021676afc0efe217e615b" name="a1dfe0dcf037021676afc0efe217e615b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dfe0dcf037021676afc0efe217e615b">&#9670;&nbsp;</a></span>count_num_corners_around_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto count_num_corners_around_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of corners incident to a given edge. </p>
<dl class="section note"><dt>Note</dt><dd>This may not be the same as the number of incident facets. E.g. the same facet may be incident to the same edge multiple times. To count the number of incident facet without duplications, you will need to write your own function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Queried edge index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of corners incident to the queried edge. </dd></dl>

</div>
</div>
<a id="a56f8387b06510534118da4d657d46f38" name="a56f8387b06510534118da4d657d46f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f8387b06510534118da4d657d46f38">&#9670;&nbsp;</a></span>count_num_corners_around_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto count_num_corners_around_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of corners incident to a given vertex. </p>
<dl class="section note"><dt>Note</dt><dd>This may not be the same as the number of incident facets. E.g. the same facet may be incident to the same vertex multiple times. To count the number of incident facet without duplications, you will need to write your own function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Queried vertex index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of corners incident to the queried vertex. </dd></dl>

</div>
</div>
<a id="a7565dd42a97331fbf4fbbe34b1cd7e73" name="a7565dd42a97331fbf4fbbe34b1cd7e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7565dd42a97331fbf4fbbe34b1cd7e73">&#9670;&nbsp;</a></span>get_one_facet_around_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_one_facet_around_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of one facet around a given edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Queried edge index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Face index of one facet incident to the queried edge. </dd></dl>

</div>
</div>
<a id="abb5d255c7768b0fe3ec34c035ac9a8cd" name="abb5d255c7768b0fe3ec34c035ac9a8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5d255c7768b0fe3ec34c035ac9a8cd">&#9670;&nbsp;</a></span>get_one_corner_around_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_one_corner_around_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of one corner around a given edge. </p>
<dl class="section note"><dt>Note</dt><dd>While this is technically redundant with get_first_corner_around_edge, the latter can be used when iterating manually over a chain of corners, while this method can be used to retrieve a single corner around a given edge.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Queried edge index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the first corner around the queried edge. </dd></dl>

</div>
</div>
<a id="a61700e476c5ca368f8a0c2a75f01fe22" name="a61700e476c5ca368f8a0c2a75f01fe22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61700e476c5ca368f8a0c2a75f01fe22">&#9670;&nbsp;</a></span>get_one_corner_around_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto get_one_corner_around_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of one corner around a given vertex. </p>
<dl class="section note"><dt>Note</dt><dd>While this is technically redundant with get_first_corner_around_vertex, the latter can be used when iterating manually over a chain of corners, while this method can be used to retrieve a single corner around a given vertex.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Queried vertex index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the first corner around the queried vertex. </dd></dl>

</div>
</div>
<a id="a0b2c302edb050ad26ee7bd0b163ce049" name="a0b2c302edb050ad26ee7bd0b163ce049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2c302edb050ad26ee7bd0b163ce049">&#9670;&nbsp;</a></span>is_boundary_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_boundary_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the specified edge e is a boundary edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Queried edge index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified edge e is a boundary edge, False otherwise. </dd></dl>

</div>
</div>
<a id="a09026c81eebf650ab207431db9534b11" name="a09026c81eebf650ab207431db9534b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09026c81eebf650ab207431db9534b11">&#9670;&nbsp;</a></span>foreach_facet_around_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void foreach_facet_around_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>)&gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a function to each facet around a prescribed edge. </p>
<dl class="section warning"><dt>Warning</dt><dd>If a facet is incident to the same edge multiple times (e.g. facet {0, 1, 0, 1}), the callback function will be called multiple times for te facet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Queried edge index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callback to apply to each incident facet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d41ed1c1f040e437e96b2d4510cb70c" name="a4d41ed1c1f040e437e96b2d4510cb70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d41ed1c1f040e437e96b2d4510cb70c">&#9670;&nbsp;</a></span>foreach_facet_around_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void foreach_facet_around_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>)&gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a function to each facet around a prescribed vertex. </p>
<dl class="section warning"><dt>Warning</dt><dd>If a facet is incident to the same vertex multiple times (e.g. facet {0, 1, 0, 1}), the callback function will be called multiple times for the facet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Queried vertex index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callback to apply to each incident facet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb2d4b3e2b0b9b3fba297a8f6eea0981" name="aeb2d4b3e2b0b9b3fba297a8f6eea0981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2d4b3e2b0b9b3fba297a8f6eea0981">&#9670;&nbsp;</a></span>foreach_corner_around_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void foreach_corner_around_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>)&gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a function to each corner around a prescribed edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Queried edge index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callback to apply to each incident corner. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa05d65af8327fbb7ff6d57a53f0b812f" name="aa05d65af8327fbb7ff6d57a53f0b812f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05d65af8327fbb7ff6d57a53f0b812f">&#9670;&nbsp;</a></span>foreach_corner_around_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void foreach_corner_around_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>)&gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a function to each corner around a prescribed vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Queried vertex index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callback to apply to each incident corner. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a032c58cae0d331473ecaec9a1c1ed079" name="a032c58cae0d331473ecaec9a1c1ed079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032c58cae0d331473ecaec9a1c1ed079">&#9670;&nbsp;</a></span>foreach_edge_around_vertex_with_duplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void foreach_edge_around_vertex_with_duplicates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>)&gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a function to each edge around a prescribed vertex. </p>
<p >The function will be applied repeatedly to each incident edges (once for each facet incident to the query vertex).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Queried vertex index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callback to apply to each incident edge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7571bd240cda6e24eebbba8e3069059" name="ab7571bd240cda6e24eebbba8e3069059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7571bd240cda6e24eebbba8e3069059">&#9670;&nbsp;</a></span>create_attribute_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> create_attribute_internal </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a>&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em> = <code><a class="el" href="group__group-surfacemesh-attr.html#gga5a2f28c8b9e2f8fce6e70b2418c46e45a57dea6f5039281b7fee517fc43bf3110">AttributeUsage::Vector</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_channels</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const ValueType &gt;&#160;</td>
          <td class="paramname"><em>initial_values</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>initial_indices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as create_attribute, but allows creation of reserved attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Attribute name to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>Mesh element to which the attribute is attached to (Vertex, Facet, etc.). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usage</td><td>Tag to indicate how the values are modified under rigid transformation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_channels</td><td>The number of channels for the attribute. Cannot be modified once the attribute has been created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initial_values</td><td>A span of initial values to populate the attribute values with. The data is copied into the attribute. If the span is provided, it must have the right dimension (number of elements x number of channels). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initial_indices</td><td>A span of initial values to populate the attribute indices with. If the attribute element type is not Indexed, providing a non-empty value for this argument will result in a runtime error. The data is copied into the attribute. If the span is provided, it must have the right dimension (number of corners).</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Value type for the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute identifier. </dd></dl>

</div>
</div>
<a id="a1ace702355c3de9c126c3c1a267f1a98" name="a1ace702355c3de9c126c3c1a267f1a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ace702355c3de9c126c3c1a267f1a98">&#9670;&nbsp;</a></span>set_attribute_default_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_attribute_default_internal </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set attribute default value for known internal attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the attribute being set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Value type for the attribute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea1f0451ae94715d799631b79d098299" name="aea1f0451ae94715d799631b79d098299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1f0451ae94715d799631b79d098299">&#9670;&nbsp;</a></span>reindex_vertices_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reindex_vertices_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>old_to_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reindex mesh vertices according to the given mapping. </p>
<p >It is ok to map several vertices to the same index. The mapping must form an increasing sequence, such that it is possible to copy values without an intermediate buffer. Elements mapped to <a class="el" href="group__group-utils-misc.html#ga6c3e5aabde25a440beb7fc174ab081df" title="You can use invalid&lt;T&gt;() to get a value that can represent &quot;invalid&quot; values, such as invalid indices ...">invalid&lt;Index&gt;()</a> will not be copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">old_to_new</td><td>Mapping old vertex index -&gt; new vertex index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabaf85396713373a0328ce1d01696e65" name="aabaf85396713373a0328ce1d01696e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabaf85396713373a0328ce1d01696e65">&#9670;&nbsp;</a></span>reindex_facets_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto reindex_facets_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>old_to_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reindex mesh facets according to the given mapping. </p>
<p >Facet corners will be copied accordingly. It is ok to map several facets to the same index. The mapping must form an increasing sequence, such that it is possible to copy values without an intermediate buffer. Elements mapped to <a class="el" href="group__group-utils-misc.html#ga6c3e5aabde25a440beb7fc174ab081df" title="You can use invalid&lt;T&gt;() to get a value that can represent &quot;invalid&quot; values, such as invalid indices ...">invalid&lt;Index&gt;()</a> will not be copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">old_to_new</td><td>Mapping old facet index -&gt; new facet index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair (nc, ne) containing the new number of corners &amp; edges, respectively. </dd></dl>

</div>
</div>
<a id="a83667a37a14859de5d28036398cf5089" name="a83667a37a14859de5d28036398cf5089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83667a37a14859de5d28036398cf5089">&#9670;&nbsp;</a></span>resize_elements_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resize_elements_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_elements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the buffers associated to a specific element type in the mesh. </p>
<p >Newly inserted elements will be default-initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_elements</td><td>New number of elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">element</td><td>Element type to resize (vertices, facets, etc.). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ffcdb24287c1b3de2d64721b20547ff" name="a4ffcdb24287c1b3de2d64721b20547ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffcdb24287c1b3de2d64721b20547ff">&#9670;&nbsp;</a></span>resize_vertices_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resize_vertices_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the buffers associated to mesh vertices and their attributes. </p>
<p >Newly inserted elements will be default-initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_vertices</td><td>New number of vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f115ee59c274a6ec785007793b9d093" name="a1f115ee59c274a6ec785007793b9d093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f115ee59c274a6ec785007793b9d093">&#9670;&nbsp;</a></span>resize_facets_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resize_facets_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the buffers associated to mesh facets and their attributes. </p>
<p >Newly inserted elements will be default-initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_facets</td><td>New number of facets. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71dad57d3c6a420665c94f0d6d488943" name="a71dad57d3c6a420665c94f0d6d488943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71dad57d3c6a420665c94f0d6d488943">&#9670;&nbsp;</a></span>resize_corners_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resize_corners_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_corners</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the buffers associated to mesh corners and their attributes. </p>
<p >Newly inserted elements will be default-initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_corners</td><td>New number of corners. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1ab6cab6408ce9e8f7cfb463d0e3239" name="aa1ab6cab6408ce9e8f7cfb463d0e3239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ab6cab6408ce9e8f7cfb463d0e3239">&#9670;&nbsp;</a></span>resize_edges_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resize_edges_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the buffers associated to mesh edges and their attributes. </p>
<p >Newly inserted elements will be default-initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_edges</td><td>New number of edges. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03dc899155af8a6a73076bcf62210cdb" name="a03dc899155af8a6a73076bcf62210cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03dc899155af8a6a73076bcf62210cdb">&#9670;&nbsp;</a></span>reserve_indices_internal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto reserve_indices_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>facet_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve index buffer for multiple facets of a given size. </p>
<p >If storage needs to be changed to a hybrid format, allocates facet offsets as necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_facets</td><td>Number of facets to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_size</td><td>Size of each facet to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A writable span pointing to the newly inserted rows of the corner_to_vertex attribute. </dd></dl>

</div>
</div>
<a id="aeced0acd223fc3b2c198bdff67199dea" name="aeced0acd223fc3b2c198bdff67199dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeced0acd223fc3b2c198bdff67199dea">&#9670;&nbsp;</a></span>reserve_indices_internal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto reserve_indices_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>facet_sizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve index buffer for multiple facets of a given size. </p>
<p >If storage needs to be changed to a hybrid format, allocates facet offsets as necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_sizes</td><td>A contiguous array representing the size of each facet to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A writable span pointing to the newly inserted rows of the corner_to_vertex attribute. </dd></dl>

</div>
</div>
<a id="a750df16a145f96f1a9ccbc409e96637b" name="a750df16a145f96f1a9ccbc409e96637b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750df16a145f96f1a9ccbc409e96637b">&#9670;&nbsp;</a></span>reserve_indices_internal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto reserve_indices_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a170c2bfbae529972c9db5de7025ab581">GetFacetsSizeFunction</a>&#160;</td>
          <td class="paramname"><em>get_facets_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve index buffer for multiple facets of a given size. </p>
<p >If storage needs to be changed to a hybrid format, allocates facet offsets as necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_facets</td><td>Number of facets to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">get_facets_size</td><td>Callable function to retrieve the size of each facet to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A writable span pointing to the newly inserted rows of the corner_to_vertex attribute. </dd></dl>

</div>
</div>
<a id="a7bd14a2e9f34e21802ba9488082088da" name="a7bd14a2e9f34e21802ba9488082088da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd14a2e9f34e21802ba9488082088da">&#9670;&nbsp;</a></span>compute_corner_to_facet_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void compute_corner_to_facet_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>facet_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>facet_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute inverse mapping corner -&gt; facet index for a specific range of facets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_begin</td><td>First facet in the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_end</td><td>Index beyond the last facet in the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e58c6b801afb40e39301667d674e34b" name="a7e58c6b801afb40e39301667d674e34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e58c6b801afb40e39301667d674e34b">&#9670;&nbsp;</a></span>initialize_edges_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_edges_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_user_edges</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a0099ac3b79b3ecddccca10409e576f8f">GetEdgeVertices</a> *&#160;</td>
          <td class="paramname"><em>get_user_edge_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes attributes associated to mesh edges and connectivity. </p>
<p >Internal method to avoid code duplication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_user_edges</td><td>Number of edges in the user-provided ordering. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">get_user_edge_ptr</td><td>Callback function to retrieve the vertices endpoints of an edge given its user-provided index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12ee1e1e55612c564e7d8e6014004688" name="a12ee1e1e55612c564e7d8e6014004688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ee1e1e55612c564e7d8e6014004688">&#9670;&nbsp;</a></span>update_edges_range_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void update_edges_range_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>facet_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>facet_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_user_edges</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a0099ac3b79b3ecddccca10409e576f8f">GetEdgeVertices</a> *&#160;</td>
          <td class="paramname"><em>get_user_edge_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update attributes associated to mesh edges and connectivity for a specific range of facets. </p>
<p >Corner chains are recomputed for the affected facet corners, unused edge indices are recycled and edge attributes are resized accordingly.</p>
<p >This function is called internally when edge attributes are initialized, when new facets are added to the mesh, or manually after a user updates facet indices.</p>
<p >If a user-defined ordering of the mesh edges is provided, it must be a valid indexing for the newly added edges (i.e. all edges that were not already present in the mesh must appear exactly once in the user-provided array).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlagrange_1_1_surface_mesh.html#acf3519681c8bdac36dbb106499192c51" title="Initializes attributes associated to mesh edges and connectivity.">initialize_edges</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_begin</td><td>First facet in the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_end</td><td>Index beyond the last facet in the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_user_edges</td><td>Number of edges in the user-provided ordering. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">get_user_edge_ptr</td><td>Callback function to retrieve the vertices endpoints of an edge given its user-provided index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a905d978584e7aaccf4ff04fdbf488d1c" name="a905d978584e7aaccf4ff04fdbf488d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905d978584e7aaccf4ff04fdbf488d1c">&#9670;&nbsp;</a></span>update_edges_last_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void update_edges_last_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_user_edges</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a0099ac3b79b3ecddccca10409e576f8f">GetEdgeVertices</a> *&#160;</td>
          <td class="paramname"><em>get_user_edge_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as update_edges_range_internal, but operate on the last count facets in the mesh instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of facets to update. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_user_edges</td><td>Number of edges in the user-provided ordering. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">get_user_edge_ptr</td><td>Callback function to retrieve the vertices endpoints of an edge given its user-provided index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6993d164e45277c2f73997d57d3ec7e4" name="a6993d164e45277c2f73997d57d3ec7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6993d164e45277c2f73997d57d3ec7e4">&#9670;&nbsp;</a></span>get_num_elements_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t get_num_elements_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a>&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of mesh elements, based on an element type. </p>
<p >If the queried element type is edges, and edge data has not been initialized, an exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>Type of element (vertex, facet, etc.).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of such elements in the mesh. </dd></dl>

</div>
</div>
<a id="a9e87cb0c6d68efd943c2e9c97d4df630" name="a9e87cb0c6d68efd943c2e9c97d4df630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e87cb0c6d68efd943c2e9c97d4df630">&#9670;&nbsp;</a></span>wrap_as_attribute_internal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wrap_as_attribute_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; std::decay_t&lt; ValueType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; ValueType &gt;&#160;</td>
          <td class="paramname"><em>values_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap a span in an attribute. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The attribute value type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>The attribute object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_values</td><td>The number of elements to wrap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values_view</td><td>A view of the raw buffer. Its size must sufficiently large to hold at least <code>num_values</code> elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a346bba81c64f5cf24324103e348f2417" name="a346bba81c64f5cf24324103e348f2417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346bba81c64f5cf24324103e348f2417">&#9670;&nbsp;</a></span>wrap_as_attribute_internal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wrap_as_attribute_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; std::decay_t&lt; ValueType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; ValueType &gt;&#160;</td>
          <td class="paramname"><em>shared_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap a shared span in an attribute. </p>
<p >The attribute object will take a share of the memory ownership of the external buffer referred by the shared span so that it will stay alive as long as the attribute is using it.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The attribute value type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>The attribute object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_values</td><td>The number of elements to wrap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shared_values</td><td>A shared span object with memory ownership tracking support. Its size must sufficiently large to hold at least <code>num_values</code> elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c13e7459875ddd222a3841959f627c0" name="a5c13e7459875ddd222a3841959f627c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c13e7459875ddd222a3841959f627c0">&#9670;&nbsp;</a></span>wrap_as_facets_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_facets_internal </td>
          <td>(</td>
          <td class="paramtype">OffsetSpan&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FacetSpan&#160;</td>
          <td class="paramname"><em>facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html#a726cb631080e40f5e472e0c3f6e59eda">Index</a>&#160;</td>
          <td class="paramname"><em>num_corners</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap shared spans as offsets and facets. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OffsetSpan</td><td>The offset span type. Should be either <code>span&lt;T&gt;</code> or <code><a class="el" href="classlagrange_1_1_shared_span.html" title="Shared span with ownership tracking.">SharedSpan</a>&lt;T&gt;</code>. </td></tr>
    <tr><td class="paramname">FacetSpan</td><td>The facet span type. Should be either <code>span&lt;T&gt;</code> or <code><a class="el" href="classlagrange_1_1_shared_span.html" title="Shared span with ownership tracking.">SharedSpan</a>&lt;T&gt;</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>The offset span. Its size should be &gt;= <code>num_facets</code>. </td></tr>
    <tr><td class="paramname">num_facets</td><td>The number of facets. </td></tr>
    <tr><td class="paramname">facets</td><td>The facet span. Its size should be &gt;= <code>num_corners</code>. </td></tr>
    <tr><td class="paramname">num_corners</td><td>The number of corners.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corner-to-vertex attribute id. </dd></dl>

</div>
</div>
<a id="acc50bde3a18f6bd4f9a1db85f8a0daa6" name="acc50bde3a18f6bd4f9a1db85f8a0daa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc50bde3a18f6bd4f9a1db85f8a0daa6">&#9670;&nbsp;</a></span>wrap_as_attribute_internal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> wrap_as_attribute_internal </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a>&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueSpan&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexSpan&#160;</td>
          <td class="paramname"><em>indices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The most generic way of creating an attribute wrapped around external buffers. </p>
<p >Based on the <code>element</code> type, it will create either a normal attribute or an indexed attribute. The generated attribute will have the same "const-ness" as the <code>value_type</code> of the span. If a <a class="el" href="classlagrange_1_1_shared_span.html" title="Shared span with ownership tracking.">SharedSpan</a> is used, the attribute will participate in ownership sharing of the buffer it uses.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueSpan</td><td>The value span type. Should be either <code>span&lt;T&gt;</code> or <code><a class="el" href="classlagrange_1_1_shared_span.html" title="Shared span with ownership tracking.">SharedSpan</a>&lt;T&gt;</code>. </td></tr>
    <tr><td class="paramname">IndexSpan</td><td>The index span type. Should be either <code>span&lt;T&gt;</code> or <code><a class="el" href="classlagrange_1_1_shared_span.html" title="Shared span with ownership tracking.">SharedSpan</a>&lt;T&gt;</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The attribute name. </td></tr>
    <tr><td class="paramname">element</td><td>The attribute element type. </td></tr>
    <tr><td class="paramname">usage</td><td>The attribute usage type. </td></tr>
    <tr><td class="paramname">num_values</td><td>The number of values. </td></tr>
    <tr><td class="paramname">num_channels</td><td>The number of channels. </td></tr>
    <tr><td class="paramname">values</td><td>The value span. Its size should be &gt;= num_values * num_channels. </td></tr>
    <tr><td class="paramname">indices</td><td>The index span. Its size should be &gt;= the number of corresponding elements. It is only used for creating indexed attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute id of the generated attribute. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2722b88a19f12a9e1bef59e8f530ab51" name="a2722b88a19f12a9e1bef59e8f530ab51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2722b88a19f12a9e1bef59e8f530ab51">&#9670;&nbsp;</a></span>items</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view items[9]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">            <span class="stringliteral">&quot;$vertex_to_position&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;$corner_to_vertex&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;$facet_to_first_corner&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;$corner_to_facet&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;$corner_to_edge&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;$edge_to_first_corner&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;$next_corner_around_edge&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;$vertex_to_first_corner&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;$next_corner_around_vertex&quot;</span>,</div>
<div class="line">        }</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>lagrange/<a class="el" href="_surface_mesh_8h_source.html">SurfaceMesh.h</a></li>
<li>SurfaceMesh.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelagrange.html">lagrange</a></li><li class="navelem"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>

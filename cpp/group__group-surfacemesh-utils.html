<!-- HTML header for doxygen 1.9.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lagrange: Mesh utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Lagrange
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__group-surfacemesh-utils.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Mesh utilities<div class="ingroups"><a class="el" href="group__module-core.html">Core Module</a> &raquo; <a class="el" href="group__group-surfacemesh.html">SurfaceMesh</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Various attribute processing utilities.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_facet_area_options.html">FacetAreaOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing per-facet area.  <a href="structlagrange_1_1_facet_area_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_mesh_area_options.html">MeshAreaOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing mesh area.  <a href="structlagrange_1_1_mesh_area_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_facet_centroid_options.html">FacetCentroidOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing per-facet centroid.  <a href="structlagrange_1_1_facet_centroid_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_mesh_centroid_options.html">MeshCentroidOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing mesh centroid.  <a href="structlagrange_1_1_mesh_centroid_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_component_options.html">ComponentOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to control connected components computation.  <a href="structlagrange_1_1_component_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_dihedral_angle_options.html">DihedralAngleOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing dihedral angles.  <a href="structlagrange_1_1_dihedral_angle_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_dijkstra_distance_options.html">DijkstraDistanceOptions&lt; Scalar, Index &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for compute_dijkstra_distance.  <a href="structlagrange_1_1_dijkstra_distance_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_edge_length_options.html">EdgeLengthOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_facet_normal_options.html">FacetNormalOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing per-facet mesh normals.  <a href="structlagrange_1_1_facet_normal_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_normal_options.html">NormalOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing indexed mesh normals.  <a href="structlagrange_1_1_normal_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_tangent_bitangent_options.html">TangentBitangentOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing tangent and bitangent vectors.  <a href="structlagrange_1_1_tangent_bitangent_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_tangent_bitangent_result.html">TangentBitangentResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type of the compute_tangent_bitangent function.  <a href="structlagrange_1_1_tangent_bitangent_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_u_v_distortion_options.html">UVDistortionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for compute uv distortion.  <a href="structlagrange_1_1_u_v_distortion_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_vertex_normal_options.html">VertexNormalOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing per-vertex mesh normals.  <a href="structlagrange_1_1_vertex_normal_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_vertex_valence_options.html">VertexValenceOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing vertex valence.  <a href="structlagrange_1_1_vertex_valence_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_corner_normal_options.html">CornerNormalOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing per-corner mesh normals.  <a href="structlagrange_1_1_corner_normal_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_submesh_options.html">SubmeshOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for extract submesh.  <a href="structlagrange_1_1_submesh_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_attribute_filter.html">AttributeFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper object to filter attributes based on name, id, usage or element type.  <a href="structlagrange_1_1_attribute_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_remap_vertices_options.html">RemapVerticesOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap vertices options.  <a href="structlagrange_1_1_remap_vertices_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_separate_by_components_options.html">SeparateByComponentsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option settings for <code>separate_by_components</code>.  <a href="structlagrange_1_1_separate_by_components_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_separate_by_facet_groups_options.html">SeparateByFacetGroupsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option settings for <code>separate_by_facet_groups</code>.  <a href="structlagrange_1_1_separate_by_facet_groups_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_transform_options.html">TransformOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options available when applying affine transforms to a mesh.  <a href="structlagrange_1_1_transform_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gadab1480827f4522cbf1f9e1d4c28db91"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gadab1480827f4522cbf1f9e1d4c28db91">DistortionMetric</a> { <br />
&#160;&#160;<a class="el" href="group__group-surfacemesh-utils.html#ggadab1480827f4522cbf1f9e1d4c28db91abac152b762896edff34ed668ae1a546f">Dirichlet</a>
, <a class="el" href="group__group-surfacemesh-utils.html#ggadab1480827f4522cbf1f9e1d4c28db91a541c024e21b5989aa74764f7c362dfd2">InverseDirichlet</a>
, <a class="el" href="group__group-surfacemesh-utils.html#ggadab1480827f4522cbf1f9e1d4c28db91a6043446227f6a89342620a00a131257f">SymmetricDirichlet</a>
, <b>AreaRatio</b>
, <br />
&#160;&#160;<a class="el" href="group__group-surfacemesh-utils.html#ggadab1480827f4522cbf1f9e1d4c28db91a16c8e070f0f6edd7ac0ae016e9bf2997">MIPS</a>
<br />
 }</td></tr>
<tr class="memdesc:gadab1480827f4522cbf1f9e1d4c28db91"><td class="mdescLeft">&#160;</td><td class="mdescRight">UV distortion metric type.  <a href="group__group-surfacemesh-utils.html#gadab1480827f4522cbf1f9e1d4c28db91">More...</a><br /></td></tr>
<tr class="separator:gadab1480827f4522cbf1f9e1d4c28db91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa88e833ed770762b02e187f0c2377d3d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gaa88e833ed770762b02e187f0c2377d3d">NormalWeightingType</a> : char { <a class="el" href="group__group-surfacemesh-utils.html#ggaa88e833ed770762b02e187f0c2377d3daf19516d11f2946f894070e92fcb56b6d">Uniform</a> = 0
, <a class="el" href="group__group-surfacemesh-utils.html#ggaa88e833ed770762b02e187f0c2377d3da84f023fc44b6b158de6ccc157c8dab06">CornerTriangleArea</a> = 1
, <a class="el" href="group__group-surfacemesh-utils.html#ggaa88e833ed770762b02e187f0c2377d3da45f4ce6c3306644b1efe333f4f8d6929">Angle</a> = 2
 }</td></tr>
<tr class="memdesc:gaa88e833ed770762b02e187f0c2377d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighting types for averaging corner normals around a vertex.  <a href="group__group-surfacemesh-utils.html#gaa88e833ed770762b02e187f0c2377d3d">More...</a><br /></td></tr>
<tr class="separator:gaa88e833ed770762b02e187f0c2377d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab7596be540e8db5808abc8c322fd7460"><td class="memTemplParams" colspan="2">template&lt;typename ToScalar , typename ToIndex , typename FromScalar , typename FromIndex &gt; </td></tr>
<tr class="memitem:gab7596be540e8db5808abc8c322fd7460"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; ToScalar, ToIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gab7596be540e8db5808abc8c322fd7460">cast</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; FromScalar, FromIndex &gt; &amp;source_mesh, const <a class="el" href="structlagrange_1_1_attribute_filter.html">AttributeFilter</a> &amp;convertible_attributes={}, std::vector&lt; std::string &gt; *converted_attributes_names=nullptr)</td></tr>
<tr class="memdesc:gab7596be540e8db5808abc8c322fd7460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a mesh to a mesh of different scalar and/or index type.  <a href="group__group-surfacemesh-utils.html#gab7596be540e8db5808abc8c322fd7460">More...</a><br /></td></tr>
<tr class="separator:gab7596be540e8db5808abc8c322fd7460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga363707c2e65474638292c738c072868c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga363707c2e65474638292c738c072868c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga363707c2e65474638292c738c072868c">combine_meshes</a> (std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; * &gt; meshes, bool preserve_attributes=true)</td></tr>
<tr class="memdesc:ga363707c2e65474638292c738c072868c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine multiple meshes into a single mesh.  <a href="group__group-surfacemesh-utils.html#ga363707c2e65474638292c738c072868c">More...</a><br /></td></tr>
<tr class="separator:ga363707c2e65474638292c738c072868c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07291901c4f594454dfafb0764f4dad5"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga07291901c4f594454dfafb0764f4dad5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga07291901c4f594454dfafb0764f4dad5">combine_meshes</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &gt; meshes, bool preserve_attributes=true)</td></tr>
<tr class="memdesc:ga07291901c4f594454dfafb0764f4dad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine multiple meshes into a single mesh.  <a href="group__group-surfacemesh-utils.html#ga07291901c4f594454dfafb0764f4dad5">More...</a><br /></td></tr>
<tr class="separator:ga07291901c4f594454dfafb0764f4dad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e874e29c25e3a587a9352147e36772d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga9e874e29c25e3a587a9352147e36772d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga9e874e29c25e3a587a9352147e36772d">combine_meshes</a> (size_t num_meshes, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;(size_t)&gt; get_mesh, bool preserve_attributes=true)</td></tr>
<tr class="memdesc:ga9e874e29c25e3a587a9352147e36772d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine multiple meshes into a single mesh.  <a href="group__group-surfacemesh-utils.html#ga9e874e29c25e3a587a9352147e36772d">More...</a><br /></td></tr>
<tr class="separator:ga9e874e29c25e3a587a9352147e36772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga579af81b3ee4ae244a8b5cb92fc76d5c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga579af81b3ee4ae244a8b5cb92fc76d5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga579af81b3ee4ae244a8b5cb92fc76d5c">compute_facet_area</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_facet_area_options.html">FacetAreaOptions</a> options={})</td></tr>
<tr class="memdesc:ga579af81b3ee4ae244a8b5cb92fc76d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute per-facet area.  <a href="group__group-surfacemesh-utils.html#ga579af81b3ee4ae244a8b5cb92fc76d5c">More...</a><br /></td></tr>
<tr class="separator:ga579af81b3ee4ae244a8b5cb92fc76d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8852c901ee9b6908389b24d03632306f"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index , int Dimension&gt; </td></tr>
<tr class="memitem:ga8852c901ee9b6908389b24d03632306f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga8852c901ee9b6908389b24d03632306f">compute_facet_area</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const Eigen::Transform&lt; Scalar, Dimension, Eigen::Affine &gt; &amp;transformation, <a class="el" href="structlagrange_1_1_facet_area_options.html">FacetAreaOptions</a> options={})</td></tr>
<tr class="memdesc:ga8852c901ee9b6908389b24d03632306f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute per-facet area.  <a href="group__group-surfacemesh-utils.html#ga8852c901ee9b6908389b24d03632306f">More...</a><br /></td></tr>
<tr class="separator:ga8852c901ee9b6908389b24d03632306f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga685d104f63c148710e7f8e3ffb2bb779"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga685d104f63c148710e7f8e3ffb2bb779"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga685d104f63c148710e7f8e3ffb2bb779">compute_mesh_area</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_mesh_area_options.html">MeshAreaOptions</a> options={})</td></tr>
<tr class="memdesc:ga685d104f63c148710e7f8e3ffb2bb779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mesh area.  <a href="group__group-surfacemesh-utils.html#ga685d104f63c148710e7f8e3ffb2bb779">More...</a><br /></td></tr>
<tr class="separator:ga685d104f63c148710e7f8e3ffb2bb779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3b913ec3b353ba77d4b71549e8079a1"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index , int Dimension&gt; </td></tr>
<tr class="memitem:gad3b913ec3b353ba77d4b71549e8079a1"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gad3b913ec3b353ba77d4b71549e8079a1">compute_mesh_area</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const Eigen::Transform&lt; Scalar, Dimension, Eigen::Affine &gt; &amp;transformation, <a class="el" href="structlagrange_1_1_mesh_area_options.html">MeshAreaOptions</a> options={})</td></tr>
<tr class="memdesc:gad3b913ec3b353ba77d4b71549e8079a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mesh area.  <a href="group__group-surfacemesh-utils.html#gad3b913ec3b353ba77d4b71549e8079a1">More...</a><br /></td></tr>
<tr class="separator:gad3b913ec3b353ba77d4b71549e8079a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9362d326a1cbd65aca95f481bc2d5e3c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga9362d326a1cbd65aca95f481bc2d5e3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga9362d326a1cbd65aca95f481bc2d5e3c">compute_facet_centroid</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_facet_centroid_options.html">FacetCentroidOptions</a> options={})</td></tr>
<tr class="memdesc:ga9362d326a1cbd65aca95f481bc2d5e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute per-facet centroid.  <a href="group__group-surfacemesh-utils.html#ga9362d326a1cbd65aca95f481bc2d5e3c">More...</a><br /></td></tr>
<tr class="separator:ga9362d326a1cbd65aca95f481bc2d5e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae64040c03275b07fff5b820f2a61d0ba"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gae64040c03275b07fff5b820f2a61d0ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gae64040c03275b07fff5b820f2a61d0ba">compute_mesh_centroid</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; Scalar &gt; centroid, <a class="el" href="structlagrange_1_1_mesh_centroid_options.html">MeshCentroidOptions</a> options={})</td></tr>
<tr class="memdesc:gae64040c03275b07fff5b820f2a61d0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mesh centroid, where mesh centroid is defined as the weighted sum of facet centroids.  <a href="group__group-surfacemesh-utils.html#gae64040c03275b07fff5b820f2a61d0ba">More...</a><br /></td></tr>
<tr class="separator:gae64040c03275b07fff5b820f2a61d0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafedc8c0d66af62d6f3d540465c0018c6"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gafedc8c0d66af62d6f3d540465c0018c6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gafedc8c0d66af62d6f3d540465c0018c6">compute_components</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_component_options.html">ComponentOptions</a> options={})</td></tr>
<tr class="memdesc:gafedc8c0d66af62d6f3d540465c0018c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute connected components of an input mesh.  <a href="group__group-surfacemesh-utils.html#gafedc8c0d66af62d6f3d540465c0018c6">More...</a><br /></td></tr>
<tr class="separator:gafedc8c0d66af62d6f3d540465c0018c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe6250f56cb0f4cfbde68b857321d107"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gabe6250f56cb0f4cfbde68b857321d107"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gabe6250f56cb0f4cfbde68b857321d107">compute_components</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; blocker_elements, <a class="el" href="structlagrange_1_1_component_options.html">ComponentOptions</a> options={})</td></tr>
<tr class="memdesc:gabe6250f56cb0f4cfbde68b857321d107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute connected components of an input mesh.  <a href="group__group-surfacemesh-utils.html#gabe6250f56cb0f4cfbde68b857321d107">More...</a><br /></td></tr>
<tr class="separator:gabe6250f56cb0f4cfbde68b857321d107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab65464571f0034e009273ade90fcb4bf"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gab65464571f0034e009273ade90fcb4bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gab65464571f0034e009273ade90fcb4bf">compute_dihedral_angles</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const <a class="el" href="structlagrange_1_1_dihedral_angle_options.html">DihedralAngleOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:gab65464571f0034e009273ade90fcb4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes dihedral angles for each edge in the mesh.  <a href="group__group-surfacemesh-utils.html#gab65464571f0034e009273ade90fcb4bf">More...</a><br /></td></tr>
<tr class="separator:gab65464571f0034e009273ade90fcb4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63cc672971ecc26849450a45db354f6b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga63cc672971ecc26849450a45db354f6b"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga63cc672971ecc26849450a45db354f6b">compute_dijkstra_distance</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const <a class="el" href="structlagrange_1_1_dijkstra_distance_options.html">DijkstraDistanceOptions</a>&lt; Scalar, Index &gt; &amp;options={})</td></tr>
<tr class="memdesc:ga63cc672971ecc26849450a45db354f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes dijkstra distance from a seed facet.  <a href="group__group-surfacemesh-utils.html#ga63cc672971ecc26849450a45db354f6b">More...</a><br /></td></tr>
<tr class="separator:ga63cc672971ecc26849450a45db354f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58593e3709263771bc25ff51f473c92a"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga58593e3709263771bc25ff51f473c92a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga58593e3709263771bc25ff51f473c92a">compute_edge_lengths</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const <a class="el" href="structlagrange_1_1_edge_length_options.html">EdgeLengthOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:ga58593e3709263771bc25ff51f473c92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes edge lengths attribute.  <a href="group__group-surfacemesh-utils.html#ga58593e3709263771bc25ff51f473c92a">More...</a><br /></td></tr>
<tr class="separator:ga58593e3709263771bc25ff51f473c92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50e835144b2dd2ad5df9848293c8b097"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga50e835144b2dd2ad5df9848293c8b097"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga50e835144b2dd2ad5df9848293c8b097">compute_facet_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_facet_normal_options.html">FacetNormalOptions</a> options={})</td></tr>
<tr class="memdesc:ga50e835144b2dd2ad5df9848293c8b097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute facet normals.  <a href="group__group-surfacemesh-utils.html#ga50e835144b2dd2ad5df9848293c8b097">More...</a><br /></td></tr>
<tr class="separator:ga50e835144b2dd2ad5df9848293c8b097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1dc948d0cb8aa8b7759e34a34df7bc"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga0d1dc948d0cb8aa8b7759e34a34df7bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga0d1dc948d0cb8aa8b7759e34a34df7bc">compute_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; bool(Index)&gt; is_edge_smooth, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; cone_vertices={}, <a class="el" href="structlagrange_1_1_normal_options.html">NormalOptions</a> options={})</td></tr>
<tr class="memdesc:ga0d1dc948d0cb8aa8b7759e34a34df7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute smooth normals based on specified sharp edges and cone vertices.  <a href="group__group-surfacemesh-utils.html#ga0d1dc948d0cb8aa8b7759e34a34df7bc">More...</a><br /></td></tr>
<tr class="separator:ga0d1dc948d0cb8aa8b7759e34a34df7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe91547f24b4936c8feddd9b74b1aa02"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gabe91547f24b4936c8feddd9b74b1aa02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gabe91547f24b4936c8feddd9b74b1aa02">compute_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; bool(Index, Index)&gt; is_edge_smooth, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; cone_vertices={}, <a class="el" href="structlagrange_1_1_normal_options.html">NormalOptions</a> options={})</td></tr>
<tr class="memdesc:gabe91547f24b4936c8feddd9b74b1aa02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute smooth normals based on specified sharp edges and cone vertices.  <a href="group__group-surfacemesh-utils.html#gabe91547f24b4936c8feddd9b74b1aa02">More...</a><br /></td></tr>
<tr class="separator:gabe91547f24b4936c8feddd9b74b1aa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga668cc68bd27510b1bec92cf8dbe0e362"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga668cc68bd27510b1bec92cf8dbe0e362"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga668cc68bd27510b1bec92cf8dbe0e362">compute_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Scalar feature_angle_threshold, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; cone_vertices={}, <a class="el" href="structlagrange_1_1_normal_options.html">NormalOptions</a> options={})</td></tr>
<tr class="memdesc:ga668cc68bd27510b1bec92cf8dbe0e362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute smooth normal based on specified dihedral angle threshold and cone vertices.  <a href="group__group-surfacemesh-utils.html#ga668cc68bd27510b1bec92cf8dbe0e362">More...</a><br /></td></tr>
<tr class="separator:ga668cc68bd27510b1bec92cf8dbe0e362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0b89e21157c268e2931da3910bc2930"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gac0b89e21157c268e2931da3910bc2930"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_tangent_bitangent_result.html">TangentBitangentResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gac0b89e21157c268e2931da3910bc2930">compute_tangent_bitangent</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_tangent_bitangent_options.html">TangentBitangentOptions</a> options={})</td></tr>
<tr class="memdesc:gac0b89e21157c268e2931da3910bc2930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mesh tangent and bitangent vectors orthogonal to the input mesh normals.  <a href="group__group-surfacemesh-utils.html#gac0b89e21157c268e2931da3910bc2930">More...</a><br /></td></tr>
<tr class="separator:gac0b89e21157c268e2931da3910bc2930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad96a9c0374e82142015e619d6cf3bf67"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gad96a9c0374e82142015e619d6cf3bf67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gad96a9c0374e82142015e619d6cf3bf67">compute_uv_distortion</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const <a class="el" href="structlagrange_1_1_u_v_distortion_options.html">UVDistortionOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:gad96a9c0374e82142015e619d6cf3bf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute uv distortion using the selected distortion measure.  <a href="group__group-surfacemesh-utils.html#gad96a9c0374e82142015e619d6cf3bf67">More...</a><br /></td></tr>
<tr class="separator:gad96a9c0374e82142015e619d6cf3bf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9c124c65e79e319a4aefc92ccb5ce7f"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gaa9c124c65e79e319a4aefc92ccb5ce7f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int32_t, int32_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gaa9c124c65e79e319a4aefc92ccb5ce7f">compute_uv_tile_list</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:gaa9c124c65e79e319a4aefc92ccb5ce7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the list of all UV tiles that a mesh's parametrization spans.  <a href="group__group-surfacemesh-utils.html#gaa9c124c65e79e319a4aefc92ccb5ce7f">More...</a><br /></td></tr>
<tr class="separator:gaa9c124c65e79e319a4aefc92ccb5ce7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c1ac1ec1658273f6e6bb312dd2b0718"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga8c1ac1ec1658273f6e6bb312dd2b0718"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga8c1ac1ec1658273f6e6bb312dd2b0718">compute_vertex_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_vertex_normal_options.html">VertexNormalOptions</a> options={})</td></tr>
<tr class="memdesc:ga8c1ac1ec1658273f6e6bb312dd2b0718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute per-vertex normals based on specified weighting type.  <a href="group__group-surfacemesh-utils.html#ga8c1ac1ec1658273f6e6bb312dd2b0718">More...</a><br /></td></tr>
<tr class="separator:ga8c1ac1ec1658273f6e6bb312dd2b0718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a2a7d7f5165ef7f5433ef67efad4306"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga6a2a7d7f5165ef7f5433ef67efad4306"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga6a2a7d7f5165ef7f5433ef67efad4306">compute_vertex_valence</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_vertex_valence_options.html">VertexValenceOptions</a> options={})</td></tr>
<tr class="memdesc:ga6a2a7d7f5165ef7f5433ef67efad4306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vertex valence.  <a href="group__group-surfacemesh-utils.html#ga6a2a7d7f5165ef7f5433ef67efad4306">More...</a><br /></td></tr>
<tr class="separator:ga6a2a7d7f5165ef7f5433ef67efad4306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga203af050581e879b52d339558b788a08"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga203af050581e879b52d339558b788a08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_adjacency_list.html">AdjacencyList</a>&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga203af050581e879b52d339558b788a08">compute_vertex_vertex_adjacency</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga203af050581e879b52d339558b788a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vertex-vertex adjacency information.  <a href="group__group-surfacemesh-utils.html#ga203af050581e879b52d339558b788a08">More...</a><br /></td></tr>
<tr class="separator:ga203af050581e879b52d339558b788a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa13892cc06d31d64e6613c3e48785591"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gaa13892cc06d31d64e6613c3e48785591"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gaa13892cc06d31d64e6613c3e48785591">compute_weighted_corner_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_corner_normal_options.html">CornerNormalOptions</a> option={})</td></tr>
<tr class="memdesc:gaa13892cc06d31d64e6613c3e48785591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute corner normals.  <a href="group__group-surfacemesh-utils.html#gaa13892cc06d31d64e6613c3e48785591">More...</a><br /></td></tr>
<tr class="separator:gaa13892cc06d31d64e6613c3e48785591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7934b43c189ee9cbc1a684ee38ac026c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index , typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:ga7934b43c189ee9cbc1a684ee38ac026c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga7934b43c189ee9cbc1a684ee38ac026c">eigen_to_surface_mesh</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:ga7934b43c189ee9cbc1a684ee38ac026c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classlagrange_1_1_surface_mesh.html" title="A general purpose polygonal mesh class.">SurfaceMesh</a> from a igl-style pair of matrices (V, F).  <a href="group__group-surfacemesh-utils.html#ga7934b43c189ee9cbc1a684ee38ac026c">More...</a><br /></td></tr>
<tr class="separator:ga7934b43c189ee9cbc1a684ee38ac026c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab32ca760af612ea529943197c79f719b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gab32ca760af612ea529943197c79f719b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gab32ca760af612ea529943197c79f719b">extract_boundary_loops</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:gab32ca760af612ea529943197c79f719b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract boundary loops from a surface mesh.  <a href="group__group-surfacemesh-utils.html#gab32ca760af612ea529943197c79f719b">More...</a><br /></td></tr>
<tr class="separator:gab32ca760af612ea529943197c79f719b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f1b4f791ba72765e9c19df688bffd1c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga6f1b4f791ba72765e9c19df688bffd1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga6f1b4f791ba72765e9c19df688bffd1c">extract_submesh</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; selected_facets, const <a class="el" href="structlagrange_1_1_submesh_options.html">SubmeshOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:ga6f1b4f791ba72765e9c19df688bffd1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a submesh that consists of a subset of the facets of the source mesh.  <a href="group__group-surfacemesh-utils.html#ga6f1b4f791ba72765e9c19df688bffd1c">More...</a><br /></td></tr>
<tr class="separator:ga6f1b4f791ba72765e9c19df688bffd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfe7b2432f1f1a2cdd4c9b75dc2dec31"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gacfe7b2432f1f1a2cdd4c9b75dc2dec31"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gacfe7b2432f1f1a2cdd4c9b75dc2dec31">filtered_attribute_ids</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const <a class="el" href="structlagrange_1_1_attribute_filter.html">AttributeFilter</a> &amp;options)</td></tr>
<tr class="memdesc:gacfe7b2432f1f1a2cdd4c9b75dc2dec31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a list of attribute ids corresponding to the given filter.  <a href="group__group-surfacemesh-utils.html#gacfe7b2432f1f1a2cdd4c9b75dc2dec31">More...</a><br /></td></tr>
<tr class="separator:gacfe7b2432f1f1a2cdd4c9b75dc2dec31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac94fc907068f80f41ede4fabca362289"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gac94fc907068f80f41ede4fabca362289"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gac94fc907068f80f41ede4fabca362289">filter_attributes</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; source_mesh, const <a class="el" href="structlagrange_1_1_attribute_filter.html">AttributeFilter</a> &amp;options={})</td></tr>
<tr class="memdesc:gac94fc907068f80f41ede4fabca362289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters the attributes of mesh according to user specifications.  <a href="group__group-surfacemesh-utils.html#gac94fc907068f80f41ede4fabca362289">More...</a><br /></td></tr>
<tr class="separator:gac94fc907068f80f41ede4fabca362289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb5fc3fc93e8d973bcc534398eeb0aa9"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index , typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:gabb5fc3fc93e8d973bcc534398eeb0aa9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gabb5fc3fc93e8d973bcc534398eeb0aa9">to_surface_mesh_copy</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="memdesc:gabb5fc3fc93e8d973bcc534398eeb0aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a legacy mesh object to a surface mesh object.  <a href="group__group-surfacemesh-utils.html#gabb5fc3fc93e8d973bcc534398eeb0aa9">More...</a><br /></td></tr>
<tr class="separator:gabb5fc3fc93e8d973bcc534398eeb0aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68ad17ee5b7475decfbaf17fcfa63d65"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index , typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:ga68ad17ee5b7475decfbaf17fcfa63d65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga68ad17ee5b7475decfbaf17fcfa63d65">to_surface_mesh_wrap</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&amp;mesh)</td></tr>
<tr class="memdesc:ga68ad17ee5b7475decfbaf17fcfa63d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a legacy mesh object as a surface mesh object.  <a href="group__group-surfacemesh-utils.html#ga68ad17ee5b7475decfbaf17fcfa63d65">More...</a><br /></td></tr>
<tr class="separator:ga68ad17ee5b7475decfbaf17fcfa63d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac349d354b36d62bc2efeb93dd2b7f078"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gac349d354b36d62bc2efeb93dd2b7f078"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gac349d354b36d62bc2efeb93dd2b7f078">to_legacy_mesh</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:gac349d354b36d62bc2efeb93dd2b7f078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a surface mesh object to a legacy mesh object.  <a href="group__group-surfacemesh-utils.html#gac349d354b36d62bc2efeb93dd2b7f078">More...</a><br /></td></tr>
<tr class="separator:gac349d354b36d62bc2efeb93dd2b7f078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf07b7ee38e3c92577a3cdc9a7bb38479"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gaf07b7ee38e3c92577a3cdc9a7bb38479"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gaf07b7ee38e3c92577a3cdc9a7bb38479">normalize_mesh</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:gaf07b7ee38e3c92577a3cdc9a7bb38479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a mesh to fit in a unit box centered at the origin.  <a href="group__group-surfacemesh-utils.html#gaf07b7ee38e3c92577a3cdc9a7bb38479">More...</a><br /></td></tr>
<tr class="separator:gaf07b7ee38e3c92577a3cdc9a7bb38479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad46e0464a61ba9b6c5fd7948af53c304"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gad46e0464a61ba9b6c5fd7948af53c304"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gad46e0464a61ba9b6c5fd7948af53c304">normalize_meshes</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; * &gt; meshes)</td></tr>
<tr class="memdesc:gad46e0464a61ba9b6c5fd7948af53c304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a list of meshes to fit in a unit box centered at the origin.  <a href="group__group-surfacemesh-utils.html#gad46e0464a61ba9b6c5fd7948af53c304">More...</a><br /></td></tr>
<tr class="separator:gad46e0464a61ba9b6c5fd7948af53c304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bb6f1ff87f6aac0062ac21dba0f2349"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga4bb6f1ff87f6aac0062ac21dba0f2349"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga4bb6f1ff87f6aac0062ac21dba0f2349">permute_facets</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; new_to_old)</td></tr>
<tr class="memdesc:ga4bb6f1ff87f6aac0062ac21dba0f2349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder facets of a mesh based on a given permutation.  <a href="group__group-surfacemesh-utils.html#ga4bb6f1ff87f6aac0062ac21dba0f2349">More...</a><br /></td></tr>
<tr class="separator:ga4bb6f1ff87f6aac0062ac21dba0f2349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aea6bef4481de2ace23921d95fdc8fe"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga8aea6bef4481de2ace23921d95fdc8fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga8aea6bef4481de2ace23921d95fdc8fe">permute_vertices</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; new_to_old)</td></tr>
<tr class="memdesc:ga8aea6bef4481de2ace23921d95fdc8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder vertices of a mesh based on a given permutation.  <a href="group__group-surfacemesh-utils.html#ga8aea6bef4481de2ace23921d95fdc8fe">More...</a><br /></td></tr>
<tr class="separator:ga8aea6bef4481de2ace23921d95fdc8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78898b0da8d43677481cdc176f2391f8"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga78898b0da8d43677481cdc176f2391f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga78898b0da8d43677481cdc176f2391f8">remap_vertices</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; forward_mapping, <a class="el" href="structlagrange_1_1_remap_vertices_options.html">RemapVerticesOptions</a> options={})</td></tr>
<tr class="memdesc:ga78898b0da8d43677481cdc176f2391f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap vertices of a mesh based on provided forward mapping.  <a href="group__group-surfacemesh-utils.html#ga78898b0da8d43677481cdc176f2391f8">More...</a><br /></td></tr>
<tr class="separator:ga78898b0da8d43677481cdc176f2391f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga954105400081aec257b861eabc11caa4"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga954105400081aec257b861eabc11caa4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga954105400081aec257b861eabc11caa4">separate_by_components</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const <a class="el" href="structlagrange_1_1_separate_by_components_options.html">SeparateByComponentsOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:ga954105400081aec257b861eabc11caa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separate a mesh by connected components.  <a href="group__group-surfacemesh-utils.html#ga954105400081aec257b861eabc11caa4">More...</a><br /></td></tr>
<tr class="separator:ga954105400081aec257b861eabc11caa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a916fec3d88a2f142479beb6d1dabbc"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga3a916fec3d88a2f142479beb6d1dabbc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga3a916fec3d88a2f142479beb6d1dabbc">separate_by_facet_groups</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, size_t num_groups, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; facet_group_indices, const <a class="el" href="structlagrange_1_1_separate_by_facet_groups_options.html">SeparateByFacetGroupsOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:ga3a916fec3d88a2f142479beb6d1dabbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a set of submeshes based on facet groups.  <a href="group__group-surfacemesh-utils.html#ga3a916fec3d88a2f142479beb6d1dabbc">More...</a><br /></td></tr>
<tr class="separator:ga3a916fec3d88a2f142479beb6d1dabbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bfc61d050dfff96cd48f72f4bd4b149"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga8bfc61d050dfff96cd48f72f4bd4b149"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga8bfc61d050dfff96cd48f72f4bd4b149">separate_by_facet_groups</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; facet_group_indices, const <a class="el" href="structlagrange_1_1_separate_by_facet_groups_options.html">SeparateByFacetGroupsOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:ga8bfc61d050dfff96cd48f72f4bd4b149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a set of submeshes based on facet groups.  <a href="group__group-surfacemesh-utils.html#ga8bfc61d050dfff96cd48f72f4bd4b149">More...</a><br /></td></tr>
<tr class="separator:ga8bfc61d050dfff96cd48f72f4bd4b149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987e83dd82916a9347d04f1d45a7934e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga987e83dd82916a9347d04f1d45a7934e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga987e83dd82916a9347d04f1d45a7934e">separate_by_facet_groups</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, size_t num_groups, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; Index(Index)&gt; get_facet_group, const <a class="el" href="structlagrange_1_1_separate_by_facet_groups_options.html">SeparateByFacetGroupsOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:ga987e83dd82916a9347d04f1d45a7934e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a set of submeshes based on facet groups.  <a href="group__group-surfacemesh-utils.html#ga987e83dd82916a9347d04f1d45a7934e">More...</a><br /></td></tr>
<tr class="separator:ga987e83dd82916a9347d04f1d45a7934e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga256e7ab23f324bc2f7fb5fd977405932"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga256e7ab23f324bc2f7fb5fd977405932"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga256e7ab23f324bc2f7fb5fd977405932">compute_euler</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga256e7ab23f324bc2f7fb5fd977405932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Euler characteristic of a mesh.  <a href="group__group-surfacemesh-utils.html#ga256e7ab23f324bc2f7fb5fd977405932">More...</a><br /></td></tr>
<tr class="separator:ga256e7ab23f324bc2f7fb5fd977405932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c7a15cae60d68a94bac4068de177b4a"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga8c7a15cae60d68a94bac4068de177b4a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga8c7a15cae60d68a94bac4068de177b4a">is_vertex_manifold</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga8c7a15cae60d68a94bac4068de177b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a mesh is vertex-manifold.  <a href="group__group-surfacemesh-utils.html#ga8c7a15cae60d68a94bac4068de177b4a">More...</a><br /></td></tr>
<tr class="separator:ga8c7a15cae60d68a94bac4068de177b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52aec6a70ed2240fe977f81f393d1259"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga52aec6a70ed2240fe977f81f393d1259"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga52aec6a70ed2240fe977f81f393d1259">is_edge_manifold</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga52aec6a70ed2240fe977f81f393d1259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a mesh is edge-manifold.  <a href="group__group-surfacemesh-utils.html#ga52aec6a70ed2240fe977f81f393d1259">More...</a><br /></td></tr>
<tr class="separator:ga52aec6a70ed2240fe977f81f393d1259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b70a6e7c30cd0524e2fc2490f280b69"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga4b70a6e7c30cd0524e2fc2490f280b69"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga4b70a6e7c30cd0524e2fc2490f280b69">is_manifold</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga4b70a6e7c30cd0524e2fc2490f280b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a mesh is both vertex-manifold and edge-manifold.  <a href="group__group-surfacemesh-utils.html#ga4b70a6e7c30cd0524e2fc2490f280b69">More...</a><br /></td></tr>
<tr class="separator:ga4b70a6e7c30cd0524e2fc2490f280b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc5a05b5bc041f50fbff82c00e18c631"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index , int Dimension&gt; </td></tr>
<tr class="memitem:gacc5a05b5bc041f50fbff82c00e18c631"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gacc5a05b5bc041f50fbff82c00e18c631">transform_mesh</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const Eigen::Transform&lt; Scalar, Dimension, Eigen::Affine &gt; &amp;transform, const <a class="el" href="structlagrange_1_1_transform_options.html">TransformOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:gacc5a05b5bc041f50fbff82c00e18c631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an affine transform \( M \) to a mesh in-place.  <a href="group__group-surfacemesh-utils.html#gacc5a05b5bc041f50fbff82c00e18c631">More...</a><br /></td></tr>
<tr class="separator:gacc5a05b5bc041f50fbff82c00e18c631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac646c16958d9cb11644e1c9e72e305dc"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index , int Dimension&gt; </td></tr>
<tr class="memitem:gac646c16958d9cb11644e1c9e72e305dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gac646c16958d9cb11644e1c9e72e305dc">transformed_mesh</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; mesh, const Eigen::Transform&lt; Scalar, Dimension, Eigen::Affine &gt; &amp;transform, const <a class="el" href="structlagrange_1_1_transform_options.html">TransformOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:gac646c16958d9cb11644e1c9e72e305dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an affine transform to a mesh and return the transformed mesh.  <a href="group__group-surfacemesh-utils.html#gac646c16958d9cb11644e1c9e72e305dc">More...</a><br /></td></tr>
<tr class="separator:gac646c16958d9cb11644e1c9e72e305dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48af6105ece8a970755870c73af73ddd"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga48af6105ece8a970755870c73af73ddd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga48af6105ece8a970755870c73af73ddd">triangulate_polygonal_facets</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga48af6105ece8a970755870c73af73ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulate polygonal facets of a mesh using a prescribed set of rules.  <a href="group__group-surfacemesh-utils.html#ga48af6105ece8a970755870c73af73ddd">More...</a><br /></td></tr>
<tr class="separator:ga48af6105ece8a970755870c73af73ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Various attribute processing utilities. </p>
<p >Various mesh processing utilities.</p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gadab1480827f4522cbf1f9e1d4c28db91" name="gadab1480827f4522cbf1f9e1d4c28db91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadab1480827f4522cbf1f9e1d4c28db91">&#9670;&nbsp;</a></span>DistortionMetric</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__group-surfacemesh-utils.html#gadab1480827f4522cbf1f9e1d4c28db91">DistortionMetric</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/DistortionMetric.h&gt;</code></p>

<p>UV distortion metric type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadab1480827f4522cbf1f9e1d4c28db91abac152b762896edff34ed668ae1a546f" name="ggadab1480827f4522cbf1f9e1d4c28db91abac152b762896edff34ed668ae1a546f"></a>Dirichlet&#160;</td><td class="fielddoc"><p >Dirichlet energy. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadab1480827f4522cbf1f9e1d4c28db91a541c024e21b5989aa74764f7c362dfd2" name="ggadab1480827f4522cbf1f9e1d4c28db91a541c024e21b5989aa74764f7c362dfd2"></a>InverseDirichlet&#160;</td><td class="fielddoc"><p >Inverse Dirichlet energy. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadab1480827f4522cbf1f9e1d4c28db91a6043446227f6a89342620a00a131257f" name="ggadab1480827f4522cbf1f9e1d4c28db91a6043446227f6a89342620a00a131257f"></a>SymmetricDirichlet&#160;</td><td class="fielddoc"><p >Symmetric Dirichlet energy. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadab1480827f4522cbf1f9e1d4c28db91a16c8e070f0f6edd7ac0ae016e9bf2997" name="ggadab1480827f4522cbf1f9e1d4c28db91a16c8e070f0f6edd7ac0ae016e9bf2997"></a>MIPS&#160;</td><td class="fielddoc"><p >UV triangle area / 3D triangle area. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa88e833ed770762b02e187f0c2377d3d" name="gaa88e833ed770762b02e187f0c2377d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa88e833ed770762b02e187f0c2377d3d">&#9670;&nbsp;</a></span>NormalWeightingType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__group-surfacemesh-utils.html#gaa88e833ed770762b02e187f0c2377d3d">NormalWeightingType</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/NormalWeightingType.h&gt;</code></p>

<p>Weighting types for averaging corner normals around a vertex. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa88e833ed770762b02e187f0c2377d3daf19516d11f2946f894070e92fcb56b6d" name="ggaa88e833ed770762b02e187f0c2377d3daf19516d11f2946f894070e92fcb56b6d"></a>Uniform&#160;</td><td class="fielddoc"><p >Incident face normals have uniform influence on vertex normal. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa88e833ed770762b02e187f0c2377d3da84f023fc44b6b158de6ccc157c8dab06" name="ggaa88e833ed770762b02e187f0c2377d3da84f023fc44b6b158de6ccc157c8dab06"></a>CornerTriangleArea&#160;</td><td class="fielddoc"><p >Incident face normals are averaged weighted by area of the corner triangle. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa88e833ed770762b02e187f0c2377d3da45f4ce6c3306644b1efe333f4f8d6929" name="ggaa88e833ed770762b02e187f0c2377d3da45f4ce6c3306644b1efe333f4f8d6929"></a>Angle&#160;</td><td class="fielddoc"><p >Incident face normals are averaged weighted by incident angle of vertex. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab7596be540e8db5808abc8c322fd7460" name="gab7596be540e8db5808abc8c322fd7460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7596be540e8db5808abc8c322fd7460">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; ToScalar, ToIndex &gt; cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; FromScalar, FromIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>source_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_attribute_filter.html">AttributeFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>convertible_attributes</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>converted_attributes_names</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/cast.h&gt;</code></p>

<p>Cast a mesh to a mesh of different scalar and/or index type. </p>
<dl class="section note"><dt>Note</dt><dd>To filter only certain attributes prior to casting a mesh, use the filter_attributes function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source_mesh</td><td>Input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">convertible_attributes</td><td>Filter to determine which attribute are convertible. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">converted_attributes_names</td><td>Optional output arg storing the list of non-reserved attribute names that were actually converted to a different type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ToScalar</td><td>Scalar type of the output mesh. </td></tr>
    <tr><td class="paramname">ToIndex</td><td>Index type of the output mesh. </td></tr>
    <tr><td class="paramname">FromScalar</td><td>Scalar type of the input mesh. </td></tr>
    <tr><td class="paramname">FromIndex</td><td>Index type of the input mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output mesh.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group-surfacemesh-utils.html#gac94fc907068f80f41ede4fabca362289" title="Filters the attributes of mesh according to user specifications.">filter_attributes</a> </dd></dl>

</div>
</div>
<a id="ga363707c2e65474638292c738c072868c" name="ga363707c2e65474638292c738c072868c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga363707c2e65474638292c738c072868c">&#9670;&nbsp;</a></span>combine_meshes() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; combine_meshes </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; * &gt;&#160;</td>
          <td class="paramname"><em>meshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_attributes</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/combine_meshes.h&gt;</code></p>

<p>Combine multiple meshes into a single mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshes</td><td>The set of input mesh pointers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preserve_attributes</td><td>Preserve shared attributes and map them to the output mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The combined mesh. </dd></dl>

</div>
</div>
<a id="ga07291901c4f594454dfafb0764f4dad5" name="ga07291901c4f594454dfafb0764f4dad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07291901c4f594454dfafb0764f4dad5">&#9670;&nbsp;</a></span>combine_meshes() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; combine_meshes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &gt;&#160;</td>
          <td class="paramname"><em>meshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_attributes</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/combine_meshes.h&gt;</code></p>

<p>Combine multiple meshes into a single mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshes</td><td>Meshes to combine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preserve_attributes</td><td>Preserve shared attributes and map them to the output mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The combined mesh.</dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga9e874e29c25e3a587a9352147e36772d" name="ga9e874e29c25e3a587a9352147e36772d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e874e29c25e3a587a9352147e36772d">&#9670;&nbsp;</a></span>combine_meshes() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; combine_meshes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_meshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;(size_t)&gt;&#160;</td>
          <td class="paramname"><em>get_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_attributes</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/combine_meshes.h&gt;</code></p>

<p>Combine multiple meshes into a single mesh. </p>
<p >This is the most generic version, where <code>get_mesh(i)</code> provides the <code>i</code>th mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_meshes</td><td>Number of meshes to combine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">get_mesh</td><td>Retrieve the i-th mesh to combine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preserve_attributes</td><td>Preserve shared attributes and map them to the output mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The combined mesh.</dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga579af81b3ee4ae244a8b5cb92fc76d5c" name="ga579af81b3ee4ae244a8b5cb92fc76d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga579af81b3ee4ae244a8b5cb92fc76d5c">&#9670;&nbsp;</a></span>compute_facet_area() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> compute_facet_area </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlagrange_1_1_facet_area_options.html">FacetAreaOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_area.h&gt;</code></p>

<p>Compute per-facet area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>The options controlling the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute id of the facet area attribute. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_facet_area_options.html" title="Option struct for computing per-facet area.">FacetAreaOptions</a></code> </dd></dl>

</div>
</div>
<a id="ga8852c901ee9b6908389b24d03632306f" name="ga8852c901ee9b6908389b24d03632306f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8852c901ee9b6908389b24d03632306f">&#9670;&nbsp;</a></span>compute_facet_area() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> compute_facet_area </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, Dimension, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlagrange_1_1_facet_area_options.html">FacetAreaOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_area.h&gt;</code></p>

<p>Compute per-facet area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transformation</td><td>Affine transformation to apply on mesh geometry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>The options controlling the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type. </td></tr>
    <tr><td class="paramname">Dimension</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute id of the facet area attribute. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_facet_area_options.html" title="Option struct for computing per-facet area.">FacetAreaOptions</a></code> </dd></dl>

</div>
</div>
<a id="ga685d104f63c148710e7f8e3ffb2bb779" name="ga685d104f63c148710e7f8e3ffb2bb779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga685d104f63c148710e7f8e3ffb2bb779">&#9670;&nbsp;</a></span>compute_mesh_area() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar compute_mesh_area </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlagrange_1_1_mesh_area_options.html">MeshAreaOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_area.h&gt;</code></p>

<p>Compute mesh area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>The options controlling the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed mesh area. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_mesh_area_options.html" title="Option struct for computing mesh area.">MeshAreaOptions</a></code> </dd></dl>

</div>
</div>
<a id="gad3b913ec3b353ba77d4b71549e8079a1" name="gad3b913ec3b353ba77d4b71549e8079a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3b913ec3b353ba77d4b71549e8079a1">&#9670;&nbsp;</a></span>compute_mesh_area() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar compute_mesh_area </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, Dimension, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlagrange_1_1_mesh_area_options.html">MeshAreaOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_area.h&gt;</code></p>

<p>Compute mesh area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transformation</td><td>Affine transformation to apply on mesh geometry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>The options controlling the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type. </td></tr>
    <tr><td class="paramname">Dimension</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed mesh area. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_mesh_area_options.html" title="Option struct for computing mesh area.">MeshAreaOptions</a></code> </dd></dl>

</div>
</div>
<a id="ga9362d326a1cbd65aca95f481bc2d5e3c" name="ga9362d326a1cbd65aca95f481bc2d5e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9362d326a1cbd65aca95f481bc2d5e3c">&#9670;&nbsp;</a></span>compute_facet_centroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> compute_facet_centroid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlagrange_1_1_facet_centroid_options.html">FacetCentroidOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_centroid.h&gt;</code></p>

<p>Compute per-facet centroid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Option settings to control the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> Scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> Index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The id of the facet centroid attribute. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_facet_centroid_options.html" title="Option struct for computing per-facet centroid.">FacetCentroidOptions</a></code> </dd></dl>

</div>
</div>
<a id="gae64040c03275b07fff5b820f2a61d0ba" name="gae64040c03275b07fff5b820f2a61d0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae64040c03275b07fff5b820f2a61d0ba">&#9670;&nbsp;</a></span>compute_mesh_centroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_mesh_centroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; Scalar &gt;&#160;</td>
          <td class="paramname"><em>centroid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlagrange_1_1_mesh_centroid_options.html">MeshCentroidOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_centroid.h&gt;</code></p>

<p>Compute mesh centroid, where mesh centroid is defined as the weighted sum of facet centroids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">centroid</td><td>The buffer to store centroid coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Option settings to control the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> Scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> Index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_mesh_centroid_options.html" title="Option struct for computing mesh centroid.">MeshCentroidOptions</a></code> </dd></dl>

</div>
</div>
<a id="gafedc8c0d66af62d6f3d540465c0018c6" name="gafedc8c0d66af62d6f3d540465c0018c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafedc8c0d66af62d6f3d540465c0018c6">&#9670;&nbsp;</a></span>compute_components() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t compute_components </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlagrange_1_1_component_options.html">ComponentOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_components.h&gt;</code></p>

<p>Compute connected components of an input mesh. </p>
<p >This method will create a per-facet component id in an attribute named <code><a class="el" href="structlagrange_1_1_component_options.html#ad9fcba39803c665ca7be48a39d079f00" title="Output component id attribute name.">ComponentOptions::output_attribute_name</a></code>. Each component id is in [0, num_components-1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>Input mesh. </td></tr>
    <tr><td class="paramname">options</td><td>Options to control component computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of connected components.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_component_options.html" title="Options to control connected components computation.">ComponentOptions</a></code> </dd></dl>

</div>
</div>
<a id="gabe6250f56cb0f4cfbde68b857321d107" name="gabe6250f56cb0f4cfbde68b857321d107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe6250f56cb0f4cfbde68b857321d107">&#9670;&nbsp;</a></span>compute_components() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t compute_components </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt;&#160;</td>
          <td class="paramname"><em>blocker_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlagrange_1_1_component_options.html">ComponentOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_components.h&gt;</code></p>

<p>Compute connected components of an input mesh. </p>
<p >This method will create a per-facet component id in an attribute named <code><a class="el" href="structlagrange_1_1_component_options.html#ad9fcba39803c665ca7be48a39d079f00" title="Output component id attribute name.">ComponentOptions::output_attribute_name</a></code>. Each component id is in [0, num_components-1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>Input mesh. </td></tr>
    <tr><td class="paramname">blocker_elements</td><td>An array of blocker element indices. The blocker element index is either a vertex index or an edge index depending on <code>options.connectivity_type</code>. If <code>options.connectivity_type</code> is <code><a class="el" href="namespacelagrange.html#a312f57b0318728667933d7254778058bae4a297a0f76119a442c2595ac040673e" title="Two facets are considered connected if they share an edge.">ConnectivityType::Edge</a></code>, facets adjacent to a blocker edge are not considered as connected through this edge. If <code>options.connectivity_type</code> is <code><a class="el" href="namespacelagrange.html#a312f57b0318728667933d7254778058bab22b929ba52471a02d18bb3a4e4472e6" title="Two facets are considered connected if they share a vertex.">ConnectivityType::Vertex</a></code>, facets sharing a blocker vertex are not considered as connected through this vertex. If empty, no blocker elements are used. </td></tr>
    <tr><td class="paramname">options</td><td>Options to control component computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of connected components.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_component_options.html" title="Options to control connected components computation.">ComponentOptions</a></code> </dd></dl>

</div>
</div>
<a id="gab65464571f0034e009273ade90fcb4bf" name="gab65464571f0034e009273ade90fcb4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab65464571f0034e009273ade90fcb4bf">&#9670;&nbsp;</a></span>compute_dihedral_angles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> compute_dihedral_angles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_dihedral_angle_options.html">DihedralAngleOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_dihedral_angles.h&gt;</code></p>

<p>Computes dihedral angles for each edge in the mesh. </p>
<p >The dihedral angle of an edge is defined as the angle between the <b>normals</b> of two facets adjacent to the edge. The dihedral angle is always in the range \([0, \pi]\) for manifold edges. For boundary edges, the dihedral angle defaults to 0. For non-manifold edges, the dihedral angle is not well-defined and will be set to the special value \( 2\pi \).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options for computing dihedral angles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The id of the dihedral angle attribute.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structlagrange_1_1_dihedral_angle_options.html" title="Option struct for computing dihedral angles.">DihedralAngleOptions</a> </dd></dl>

</div>
</div>
<a id="ga63cc672971ecc26849450a45db354f6b" name="ga63cc672971ecc26849450a45db354f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63cc672971ecc26849450a45db354f6b">&#9670;&nbsp;</a></span>compute_dijkstra_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::vector&lt; Index &gt; &gt; compute_dijkstra_distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_dijkstra_distance_options.html">DijkstraDistanceOptions</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_dijkstra_distance.h&gt;</code></p>

<p>Computes dijkstra distance from a seed facet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>Input mesh. </td></tr>
    <tr><td class="paramname">options</td><td>Options for computing dijkstra distance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optionally, a vector of indices of vertices involved </dd></dl>

</div>
</div>
<a id="ga58593e3709263771bc25ff51f473c92a" name="ga58593e3709263771bc25ff51f473c92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58593e3709263771bc25ff51f473c92a">&#9670;&nbsp;</a></span>compute_edge_lengths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> compute_edge_lengths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_edge_length_options.html">EdgeLengthOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_edge_lengths.h&gt;</code></p>

<p>Computes edge lengths attribute. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh </td></tr>
    <tr><td class="paramname">options</td><td>Options for computing edge lengths.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> ID of the computed edge lengths attribute. </dd></dl>

</div>
</div>
<a id="ga50e835144b2dd2ad5df9848293c8b097" name="ga50e835144b2dd2ad5df9848293c8b097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50e835144b2dd2ad5df9848293c8b097">&#9670;&nbsp;</a></span>compute_facet_normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> compute_facet_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlagrange_1_1_facet_normal_options.html">FacetNormalOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_facet_normal.h&gt;</code></p>

<p>Compute facet normals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Optional arguments to control normal generation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AttributeId The attribute id of the facet normal attribute.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The computed facet normals are stored in <code>mesh</code> as a facet attribute named <code>options.output_attribute_name</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-planar polygonal facet's normal is not well defined. This method can only compute an approximated normal using a triangle fan.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_facet_normal_options.html" title="Option struct for computing per-facet mesh normals.">FacetNormalOptions</a></code>. </dd></dl>

</div>
</div>
<a id="ga0d1dc948d0cb8aa8b7759e34a34df7bc" name="ga0d1dc948d0cb8aa8b7759e34a34df7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d1dc948d0cb8aa8b7759e34a34df7bc">&#9670;&nbsp;</a></span>compute_normal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> compute_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; bool(Index)&gt;&#160;</td>
          <td class="paramname"><em>is_edge_smooth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt;&#160;</td>
          <td class="paramname"><em>cone_vertices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlagrange_1_1_normal_options.html">NormalOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_normal.h&gt;</code></p>

<p>Compute smooth normals based on specified sharp edges and cone vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_edge_smooth</td><td>Returns true on e if the edge is smooth. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cone_vertices</td><td>A list of cone vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Optional arguments to control normal generation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The indexed attribute id of normal attribute.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_normal_options.html" title="Option struct for computing indexed mesh normals.">NormalOptions</a></code>. </dd></dl>

</div>
</div>
<a id="gabe91547f24b4936c8feddd9b74b1aa02" name="gabe91547f24b4936c8feddd9b74b1aa02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe91547f24b4936c8feddd9b74b1aa02">&#9670;&nbsp;</a></span>compute_normal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> compute_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; bool(Index, Index)&gt;&#160;</td>
          <td class="paramname"><em>is_edge_smooth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt;&#160;</td>
          <td class="paramname"><em>cone_vertices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlagrange_1_1_normal_options.html">NormalOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_normal.h&gt;</code></p>

<p>Compute smooth normals based on specified sharp edges and cone vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_edge_smooth</td><td>Returns true on (fi, fj) if the edge between fi and fj is smooth. Assumes fi and fi are adjacent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cone_vertices</td><td>A list of cone vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Optional arguments to control normal generation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The indexed attribute id of normal attribute.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_normal_options.html" title="Option struct for computing indexed mesh normals.">NormalOptions</a></code>. </dd></dl>

</div>
</div>
<a id="ga668cc68bd27510b1bec92cf8dbe0e362" name="ga668cc68bd27510b1bec92cf8dbe0e362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga668cc68bd27510b1bec92cf8dbe0e362">&#9670;&nbsp;</a></span>compute_normal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> compute_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>feature_angle_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt;&#160;</td>
          <td class="paramname"><em>cone_vertices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlagrange_1_1_normal_options.html">NormalOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_normal.h&gt;</code></p>

<p>Compute smooth normal based on specified dihedral angle threshold and cone vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">feature_angle_threshold</td><td>An edge with dihedral angle larger than this threshold is considered as an feature edge. The angle is expressed in radian. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cone_vertices</td><td>A list of cone vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Optional arguments to control normal generation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The indexed attribute id of normal attribute.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_normal_options.html" title="Option struct for computing indexed mesh normals.">NormalOptions</a></code>. </dd></dl>

</div>
</div>
<a id="gac0b89e21157c268e2931da3910bc2930" name="gac0b89e21157c268e2931da3910bc2930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0b89e21157c268e2931da3910bc2930">&#9670;&nbsp;</a></span>compute_tangent_bitangent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlagrange_1_1_tangent_bitangent_result.html">TangentBitangentResult</a> compute_tangent_bitangent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlagrange_1_1_tangent_bitangent_options.html">TangentBitangentOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_tangent_bitangent.h&gt;</code></p>

<p>Compute mesh tangent and bitangent vectors orthogonal to the input mesh normals. </p>
<dl class="section note"><dt>Note</dt><dd>The input mesh must have existing indexed normal and UV attributes. The input UV attribute is used to orient the resulting T/B vectors coherently wrt to the UV mapping.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Optional arguments to control tangent/bitangent generation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A struct containing the id of the generated tangent/bitangent attributes.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_tangent_bitangent_options.html" title="Option struct for computing tangent and bitangent vectors.">TangentBitangentOptions</a></code>. </dd></dl>

</div>
</div>
<a id="gad96a9c0374e82142015e619d6cf3bf67" name="gad96a9c0374e82142015e619d6cf3bf67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad96a9c0374e82142015e619d6cf3bf67">&#9670;&nbsp;</a></span>compute_uv_distortion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> compute_uv_distortion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_u_v_distortion_options.html">UVDistortionOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_uv_distortion.h&gt;</code></p>

<p>Compute uv distortion using the selected distortion measure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>The computation option settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute id of the distortion measure facet attribute.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_u_v_distortion_options.html" title="Option struct for compute uv distortion.">UVDistortionOptions</a></code>. </dd></dl>

</div>
</div>
<a id="gaa9c124c65e79e319a4aefc92ccb5ce7f" name="gaa9c124c65e79e319a4aefc92ccb5ce7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9c124c65e79e319a4aefc92ccb5ce7f">&#9670;&nbsp;</a></span>compute_uv_tile_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; int32_t, int32_t &gt; &gt; compute_uv_tile_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_uv_tile_list.h&gt;</code></p>

<p>Extract the list of all UV tiles that a mesh's parametrization spans. </p>
<p >UV tiles are usually understood to be a regular unit grid in UV space. This process thus reads UV for all vertices of the input mesh, and adds an entry to the output for each new integer pair that it finds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> to be analyzed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of integer coordinates with one entry for each UV tile of mesh. </dd></dl>

</div>
</div>
<a id="ga8c1ac1ec1658273f6e6bb312dd2b0718" name="ga8c1ac1ec1658273f6e6bb312dd2b0718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c1ac1ec1658273f6e6bb312dd2b0718">&#9670;&nbsp;</a></span>compute_vertex_normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> compute_vertex_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlagrange_1_1_vertex_normal_options.html">VertexNormalOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_vertex_normal.h&gt;</code></p>

<p>Compute per-vertex normals based on specified weighting type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Optional arguments to control normal generation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute id of vertex normal attribute.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_vertex_normal_options.html" title="Option struct for computing per-vertex mesh normals.">VertexNormalOptions</a></code>. </dd></dl>

</div>
</div>
<a id="ga6a2a7d7f5165ef7f5433ef67efad4306" name="ga6a2a7d7f5165ef7f5433ef67efad4306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a2a7d7f5165ef7f5433ef67efad4306">&#9670;&nbsp;</a></span>compute_vertex_valence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> compute_vertex_valence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlagrange_1_1_vertex_valence_options.html">VertexValenceOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_vertex_valence.h&gt;</code></p>

<p>Compute vertex valence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramname">options</td><td>Optional settings to control valence computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vertex attribute id containing valence information.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_vertex_valence_options.html" title="Option struct for computing vertex valence.">VertexValenceOptions</a></code> </dd></dl>

</div>
</div>
<a id="ga203af050581e879b52d339558b788a08" name="ga203af050581e879b52d339558b788a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga203af050581e879b52d339558b788a08">&#9670;&nbsp;</a></span>compute_vertex_vertex_adjacency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_adjacency_list.html">AdjacencyList</a>&lt; Index &gt; compute_vertex_vertex_adjacency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_vertex_vertex_adjacency.h&gt;</code></p>

<p>Compute vertex-vertex adjacency information. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vertex-vertex adjacency data and adjacency indices. </dd></dl>

</div>
</div>
<a id="gaa13892cc06d31d64e6613c3e48785591" name="gaa13892cc06d31d64e6613c3e48785591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa13892cc06d31d64e6613c3e48785591">&#9670;&nbsp;</a></span>compute_weighted_corner_normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> compute_weighted_corner_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlagrange_1_1_corner_normal_options.html">CornerNormalOptions</a>&#160;</td>
          <td class="paramname"><em>option</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/compute_weighted_corner_normal.h&gt;</code></p>

<p>Compute corner normals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Optional arguments to control normal generation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corner attribute id of corner normal attribute.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>options.weight_type</code> is not <code>Uniform</code>, the resulting corner normal's lengths encodes the corresponding weight.</dd>
<dd>
Corner normals around a given vertex could be different even when the vertex is at a smooth region. For computing smooth normal, use <a class="el" href="group__group-surfacemesh-utils.html#ga0d1dc948d0cb8aa8b7759e34a34df7bc">compute_normal</a> instead.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_corner_normal_options.html" title="Option struct for computing per-corner mesh normals.">CornerNormalOptions</a></code>, <code><a class="el" href="group__group-surfacemesh-utils.html#ga0d1dc948d0cb8aa8b7759e34a34df7bc" title="Compute smooth normals based on specified sharp edges and cone vertices.">compute_normal</a></code>. </dd></dl>

</div>
</div>
<a id="ga7934b43c189ee9cbc1a684ee38ac026c" name="ga7934b43c189ee9cbc1a684ee38ac026c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7934b43c189ee9cbc1a684ee38ac026c">&#9670;&nbsp;</a></span>eigen_to_surface_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; eigen_to_surface_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/eigen_convert.h&gt;</code></p>

<p>Create a <a class="el" href="classlagrange_1_1_surface_mesh.html" title="A general purpose polygonal mesh class.">SurfaceMesh</a> from a igl-style pair of matrices (V, F). </p>
<dl class="section note"><dt>Note</dt><dd>The target Scalar x Index type must be explicitly specified. In the future, we may allow automatic deduction based on the input matrix types.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V x d matrix of vertex positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F x k matrix of facet indices. E.g. k=3 for triangle meshes, k=4 for quad meshes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Target mesh scalar type (required). Either float or double. </td></tr>
    <tr><td class="paramname">Index</td><td>Target mesh index type (required). Either uint32_t or uint64_t. </td></tr>
    <tr><td class="paramname">DerivedV</td><td>Input vertex matrix type. </td></tr>
    <tr><td class="paramname">DerivedF</td><td>Input facet matrix type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New mesh object. </dd></dl>

</div>
</div>
<a id="gab32ca760af612ea529943197c79f719b" name="gab32ca760af612ea529943197c79f719b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab32ca760af612ea529943197c79f719b">&#9670;&nbsp;</a></span>extract_boundary_loops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; Index &gt; &gt; extract_boundary_loops </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/extract_boundary_loops.h&gt;</code></p>

<p>Extract boundary loops from a surface mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type of the mesh. </td></tr>
    <tr><td class="paramname">Index</td><td>The index type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input surface mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of boundary loops, each represented by a vector of vertex indices. </dd></dl>

</div>
</div>
<a id="ga6f1b4f791ba72765e9c19df688bffd1c" name="ga6f1b4f791ba72765e9c19df688bffd1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f1b4f791ba72765e9c19df688bffd1c">&#9670;&nbsp;</a></span>extract_submesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; extract_submesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt;&#160;</td>
          <td class="paramname"><em>selected_facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_submesh_options.html">SubmeshOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/extract_submesh.h&gt;</code></p>

<p>Extract a submesh that consists of a subset of the facets of the source mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td>The index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The source mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">selected_facets</td><td>The set of selected facets to extract. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Extraction options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mesh containing the selected facets.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_submesh_options.html" title="Options for extract submesh.">SubmeshOptions</a></code> </dd></dl>

</div>
</div>
<a id="gacfe7b2432f1f1a2cdd4c9b75dc2dec31" name="gacfe7b2432f1f1a2cdd4c9b75dc2dec31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfe7b2432f1f1a2cdd4c9b75dc2dec31">&#9670;&nbsp;</a></span>filtered_attribute_ids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> &gt; filtered_attribute_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_attribute_filter.html">AttributeFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/filter_attributes.h&gt;</code></p>

<p>Create a list of attribute ids corresponding to the given filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> whose attributes are being filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Filter options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of attribute ids matching the filter. </dd></dl>

</div>
</div>
<a id="gac94fc907068f80f41ede4fabca362289" name="gac94fc907068f80f41ede4fabca362289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac94fc907068f80f41ede4fabca362289">&#9670;&nbsp;</a></span>filter_attributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; filter_attributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td>
          <td class="paramname"><em>source_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_attribute_filter.html">AttributeFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/filter_attributes.h&gt;</code></p>

<p>Filters the attributes of mesh according to user specifications. </p>
<dl class="section note"><dt>Note</dt><dd>If the filter option does not contains AttributeElement::Edge as one of its element type, mesh edge information will be removed in the output mesh.</dd>
<dd>
To convert a mesh and its attributes to different types, use the cast function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source_mesh</td><td>Input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Filter options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output mesh.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group-surfacemesh-utils.html#gab7596be540e8db5808abc8c322fd7460" title="Cast a mesh to a mesh of different scalar and/or index type.">cast</a> </dd></dl>

</div>
</div>
<a id="gabb5fc3fc93e8d973bcc534398eeb0aa9" name="gabb5fc3fc93e8d973bcc534398eeb0aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb5fc3fc93e8d973bcc534398eeb0aa9">&#9670;&nbsp;</a></span>to_surface_mesh_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; to_surface_mesh_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/mesh_convert.h&gt;</code></p>

<p>Convert a legacy mesh object to a surface mesh object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Output mesh scalar type. Must be either float or double. </td></tr>
    <tr><td class="paramname">Index</td><td>Output mesh index type. Must be either uint32_t or uint64_t. </td></tr>
    <tr><td class="paramname">MeshType</td><td>Input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New mesh object. </dd></dl>

</div>
</div>
<a id="ga68ad17ee5b7475decfbaf17fcfa63d65" name="ga68ad17ee5b7475decfbaf17fcfa63d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68ad17ee5b7475decfbaf17fcfa63d65">&#9670;&nbsp;</a></span>to_surface_mesh_wrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; to_surface_mesh_wrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/mesh_convert.h&gt;</code></p>

<p>Wrap a legacy mesh object as a surface mesh object. </p>
<p >The mesh scalar &amp; index types must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object to convert. The mesh object must be a lvalue reference (no temporary).</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Output mesh scalar type. Must be either float or double. </td></tr>
    <tr><td class="paramname">Index</td><td>Output mesh index type. Must be either uint32_t or uint64_t. </td></tr>
    <tr><td class="paramname">MeshType</td><td>Input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New mesh object. </dd></dl>

</div>
</div>
<a id="gac349d354b36d62bc2efeb93dd2b7f078" name="gac349d354b36d62bc2efeb93dd2b7f078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac349d354b36d62bc2efeb93dd2b7f078">&#9670;&nbsp;</a></span>to_legacy_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; to_legacy_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/mesh_convert.h&gt;</code></p>

<p>Convert a surface mesh object to a legacy mesh object. </p>
<p >The mesh must be a regular mesh object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>Output mesh type. </td></tr>
    <tr><td class="paramname">Scalar</td><td>Input mesh scalar type. Must be either float or double. </td></tr>
    <tr><td class="paramname">Index</td><td>Input mesh index type. Must be either uint32_t or uint64_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New mesh object. </dd></dl>

</div>
</div>
<a id="gaf07b7ee38e3c92577a3cdc9a7bb38479" name="gaf07b7ee38e3c92577a3cdc9a7bb38479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf07b7ee38e3c92577a3cdc9a7bb38479">&#9670;&nbsp;</a></span>normalize_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void normalize_mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/normalize_meshes.h&gt;</code></p>

<p>Normalize a mesh to fit in a unit box centered at the origin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Input mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad46e0464a61ba9b6c5fd7948af53c304" name="gad46e0464a61ba9b6c5fd7948af53c304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad46e0464a61ba9b6c5fd7948af53c304">&#9670;&nbsp;</a></span>normalize_meshes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void normalize_meshes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; * &gt;&#160;</td>
          <td class="paramname"><em>meshes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/normalize_meshes.h&gt;</code></p>

<p>Normalize a list of meshes to fit in a unit box centered at the origin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshes</td><td>List of pointers to the meshes to modify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4bb6f1ff87f6aac0062ac21dba0f2349" name="ga4bb6f1ff87f6aac0062ac21dba0f2349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bb6f1ff87f6aac0062ac21dba0f2349">&#9670;&nbsp;</a></span>permute_facets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void permute_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt;&#160;</td>
          <td class="paramname"><em>new_to_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/permute_facets.h&gt;</code></p>

<p>Reorder facets of a mesh based on a given permutation. </p>
<p >i.e. rearrangement facets so that they are ordered as specified by the <code>new_to_old</code> index array. The total number of facets is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>The target mesh whose facets will be reordered in place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_to_old</td><td>The permutation index array specifying the new facet order. This array can often be obtained via index-based sorting of the facets with customized comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group-surfacemesh-utils.html#ga6f1b4f791ba72765e9c19df688bffd1c" title="Extract a submesh that consists of a subset of the facets of the source mesh.">extract_submesh</a></code> to extract a subset of the facets. </dd></dl>

</div>
</div>
<a id="ga8aea6bef4481de2ace23921d95fdc8fe" name="ga8aea6bef4481de2ace23921d95fdc8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8aea6bef4481de2ace23921d95fdc8fe">&#9670;&nbsp;</a></span>permute_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void permute_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt;&#160;</td>
          <td class="paramname"><em>new_to_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/permute_vertices.h&gt;</code></p>

<p>Reorder vertices of a mesh based on a given permutation. </p>
<p >i.e. rearrangement vertices so that they are ordered as specified by the <code>new_to_old</code> index array. The total number of vertices is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>The target mesh whose vertices will be reordered in place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_to_old</td><td>The permutation index array specifying the new vertex order. This array can often be obtained via index-based sorting of the vertices with customized comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group-surfacemesh-utils.html#ga78898b0da8d43677481cdc176f2391f8" title="Remap vertices of a mesh based on provided forward mapping.">remap_vertices</a></code> if two or more vertices may be combined. </dd></dl>

</div>
</div>
<a id="ga78898b0da8d43677481cdc176f2391f8" name="ga78898b0da8d43677481cdc176f2391f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78898b0da8d43677481cdc176f2391f8">&#9670;&nbsp;</a></span>remap_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remap_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt;&#160;</td>
          <td class="paramname"><em>forward_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlagrange_1_1_remap_vertices_options.html">RemapVerticesOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/remap_vertices.h&gt;</code></p>

<p>Remap vertices of a mesh based on provided forward mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>The target mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forward_mapping</td><td>Vertex mapping where vertex <code>i</code> will be remapped to vertex <code>forward_mapping[i]</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li><code>forward_mapping</code> must be surjective.</li>
<li>Edge information cannot be updated, thus its presence will cause an exception.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>All vertex attributes will be updated.</li>
<li>The order of facets are unchanged.</li>
<li>If two vertices are mapped to the same index, they will be merged based on the collision policy specified in <code>options</code>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group-surfacemesh-utils.html#ga8aea6bef4481de2ace23921d95fdc8fe" title="Reorder vertices of a mesh based on a given permutation.">permute_vertices</a></code> for simply permuting the vertex order. </dd>
<dd>
<code><a class="el" href="structlagrange_1_1_remap_vertices_options.html" title="Remap vertices options.">RemapVerticesOptions</a></code>. </dd></dl>

</div>
</div>
<a id="ga954105400081aec257b861eabc11caa4" name="ga954105400081aec257b861eabc11caa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga954105400081aec257b861eabc11caa4">&#9670;&nbsp;</a></span>separate_by_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &gt; separate_by_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_separate_by_components_options.html">SeparateByComponentsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/separate_by_components.h&gt;</code></p>

<p>Separate a mesh by connected components. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td>The index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The source mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Option settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of meshes representing the set of connected components.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1_submesh_options.html" title="Options for extract submesh.">SubmeshOptions</a></code> </dd></dl>

</div>
</div>
<a id="ga3a916fec3d88a2f142479beb6d1dabbc" name="ga3a916fec3d88a2f142479beb6d1dabbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a916fec3d88a2f142479beb6d1dabbc">&#9670;&nbsp;</a></span>separate_by_facet_groups() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &gt; separate_by_facet_groups </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt;&#160;</td>
          <td class="paramname"><em>facet_group_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_separate_by_facet_groups_options.html">SeparateByFacetGroupsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/separate_by_facet_groups.h&gt;</code></p>

<p>Extract a set of submeshes based on facet groups. </p>
<p >Facets with the same group index are grouped together in a single submesh.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td>The index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The source mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_groups</td><td>The number of face groups. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_group_indices</td><td>The group index of each facet. Each group index must be in the range of [0, num_groups - 1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Extraction options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of submeshes representing each facet group. </dd></dl>

</div>
</div>
<a id="ga8bfc61d050dfff96cd48f72f4bd4b149" name="ga8bfc61d050dfff96cd48f72f4bd4b149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bfc61d050dfff96cd48f72f4bd4b149">&#9670;&nbsp;</a></span>separate_by_facet_groups() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &gt; separate_by_facet_groups </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt;&#160;</td>
          <td class="paramname"><em>facet_group_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_separate_by_facet_groups_options.html">SeparateByFacetGroupsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/separate_by_facet_groups.h&gt;</code></p>

<p>Extract a set of submeshes based on facet groups. </p>
<p >Facets with the same group index are grouped together in a single submesh.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td>The index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The source mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_group_indices</td><td>The group index of each facet. Each group index must be in the range of [0, max(facet_group_indices)]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Extraction options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of submeshes representing each facet group. </dd></dl>

</div>
</div>
<a id="ga987e83dd82916a9347d04f1d45a7934e" name="ga987e83dd82916a9347d04f1d45a7934e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga987e83dd82916a9347d04f1d45a7934e">&#9670;&nbsp;</a></span>separate_by_facet_groups() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &gt; separate_by_facet_groups </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; Index(Index)&gt;&#160;</td>
          <td class="paramname"><em>get_facet_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_separate_by_facet_groups_options.html">SeparateByFacetGroupsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/separate_by_facet_groups.h&gt;</code></p>

<p>Extract a set of submeshes based on facet groups. </p>
<p >Facets with the same group index are grouped together in a single submesh.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td>The index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The source mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_groups</td><td>The number of face groups. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">get_facet_group</td><td>Function that returns the facet group id from facet id. The groud id must be in [0, num_groups - 1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Extraction options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of submeshes representing each facet group. </dd></dl>

</div>
</div>
<a id="ga256e7ab23f324bc2f7fb5fd977405932" name="ga256e7ab23f324bc2f7fb5fd977405932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga256e7ab23f324bc2f7fb5fd977405932">&#9670;&nbsp;</a></span>compute_euler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compute_euler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/topology.h&gt;</code></p>

<p>Compute Euler characteristic of a mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type of the mesh. </td></tr>
    <tr><td class="paramname">Index</td><td>The index type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Euler characteristic of the mesh. </dd></dl>

</div>
</div>
<a id="ga8c7a15cae60d68a94bac4068de177b4a" name="ga8c7a15cae60d68a94bac4068de177b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c7a15cae60d68a94bac4068de177b4a">&#9670;&nbsp;</a></span>is_vertex_manifold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_vertex_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/topology.h&gt;</code></p>

<p>Check if a mesh is vertex-manifold. </p>
<p >A mesh is vertex-manifold if and only if the one-ring neighborhood of each vertex is of disc topology. I.e. The boundary of the 1-ring neighborhood is a simple loop for interior vertices, and a simple chain for boundary vertices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type of the mesh. </td></tr>
    <tr><td class="paramname">Index</td><td>The index type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the mesh is vertex-manifold. </dd></dl>
<p >&lt; initial value of the result.</p>
<p >&lt; initial value of the result.</p>

</div>
</div>
<a id="ga52aec6a70ed2240fe977f81f393d1259" name="ga52aec6a70ed2240fe977f81f393d1259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52aec6a70ed2240fe977f81f393d1259">&#9670;&nbsp;</a></span>is_edge_manifold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_edge_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/topology.h&gt;</code></p>

<p>Check if a mesh is edge-manifold. </p>
<p >A mesh is edge-manifold if and only if every interior edge is incident to exactly two facets, and every boundary edge is incident to exactly one facet.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type of the mesh. </td></tr>
    <tr><td class="paramname">Index</td><td>The index type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the mesh is edge-manifold. </dd></dl>

</div>
</div>
<a id="ga4b70a6e7c30cd0524e2fc2490f280b69" name="ga4b70a6e7c30cd0524e2fc2490f280b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b70a6e7c30cd0524e2fc2490f280b69">&#9670;&nbsp;</a></span>is_manifold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/topology.h&gt;</code></p>

<p>Check if a mesh is both vertex-manifold and edge-manifold. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type of the mesh. </td></tr>
    <tr><td class="paramname">Index</td><td>The index type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the mesh is both vertex-manifold and edge-manifold. </dd></dl>

</div>
</div>
<a id="gacc5a05b5bc041f50fbff82c00e18c631" name="gacc5a05b5bc041f50fbff82c00e18c631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc5a05b5bc041f50fbff82c00e18c631">&#9670;&nbsp;</a></span>transform_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void transform_mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, Dimension, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_transform_options.html">TransformOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/transform_mesh.h&gt;</code></p>

<p>Apply an affine transform \( M \) to a mesh in-place. </p>
<p >All mesh attributes are transformed based on their usage tags:</p>
<ul>
<li>Position: Applies \( P \to M * P \)</li>
<li>Normal: Applies \( P \to \det(M) M^{-T} * P \)</li>
<li>Tangent: Applies \( P \to normalize(M * P) \)</li>
<li><p class="startli">Bitangent: Applies \( P \to normalize(M * P) \)</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Add an overload for 2D transforms.</dd></dl>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> to transform in-place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>Affine transform to apply. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Transform options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type. </td></tr>
    <tr><td class="paramname">Dimension</td><td>Transform dimension (either 2 or 3). Must match mesh dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac646c16958d9cb11644e1c9e72e305dc" name="gac646c16958d9cb11644e1c9e72e305dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac646c16958d9cb11644e1c9e72e305dc">&#9670;&nbsp;</a></span>transformed_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; transformed_mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; Scalar, Dimension, Eigen::Affine &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_transform_options.html">TransformOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/transform_mesh.h&gt;</code></p>

<p>Apply an affine transform to a mesh and return the transformed mesh. </p>
<p >All mesh attributes are transformed based on their usage tags:</p>
<ul>
<li>Position: Applies \( P \to M * P \)</li>
<li>Normal: Applies \( P \to \det(M) M^{-T} * P \)</li>
<li>Tangent: Applies \( P \to normalize(M * P) \)</li>
<li><p class="startli">Bitangent: Applies \( P \to normalize(M * P) \)</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Add an overload for 2D transforms.</dd></dl>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> to transform in-place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>Affine transform to apply. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Transform options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type. </td></tr>
    <tr><td class="paramname">Dimension</td><td>Transform dimension (either 2 or 3). Must match mesh dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed mesh. </dd></dl>

</div>
</div>
<a id="ga48af6105ece8a970755870c73af73ddd" name="ga48af6105ece8a970755870c73af73ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48af6105ece8a970755870c73af73ddd">&#9670;&nbsp;</a></span>triangulate_polygonal_facets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void triangulate_polygonal_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;lagrange/triangulate_polygonal_facets.h&gt;</code></p>

<p>Triangulate polygonal facets of a mesh using a prescribed set of rules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>Polygonal mesh to triangulate in place.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>

<!-- HTML header for doxygen 1.9.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lagrange: lagrange::internal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Lagrange
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacelagrange_1_1internal.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">lagrange::internal Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>nullptr_t, size_t, ptrdiff_t basic_ostream bad_weak_ptr extent, remove_extent, is_array, is_void, common_type move, forward, swap  
<a href="namespacelagrange_1_1internal.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1internal_1_1_bucket_sort_offset.html">BucketSortOffset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket sort offset infos.  <a href="structlagrange_1_1internal_1_1_bucket_sort_offset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1internal_1_1_bucket_sort_result.html">BucketSortResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket sort result object.  <a href="structlagrange_1_1internal_1_1_bucket_sort_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1control__block.html">control_block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOT implemented: custom allocator support.  <a href="classlagrange_1_1internal_1_1control__block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1control__block__base.html">control_block_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1default__delete.html">default_delete</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1default__delete_3_01_t_0f_0e_4.html">default_delete&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1internal_1_1_map_attributes_options.html">MapAttributesOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> mapping options.  <a href="structlagrange_1_1internal_1_1_map_attributes_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1ptr.html">ptr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOT implemented: custom allocator support.  <a href="classlagrange_1_1internal_1_1shared__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr__access.html">shared_ptr_access</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr__access_3_01_t_00_01false_00_01true_01_4.html">shared_ptr_access&lt; T, false, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr__access_3_01_t_00_01true_00_01false_01_4.html">shared_ptr_access&lt; T, true, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1internal_1_1_skinning_extract_n_result.html">SkinningExtractNResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1weak__ptr.html">weak_ptr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad55f96a0a38571fab295b3dcfa5ccaac"><td class="memItemLeft" align="right" valign="top"><a id="ad55f96a0a38571fab295b3dcfa5ccaac" name="ad55f96a0a38571fab295b3dcfa5ccaac"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>ResetToDefault</b> { <b>Yes</b>
, <b>No</b>
 }</td></tr>
<tr class="separator:ad55f96a0a38571fab295b3dcfa5ccaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1094c838f626d32cbbd591b269c17aba"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a1094c838f626d32cbbd591b269c17aba">to_string</a> (<a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> element)</td></tr>
<tr class="memdesc:a1094c838f626d32cbbd591b269c17aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of an attribute element type.  <a href="namespacelagrange_1_1internal.html#a1094c838f626d32cbbd591b269c17aba">More...</a><br /></td></tr>
<tr class="separator:a1094c838f626d32cbbd591b269c17aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf501173c662983dbe2e4436cd90f35"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a1bf501173c662983dbe2e4436cd90f35">to_string</a> (<a class="el" href="classlagrange_1_1_bit_field.html">BitField</a>&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; element)</td></tr>
<tr class="memdesc:a1bf501173c662983dbe2e4436cd90f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of an attribute element type.  <a href="namespacelagrange_1_1internal.html#a1bf501173c662983dbe2e4436cd90f35">More...</a><br /></td></tr>
<tr class="separator:a1bf501173c662983dbe2e4436cd90f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ef58c4f14fd3da88c3ddfb8541c1fb"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#ad1ef58c4f14fd3da88c3ddfb8541c1fb">to_string</a> (<a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> usage)</td></tr>
<tr class="memdesc:ad1ef58c4f14fd3da88c3ddfb8541c1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of an attribute usage.  <a href="namespacelagrange_1_1internal.html#ad1ef58c4f14fd3da88c3ddfb8541c1fb">More...</a><br /></td></tr>
<tr class="separator:ad1ef58c4f14fd3da88c3ddfb8541c1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365755bee2e12743525ba9d78a556c09"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a365755bee2e12743525ba9d78a556c09"><td class="memTemplItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a365755bee2e12743525ba9d78a556c09">value_type_name</a> (const <a class="el" href="classlagrange_1_1_attribute.html">lagrange::Attribute</a>&lt; ValueType &gt; &amp;attr)</td></tr>
<tr class="memdesc:a365755bee2e12743525ba9d78a556c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of the attribute value type.  <a href="namespacelagrange_1_1internal.html#a365755bee2e12743525ba9d78a556c09">More...</a><br /></td></tr>
<tr class="separator:a365755bee2e12743525ba9d78a556c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252940a1c11ea835592d9e6d1952c868"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a252940a1c11ea835592d9e6d1952c868"><td class="memTemplItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a252940a1c11ea835592d9e6d1952c868">value_type_name</a> ()</td></tr>
<tr class="memdesc:a252940a1c11ea835592d9e6d1952c868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of the attribute value type.  <a href="namespacelagrange_1_1internal.html#a252940a1c11ea835592d9e6d1952c868">More...</a><br /></td></tr>
<tr class="separator:a252940a1c11ea835592d9e6d1952c868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b9d17084e2958faea52fd3672dea5f"><td class="memTemplParams" colspan="2"><a id="a10b9d17084e2958faea52fd3672dea5f" name="a10b9d17084e2958faea52fd3672dea5f"></a>
template&lt;typename DerivedF , typename DerivedFF , typename DerivedC &gt; </td></tr>
<tr class="memitem:a10b9d17084e2958faea52fd3672dea5f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bfs_orient</b> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;FF, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="separator:a10b9d17084e2958faea52fd3672dea5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318ef64371a044ade0e7bf035cd67490"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a318ef64371a044ade0e7bf035cd67490"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a318ef64371a044ade0e7bf035cd67490">dijkstra</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; seed_vertices, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar &gt; seed_vertex_dist, Scalar radius, const <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; Scalar(Index, Index)&gt; &amp;dist, const <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; bool(Index, Scalar)&gt; &amp;process)</td></tr>
<tr class="memdesc:a318ef64371a044ade0e7bf035cd67490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the mesh based on Dijkstra's algorithm with customized distance metric and process functions.  <a href="namespacelagrange_1_1internal.html#a318ef64371a044ade0e7bf035cd67490">More...</a><br /></td></tr>
<tr class="separator:a318ef64371a044ade0e7bf035cd67490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938e5aaf48b8f05271ca164e6d329bfb"><td class="memTemplParams" colspan="2"><a id="a938e5aaf48b8f05271ca164e6d329bfb" name="a938e5aaf48b8f05271ca164e6d329bfb"></a>
template&lt;typename DerivedV , typename DerivedF , typename DeriveddblA &gt; </td></tr>
<tr class="memitem:a938e5aaf48b8f05271ca164e6d329bfb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>doublearea</b> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DeriveddblA &gt; &amp;dblA)</td></tr>
<tr class="separator:a938e5aaf48b8f05271ca164e6d329bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5d3bb97af070a81d6a1d624fce12af"><td class="memTemplParams" colspan="2">template&lt;typename ExpectedValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:aae5d3bb97af070a81d6a1d624fce12af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#aae5d3bb97af070a81d6a1d624fce12af">find_matching_attribute</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view name, <a class="el" href="classlagrange_1_1_bit_field.html">BitField</a>&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; expected_element, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> expected_usage, size_t expected_channels)</td></tr>
<tr class="memdesc:aae5d3bb97af070a81d6a1d624fce12af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an attribute with a given name, ensuring the usage and element type match an expected target.  <a href="namespacelagrange_1_1internal.html#aae5d3bb97af070a81d6a1d624fce12af">More...</a><br /></td></tr>
<tr class="separator:aae5d3bb97af070a81d6a1d624fce12af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8107009117bbde794f9885c9b11c29d8"><td class="memTemplParams" colspan="2">template&lt;typename ExpectedValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a8107009117bbde794f9885c9b11c29d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a8107009117bbde794f9885c9b11c29d8">find_matching_attribute</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> &gt; selected_ids, <a class="el" href="classlagrange_1_1_bit_field.html">BitField</a>&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; expected_element, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> expected_usage, size_t expected_channels)</td></tr>
<tr class="memdesc:a8107009117bbde794f9885c9b11c29d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an attribute from a selected set of ids, ensuring the usage and element type match an expected target.  <a href="namespacelagrange_1_1internal.html#a8107009117bbde794f9885c9b11c29d8">More...</a><br /></td></tr>
<tr class="separator:a8107009117bbde794f9885c9b11c29d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e449214cdb7a7f4c42a69d9eb718483"><td class="memTemplParams" colspan="2">template&lt;typename ExpectedValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a4e449214cdb7a7f4c42a69d9eb718483"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a4e449214cdb7a7f4c42a69d9eb718483">find_attribute</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view name, <a class="el" href="classlagrange_1_1_bit_field.html">BitField</a>&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; expected_element, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> expected_usage, size_t expected_channels)</td></tr>
<tr class="memdesc:a4e449214cdb7a7f4c42a69d9eb718483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an attribute with a given name, ensuring the usage and element type match an expected target.  <a href="namespacelagrange_1_1internal.html#a4e449214cdb7a7f4c42a69d9eb718483">More...</a><br /></td></tr>
<tr class="separator:a4e449214cdb7a7f4c42a69d9eb718483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcff88ab81e30f4cd399e5fd3fb2ab2"><td class="memTemplParams" colspan="2">template&lt;typename ExpectedValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:adbcff88ab81e30f4cd399e5fd3fb2ab2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#adbcff88ab81e30f4cd399e5fd3fb2ab2">find_or_create_attribute</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> expected_element, <a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a> expected_usage, size_t expected_channels, ResetToDefault reset_tag)</td></tr>
<tr class="memdesc:adbcff88ab81e30f4cd399e5fd3fb2ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either retrieve or create an attribute with a prescribed name, element type and usage.  <a href="namespacelagrange_1_1internal.html#adbcff88ab81e30f4cd399e5fd3fb2ab2">More...</a><br /></td></tr>
<tr class="separator:adbcff88ab81e30f4cd399e5fd3fb2ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8b8c95bd1fe5343f763045a81314ee"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedK &gt; </td></tr>
<tr class="memitem:a8d8b8c95bd1fe5343f763045a81314ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a8d8b8c95bd1fe5343f763045a81314ee">internal_angles</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;vertices, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;facets, Eigen::PlainObjectBase&lt; DerivedK &gt; &amp;angles)</td></tr>
<tr class="memdesc:a8d8b8c95bd1fe5343f763045a81314ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute internal angles for a triangle mesh.  <a href="namespacelagrange_1_1internal.html#a8d8b8c95bd1fe5343f763045a81314ee">More...</a><br /></td></tr>
<tr class="separator:a8d8b8c95bd1fe5343f763045a81314ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816e515c3b9d808526087b1c58b37fdd"><td class="memTemplParams" colspan="2">template&lt;typename Index , typename Function &gt; </td></tr>
<tr class="memitem:a816e515c3b9d808526087b1c58b37fdd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a816e515c3b9d808526087b1c58b37fdd">invert_mapping</a> (Index num_source_entries, Function old2new, Index num_target_entries) -&gt; std::tuple&lt; std::vector&lt; Index &gt;, std::vector&lt; Index &gt; &gt;</td></tr>
<tr class="memdesc:a816e515c3b9d808526087b1c58b37fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the target-to-source (i.e.  <a href="namespacelagrange_1_1internal.html#a816e515c3b9d808526087b1c58b37fdd">More...</a><br /></td></tr>
<tr class="separator:a816e515c3b9d808526087b1c58b37fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483149cef61e7cd6355dd8e90055d297"><td class="memTemplParams" colspan="2">template&lt;typename Index &gt; </td></tr>
<tr class="memitem:a483149cef61e7cd6355dd8e90055d297"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a483149cef61e7cd6355dd8e90055d297">invert_mapping</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; Index &gt; old2new, Index num_target_entries) -&gt; std::tuple&lt; std::vector&lt; Index &gt;, std::vector&lt; Index &gt; &gt;</td></tr>
<tr class="memdesc:a483149cef61e7cd6355dd8e90055d297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the target-to-source (i.e.  <a href="namespacelagrange_1_1internal.html#a483149cef61e7cd6355dd8e90055d297">More...</a><br /></td></tr>
<tr class="separator:a483149cef61e7cd6355dd8e90055d297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef57d47fd036494daf8bf23f015dd07"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> element, typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:aaef57d47fd036494daf8bf23f015dd07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#aaef57d47fd036494daf8bf23f015dd07">map_attributes</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;source_mesh, <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;target_mesh, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; mapping_data, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; mapping_offsets={}, const <a class="el" href="structlagrange_1_1internal_1_1_map_attributes_options.html">MapAttributesOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:aaef57d47fd036494daf8bf23f015dd07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map attributes from the source mesh to the target mesh.  <a href="namespacelagrange_1_1internal.html#aaef57d47fd036494daf8bf23f015dd07">More...</a><br /></td></tr>
<tr class="separator:aaef57d47fd036494daf8bf23f015dd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d6dc48e6ba95a80b253104e1e86b79"><td class="memTemplParams" colspan="2"><a id="aa7d6dc48e6ba95a80b253104e1e86b79" name="aa7d6dc48e6ba95a80b253104e1e86b79"></a>
template&lt;typename DerivedF , typename DerivedC , typename AScalar &gt; </td></tr>
<tr class="memitem:aa7d6dc48e6ba95a80b253104e1e86b79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>orientable_patches</b> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::SparseMatrix&lt; AScalar &gt; &amp;A)</td></tr>
<tr class="separator:aa7d6dc48e6ba95a80b253104e1e86b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff7d9e150e94dda90548aa05385e452"><td class="memTemplParams" colspan="2"><a id="afff7d9e150e94dda90548aa05385e452" name="afff7d9e150e94dda90548aa05385e452"></a>
template&lt;typename DerivedF , typename DerivedC &gt; </td></tr>
<tr class="memitem:afff7d9e150e94dda90548aa05385e452"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>orientable_patches</b> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="separator:afff7d9e150e94dda90548aa05385e452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ef256275abbacbafd29fa49b709b7f"><td class="memTemplParams" colspan="2"><a id="aa6ef256275abbacbafd29fa49b709b7f" name="aa6ef256275abbacbafd29fa49b709b7f"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:aa6ef256275abbacbafd29fa49b709b7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_shared</b> (<a class="el" href="struct_args.html">Args</a> &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa6ef256275abbacbafd29fa49b709b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html" title="NOT implemented: custom allocator support.">shared_ptr</a> that manages a new object. <br /></td></tr>
<tr class="separator:aa6ef256275abbacbafd29fa49b709b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a2d82ae6bd886c1ccdfa48800adda4"><td class="memTemplParams" colspan="2"><a id="a69a2d82ae6bd886c1ccdfa48800adda4" name="a69a2d82ae6bd886c1ccdfa48800adda4"></a>
template&lt;typename T , typename A , typename... Args&gt; </td></tr>
<tr class="memitem:a69a2d82ae6bd886c1ccdfa48800adda4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>allocate_shared</b> (const A &amp;a, <a class="el" href="struct_args.html">Args</a> &amp;&amp;... args)=delete</td></tr>
<tr class="separator:a69a2d82ae6bd886c1ccdfa48800adda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6ff2092bf65397167b911826620b54"><td class="memTemplParams" colspan="2"><a id="a5d6ff2092bf65397167b911826620b54" name="a5d6ff2092bf65397167b911826620b54"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a5d6ff2092bf65397167b911826620b54"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;sp1, const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;sp2)</td></tr>
<tr class="memdesc:a5d6ff2092bf65397167b911826620b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator == overloading. <br /></td></tr>
<tr class="separator:a5d6ff2092bf65397167b911826620b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1fe61b4c1498a92635a5a96e4da71b"><td class="memTemplParams" colspan="2"><a id="a5c1fe61b4c1498a92635a5a96e4da71b" name="a5c1fe61b4c1498a92635a5a96e4da71b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5c1fe61b4c1498a92635a5a96e4da71b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;sp, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a5c1fe61b4c1498a92635a5a96e4da71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf34475f57f5126a9c7b5a3cb3298f25"><td class="memTemplParams" colspan="2"><a id="abf34475f57f5126a9c7b5a3cb3298f25" name="abf34475f57f5126a9c7b5a3cb3298f25"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf34475f57f5126a9c7b5a3cb3298f25"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (std::nullptr_t, const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;sp) noexcept</td></tr>
<tr class="separator:abf34475f57f5126a9c7b5a3cb3298f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad286172613b604c97dc3eac1e22538c0"><td class="memTemplParams" colspan="2"><a id="ad286172613b604c97dc3eac1e22538c0" name="ad286172613b604c97dc3eac1e22538c0"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad286172613b604c97dc3eac1e22538c0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;sp1, const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;sp2)</td></tr>
<tr class="memdesc:ad286172613b604c97dc3eac1e22538c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator != overloading. <br /></td></tr>
<tr class="separator:ad286172613b604c97dc3eac1e22538c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac522af40e076026b37c1c5ae27bd3c8c"><td class="memTemplParams" colspan="2"><a id="ac522af40e076026b37c1c5ae27bd3c8c" name="ac522af40e076026b37c1c5ae27bd3c8c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac522af40e076026b37c1c5ae27bd3c8c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;sp, std::nullptr_t) noexcept</td></tr>
<tr class="separator:ac522af40e076026b37c1c5ae27bd3c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c9ecf520b3f14073b546cfb607b080"><td class="memTemplParams" colspan="2"><a id="a87c9ecf520b3f14073b546cfb607b080" name="a87c9ecf520b3f14073b546cfb607b080"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87c9ecf520b3f14073b546cfb607b080"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (std::nullptr_t, const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;sp) noexcept</td></tr>
<tr class="separator:a87c9ecf520b3f14073b546cfb607b080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9df441af1caf6ddb6771a0a2851526"><td class="memTemplParams" colspan="2"><a id="a6f9df441af1caf6ddb6771a0a2851526" name="a6f9df441af1caf6ddb6771a0a2851526"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f9df441af1caf6ddb6771a0a2851526"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;sp1, <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;sp2)</td></tr>
<tr class="memdesc:a6f9df441af1caf6ddb6771a0a2851526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps with another <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html" title="NOT implemented: custom allocator support.">shared_ptr</a>. <br /></td></tr>
<tr class="separator:a6f9df441af1caf6ddb6771a0a2851526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e01dbc9f23d09dbff7b70dac858d96a"><td class="memTemplParams" colspan="2"><a id="a3e01dbc9f23d09dbff7b70dac858d96a" name="a3e01dbc9f23d09dbff7b70dac858d96a"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a3e01dbc9f23d09dbff7b70dac858d96a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>static_pointer_cast</b> (const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;sp) noexcept</td></tr>
<tr class="separator:a3e01dbc9f23d09dbff7b70dac858d96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0610600e6629138228f38045235aaa69"><td class="memTemplParams" colspan="2"><a id="a0610600e6629138228f38045235aaa69" name="a0610600e6629138228f38045235aaa69"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a0610600e6629138228f38045235aaa69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>const_pointer_cast</b> (const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;sp) noexcept</td></tr>
<tr class="separator:a0610600e6629138228f38045235aaa69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5a8760dc1fa4d7ab9e8a711e574f43"><td class="memTemplParams" colspan="2"><a id="abf5a8760dc1fa4d7ab9e8a711e574f43" name="abf5a8760dc1fa4d7ab9e8a711e574f43"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:abf5a8760dc1fa4d7ab9e8a711e574f43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dynamic_pointer_cast</b> (const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;sp) noexcept</td></tr>
<tr class="separator:abf5a8760dc1fa4d7ab9e8a711e574f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ff4ffab03ba87fe8403901d3158547"><td class="memTemplParams" colspan="2"><a id="ae7ff4ffab03ba87fe8403901d3158547" name="ae7ff4ffab03ba87fe8403901d3158547"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae7ff4ffab03ba87fe8403901d3158547"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reinterpret_pointer_cast</b> (const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;sp) noexcept</td></tr>
<tr class="separator:ae7ff4ffab03ba87fe8403901d3158547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ed27ffdac1ef37d73e3cb10116f9b5"><td class="memTemplParams" colspan="2"><a id="a54ed27ffdac1ef37d73e3cb10116f9b5" name="a54ed27ffdac1ef37d73e3cb10116f9b5"></a>
template&lt;class E , class T , class Y &gt; </td></tr>
<tr class="memitem:a54ed27ffdac1ef37d73e3cb10116f9b5"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; E, T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::basic_ostream&lt; E, T &gt; &amp;os, const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;sp)</td></tr>
<tr class="separator:a54ed27ffdac1ef37d73e3cb10116f9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3203c9baec9499bfcd349e84e4a7534"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ae3203c9baec9499bfcd349e84e4a7534"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#ae3203c9baec9499bfcd349e84e4a7534">skinning_deform</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const <a class="el" href="classlagrange_1_1_attribute.html">lagrange::Attribute</a>&lt; Scalar &gt; &amp;original_vertices, const std::vector&lt; Eigen::Transform&lt; Scalar, 3, Eigen::TransformTraits::Affine &gt; &gt; &amp;transforms, const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;weights, const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;weight_complement={})</td></tr>
<tr class="memdesc:ae3203c9baec9499bfcd349e84e4a7534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs linear blend skinning deformation on a mesh.  <a href="namespacelagrange_1_1internal.html#ae3203c9baec9499bfcd349e84e4a7534">More...</a><br /></td></tr>
<tr class="separator:ae3203c9baec9499bfcd349e84e4a7534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cd42255b49f9172ae11da3f73ad534"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:aa2cd42255b49f9172ae11da3f73ad534"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#aa2cd42255b49f9172ae11da3f73ad534">skinning_deform</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const <a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; Scalar &gt; &amp;original_vertices, const std::vector&lt; Eigen::Transform&lt; Scalar, 3, Eigen::TransformTraits::Affine &gt; &gt; &amp;transforms)</td></tr>
<tr class="memdesc:aa2cd42255b49f9172ae11da3f73ad534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs linear blend skinning on a mesh, using weights information from the mesh attributes.  <a href="namespacelagrange_1_1internal.html#aa2cd42255b49f9172ae11da3f73ad534">More...</a><br /></td></tr>
<tr class="separator:aa2cd42255b49f9172ae11da3f73ad534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3930134555d556f0e0865b5b0a5f75"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:afd3930134555d556f0e0865b5b0a5f75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1internal_1_1_skinning_extract_n_result.html">SkinningExtractNResult</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#afd3930134555d556f0e0865b5b0a5f75">skinning_extract_n</a> (const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;weights, int n, const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;weight_complement=Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;())</td></tr>
<tr class="memdesc:afd3930134555d556f0e0865b5b0a5f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">From a weight matrix |V| x |H|, constructs a weight matrix |V| x n, where n is an arbitrary contraint (typically 4 or 8).  <a href="namespacelagrange_1_1internal.html#afd3930134555d556f0e0865b5b0a5f75">More...</a><br /></td></tr>
<tr class="separator:afd3930134555d556f0e0865b5b0a5f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee42324f5d5b6765bcfe4ee7f489a9c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index , typename WeightScalar  = Scalar&gt; </td></tr>
<tr class="memitem:a0ee42324f5d5b6765bcfe4ee7f489a9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">lagrange::AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a0ee42324f5d5b6765bcfe4ee7f489a9c">weights_to_mesh_attribute</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const Eigen::Matrix&lt; WeightScalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;weights)</td></tr>
<tr class="memdesc:a0ee42324f5d5b6765bcfe4ee7f489a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports the weights matrix as weight attributes of the mesh.  <a href="namespacelagrange_1_1internal.html#a0ee42324f5d5b6765bcfe4ee7f489a9c">More...</a><br /></td></tr>
<tr class="separator:a0ee42324f5d5b6765bcfe4ee7f489a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780b468767386d3739edd17f56008b88"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index , typename WeightScalar  = Scalar, typename WeightIndex  = Index&gt; </td></tr>
<tr class="memitem:a780b468767386d3739edd17f56008b88"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">lagrange::AttributeId</a>, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">lagrange::AttributeId</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a780b468767386d3739edd17f56008b88">weights_to_indexed_mesh_attribute</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const Eigen::Matrix&lt; WeightScalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;weights, int n)</td></tr>
<tr class="memdesc:a780b468767386d3739edd17f56008b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports the weights matrix as indexed weight attributes of the mesh.  <a href="namespacelagrange_1_1internal.html#a780b468767386d3739edd17f56008b88">More...</a><br /></td></tr>
<tr class="separator:a780b468767386d3739edd17f56008b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b2216e320f870d0f296a22637ce7a5"><td class="memTemplParams" colspan="2"><a id="aa2b2216e320f870d0f296a22637ce7a5" name="aa2b2216e320f870d0f296a22637ce7a5"></a>
template&lt;typename DerivedX , typename DerivedIX &gt; </td></tr>
<tr class="memitem:aa2b2216e320f870d0f296a22637ce7a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sortrows</b> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const bool ascending, Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;Y, Eigen::PlainObjectBase&lt; DerivedIX &gt; &amp;IX)</td></tr>
<tr class="separator:aa2b2216e320f870d0f296a22637ce7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23470163b5873880ae388a9ac065bbad"><td class="memTemplParams" colspan="2"><a id="a23470163b5873880ae388a9ac065bbad" name="a23470163b5873880ae388a9ac065bbad"></a>
template&lt;typename DerivedX &gt; </td></tr>
<tr class="memitem:a23470163b5873880ae388a9ac065bbad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sortrows</b> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const bool ascending, Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;Y)</td></tr>
<tr class="separator:a23470163b5873880ae388a9ac065bbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2557ea7a3130377e7bd3d96f199bbe72"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a2557ea7a3130377e7bd3d96f199bbe72"><td class="memTemplItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a2557ea7a3130377e7bd3d96f199bbe72">string_from_scalar</a> ()</td></tr>
<tr class="memdesc:a2557ea7a3130377e7bd3d96f199bbe72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a human-readable string from any supported attribute value type.  <a href="namespacelagrange_1_1internal.html#a2557ea7a3130377e7bd3d96f199bbe72">More...</a><br /></td></tr>
<tr class="separator:a2557ea7a3130377e7bd3d96f199bbe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe26af952d8bb3b8cc5dad9fbe582042"><td class="memTemplParams" colspan="2"><a id="abe26af952d8bb3b8cc5dad9fbe582042" name="abe26af952d8bb3b8cc5dad9fbe582042"></a>
template&lt;typename DerivedA , typename DerivedC , typename DerivedIA , typename DerivedIC &gt; </td></tr>
<tr class="memitem:abe26af952d8bb3b8cc5dad9fbe582042"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unique_rows</b> (const Eigen::DenseBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedIA &gt; &amp;IA, Eigen::PlainObjectBase&lt; DerivedIC &gt; &amp;IC)</td></tr>
<tr class="separator:abe26af952d8bb3b8cc5dad9fbe582042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc7ff9ea5d4816d945ff0ad80d70a44"><td class="memTemplParams" colspan="2"><a id="a8bc7ff9ea5d4816d945ff0ad80d70a44" name="a8bc7ff9ea5d4816d945ff0ad80d70a44"></a>
template&lt;typename DerivedA , typename DerivedC , typename Derivedcounts &gt; </td></tr>
<tr class="memitem:a8bc7ff9ea5d4816d945ff0ad80d70a44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vertex_components</b> (const Eigen::SparseCompressedBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; Derivedcounts &gt; &amp;counts)</td></tr>
<tr class="separator:a8bc7ff9ea5d4816d945ff0ad80d70a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d103bf5417f9c49aac164e7b0e18863"><td class="memTemplParams" colspan="2"><a id="a0d103bf5417f9c49aac164e7b0e18863" name="a0d103bf5417f9c49aac164e7b0e18863"></a>
template&lt;typename DerivedA , typename DerivedC &gt; </td></tr>
<tr class="memitem:a0d103bf5417f9c49aac164e7b0e18863"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vertex_components</b> (const Eigen::SparseCompressedBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="separator:a0d103bf5417f9c49aac164e7b0e18863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e3c2a0f0e48b6de37e69608dd62ece"><td class="memTemplParams" colspan="2"><a id="aa7e3c2a0f0e48b6de37e69608dd62ece" name="aa7e3c2a0f0e48b6de37e69608dd62ece"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa7e3c2a0f0e48b6de37e69608dd62ece"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classlagrange_1_1internal_1_1weak__ptr.html">weak_ptr</a>&lt; T &gt; &amp;wp1, <a class="el" href="classlagrange_1_1internal_1_1weak__ptr.html">weak_ptr</a>&lt; T &gt; &amp;wp2)</td></tr>
<tr class="memdesc:aa7e3c2a0f0e48b6de37e69608dd62ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps with another <a class="el" href="classlagrange_1_1internal_1_1weak__ptr.html">weak_ptr</a>. <br /></td></tr>
<tr class="separator:aa7e3c2a0f0e48b6de37e69608dd62ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad476d3f6a2e97576948cbeb2d7d4f269"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:ad476d3f6a2e97576948cbeb2d7d4f269"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#ad476d3f6a2e97576948cbeb2d7d4f269">compute_triangle_areas</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh) -&gt; AttributeArrayOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;</td></tr>
<tr class="memdesc:ad476d3f6a2e97576948cbeb2d7d4f269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the triangle areas.  <a href="namespacelagrange_1_1internal.html#ad476d3f6a2e97576948cbeb2d7d4f269">More...</a><br /></td></tr>
<tr class="separator:ad476d3f6a2e97576948cbeb2d7d4f269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18efc9f6e2bdf77c1b85bc5c3794edd1"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a18efc9f6e2bdf77c1b85bc5c3794edd1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a18efc9f6e2bdf77c1b85bc5c3794edd1">compute_quad_areas</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh) -&gt; AttributeArrayOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;</td></tr>
<tr class="memdesc:a18efc9f6e2bdf77c1b85bc5c3794edd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the quad areas.  <a href="namespacelagrange_1_1internal.html#a18efc9f6e2bdf77c1b85bc5c3794edd1">More...</a><br /></td></tr>
<tr class="separator:a18efc9f6e2bdf77c1b85bc5c3794edd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1913ecb96655b3d75c05d2814d01e8d"><td class="memItemLeft" align="right" valign="top"><a id="ac1913ecb96655b3d75c05d2814d01e8d" name="ac1913ecb96655b3d75c05d2814d01e8d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>point_on_segment_2d</b> (Eigen::Vector2d p, Eigen::Vector2d a, Eigen::Vector2d b)</td></tr>
<tr class="separator:ac1913ecb96655b3d75c05d2814d01e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736a015927ef32c48b086e91011056a5"><td class="memItemLeft" align="right" valign="top"><a id="a736a015927ef32c48b086e91011056a5" name="a736a015927ef32c48b086e91011056a5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>point_on_segment_3d</b> (Eigen::Vector3d p, Eigen::Vector3d a, Eigen::Vector3d b)</td></tr>
<tr class="separator:a736a015927ef32c48b086e91011056a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a49ab6f672c04f4f72e198181a887c"><td class="memTemplParams" colspan="2">template&lt;typename Index &gt; </td></tr>
<tr class="memitem:a87a49ab6f672c04f4f72e198181a887c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1internal_1_1_bucket_sort_result.html">BucketSortResult</a>&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a87a49ab6f672c04f4f72e198181a887c">bucket_sort</a> (<a class="el" href="classlagrange_1_1_disjoint_sets.html">DisjointSets</a>&lt; Index &gt; &amp;unified_indices, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; Index &gt; element_representative)</td></tr>
<tr class="memdesc:a87a49ab6f672c04f4f72e198181a887c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a bucket sort over a range of elements.  <a href="namespacelagrange_1_1internal.html#a87a49ab6f672c04f4f72e198181a887c">More...</a><br /></td></tr>
<tr class="separator:a87a49ab6f672c04f4f72e198181a887c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c60561ca55faebfa701db5f3c0100c2"><td class="memTemplParams" colspan="2">template&lt;typename Index , typename Function &gt; </td></tr>
<tr class="memitem:a9c60561ca55faebfa701db5f3c0100c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1internal_1_1_bucket_sort_offset.html">BucketSortOffset</a>&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a9c60561ca55faebfa701db5f3c0100c2">bucket_sort</a> (std::vector&lt; Index &gt; &amp;elements, Index num_buckets, Function get_representative)</td></tr>
<tr class="memdesc:a9c60561ca55faebfa701db5f3c0100c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a bucket sort over a range of elements in place.  <a href="namespacelagrange_1_1internal.html#a9c60561ca55faebfa701db5f3c0100c2">More...</a><br /></td></tr>
<tr class="separator:a9c60561ca55faebfa701db5f3c0100c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425b6670a3b7465f0b6a712b35f91b7c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a425b6670a3b7465f0b6a712b35f91b7c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, 3, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a425b6670a3b7465f0b6a712b35f91b7c">compute_weighted_corner_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Index ci, <a class="el" href="group__group-surfacemesh-utils.html#gaa88e833ed770762b02e187f0c2377d3d">NormalWeightingType</a> weighting=<a class="el" href="group__group-surfacemesh-utils.html#ggaa88e833ed770762b02e187f0c2377d3da84f023fc44b6b158de6ccc157c8dab06">NormalWeightingType::CornerTriangleArea</a>)</td></tr>
<tr class="memdesc:a425b6670a3b7465f0b6a712b35f91b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute weighted corner normal based on the weighting type.  <a href="namespacelagrange_1_1internal.html#a425b6670a3b7465f0b6a712b35f91b7c">More...</a><br /></td></tr>
<tr class="separator:a425b6670a3b7465f0b6a712b35f91b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c5d2a9463c0ede0593a8c564e0e58a"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a37c5d2a9463c0ede0593a8c564e0e58a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a37c5d2a9463c0ede0593a8c564e0e58a">recompute_facet_normal_if_needed</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view facet_normal_attribute_name, bool recompute_facet_normals)</td></tr>
<tr class="memdesc:a37c5d2a9463c0ede0593a8c564e0e58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute facet normal attribute if necessary or as requested.  <a href="namespacelagrange_1_1internal.html#a37c5d2a9463c0ede0593a8c564e0e58a">More...</a><br /></td></tr>
<tr class="separator:a37c5d2a9463c0ede0593a8c564e0e58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ad6c926e4a0aa8b443685e2b183b78"><td class="memTemplParams" colspan="2"><a id="af5ad6c926e4a0aa8b443685e2b183b78" name="af5ad6c926e4a0aa8b443685e2b183b78"></a>
template&lt;typename ValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:af5ad6c926e4a0aa8b443685e2b183b78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>weld_indexed_attribute</b> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> attr_id, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; bool(Index, Index)&gt; equal)</td></tr>
<tr class="separator:af5ad6c926e4a0aa8b443685e2b183b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >nullptr_t, size_t, ptrdiff_t basic_ostream bad_weak_ptr extent, remove_extent, is_array, is_void, common_type move, forward, swap </p>
<p >This file contains commonly used functions related to skinning deformation on a mesh.</p>
<p ><code>skinning_deform</code> deforms a mesh with weights.</p>
<p ><code>skinning_extract_n</code> takes a weight matrix |V| x |H| and outputs indexed weights, up to n per vertex.</p>
<p ><code>weights_to_mesh_attribute</code> and <code>weights_to_indexed_mesh_attribute</code> save a weights matrix as attributes. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a1094c838f626d32cbbd591b269c17aba" name="a1094c838f626d32cbbd591b269c17aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1094c838f626d32cbbd591b269c17aba">&#9670;&nbsp;</a></span>to_string() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a>&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of an attribute element type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> element type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String representation. </dd></dl>

</div>
</div>
<a id="a1bf501173c662983dbe2e4436cd90f35" name="a1bf501173c662983dbe2e4436cd90f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf501173c662983dbe2e4436cd90f35">&#9670;&nbsp;</a></span>to_string() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_bit_field.html">BitField</a>&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of an attribute element type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> element type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String representation. </dd></dl>

</div>
</div>
<a id="ad1ef58c4f14fd3da88c3ddfb8541c1fb" name="ad1ef58c4f14fd3da88c3ddfb8541c1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ef58c4f14fd3da88c3ddfb8541c1fb">&#9670;&nbsp;</a></span>to_string() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of an attribute usage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">usage</td><td><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> usage.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String representation. </dd></dl>

</div>
</div>
<a id="a365755bee2e12743525ba9d78a556c09" name="a365755bee2e12743525ba9d78a556c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365755bee2e12743525ba9d78a556c09">&#9670;&nbsp;</a></span>value_type_name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view value_type_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_attribute.html">lagrange::Attribute</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of the attribute value type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>Input attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> value type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String representation. </dd></dl>

</div>
</div>
<a id="a252940a1c11ea835592d9e6d1952c868" name="a252940a1c11ea835592d9e6d1952c868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252940a1c11ea835592d9e6d1952c868">&#9670;&nbsp;</a></span>value_type_name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view value_type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of the attribute value type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> value type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String representation. </dd></dl>

</div>
</div>
<a id="a318ef64371a044ade0e7bf035cd67490" name="a318ef64371a044ade0e7bf035cd67490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318ef64371a044ade0e7bf035cd67490">&#9670;&nbsp;</a></span>dijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dijkstra </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt;&#160;</td>
          <td class="paramname"><em>seed_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar &gt;&#160;</td>
          <td class="paramname"><em>seed_vertex_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; Scalar(Index, Index)&gt; &amp;&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; bool(Index, Scalar)&gt; &amp;&#160;</td>
          <td class="paramname"><em>process</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse the mesh based on Dijkstra's algorithm with customized distance metric and process functions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramname">seed_vertices</td><td>Seed vertices. </td></tr>
    <tr><td class="paramname">seed_vertex_dist</td><td>Initial distance to the seed vertices. </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of the search. Radius &lt;= 0 denotes the search is over the entire mesh. </td></tr>
    <tr><td class="paramname">dist</td><td>The distance metric. e.g. <code>d = dist(v0, v1)</code> </td></tr>
    <tr><td class="paramname">process</td><td>Call back function to process each new vertex reached. Its return type indicates whether the search is done. e.g. <code>done = process(vid, v_dist)</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae5d3bb97af070a81d6a1d624fce12af" name="aae5d3bb97af070a81d6a1d624fce12af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5d3bb97af070a81d6a1d624fce12af">&#9670;&nbsp;</a></span>find_matching_attribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> find_matching_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_bit_field.html">BitField</a>&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt;&#160;</td>
          <td class="paramname"><em>expected_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>expected_usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expected_channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an attribute with a given name, ensuring the usage and element type match an expected target. </p>
<p >If the provided name is empty, the first attribute with matching properties is returned. If no such attribute is found, <a class="el" href="group__group-surfacemesh-attr.html#gaaf6e674ed673001dca1c6390bc0e0fc9" title="Invalid attribute id.">invalid_attribute_id()</a> is returned instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> where to look for attributes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Optional name of the attribute to find. If empty, the first matching attribute id will be returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_element</td><td>Expected element type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_usage</td><td>Expected attribute usage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_channels</td><td>Expected number of channels. If 0, then the check is skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpectedValueType</td><td>Expected attribute value type. </td></tr>
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> id of the first matching attribute. </dd></dl>

</div>
</div>
<a id="a8107009117bbde794f9885c9b11c29d8" name="a8107009117bbde794f9885c9b11c29d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8107009117bbde794f9885c9b11c29d8">&#9670;&nbsp;</a></span>find_matching_attribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> find_matching_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> &gt;&#160;</td>
          <td class="paramname"><em>selected_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_bit_field.html">BitField</a>&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt;&#160;</td>
          <td class="paramname"><em>expected_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>expected_usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expected_channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an attribute from a selected set of ids, ensuring the usage and element type match an expected target. </p>
<p >If the provided <code>selected_ids</code> is empty, it will search all attributes. Otherwise, only attributes corresponding to <code>selected_ids</code> are searched. The first attribute with matching properties is returned. If no such attribute is found, <a class="el" href="group__group-surfacemesh-attr.html#gaaf6e674ed673001dca1c6390bc0e0fc9" title="Invalid attribute id.">invalid_attribute_id()</a> is returned instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> where to look for attributes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">selected_ids</td><td>Selected attribute ids. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_element</td><td>Expected element type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_usage</td><td>Expected attribute usage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_channels</td><td>Expected number of channels. If 0, then the check is skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpectedValueType</td><td>Expected attribute value type. </td></tr>
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> id of the first matching attribute. </dd></dl>

</div>
</div>
<a id="a4e449214cdb7a7f4c42a69d9eb718483" name="a4e449214cdb7a7f4c42a69d9eb718483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e449214cdb7a7f4c42a69d9eb718483">&#9670;&nbsp;</a></span>find_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> find_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_bit_field.html">BitField</a>&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt;&#160;</td>
          <td class="paramname"><em>expected_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>expected_usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expected_channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an attribute with a given name, ensuring the usage and element type match an expected target. </p>
<p >This function does not allow empty names to be provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> where to look for attributes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the attribute to find. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_element</td><td>Expected element type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_usage</td><td>Expected attribute usage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_channels</td><td>Expected number of channels. If 0, then the check is skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpectedValueType</td><td>Expected attribute value type. </td></tr>
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> id of the first matching attribute. </dd></dl>

</div>
</div>
<a id="adbcff88ab81e30f4cd399e5fd3fb2ab2" name="adbcff88ab81e30f4cd399e5fd3fb2ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcff88ab81e30f4cd399e5fd3fb2ab2">&#9670;&nbsp;</a></span>find_or_create_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> find_or_create_attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a>&#160;</td>
          <td class="paramname"><em>expected_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga5a2f28c8b9e2f8fce6e70b2418c46e45">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>expected_usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expected_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResetToDefault&#160;</td>
          <td class="paramname"><em>reset_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either retrieve or create an attribute with a prescribed name, element type and usage. </p>
<p >When retrieving an existing attribute, this function performs additional sanity checks, such as ensuring that the attribute usage is correctly set, that the number of channels is correct, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> whose attribute to retrieve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the attribute to retrieve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_element</td><td>Expected element type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_usage</td><td>Expected attribute usage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_channels</td><td>Expected number of channels. If 0, then the check is skipped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reset_tag</td><td>Whether to reset attribute values to default (if attribute is not created).</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpectedValueType</td><td>Expected attribute value type. </td></tr>
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> id for the retrieved attribute. </dd></dl>

</div>
</div>
<a id="a8d8b8c95bd1fe5343f763045a81314ee" name="a8d8b8c95bd1fe5343f763045a81314ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8b8c95bd1fe5343f763045a81314ee">&#9670;&nbsp;</a></span>internal_angles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void internal_angles </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedK &gt; &amp;&#160;</td>
          <td class="paramname"><em>angles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute internal angles for a triangle mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>#vertices by dim Eigen matrix of mesh vertex nD positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facets</td><td>#facets by 3 eigen Matrix of face (triangle) indices, </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">angles</td><td>#facets by 3 eigen Matrix of internal angles for triangles, columns correspond to edges [1,2],[2,0],[0,1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>Vertices matrix type. </td></tr>
    <tr><td class="paramname">DerivedF</td><td>Facets matrix type. </td></tr>
    <tr><td class="paramname">DerivedK</td><td>Angles matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a816e515c3b9d808526087b1c58b37fdd" name="a816e515c3b9d808526087b1c58b37fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816e515c3b9d808526087b1c58b37fdd">&#9670;&nbsp;</a></span>invert_mapping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto invert_mapping </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>num_source_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>old2new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>num_target_entries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::tuple&lt;std::vector&lt;Index&gt;, std::vector&lt;Index&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the target-to-source (i.e. </p>
<p >backward) mapping from an input source-to-target (i.e. forward) mapping.</p>
<dl class="section note"><dt>Note</dt><dd>The input source-to-target mapping may be a 1-to-many mapping, where multiple source elements may be mapped to a single target element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_source_entries</td><td>The number source entries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old2new</td><td>Source-to-target mapping function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_target_entries</td><td>The total number of target elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>The index type. </td></tr>
    <tr><td class="paramname">Function</td><td>Mapping function type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The target-to-source mapping, which is a tuple consists of 2 index arrays, mapping_data and mapping_offsets.</dd></dl>
<p><code>mapping_data</code> is a flat array of indices of the source elements. <code>mapping_offsets</code> is an array of <code>mapping_data</code> offset indices. It is of size <code>num_target_entires + 1</code>. Target element <code>i</code> is mapped to source elements with index in the range from <code>mapping_data[mapping_offsets[i]]</code> to <code>mapping_data[mapping_offsets[i+1]]</code>. </p>

</div>
</div>
<a id="a483149cef61e7cd6355dd8e90055d297" name="a483149cef61e7cd6355dd8e90055d297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483149cef61e7cd6355dd8e90055d297">&#9670;&nbsp;</a></span>invert_mapping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto invert_mapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; Index &gt;&#160;</td>
          <td class="paramname"><em>old2new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>num_target_entries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::tuple&lt;std::vector&lt;Index&gt;, std::vector&lt;Index&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the target-to-source (i.e. </p>
<p >backward) mapping from an input source-to-target (i.e. forward) mapping.</p>
<dl class="section note"><dt>Note</dt><dd>The input source-to-target mapping may be a 1-to-many mapping, where multiple source elements may be mapped to a single target element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">old2new</td><td>Source-to-target mapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_target_entries</td><td>The total number of target elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>The index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The target-to-source mapping, which is a tuple consists of 2 index arrays, mapping_data and mapping_offsets.</dd></dl>
<p><code>mapping_data</code> is a flat array of indices of the source elements. <code>mapping_offsets</code> is an array of <code>mapping_data</code> offset indices. It is of size <code>num_target_entires + 1</code>. Target element <code>i</code> is mapped to source elements with index in the range from <code>mapping_data[mapping_offsets[i]]</code> to <code>mapping_data[mapping_offsets[i+1]]</code>.</p>
<p >This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aaef57d47fd036494daf8bf23f015dd07" name="aaef57d47fd036494daf8bf23f015dd07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef57d47fd036494daf8bf23f015dd07">&#9670;&nbsp;</a></span>map_attributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void map_attributes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>source_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt;&#160;</td>
          <td class="paramname"><em>mapping_offsets</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1internal_1_1_map_attributes_options.html">MapAttributesOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map attributes from the source mesh to the target mesh. </p>
<p >This is the most general version that supports many-to-many mapping. Collision policy settings in <code>options</code> define the behavior when multiple source vertices are mapped to the same target vertex.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td>The index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_mesh</td><td>The source mesh. </td></tr>
    <tr><td class="paramname">target_mesh</td><td>The target mesh. </td></tr>
    <tr><td class="paramname">mapping_data</td><td>A flat array of source element indices. </td></tr>
    <tr><td class="paramname">mapping_offsets</td><td>The offset index array into the <code>mapping_data</code>. Source element with index listed from <code>mapping_data[mapping_offset[i]]</code> to <code>mapping_data[mapping_offset[i+1]]</code> are mapped to target element <code>i</code>. If empty, source element with index <code>mapping_data[i]</code> is mapped to target element <code>i</code>. </td></tr>
    <tr><td class="paramname">options</td><td>Option settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structlagrange_1_1internal_1_1_map_attributes_options.html" title="Attribute mapping options.">MapAttributesOptions</a></code>. </dd></dl>

</div>
</div>
<a id="ae3203c9baec9499bfcd349e84e4a7534" name="ae3203c9baec9499bfcd349e84e4a7534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3203c9baec9499bfcd349e84e4a7534">&#9670;&nbsp;</a></span>skinning_deform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void skinning_deform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_attribute.html">lagrange::Attribute</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>original_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Transform&lt; Scalar, 3, Eigen::TransformTraits::Affine &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>transforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>weight_complement</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs linear blend skinning deformation on a mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>vertices of this mesh will be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">original_vertices</td><td>original positions of vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transforms</td><td>vector of eigen affine transforms, describe the global movement of each handle/joint </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>|V| x |handle| weight matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight_complement</td><td>optional, acts as weights for an extra handle that does not move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2cd42255b49f9172ae11da3f73ad534" name="aa2cd42255b49f9172ae11da3f73ad534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cd42255b49f9172ae11da3f73ad534">&#9670;&nbsp;</a></span>skinning_deform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void skinning_deform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>original_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Transform&lt; Scalar, 3, Eigen::TransformTraits::Affine &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>transforms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs linear blend skinning on a mesh, using weights information from the mesh attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>vertices of this mesh will be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">original_vertices</td><td>original positions of vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transforms</td><td>vector of eigen affine transforms, describe the global movement of each handle/joint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd3930134555d556f0e0865b5b0a5f75" name="afd3930134555d556f0e0865b5b0a5f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3930134555d556f0e0865b5b0a5f75">&#9670;&nbsp;</a></span>skinning_extract_n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlagrange_1_1internal_1_1_skinning_extract_n_result.html">SkinningExtractNResult</a>&lt; Scalar, Index &gt; skinning_extract_n </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>weight_complement</em> = <code>Eigen::Matrix&lt;Scalar,&#160;Eigen::Dynamic,&#160;1&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From a weight matrix |V| x |H|, constructs a weight matrix |V| x n, where n is an arbitrary contraint (typically 4 or 8). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>|V| x |handle| weight matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>max number of weights for each vertex </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight_complement</td><td>optional, acts as weights for an extra handle that does not move.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>|V| x n weights and |V| x n indices (see struct above). </dd></dl>

</div>
</div>
<a id="a0ee42324f5d5b6765bcfe4ee7f489a9c" name="a0ee42324f5d5b6765bcfe4ee7f489a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee42324f5d5b6765bcfe4ee7f489a9c">&#9670;&nbsp;</a></span>weights_to_mesh_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">lagrange::AttributeId</a> weights_to_mesh_attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; WeightScalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imports the weights matrix as weight attributes of the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> to modify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>weights matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new weights attribute id </dd></dl>

</div>
</div>
<a id="a780b468767386d3739edd17f56008b88" name="a780b468767386d3739edd17f56008b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780b468767386d3739edd17f56008b88">&#9670;&nbsp;</a></span>weights_to_indexed_mesh_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">lagrange::AttributeId</a>, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">lagrange::AttributeId</a> &gt; weights_to_indexed_mesh_attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; WeightScalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imports the weights matrix as indexed weight attributes of the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> to modify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>Weights matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>max weights per vertex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of new attribute ids: index and weight </dd></dl>

</div>
</div>
<a id="a2557ea7a3130377e7bd3d96f199bbe72" name="a2557ea7a3130377e7bd3d96f199bbe72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2557ea7a3130377e7bd3d96f199bbe72">&#9670;&nbsp;</a></span>string_from_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view string_from_scalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a human-readable string from any supported attribute value type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Can be any supported attribute value type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A human-readable string view of the type name. </dd></dl>

</div>
</div>
<a id="ad476d3f6a2e97576948cbeb2d7d4f269" name="ad476d3f6a2e97576948cbeb2d7d4f269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad476d3f6a2e97576948cbeb2d7d4f269">&#9670;&nbsp;</a></span>compute_triangle_areas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto compute_triangle_areas </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> -&gt; AttributeArrayOf&lt;<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the triangle areas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Input triangle mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#F x 1 array of triangle areas. </dd></dl>

</div>
</div>
<a id="a18efc9f6e2bdf77c1b85bc5c3794edd1" name="a18efc9f6e2bdf77c1b85bc5c3794edd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18efc9f6e2bdf77c1b85bc5c3794edd1">&#9670;&nbsp;</a></span>compute_quad_areas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto compute_quad_areas </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> -&gt; AttributeArrayOf&lt;<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the quad areas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Input quad mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#F x 1 array of quad areas. </dd></dl>

</div>
</div>
<a id="a87a49ab6f672c04f4f72e198181a887c" name="a87a49ab6f672c04f4f72e198181a887c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a49ab6f672c04f4f72e198181a887c">&#9670;&nbsp;</a></span>bucket_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlagrange_1_1internal_1_1_bucket_sort_result.html">BucketSortResult</a>&lt; Index &gt; bucket_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_disjoint_sets.html">DisjointSets</a>&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>unified_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; Index &gt;&#160;</td>
          <td class="paramname"><em>element_representative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a bucket sort over a range of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">unified_indices</td><td>Disjoint sets covering the range of elements to sort. Due to path compression in the disjoint sets' find() method, this argument is not const. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">element_representative</td><td>Output buffer storing the representative index for each element in the range. Typically this will be the index buffer of a target indexed attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Index type to sort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bucket sort result containing a list of sorted element indices and an offset for each representative element. </dd></dl>

</div>
</div>
<a id="a9c60561ca55faebfa701db5f3c0100c2" name="a9c60561ca55faebfa701db5f3c0100c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c60561ca55faebfa701db5f3c0100c2">&#9670;&nbsp;</a></span>bucket_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlagrange_1_1internal_1_1_bucket_sort_offset.html">BucketSortOffset</a>&lt; Index &gt; bucket_sort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>num_buckets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>get_representative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a bucket sort over a range of elements in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">elements</td><td>Elements to sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_buckets</td><td>Number of buckets (max element in the range + 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">get_representative</td><td>Function to get the representative bucket for a given element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Index type. </td></tr>
    <tr><td class="paramname">Function</td><td>Callback function type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Info about the sorted buckets. </dd></dl>

</div>
</div>
<a id="a425b6670a3b7465f0b6a712b35f91b7c" name="a425b6670a3b7465f0b6a712b35f91b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425b6670a3b7465f0b6a712b35f91b7c">&#9670;&nbsp;</a></span>compute_weighted_corner_normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; Scalar, 3, 1 &gt; compute_weighted_corner_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>ci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-utils.html#gaa88e833ed770762b02e187f0c2377d3d">NormalWeightingType</a>&#160;</td>
          <td class="paramname"><em>weighting</em> = <code><a class="el" href="group__group-surfacemesh-utils.html#ggaa88e833ed770762b02e187f0c2377d3da84f023fc44b6b158de6ccc157c8dab06">NormalWeightingType::CornerTriangleArea</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute weighted corner normal based on the weighting type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ci</td><td>The target corner index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weighting</td><td>The weighting type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the weighted normal vector corresponding to the target corner. </dd></dl>

</div>
</div>
<a id="a37c5d2a9463c0ede0593a8c564e0e58a" name="a37c5d2a9463c0ede0593a8c564e0e58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c5d2a9463c0ede0593a8c564e0e58a">&#9670;&nbsp;</a></span>recompute_facet_normal_if_needed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto recompute_facet_normal_if_needed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>facet_normal_attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recompute_facet_normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute facet normal attribute if necessary or as requested. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramname">facet_normal_attribute_name</td><td>The facet normal attribute name. </td></tr>
    <tr><td class="paramname">recompute_facet_normals</td><td>Whether to recompute facet normals if one already exists.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of the facet normal attribute id and a boolean indicating whether the facet </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelagrange.html">lagrange</a></li><li class="navelem"><a class="el" href="namespacelagrange_1_1internal.html">internal</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>

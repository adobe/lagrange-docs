<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lagrange: EmbreeRayCaster&lt; ScalarType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lagrange
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelagrange.html">lagrange</a></li><li class="navelem"><a class="el" href="namespacelagrange_1_1raycasting.html">raycasting</a></li><li class="navelem"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html">EmbreeRayCaster</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classlagrange_1_1raycasting_1_1_embree_ray_caster-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">EmbreeRayCaster&lt; ScalarType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A wrapper for Embree's raycasting API to compute ray intersections with (instances of) meshes.  
 <a href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_embree_ray_caster_8h_source.html">lagrange/raycasting/EmbreeRayCaster.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a84e9b844fb562b2576cc8d2810d48b16"><td class="memItemLeft" align="right" valign="top"><a id="a84e9b844fb562b2576cc8d2810d48b16" name="a84e9b844fb562b2576cc8d2810d48b16"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Scalar</b> = ScalarType</td></tr>
<tr class="separator:a84e9b844fb562b2576cc8d2810d48b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fee9506a74ca0b951fdc7f92f98bea6"><td class="memItemLeft" align="right" valign="top"><a id="a7fee9506a74ca0b951fdc7f92f98bea6" name="a7fee9506a74ca0b951fdc7f92f98bea6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Transform</b> = Eigen::Matrix&lt; Scalar, 4, 4 &gt;</td></tr>
<tr class="separator:a7fee9506a74ca0b951fdc7f92f98bea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e710d7c4eedc8fba4f5029e91559adc"><td class="memItemLeft" align="right" valign="top"><a id="a3e710d7c4eedc8fba4f5029e91559adc" name="a3e710d7c4eedc8fba4f5029e91559adc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Point</b> = Eigen::Matrix&lt; Scalar, 3, 1 &gt;</td></tr>
<tr class="separator:a3e710d7c4eedc8fba4f5029e91559adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77986726b03bfa3170a2ea6060e51247"><td class="memItemLeft" align="right" valign="top"><a id="a77986726b03bfa3170a2ea6060e51247" name="a77986726b03bfa3170a2ea6060e51247"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Direction</b> = Eigen::Matrix&lt; Scalar, 3, 1 &gt;</td></tr>
<tr class="separator:a77986726b03bfa3170a2ea6060e51247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7179da0c33f39912b509687002fd28"><td class="memItemLeft" align="right" valign="top"><a id="abc7179da0c33f39912b509687002fd28" name="abc7179da0c33f39912b509687002fd28"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Index</b> = size_t</td></tr>
<tr class="separator:abc7179da0c33f39912b509687002fd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053efe7d4eaecbc7f5b581ec6ff9f1fe"><td class="memItemLeft" align="right" valign="top"><a id="a053efe7d4eaecbc7f5b581ec6ff9f1fe" name="a053efe7d4eaecbc7f5b581ec6ff9f1fe"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ClosestPoint</b> = <a class="el" href="structlagrange_1_1raycasting_1_1_closest_point_result.html">ClosestPointResult</a>&lt; Scalar &gt;</td></tr>
<tr class="separator:a053efe7d4eaecbc7f5b581ec6ff9f1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23545443caa1638a3d750edf3bb2ce5"><td class="memItemLeft" align="right" valign="top"><a id="af23545443caa1638a3d750edf3bb2ce5" name="af23545443caa1638a3d750edf3bb2ce5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TransformVector</b> = std::vector&lt; Transform &gt;</td></tr>
<tr class="separator:af23545443caa1638a3d750edf3bb2ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f77adbfe76f67cc6ff56888afe3ccd"><td class="memItemLeft" align="right" valign="top"><a id="a92f77adbfe76f67cc6ff56888afe3ccd" name="a92f77adbfe76f67cc6ff56888afe3ccd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Point4</b> = Eigen::Matrix&lt; Scalar, 4, 3 &gt;</td></tr>
<tr class="separator:a92f77adbfe76f67cc6ff56888afe3ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f231a3c942b36a01683509b9ec3900"><td class="memItemLeft" align="right" valign="top"><a id="a73f231a3c942b36a01683509b9ec3900" name="a73f231a3c942b36a01683509b9ec3900"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Direction4</b> = Eigen::Matrix&lt; Scalar, 4, 3 &gt;</td></tr>
<tr class="separator:a73f231a3c942b36a01683509b9ec3900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c669e2e3e726be5034b5759892c14da"><td class="memItemLeft" align="right" valign="top"><a id="a5c669e2e3e726be5034b5759892c14da" name="a5c669e2e3e726be5034b5759892c14da"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Index4</b> = Eigen::Matrix&lt; size_t, 4, 1 &gt;</td></tr>
<tr class="separator:a5c669e2e3e726be5034b5759892c14da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008f8492b7ed7fc6bd98ae501e5c974e"><td class="memItemLeft" align="right" valign="top"><a id="a008f8492b7ed7fc6bd98ae501e5c974e" name="a008f8492b7ed7fc6bd98ae501e5c974e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Scalar4</b> = Eigen::Matrix&lt; Scalar, 4, 1 &gt;</td></tr>
<tr class="separator:a008f8492b7ed7fc6bd98ae501e5c974e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac677736a4627755b1b6b70907776b00e"><td class="memItemLeft" align="right" valign="top"><a id="ac677736a4627755b1b6b70907776b00e" name="ac677736a4627755b1b6b70907776b00e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Mask4</b> = Eigen::Matrix&lt; std::int32_t, 4, 1 &gt;</td></tr>
<tr class="separator:ac677736a4627755b1b6b70907776b00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911e965d01d9a38df03e573b2d635bbd"><td class="memItemLeft" align="right" valign="top"><a id="a911e965d01d9a38df03e573b2d635bbd" name="a911e965d01d9a38df03e573b2d635bbd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FloatData</b> = std::vector&lt; float &gt;</td></tr>
<tr class="separator:a911e965d01d9a38df03e573b2d635bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff760205d87779ee1a2ab0d118ec2cd6"><td class="memItemLeft" align="right" valign="top"><a id="aff760205d87779ee1a2ab0d118ec2cd6" name="aff760205d87779ee1a2ab0d118ec2cd6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IntData</b> = std::vector&lt; unsigned &gt;</td></tr>
<tr class="separator:aff760205d87779ee1a2ab0d118ec2cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f3adb3c6dc669144af2cf7b7c4a2f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ad7f3adb3c6dc669144af2cf7b7c4a2f7">FilterFunction</a> = std::function&lt; void(const <a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html">EmbreeRayCaster</a> *obj, const Index *mesh_index, const Index *instance_index, const RTCFilterFunctionNArguments *args)&gt;</td></tr>
<tr class="memdesc:ad7f3adb3c6dc669144af2cf7b7c4a2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for a hit filter function.  <a href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ad7f3adb3c6dc669144af2cf7b7c4a2f7">More...</a><br /></td></tr>
<tr class="separator:ad7f3adb3c6dc669144af2cf7b7c4a2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab3221c3d429d0073beaf6c3d2c26ef39"><td class="memItemLeft" align="right" valign="top"><a id="ab3221c3d429d0073beaf6c3d2c26ef39" name="ab3221c3d429d0073beaf6c3d2c26ef39"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EmbreeRayCaster</b> (RTCSceneFlags scene_flags=RTC_SCENE_FLAG_DYNAMIC, RTCBuildQuality build_quality=RTC_BUILD_QUALITY_LOW)</td></tr>
<tr class="memdesc:ab3221c3d429d0073beaf6c3d2c26ef39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:ab3221c3d429d0073beaf6c3d2c26ef39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483d2ac55ed7a139a407b0ee4b9eb4d3"><td class="memItemLeft" align="right" valign="top"><a id="a483d2ac55ed7a139a407b0ee4b9eb4d3" name="a483d2ac55ed7a139a407b0ee4b9eb4d3"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~EmbreeRayCaster</b> ()</td></tr>
<tr class="memdesc:a483d2ac55ed7a139a407b0ee4b9eb4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a483d2ac55ed7a139a407b0ee4b9eb4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb59c4a61b58d9850433b2a1ae38c341"><td class="memItemLeft" align="right" valign="top"><a id="afb59c4a61b58d9850433b2a1ae38c341" name="afb59c4a61b58d9850433b2a1ae38c341"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EmbreeRayCaster</b> (const <a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html">EmbreeRayCaster</a> &amp;)=delete</td></tr>
<tr class="separator:afb59c4a61b58d9850433b2a1ae38c341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36db56a6eb6a80edee04fbb11ea25cd5"><td class="memItemLeft" align="right" valign="top"><a id="a36db56a6eb6a80edee04fbb11ea25cd5" name="a36db56a6eb6a80edee04fbb11ea25cd5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html">EmbreeRayCaster</a> &amp;)=delete</td></tr>
<tr class="separator:a36db56a6eb6a80edee04fbb11ea25cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd127aea96bf2a7f9e56b7f54e23b81"><td class="memItemLeft" align="right" valign="top"><a id="acdd127aea96bf2a7f9e56b7f54e23b81" name="acdd127aea96bf2a7f9e56b7f54e23b81"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_meshes</b> () const</td></tr>
<tr class="memdesc:acdd127aea96bf2a7f9e56b7f54e23b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of meshes (not instances). <br /></td></tr>
<tr class="separator:acdd127aea96bf2a7f9e56b7f54e23b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f344510185a0fa5bb7c897d30375e2b"><td class="memItemLeft" align="right" valign="top"><a id="a7f344510185a0fa5bb7c897d30375e2b" name="a7f344510185a0fa5bb7c897d30375e2b"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_instances</b> () const</td></tr>
<tr class="memdesc:a7f344510185a0fa5bb7c897d30375e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of mesh instances. <br /></td></tr>
<tr class="separator:a7f344510185a0fa5bb7c897d30375e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2675bbad5adeffccffac66f35b98ba44"><td class="memItemLeft" align="right" valign="top"><a id="a2675bbad5adeffccffac66f35b98ba44" name="a2675bbad5adeffccffac66f35b98ba44"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_instances</b> (Index mesh_index) const</td></tr>
<tr class="memdesc:a2675bbad5adeffccffac66f35b98ba44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of instances of a particular mesh. <br /></td></tr>
<tr class="separator:a2675bbad5adeffccffac66f35b98ba44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6046f94cb64566923bc812297c621f"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:aae6046f94cb64566923bc812297c621f"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#aae6046f94cb64566923bc812297c621f">get_mesh</a> (Index index) const</td></tr>
<tr class="memdesc:aae6046f94cb64566923bc812297c621f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mesh with a given index.  <a href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#aae6046f94cb64566923bc812297c621f">More...</a><br /></td></tr>
<tr class="separator:aae6046f94cb64566923bc812297c621f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa442cb8258daacd0013fce06c08b7cb"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#afa442cb8258daacd0013fce06c08b7cb">get_mesh_for_instance</a> (Index cumulative_instance_index) const</td></tr>
<tr class="memdesc:afa442cb8258daacd0013fce06c08b7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the mesh corresponding to a given instance, where the instances are indexed sequentially starting from the instances of the first mesh, then the instances of the second mesh, and so on.  <a href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#afa442cb8258daacd0013fce06c08b7cb">More...</a><br /></td></tr>
<tr class="separator:afa442cb8258daacd0013fce06c08b7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094888507f6f6296368eec468b98dda6"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a094888507f6f6296368eec468b98dda6"><td class="memTemplItemLeft" align="right" valign="top">Index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a094888507f6f6296368eec468b98dda6">add_mesh</a> (std::shared_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; mesh, const Transform &amp;trans=Transform::Identity(), RTCBuildQuality build_quality=RTC_BUILD_QUALITY_MEDIUM)</td></tr>
<tr class="memdesc:a094888507f6f6296368eec468b98dda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an instance of a mesh to the scene, with a given transformation.  <a href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a094888507f6f6296368eec468b98dda6">More...</a><br /></td></tr>
<tr class="separator:a094888507f6f6296368eec468b98dda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046d44f4d2e373b236c89b511c2c33de"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a046d44f4d2e373b236c89b511c2c33de"><td class="memTemplItemLeft" align="right" valign="top">Index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a046d44f4d2e373b236c89b511c2c33de">add_meshes</a> (std::shared_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; mesh, const TransformVector &amp;trans_vector, RTCBuildQuality build_quality=RTC_BUILD_QUALITY_MEDIUM)</td></tr>
<tr class="memdesc:a046d44f4d2e373b236c89b511c2c33de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add multiple instances of a single mesh to the scene, with given transformations.  <a href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a046d44f4d2e373b236c89b511c2c33de">More...</a><br /></td></tr>
<tr class="separator:a046d44f4d2e373b236c89b511c2c33de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cb39a00a5b09cef4a40a70b934d744"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a28cb39a00a5b09cef4a40a70b934d744"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a28cb39a00a5b09cef4a40a70b934d744">update_mesh</a> (Index index, std::shared_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; mesh, RTCBuildQuality build_quality=RTC_BUILD_QUALITY_MEDIUM)</td></tr>
<tr class="memdesc:a28cb39a00a5b09cef4a40a70b934d744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a particular mesh with a new mesh object.  <a href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a28cb39a00a5b09cef4a40a70b934d744">More...</a><br /></td></tr>
<tr class="separator:a28cb39a00a5b09cef4a40a70b934d744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709ae0324587579f07e49f842250b786"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a709ae0324587579f07e49f842250b786">update_mesh_vertices</a> (Index index)</td></tr>
<tr class="memdesc:a709ae0324587579f07e49f842250b786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the object to reflect external changes to the vertices of a particular mesh which is already in the scene.  <a href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a709ae0324587579f07e49f842250b786">More...</a><br /></td></tr>
<tr class="separator:a709ae0324587579f07e49f842250b786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae46a46cad76c524ae5b5fd94e804c0"><td class="memItemLeft" align="right" valign="top"><a id="adae46a46cad76c524ae5b5fd94e804c0" name="adae46a46cad76c524ae5b5fd94e804c0"></a>
Transform&#160;</td><td class="memItemRight" valign="bottom"><b>get_transform</b> (Index mesh_index, Index instance_index) const</td></tr>
<tr class="memdesc:adae46a46cad76c524ae5b5fd94e804c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transform applied to a given mesh instance. <br /></td></tr>
<tr class="separator:adae46a46cad76c524ae5b5fd94e804c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68088e87d790833d6049e803b9923ba3"><td class="memItemLeft" align="right" valign="top"><a id="a68088e87d790833d6049e803b9923ba3" name="a68088e87d790833d6049e803b9923ba3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_transformation</b> (Index mesh_index, Index instance_index, const Transform &amp;trans)</td></tr>
<tr class="memdesc:a68088e87d790833d6049e803b9923ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the transform applied to a given mesh instance. <br /></td></tr>
<tr class="separator:a68088e87d790833d6049e803b9923ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582a1102d7dba577a7a4f8e778b77e03"><td class="memItemLeft" align="right" valign="top"><a id="a582a1102d7dba577a7a4f8e778b77e03" name="a582a1102d7dba577a7a4f8e778b77e03"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_visibility</b> (Index mesh_index, Index instance_index) const</td></tr>
<tr class="memdesc:a582a1102d7dba577a7a4f8e778b77e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the visibility flag of a given mesh instance. <br /></td></tr>
<tr class="separator:a582a1102d7dba577a7a4f8e778b77e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ddf8fda06773cbdd7693b35ce6d8e7"><td class="memItemLeft" align="right" valign="top"><a id="ac3ddf8fda06773cbdd7693b35ce6d8e7" name="ac3ddf8fda06773cbdd7693b35ce6d8e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_visibility</b> (Index mesh_index, Index instance_index, bool visible)</td></tr>
<tr class="memdesc:ac3ddf8fda06773cbdd7693b35ce6d8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the visibility of a given mesh index (true for visible, false for invisible). <br /></td></tr>
<tr class="separator:ac3ddf8fda06773cbdd7693b35ce6d8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a95cd7335a030b92c3d0692392e64b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a2a95cd7335a030b92c3d0692392e64b3">set_intersection_filter</a> (Index mesh_index, <a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ad7f3adb3c6dc669144af2cf7b7c4a2f7">FilterFunction</a> filter)</td></tr>
<tr class="memdesc:a2a95cd7335a030b92c3d0692392e64b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an intersection filter that is called for every hit on (every instance of) a mesh during an intersection query.  <a href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a2a95cd7335a030b92c3d0692392e64b3">More...</a><br /></td></tr>
<tr class="separator:a2a95cd7335a030b92c3d0692392e64b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d43c64a54fedb7b3a286911f983216b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ad7f3adb3c6dc669144af2cf7b7c4a2f7">FilterFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a1d43c64a54fedb7b3a286911f983216b">get_intersection_filter</a> (Index mesh_index) const</td></tr>
<tr class="memdesc:a1d43c64a54fedb7b3a286911f983216b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the intersection filter function currently bound to a given mesh.  <a href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a1d43c64a54fedb7b3a286911f983216b">More...</a><br /></td></tr>
<tr class="separator:a1d43c64a54fedb7b3a286911f983216b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4611052074b210dac90dad251102c30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ac4611052074b210dac90dad251102c30">set_occlusion_filter</a> (Index mesh_index, <a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ad7f3adb3c6dc669144af2cf7b7c4a2f7">FilterFunction</a> filter)</td></tr>
<tr class="memdesc:ac4611052074b210dac90dad251102c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an occlusion filter that is called for every hit on (every instance of) a mesh during an occlusion query.  <a href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ac4611052074b210dac90dad251102c30">More...</a><br /></td></tr>
<tr class="separator:ac4611052074b210dac90dad251102c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94009d03d904690cc9f1f4a2d4559144"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ad7f3adb3c6dc669144af2cf7b7c4a2f7">FilterFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a94009d03d904690cc9f1f4a2d4559144">get_occlusion_filter</a> (Index mesh_index) const</td></tr>
<tr class="memdesc:a94009d03d904690cc9f1f4a2d4559144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the occlusion filter function currently bound to a given mesh.  <a href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a94009d03d904690cc9f1f4a2d4559144">More...</a><br /></td></tr>
<tr class="separator:a94009d03d904690cc9f1f4a2d4559144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f429768257565881f062d0de81c6b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ab3f429768257565881f062d0de81c6b2">commit_scene_changes</a> ()</td></tr>
<tr class="memdesc:ab3f429768257565881f062d0de81c6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <code>rtcCommitScene()</code> on the overall scene, if it has been marked as modified.  <a href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ab3f429768257565881f062d0de81c6b2">More...</a><br /></td></tr>
<tr class="separator:ab3f429768257565881f062d0de81c6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f8381e37f38a65e0d57f7519f96f6d"><td class="memItemLeft" align="right" valign="top"><a id="aa1f8381e37f38a65e0d57f7519f96f6d" name="aa1f8381e37f38a65e0d57f7519f96f6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ensure_no_errors</b> () const</td></tr>
<tr class="memdesc:aa1f8381e37f38a65e0d57f7519f96f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if an Embree error has occurred. <br /></td></tr>
<tr class="separator:aa1f8381e37f38a65e0d57f7519f96f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7106fc40cfae3b6ab06c04267ad08412"><td class="memItemLeft" align="right" valign="top"><a id="a7106fc40cfae3b6ab06c04267ad08412" name="a7106fc40cfae3b6ab06c04267ad08412"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>cast4</b> (uint32_t batch_size, const Point4 &amp;origin, const Direction4 &amp;direction, const Mask4 &amp;mask, Index4 &amp;mesh_index, Index4 &amp;instance_index, Index4 &amp;facet_index, Scalar4 &amp;ray_depth, Point4 &amp;barycentric_coord, Point4 &amp;normal, const Scalar4 &amp;tmin=Scalar4::Zero(), const Scalar4 &amp;tmax=Scalar4::Constant(std::numeric_limits&lt; Scalar &gt;::infinity()))</td></tr>
<tr class="memdesc:a7106fc40cfae3b6ab06c04267ad08412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a packet of up to 4 rays through the scene, returning full data of the closest intersections including normals and instance indices. <br /></td></tr>
<tr class="separator:a7106fc40cfae3b6ab06c04267ad08412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8b66d7de9b1f8aac68d76ae67970b7"><td class="memItemLeft" align="right" valign="top"><a id="a7b8b66d7de9b1f8aac68d76ae67970b7" name="a7b8b66d7de9b1f8aac68d76ae67970b7"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>cast4</b> (uint32_t batch_size, const Point4 &amp;origin, const Direction4 &amp;direction, const Mask4 &amp;mask, Index4 &amp;mesh_index, Index4 &amp;facet_index, Scalar4 &amp;ray_depth, Point4 &amp;barycentric_coord, const Scalar4 &amp;tmin=Scalar4::Zero(), const Scalar4 &amp;tmax=Scalar4::Constant(std::numeric_limits&lt; Scalar &gt;::infinity()))</td></tr>
<tr class="memdesc:a7b8b66d7de9b1f8aac68d76ae67970b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a packet of up to 4 rays through the scene, returning data of the closest intersections excluding normals and instance indices. <br /></td></tr>
<tr class="separator:a7b8b66d7de9b1f8aac68d76ae67970b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc6fc411e1e4e1f1982a7a44d373df6"><td class="memItemLeft" align="right" valign="top"><a id="a0dc6fc411e1e4e1f1982a7a44d373df6" name="a0dc6fc411e1e4e1f1982a7a44d373df6"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>cast4</b> (uint32_t batch_size, const Point4 &amp;origin, const Direction4 &amp;direction, const Mask4 &amp;mask, const Scalar4 &amp;tmin=Scalar4::Zero(), const Scalar4 &amp;tmax=Scalar4::Constant(std::numeric_limits&lt; Scalar &gt;::infinity()))</td></tr>
<tr class="memdesc:a0dc6fc411e1e4e1f1982a7a44d373df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a packet of up to 4 rays through the scene and check whether they hit anything or not. <br /></td></tr>
<tr class="separator:a0dc6fc411e1e4e1f1982a7a44d373df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43952b3aabf5fe0825046a835c69c417"><td class="memItemLeft" align="right" valign="top"><a id="a43952b3aabf5fe0825046a835c69c417" name="a43952b3aabf5fe0825046a835c69c417"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cast</b> (const Point &amp;origin, const Direction &amp;direction, Index &amp;mesh_index, Index &amp;instance_index, Index &amp;facet_index, Scalar &amp;ray_depth, Point &amp;barycentric_coord, Point &amp;normal, Scalar tmin=0, Scalar tmax=std::numeric_limits&lt; Scalar &gt;::infinity())</td></tr>
<tr class="memdesc:a43952b3aabf5fe0825046a835c69c417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a single ray through the scene, returning full data of the closest intersection including the normal and the instance index. <br /></td></tr>
<tr class="separator:a43952b3aabf5fe0825046a835c69c417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ef73a116d613b9a3e22441dd058eb0"><td class="memItemLeft" align="right" valign="top"><a id="a77ef73a116d613b9a3e22441dd058eb0" name="a77ef73a116d613b9a3e22441dd058eb0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cast</b> (const Point &amp;origin, const Direction &amp;direction, Index &amp;mesh_index, Index &amp;facet_index, Scalar &amp;ray_depth, Point &amp;barycentric_coord, Scalar tmin=0, Scalar tmax=std::numeric_limits&lt; Scalar &gt;::infinity())</td></tr>
<tr class="memdesc:a77ef73a116d613b9a3e22441dd058eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a single ray through the scene, returning data of the closest intersection excluding the normal and the instance index. <br /></td></tr>
<tr class="separator:a77ef73a116d613b9a3e22441dd058eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab483d8d3b129e5dfc1d39c482f21786a"><td class="memItemLeft" align="right" valign="top"><a id="ab483d8d3b129e5dfc1d39c482f21786a" name="ab483d8d3b129e5dfc1d39c482f21786a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cast</b> (const Point &amp;origin, const Direction &amp;direction, Scalar tmin=0, Scalar tmax=std::numeric_limits&lt; Scalar &gt;::infinity())</td></tr>
<tr class="memdesc:ab483d8d3b129e5dfc1d39c482f21786a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a single ray through the scene and check whether it hits anything or not. <br /></td></tr>
<tr class="separator:ab483d8d3b129e5dfc1d39c482f21786a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09062b95d27e1a948235b8f855a8a63"><td class="memItemLeft" align="right" valign="top"><a id="ac09062b95d27e1a948235b8f855a8a63" name="ac09062b95d27e1a948235b8f855a8a63"></a>
<a class="el" href="structlagrange_1_1raycasting_1_1_closest_point_result.html">ClosestPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>query_closest_point</b> (const Point &amp;p) const</td></tr>
<tr class="memdesc:ac09062b95d27e1a948235b8f855a8a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the underlying BVH to find the point closest to a query point. <br /></td></tr>
<tr class="separator:ac09062b95d27e1a948235b8f855a8a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5c440b3d4ca8ab8bafb068a0739f7bb7"><td class="memItemLeft" align="right" valign="top"><a id="a5c440b3d4ca8ab8bafb068a0739f7bb7" name="a5c440b3d4ca8ab8bafb068a0739f7bb7"></a>
virtual RTCSceneFlags&#160;</td><td class="memItemRight" valign="bottom"><b>get_scene_flags</b> () const</td></tr>
<tr class="memdesc:a5c440b3d4ca8ab8bafb068a0739f7bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Embree scene flags. <br /></td></tr>
<tr class="separator:a5c440b3d4ca8ab8bafb068a0739f7bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97310b4a41d3fef45d28f46146757550"><td class="memItemLeft" align="right" valign="top"><a id="a97310b4a41d3fef45d28f46146757550" name="a97310b4a41d3fef45d28f46146757550"></a>
virtual RTCBuildQuality&#160;</td><td class="memItemRight" valign="bottom"><b>get_scene_build_quality</b> () const</td></tr>
<tr class="memdesc:a97310b4a41d3fef45d28f46146757550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Embree geometry build quality. <br /></td></tr>
<tr class="separator:a97310b4a41d3fef45d28f46146757550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9197169586df2f668825a83a359cc2a3"><td class="memItemLeft" align="right" valign="top"><a id="a9197169586df2f668825a83a359cc2a3" name="a9197169586df2f668825a83a359cc2a3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_internal</b> ()</td></tr>
<tr class="memdesc:a9197169586df2f668825a83a359cc2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update all internal structures based on the current dirty flags. <br /></td></tr>
<tr class="separator:a9197169586df2f668825a83a359cc2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3f921b5e18d96abdd45cbc9564de6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a4c3f921b5e18d96abdd45cbc9564de6c">generate_scene</a> ()</td></tr>
<tr class="memdesc:a4c3f921b5e18d96abdd45cbc9564de6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the whole Embree scene from the specified meshes, instances, etc.  <a href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a4c3f921b5e18d96abdd45cbc9564de6c">More...</a><br /></td></tr>
<tr class="separator:a4c3f921b5e18d96abdd45cbc9564de6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677cb1c6755add458b91bb9bdc565192"><td class="memItemLeft" align="right" valign="top"><a id="a677cb1c6755add458b91bb9bdc565192" name="a677cb1c6755add458b91bb9bdc565192"></a>
const float *&#160;</td><td class="memItemRight" valign="bottom"><b>extract_float_data</b> (const <a class="el" href="classlagrange_1_1raycasting_1_1_raycaster_mesh.html">RaycasterMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:a677cb1c6755add458b91bb9bdc565192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vertex data of a mesh as an array of floats. <br /></td></tr>
<tr class="separator:a677cb1c6755add458b91bb9bdc565192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb50d64946302a4799a82778edaed1de"><td class="memItemLeft" align="right" valign="top"><a id="aeb50d64946302a4799a82778edaed1de" name="aeb50d64946302a4799a82778edaed1de"></a>
const unsigned *&#160;</td><td class="memItemRight" valign="bottom"><b>extract_int_data</b> (const <a class="el" href="classlagrange_1_1raycasting_1_1_raycaster_mesh.html">RaycasterMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:aeb50d64946302a4799a82778edaed1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index data of a mesh as an array of integers. <br /></td></tr>
<tr class="separator:aeb50d64946302a4799a82778edaed1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31edbb55ba862eeac94e9feb7e56b9f3"><td class="memItemLeft" align="right" valign="top"><a id="a31edbb55ba862eeac94e9feb7e56b9f3" name="a31edbb55ba862eeac94e9feb7e56b9f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ensure_no_errors_internal</b> () const</td></tr>
<tr class="separator:a31edbb55ba862eeac94e9feb7e56b9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a57694b4ef63cf0c358a70b92d79f4e81"><td class="memItemLeft" align="right" valign="top"><a id="a57694b4ef63cf0c358a70b92d79f4e81" name="a57694b4ef63cf0c358a70b92d79f4e81"></a>
RTCSceneFlags&#160;</td><td class="memItemRight" valign="bottom"><b>m_scene_flags</b></td></tr>
<tr class="separator:a57694b4ef63cf0c358a70b92d79f4e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bae67f0becd97ca35c1e5cec0f6ec34"><td class="memItemLeft" align="right" valign="top"><a id="a8bae67f0becd97ca35c1e5cec0f6ec34" name="a8bae67f0becd97ca35c1e5cec0f6ec34"></a>
RTCBuildQuality&#160;</td><td class="memItemRight" valign="bottom"><b>m_build_quality</b></td></tr>
<tr class="separator:a8bae67f0becd97ca35c1e5cec0f6ec34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac333238e2d253598cfdf1972c48736"><td class="memItemLeft" align="right" valign="top"><a id="aaac333238e2d253598cfdf1972c48736" name="aaac333238e2d253598cfdf1972c48736"></a>
RTCDevice&#160;</td><td class="memItemRight" valign="bottom"><b>m_device</b></td></tr>
<tr class="separator:aaac333238e2d253598cfdf1972c48736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49aaae30bf00fcece81ba9b26ab46b9e"><td class="memItemLeft" align="right" valign="top"><a id="a49aaae30bf00fcece81ba9b26ab46b9e" name="a49aaae30bf00fcece81ba9b26ab46b9e"></a>
RTCScene&#160;</td><td class="memItemRight" valign="bottom"><b>m_embree_world_scene</b></td></tr>
<tr class="separator:a49aaae30bf00fcece81ba9b26ab46b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4b0a57b9bf88f2c1a8ca5f06192753"><td class="memItemLeft" align="right" valign="top"><a id="acd4b0a57b9bf88f2c1a8ca5f06192753" name="acd4b0a57b9bf88f2c1a8ca5f06192753"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_need_rebuild</b></td></tr>
<tr class="separator:acd4b0a57b9bf88f2c1a8ca5f06192753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd90fc5b5e7159b5a50bd5934fccd7c"><td class="memItemLeft" align="right" valign="top"><a id="adbd90fc5b5e7159b5a50bd5934fccd7c" name="adbd90fc5b5e7159b5a50bd5934fccd7c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_need_commit</b></td></tr>
<tr class="separator:adbd90fc5b5e7159b5a50bd5934fccd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a210b20956af7953f0ac090cdc2d5e"><td class="memItemLeft" align="right" valign="top"><a id="aa1a210b20956af7953f0ac090cdc2d5e" name="aa1a210b20956af7953f0ac090cdc2d5e"></a>
std::vector&lt; FloatData &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_float_data</b></td></tr>
<tr class="separator:aa1a210b20956af7953f0ac090cdc2d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705a1bf1d46bfe5316ae16403b788416"><td class="memItemLeft" align="right" valign="top"><a id="a705a1bf1d46bfe5316ae16403b788416" name="a705a1bf1d46bfe5316ae16403b788416"></a>
std::vector&lt; IntData &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_int_data</b></td></tr>
<tr class="separator:a705a1bf1d46bfe5316ae16403b788416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d787abdcecf28bb43b28c7e202a50f"><td class="memItemLeft" align="right" valign="top"><a id="ab8d787abdcecf28bb43b28c7e202a50f" name="ab8d787abdcecf28bb43b28c7e202a50f"></a>
std::vector&lt; std::unique_ptr&lt; <a class="el" href="classlagrange_1_1raycasting_1_1_raycaster_mesh.html">RaycasterMesh</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_meshes</b></td></tr>
<tr class="separator:ab8d787abdcecf28bb43b28c7e202a50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867cf6cdaa57bc41ff1e6f9e678610bc"><td class="memItemLeft" align="right" valign="top"><a id="a867cf6cdaa57bc41ff1e6f9e678610bc" name="a867cf6cdaa57bc41ff1e6f9e678610bc"></a>
std::vector&lt; RTCBuildQuality &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_mesh_build_qualities</b></td></tr>
<tr class="separator:a867cf6cdaa57bc41ff1e6f9e678610bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c67de40c2dfb06ac8464cee9ca2fafe"><td class="memItemLeft" align="right" valign="top"><a id="a2c67de40c2dfb06ac8464cee9ca2fafe" name="a2c67de40c2dfb06ac8464cee9ca2fafe"></a>
std::vector&lt; RTCScene &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_embree_mesh_scenes</b></td></tr>
<tr class="separator:a2c67de40c2dfb06ac8464cee9ca2fafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3335fea2f72922a7ee819e7046c1ac91"><td class="memItemLeft" align="right" valign="top"><a id="a3335fea2f72922a7ee819e7046c1ac91" name="a3335fea2f72922a7ee819e7046c1ac91"></a>
std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_mesh_vertex_counts</b></td></tr>
<tr class="separator:a3335fea2f72922a7ee819e7046c1ac91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb63ee5e87328880cab493607ebeab22"><td class="memItemLeft" align="right" valign="top"><a id="afb63ee5e87328880cab493607ebeab22" name="afb63ee5e87328880cab493607ebeab22"></a>
std::vector&lt; <a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ad7f3adb3c6dc669144af2cf7b7c4a2f7">FilterFunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_filters</b> [2]</td></tr>
<tr class="separator:afb63ee5e87328880cab493607ebeab22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc2990446a512986b934bcc1925ab78"><td class="memItemLeft" align="right" valign="top"><a id="a3dc2990446a512986b934bcc1925ab78" name="a3dc2990446a512986b934bcc1925ab78"></a>
std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_instance_index_ranges</b></td></tr>
<tr class="separator:a3dc2990446a512986b934bcc1925ab78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764aad2a198394d68b1d377303ef59bd"><td class="memItemLeft" align="right" valign="top"><a id="a764aad2a198394d68b1d377303ef59bd" name="a764aad2a198394d68b1d377303ef59bd"></a>
std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_instance_to_user_mesh</b></td></tr>
<tr class="separator:a764aad2a198394d68b1d377303ef59bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a666028a932b8b29cae757da89a6f8f"><td class="memItemLeft" align="right" valign="top"><a id="a8a666028a932b8b29cae757da89a6f8f" name="a8a666028a932b8b29cae757da89a6f8f"></a>
std::vector&lt; Transform &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_transforms</b></td></tr>
<tr class="separator:a8a666028a932b8b29cae757da89a6f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dbcea9fa508aea8ac12ce4ee21d71e"><td class="memItemLeft" align="right" valign="top"><a id="a39dbcea9fa508aea8ac12ce4ee21d71e" name="a39dbcea9fa508aea8ac12ce4ee21d71e"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_visibility</b></td></tr>
<tr class="separator:a39dbcea9fa508aea8ac12ce4ee21d71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ScalarType&gt;<br />
class lagrange::raycasting::EmbreeRayCaster&lt; ScalarType &gt;</div><p >A wrapper for Embree's raycasting API to compute ray intersections with (instances of) meshes. </p>
<p >Supports intersection and occlusion queries on single rays and ray packets (currently only packets of size at most 4 are supported). Filters may be specified (per mesh, not per instance) to process each individual hit event during any of these queries. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad7f3adb3c6dc669144af2cf7b7c4a2f7" name="ad7f3adb3c6dc669144af2cf7b7c4a2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f3adb3c6dc669144af2cf7b7c4a2f7">&#9670;&nbsp;</a></span>FilterFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ad7f3adb3c6dc669144af2cf7b7c4a2f7">FilterFunction</a> =  std::function&lt;void( const <a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html">EmbreeRayCaster</a>* obj, const Index* mesh_index, const Index* instance_index, const RTCFilterFunctionNArguments* args)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface for a hit filter function. </p>
<p >Most information in <code>RTCFilterFunctionNArguments</code> maps directly to elements of the <a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html" title="A wrapper for Embree&#39;s raycasting API to compute ray intersections with (instances of) meshes.">EmbreeRayCaster</a> class, but the mesh and instance IDs need special conversion. <code>mesh_index</code> is an array of <code>args-&gt;N</code> <a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html" title="A wrapper for Embree&#39;s raycasting API to compute ray intersections with (instances of) meshes.">EmbreeRayCaster</a> mesh indices, and <code>instance_index</code> is an array of <code>args-&gt;N</code> <a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html" title="A wrapper for Embree&#39;s raycasting API to compute ray intersections with (instances of) meshes.">EmbreeRayCaster</a> instance indices, one for each ray/hit. For the other elements of <code>args</code>, the mappings are:</p>
<div class="fragment"><div class="line">facet_index &lt;-- primID</div>
<div class="line">ray_depth &lt;-- tfar</div>
<div class="line">barycentric_coord &lt;-- [u, v, 1 - u - v]</div>
<div class="line">normal &lt;-- Ng</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aae6046f94cb64566923bc812297c621f" name="aae6046f94cb64566923bc812297c621f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6046f94cb64566923bc812297c621f">&#9670;&nbsp;</a></span>get_mesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; get_mesh </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the mesh with a given index. </p>
<p >Requires the caller to know the original type of the mesh (<em>MeshType</em>) in advance. </p>

</div>
</div>
<a id="afa442cb8258daacd0013fce06c08b7cb" name="afa442cb8258daacd0013fce06c08b7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa442cb8258daacd0013fce06c08b7cb">&#9670;&nbsp;</a></span>get_mesh_for_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index get_mesh_for_instance </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>cumulative_instance_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index of the mesh corresponding to a given instance, where the instances are indexed sequentially starting from the instances of the first mesh, then the instances of the second mesh, and so on. </p>
<p >Use <a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#aae6046f94cb64566923bc812297c621f" title="Get the mesh with a given index.">get_mesh()</a> to map the returned index to an actual mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cumulative_instance_index</td><td>An integer in the range <code>0</code> to <code><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a7f344510185a0fa5bb7c897d30375e2b" title="Get the total number of mesh instances.">get_num_instances()</a> - 1</code> (both inclusive). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a094888507f6f6296368eec468b98dda6" name="a094888507f6f6296368eec468b98dda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094888507f6f6296368eec468b98dda6">&#9670;&nbsp;</a></span>add_mesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index add_mesh </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Transform &amp;&#160;</td>
          <td class="paramname"><em>trans</em> = <code>Transform::Identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTCBuildQuality&#160;</td>
          <td class="paramname"><em>build_quality</em> = <code>RTC_BUILD_QUALITY_MEDIUM</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an instance of a mesh to the scene, with a given transformation. </p>
<p >If another instance of the same mesh has been previously added to the scene, the two instances will NOT be considered to share the same mesh, but will be treated as separate instances of separate meshes. To add multiple instances of the same mesh, use <a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a046d44f4d2e373b236c89b511c2c33de" title="Add multiple instances of a single mesh to the scene, with given transformations.">add_meshes()</a>. </p>

</div>
</div>
<a id="a046d44f4d2e373b236c89b511c2c33de" name="a046d44f4d2e373b236c89b511c2c33de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046d44f4d2e373b236c89b511c2c33de">&#9670;&nbsp;</a></span>add_meshes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index add_meshes </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TransformVector &amp;&#160;</td>
          <td class="paramname"><em>trans_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTCBuildQuality&#160;</td>
          <td class="paramname"><em>build_quality</em> = <code>RTC_BUILD_QUALITY_MEDIUM</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add multiple instances of a single mesh to the scene, with given transformations. </p>
<p >If another instance of the same mesh has been previously added to the scene, the new instances will NOT be considered to share the same mesh as the old instance, but will be treated as instances of a new mesh. Add all instances in a single <a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a046d44f4d2e373b236c89b511c2c33de" title="Add multiple instances of a single mesh to the scene, with given transformations.">add_meshes()</a> call if you want to avoid this. </p>

</div>
</div>
<a id="a28cb39a00a5b09cef4a40a70b934d744" name="a28cb39a00a5b09cef4a40a70b934d744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28cb39a00a5b09cef4a40a70b934d744">&#9670;&nbsp;</a></span>update_mesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void update_mesh </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTCBuildQuality&#160;</td>
          <td class="paramname"><em>build_quality</em> = <code>RTC_BUILD_QUALITY_MEDIUM</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update a particular mesh with a new mesh object. </p>
<p >All its instances will be affected.</p>
<dl class="section note"><dt>Note</dt><dd>If you have changed the vertices of a mesh already in the scene, and just want the object to reflect that, then call <a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a709ae0324587579f07e49f842250b786" title="Update the object to reflect external changes to the vertices of a particular mesh which is already i...">update_mesh_vertices()</a> instead. </dd></dl>

</div>
</div>
<a id="a709ae0324587579f07e49f842250b786" name="a709ae0324587579f07e49f842250b786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a709ae0324587579f07e49f842250b786">&#9670;&nbsp;</a></span>update_mesh_vertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void update_mesh_vertices </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the object to reflect external changes to the vertices of a particular mesh which is already in the scene. </p>
<p >All its instances will be affected. The number of vertices in the mesh, and their order in the vertex array, must not change. </p>

</div>
</div>
<a id="a2a95cd7335a030b92c3d0692392e64b3" name="a2a95cd7335a030b92c3d0692392e64b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a95cd7335a030b92c3d0692392e64b3">&#9670;&nbsp;</a></span>set_intersection_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_intersection_filter </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>mesh_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ad7f3adb3c6dc669144af2cf7b7c4a2f7">FilterFunction</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an intersection filter that is called for every hit on (every instance of) a mesh during an intersection query. </p>
<p >The <em>filter</em> function must be callable as:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> filter(<span class="keyword">const</span> <a class="code hl_function" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ab3221c3d429d0073beaf6c3d2c26ef39">EmbreeRayCaster</a>* obj, <span class="keyword">const</span> Index* mesh_index, <span class="keyword">const</span> Index* instance_index,</div>
<div class="line">            <span class="keyword">const</span> RTCFilterFunctionNArguments* args);</div>
<div class="ttc" id="aclasslagrange_1_1raycasting_1_1_embree_ray_caster_html_ab3221c3d429d0073beaf6c3d2c26ef39"><div class="ttname"><a href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ab3221c3d429d0073beaf6c3d2c26ef39">lagrange::raycasting::EmbreeRayCaster::EmbreeRayCaster</a></div><div class="ttdeci">EmbreeRayCaster(RTCSceneFlags scene_flags=RTC_SCENE_FLAG_DYNAMIC, RTCBuildQuality build_quality=RTC_BUILD_QUALITY_LOW)</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> EmbreeRayCaster.h:92</div></div>
</div><!-- fragment --><p >It functions exactly like Embree's <code>rtcSetGeometryIntersectFilterFunction</code>, except it also receives a handle to this object, and mesh and instance indices specific to this object. A null <em>filter</em> disables intersection filtering for this mesh.</p>
<dl class="section note"><dt>Note</dt><dd>Embree dictates that filters can be associated only with meshes (raw geometries), not instances. </dd></dl>

</div>
</div>
<a id="a1d43c64a54fedb7b3a286911f983216b" name="a1d43c64a54fedb7b3a286911f983216b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d43c64a54fedb7b3a286911f983216b">&#9670;&nbsp;</a></span>get_intersection_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ad7f3adb3c6dc669144af2cf7b7c4a2f7">FilterFunction</a> get_intersection_filter </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>mesh_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the intersection filter function currently bound to a given mesh. </p>
<dl class="section note"><dt>Note</dt><dd>Embree dictates that filters can be associated only with meshes (raw geometries), not instances. </dd></dl>

</div>
</div>
<a id="ac4611052074b210dac90dad251102c30" name="ac4611052074b210dac90dad251102c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4611052074b210dac90dad251102c30">&#9670;&nbsp;</a></span>set_occlusion_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_occlusion_filter </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>mesh_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ad7f3adb3c6dc669144af2cf7b7c4a2f7">FilterFunction</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an occlusion filter that is called for every hit on (every instance of) a mesh during an occlusion query. </p>
<p >The <em>filter</em> function must be callable as:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> filter(<span class="keyword">const</span> <a class="code hl_function" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ab3221c3d429d0073beaf6c3d2c26ef39">EmbreeRayCaster</a>* obj, <span class="keyword">const</span> Index* mesh_index, <span class="keyword">const</span> Index* instance_index,</div>
<div class="line">            <span class="keyword">const</span> RTCFilterFunctionNArguments* args);</div>
</div><!-- fragment --><p >It functions exactly like Embree's <code>rtcSetGeometryOccludedFilterFunction</code>, except it also receives a handle to this object, and mesh and instance indices specific to this object. A null <em>filter</em> disables occlusion filtering for this mesh.</p>
<dl class="section note"><dt>Note</dt><dd>Embree dictates that filters can be associated only with meshes (raw geometries), not instances. </dd></dl>

</div>
</div>
<a id="a94009d03d904690cc9f1f4a2d4559144" name="a94009d03d904690cc9f1f4a2d4559144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94009d03d904690cc9f1f4a2d4559144">&#9670;&nbsp;</a></span>get_occlusion_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#ad7f3adb3c6dc669144af2cf7b7c4a2f7">FilterFunction</a> get_occlusion_filter </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>mesh_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the occlusion filter function currently bound to a given mesh. </p>
<dl class="section note"><dt>Note</dt><dd>Embree dictates that filters can be associated only with meshes (raw geometries), not instances. </dd></dl>

</div>
</div>
<a id="ab3f429768257565881f062d0de81c6b2" name="ab3f429768257565881f062d0de81c6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f429768257565881f062d0de81c6b2">&#9670;&nbsp;</a></span>commit_scene_changes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void commit_scene_changes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call <code>rtcCommitScene()</code> on the overall scene, if it has been marked as modified. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Now that this is automatically called by <a class="el" href="classlagrange_1_1raycasting_1_1_embree_ray_caster.html#a9197169586df2f668825a83a359cc2a3" title="Update all internal structures based on the current dirty flags.">update_internal()</a> based on a dirty flag, can we make this a protected/private function? That would break the API so maybe reserve it for a major version. </dd></dl>

</div>
</div>
<a id="a4c3f921b5e18d96abdd45cbc9564de6c" name="a4c3f921b5e18d96abdd45cbc9564de6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3f921b5e18d96abdd45cbc9564de6c">&#9670;&nbsp;</a></span>generate_scene()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void generate_scene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the whole Embree scene from the specified meshes, instances, etc. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Make the dirty flags more fine-grained so that only the changed meshes are re-sent to Embree. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>

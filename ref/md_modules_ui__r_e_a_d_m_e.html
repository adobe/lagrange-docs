<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lagrange: Table of Contents</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lagrange
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Table of Contents </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#overview">Overview</a></li>
<li><a href="#geometry-loading-and-registration">Geometry loading and registration</a><ul>
<li><a href="#loading-mesh">Loading mesh</a></li>
<li><a href="#retrieving-and-interacting-with-the-mesh">Retrieving and interacting with the mesh</a></li>
<li><a href="#loading-scene">Loading scene</a></li>
</ul>
</li>
<li><a href="#adding-geometry-to-scene">Adding geometry to scene</a><ul>
<li><a href="#default-physically-based-render-pbr">Default Physically Based Render (PBR)</a></li>
<li><a href="#mesh-visualizations">Mesh visualizations</a><ul>
<li><a href="#glyphtypesurface"><code>GlyphType::Surface</code></a></li>
<li><a href="#colormaps">Colormaps</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#materials">Materials</a><ul>
<li><a href="#colortexture-material-properties">Color/Texture Material Properties</a><ul>
<li><a href="#pbrmaterial">PBRMaterial</a></li>
</ul>
</li>
<li><a href="#rasterizer-properties">Rasterizer Properties</a></li>
<li><a href="#custom-shader-properties">Custom Shader Properties</a></li>
</ul>
</li>
<li><a href="#common-components">Common components</a><ul>
<li><a href="#name"><code>Name</code></a></li>
<li><a href="#transform"><code>Transform</code></a></li>
<li><a href="#tree"><code>Tree</code></a></li>
<li><a href="#meshgeometry"><code>MeshGeometry</code></a></li>
<li><a href="#hovered-and-selected"><code>Hovered</code> and <code>Selected</code></a></li>
<li><a href="#layer"><code>Layer</code></a></li>
<li><a href="#uipanel"><code>UIPanel</code></a></li>
<li><a href="#viewport"><code>Viewport</code></a></li>
</ul>
</li>
<li><a href="#user-interface-panels">User Interface Panels</a></li>
<li><a href="#viewports">Viewports</a><ul>
<li><a href="#entity-visibility">Entity visibility</a></li>
<li><a href="#multi-viewport">Multi viewport</a></li>
</ul>
</li>
<li><a href="#entity-component-system">Entity Component System</a><ul>
<li><a href="#registry">Registry</a></li>
<li><a href="#entity">Entity</a></li>
<li><a href="#components">Components</a><ul>
<li><a href="#tag-components">Tag Components</a></li>
</ul>
</li>
<li><a href="#systems">Systems</a></li>
<li><a href="#context-variables">Context variables</a></li>
<li><a href="#design-considerations">Design considerations</a></li>
</ul>
</li>
<li><a href="#customizing-lagrange-ui">Customizing Lagrange UI</a><ul>
<li><a href="#components-1">Components</a></li>
<li><a href="#tools">Tools</a></li>
<li><a href="#geometry">Geometry</a></li>
<li><a href="#rendering">Rendering</a><ul>
<li><a href="#shader-and-material-properties">Shader and Material properties</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#examples">Examples</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
Overview</h1>
<p >Lagrange UI uses an <b>Entity-Component-System (ECS)</b> architecture:</p><ul>
<li>Entity is a unique identifier</li>
<li>Components define data and behavior (but no logic)</li>
<li>Systems define logic (but no data).</li>
</ul>
<p >See <em><a href="#entity-component-system">ECS implementation section</a></em> for more information about ECS and how it's implemented in Lagrange UI. The underlying library for ECS is <a href="https://github.com/skypjack/entt"><code>entt</code></a>.</p>
<p >Recommended namespace usage </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">namespace ui = lagrange::ui;</div>
</div><!-- fragment --><p >The entry point to the library is the <code>Viewer</code> class. It instantiates a window and owns a <code>Registry</code> instance and <code>Systems</code> instance. <code>Registry</code> contains all the data (entities, components) and <code>Systems</code> contain all the behavior (sequence of functions that is called every frame). To start the UI:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ui::Viewer viewer;</div>
<div class="line">viewer.run([](){</div>
<div class="line">    //Main loop code</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">//Or</div>
<div class="line"> </div>
<div class="line">viewer.run([](ui::Registry &amp; r){</div>
<div class="line">    //Main loop code    </div>
<div class="line">    return should_continue_running;</div>
<div class="line">});</div>
</div><!-- fragment --><p >The API to interact with the UI follows this pattern </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">ui::Entity entity = ui::do_something(registry, params)</div>
<div class="line">SomeData &amp; data = registry.get&lt;SomeData&gt;(entity);</div>
</div><!-- fragment --><p >For example: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">//Loads mesh from path</div>
<div class="line">ui::Entity mesh_geometry = ui::load_mesh(registry, path);</div>
<div class="line"> </div>
<div class="line">//Adds the mesh to scene</div>
<div class="line">ui::Entity mesh_visualization = ui::show_mesh(registry, mesh_geometry);</div>
<div class="line"> </div>
<div class="line">//Retrieves Transform component of the visualized mesh</div>
<div class="line">Transform &amp; transform = registry.get&lt;Transform&gt;(mesh_visualization);</div>
</div><!-- fragment --><p >All entities and their components live in a <code>Registry</code>. To access/set/modify the entities and components, use the <code>Viewer::registry()</code>. </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto &amp; registry = viewer.registry();</div>
<div class="line">auto entity = registry.create();</div>
<div class="line">registry.emplace&lt;MyPositionComponent&gt;(entity, MyPositionComponent(0,0,0));</div>
</div><!-- fragment --><p ><em>TODO: lifetime discussion</em></p>
<h1><a class="anchor" id="autotoc_md5"></a>
Geometry loading and registration</h1>
<h2><a class="anchor" id="autotoc_md6"></a>
Loading mesh</h2>
<p >Creates and entity that represents the mesh. This entity is only a resource - it is not rendered. It can be referenced by components that need this geometry for rendering/picking/etc. These entities have <code>MeshData</code> component attached that contains a <code><a class="el" href="classlagrange_1_1_mesh_base.html">lagrange::MeshBase</a></code> pointer.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ui::Entity mesh_from_disk = ui::load_mesh(registry, path);</div>
<div class="line">ui::Entity mesh_from_memory = ui::register_mesh(registry, lagrange::create_sphere());</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7"></a>
Retrieving and interacting with the mesh</h2>
<p >To retrieve a mesh: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">MeshType &amp; mesh = ui::get_mesh&lt;MeshType&gt;(registry, mesh_entity);</div>
</div><!-- fragment --><p >There are several methods that do not require the knowledge of the mesh type. These may however incur copy and conversion costs. </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">RowMajorMatrixXf get_mesh_vertices(const MeshData&amp; d);</div>
<div class="line">RowMajorMatrixXf get_mesh_facets(const MeshData&amp; d);</div>
<div class="line">bool has_mesh_vertex_attribute(const MeshData&amp; d, const std::string&amp; name);</div>
<div class="line">bool has_mesh_facet_attribute(const MeshData&amp; d, const std::string&amp; name);</div>
<div class="line">...</div>
<div class="line">RowMajorMatrixXf get_mesh_vertex_attribute(const MeshData&amp; d, const std::string&amp; name);</div>
<div class="line">RowMajorMatrixXf get_mesh_facet_attribute(const MeshData&amp; d, const std::string&amp; name);</div>
<div class="line">...</div>
<div class="line">std::optional&lt;RayFacetHit&gt; intersect_ray(const MeshData&amp; d, const Eigen::Vector3f&amp; origin, const Eigen::Vector3f&amp; dir);</div>
<div class="line">...</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8"></a>
Loading scene</h2>
<p >Loads a scene using Assimp. Creates a hierarchy of entities and loads meshes, materials and textures. Returns the top-level entity.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ui::Entity root = ui::load_scene(registry, path);</div>
</div><!-- fragment --><p >To iterate over the scene, see the <a href="#tree"><code>Tree</code> component</a>.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Adding geometry to scene</h1>
<h2><a class="anchor" id="autotoc_md10"></a>
Default Physically Based Render (PBR)</h2>
<p >Adds previously registered mesh geometry to the scene. This mesh will be rendered using PBR.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">ui::Entity scene_object = ui::show_mesh(registry, mesh_entity);</div>
</div><!-- fragment --><p >Uses <code>DefaultShaders::PBR</code> shader.</p>
<p >See <a href="#Materials">Materials</a> section to see how to control the appearance.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Mesh visualizations</h2>
<p >Adds a visualization of a mesh (<a href="https://git.corp.adobe.com/lagrange/Lagrange/issues/657">Jeremie's idea</a>).</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto vertex_viz_entity = ui::show_vertex_attribute(registry, mesh_entity, attribute_name, glyph_type);</div>
<div class="line">auto facet_viz_entity = ui::show_facet_attribute(registry, mesh_entity, attribute_name, glyph_type);</div>
<div class="line">auto corner_viz_entity = ui::show_corner_attribute(registry, mesh_entity, attribute_name, glyph_type);</div>
<div class="line">auto edge_viz_entity = ui::show_edge_attribute(registry, mesh_entity, attribute_name, glyph_type);</div>
</div><!-- fragment --><p >These functions will create a new scene object and render the supplied attribute using the selected glyph type.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
&lt;tt&gt;GlyphType::Surface&lt;/tt&gt;</h3>
<p >Renders unshaded surface with color mapped from the supplied attribute. Supports attributes of dimension: 1, 2, 3, and 4.</p>
<p ><em>Normalization</em>: The attribute value is automatically remapped to (0,1) range. To change the range, use <code>ui::set_colormap_range</code> <em>Colormapping</em>: By default, the attribute is interpreted as R, RG, RGB or RGBA value. To use different mapping, refer to <a href="#Colormaps">Colormaps</a> section.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Colormaps</h3>
<p >If the glyph or shader supports colormapping, use the following function to set the colormap:</p>
<p >To use on of the default colormaps: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">ui::set_colormap(registry, entity, ui::generate_colormap(ui::colormap_magma))</div>
</div><!-- fragment --><p> Or generate your own </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">ui::set_colormap(registry, entity, ui::generate_colormap([](float t){</div>
<div class="line">    return Color(</div>
<div class="line">        //... function of t from 0 to 1</div>
<div class="line">    );</div>
<div class="line">}));</div>
</div><!-- fragment --><p >Default colormaps: </p><div class="fragment"><div class="line">colormap_viridis</div>
<div class="line">colormap_magma</div>
<div class="line">colormap_plasma</div>
<div class="line">colormap_inferno</div>
<div class="line">colormap_turbo</div>
<div class="line">colormap_coolwarm</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14"></a>
Materials</h1>
<p >Any entity with <code>MeshRender</code> component has a <code>Material</code> associated with it (<code>MeshRender::material</code>).</p>
<p >To get a reference to entity's material, use:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">std::shared_ptr&lt;Material&gt; material_ptr = ui::get_material(r, entity_with_meshrender);</div>
</div><!-- fragment --><p >Similarly, you may set a new material: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">ui::set_material(r, entity_with_mesh_render, std::make_shared&lt;ui::Material&gt;(r, DefaultShaders::PBR);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
Color/Texture Material Properties</h2>
<p >You may set colors and textures of materials using the following API:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto &amp; material = *ui::get_material(r, entity_with_meshrender);</div>
<div class="line"> </div>
<div class="line">//Sets &quot;property name&quot; to a red color</div>
<div class="line">material.set_color(&quot;property name&quot;, ui::Color(1,0,0));</div>
<div class="line"> </div>
<div class="line">//Sets &quot;texture name&quot; to texture loaded from file</div>
<div class="line">material.set_texture(&quot;texture name&quot;, ui::load_texture(&quot;texture.jpg&quot;));</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16"></a>
PBRMaterial</h3>
<p >For the default <code>PBRMaterial</code>, you may use aliases for the property names: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line"> </div>
<div class="line">//Uniform rgba color</div>
<div class="line">material.set_color(PBRMaterial::BaseColor, ui::Color(1,0,0,1));</div>
<div class="line">//RGB(A) color/albedo texture</div>
<div class="line">material.set_texture(PBRMaterial::BaseColor, ui::load_texture(&quot;color.jpg&quot;));</div>
<div class="line"> </div>
<div class="line">//Normal texture (and texture only)</div>
<div class="line">material.set_texture(PBRMaterial::Normal, ui::load_texture(&quot;normal.jpg&quot;));</div>
<div class="line"> </div>
<div class="line">//Uniform roughness</div>
<div class="line">material.set_float(PBRMaterial::Roughness, 0.75f);</div>
<div class="line">//Roughness texture</div>
<div class="line">material.set_texture(PBRMaterial::Roughness, ui::load_texture(&quot;metallic.jpg&quot;));</div>
<div class="line"> </div>
<div class="line">//Uniform roughness</div>
<div class="line">material.set_float(PBRMaterial::Metallic, 0.75f); </div>
<div class="line">//Metallic texture</div>
<div class="line">material.set_texture(PBRMaterial::Metallic, ui::load_texture(&quot;metallic.jpg&quot;));</div>
<div class="line"> </div>
<div class="line">//Uniform opacity</div>
<div class="line">material.set_float(PBRMaterial::Opacity, 1.0f);</div>
<div class="line">//Opacity texture</div>
<div class="line">material.set_texture(PBRMaterial::Opacity, ui::load_texture(&quot;opacity.jpg&quot;));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md17"></a>
Rasterizer Properties</h2>
<p >To control OpenGl properties, you may following syntax:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">material.set_int(RasterizerOptions::PolygonMode, GL_LINE);</div>
<div class="line">material.set_float(RasterizerOptions::PointSize, PointSize);</div>
</div><!-- fragment --><p >See <code>&lt;lagrange/ui/Shader.h&gt;</code> for a list of supported <code>RasterizerOptions</code>;</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Custom Shader Properties</h2>
<p >You may set arbitrary <code>int</code> or <code>float</code> or <code>Color</code> or <code>Texture</code> to the material. It will be set as a shader uniform if it exists in the shader, otherwise there will be no effect.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Common components</h1>
<p >Entities can have several components that define their behavior. Here is a list of the common components used throughout Lagrange UI.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
&lt;tt&gt;Name&lt;/tt&gt;</h2>
<p >Subclassed <code>std::string</code>. Acts as a display name. Will be shown in UI if it exists, otherwise a generated name will be used. Does not have to be unique.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
&lt;tt&gt;Transform&lt;/tt&gt;</h2>
<p >Contains local and global transformations and a viewport transform.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">// Translates entity one unit in X direction</div>
<div class="line">ui::Transform &amp; transform = registry.get&lt;ui::Transform&gt;(e);</div>
<div class="line">transform.local = Eigen::Translation3f(1,0,0);</div>
</div><!-- fragment --><p >Global transformation is recomputed after each <code>Simulation</code> step. Only change the <code>local</code> transform.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
&lt;tt&gt;Tree&lt;/tt&gt;</h2>
<p >Defines scene tree relationship. Data is stored using <code>parent</code>, <code>first_child</code>, <code>previous_sibling</code> and <code>next_sibling</code> entity IDs.</p>
<p >Use helper functions to query or change the tree structure, do not change directly (unless you know what you're doing). </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">//Orphans entity and parents it under new_parent</div>
<div class="line">ui::reparent(registry, entity, new_parent);</div>
<div class="line"> </div>
<div class="line">//Applies lambda to each direct child entity of parent</div>
<div class="line">ui::foreach_child(registry, parent, [](Entity child){</div>
<div class="line">    //...</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">//Applies lambda to each  child entity of parent, recursively</div>
<div class="line">ui::foreach_child_recursive(registry, parent, [](Entity child){</div>
<div class="line">    //...</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">//In-order traversal of scene tree</div>
<div class="line">ui::iterate_inorder(registry, root, [](Entity current){</div>
<div class="line">    //On Enter</div>
<div class="line"> </div>
<div class="line">    //Return true to continue to traverse children</div>
<div class="line">    return true;</div>
<div class="line">},[](Entity current){</div>
<div class="line">    //On Exit</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// See utils/treenode.h for more details</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md23"></a>
&lt;tt&gt;MeshGeometry&lt;/tt&gt;</h2>
<p >Contains reference to geometry entity</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">MeshGeometry mg;</div>
<div class="line">mg.entity = ..</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md24"></a>
&lt;tt&gt;Hovered&lt;/tt&gt; and &lt;tt&gt;Selected&lt;/tt&gt;</h2>
<p >These components acts as flags whether the entity is hovered or selected respectively.</p>
<p >Useful helper functions </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">bool is_selected(Registry &amp;registry, Entity e);</div>
<div class="line">bool is_hovered(Registry &amp;registry, Entity e);</div>
<div class="line">bool select(Registry&amp; registry, Entity e);</div>
<div class="line">bool deselect(Registry&amp; registry, Entity e);</div>
<div class="line">std::vector&lt;Entity&gt; collect_selected(const Registry&amp; registry);</div>
<div class="line">std::vector&lt;Entity&gt; collect_hovered(const Registry&amp; registry);</div>
<div class="line">//See `utils/selection.h` for details</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md25"></a>
&lt;tt&gt;Layer&lt;/tt&gt;</h2>
<p >There are 256 layers an entity can belong to. The <code>Layer</code> component specifies which layers the entity belongs to. Entity can belong to several layers at once. There are several default layers: <code>ui::DefaultLayers::Default</code> - everything belongs to it by default <code>ui::DefaultLayers::Selection</code> - selected entities <code>ui::DefaultLayers::Hover</code> - hovered entities</p>
<p >Default constructed <code>Layer</code> component belongs to <code>ui::DefaultLayers::Default</code>.</p>
<p >You can register your own layer by calling </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">ui::LayerIndex layer_index = ui::register_layer_name(r, &quot;my layer name&quot;);</div>
</div><!-- fragment --><p >There are several utility functions for working with layers: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">void add_to_layer(Registry&amp;, Entity e, LayerIndex index);</div>
<div class="line">void remove_from_layer(Registry&amp;, Entity e, LayerIndex index);</div>
<div class="line">bool is_in_layer(Registry&amp;, Entity e, LayerIndex index);</div>
<div class="line">bool is_in_any_layers(Registry&amp;, Entity e, Layer layers_bitset);</div>
<div class="line">bool is_visible_in(</div>
<div class="line">    const Registry&amp;,</div>
<div class="line">    Entity e,</div>
<div class="line">    const Layer&amp; visible_layers,</div>
<div class="line">    const Layer&amp; hidden_layers);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md26"></a>
&lt;tt&gt;UIPanel&lt;/tt&gt;</h2>
<p >See <a href="#User-Interface-Panels">section</a> below.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
&lt;tt&gt;Viewport&lt;/tt&gt;</h2>
<p >See <a href="#Viewports">section</a> below.</p>
<h1><a class="anchor" id="autotoc_md28"></a>
User Interface Panels</h1>
<p >UI Panels are implemented also as entities. Panels have the <code>UIPanel</code> component. The <code>UIPanel</code> components describes the ImGui information (panel title, position, etc.).</p>
<p >To create a new UI panel: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto panel_entity = ui::add_panel(registry, &quot;Title of the panel&quot;,[](){</div>
<div class="line">    // Do NOT call Imgui::Begin()/End()</div>
<div class="line">    Imgui::Text(&quot;Hello world&quot;);</div>
<div class="line">});</div>
<div class="line">//or</div>
<div class="line">auto panel_entity = ui::add_panel(registry, &quot;Title of the panel&quot;, [](Registry &amp;registry, Entity e){</div>
<div class="line">    //Entity e is the panel_entity    </div>
<div class="line">});</div>
</div><!-- fragment --><p >Example of multiple instances of a same "type" of panel:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line"> </div>
<div class="line">struct MyPanelState { int x = 0; }</div>
<div class="line"> </div>
<div class="line">auto panel_fn = [](Registry &amp;registry, Entity e){</div>
<div class="line">    auto &amp; state = registry.get_or_emplace&lt;MyPanelState&gt;(e);</div>
<div class="line">    ImGui::InputInt(&quot;x&quot;, &amp;state.x);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">auto panel0 = ui::add_panel(registry,&quot;panel with x = 0&quot;,panel_fn)</div>
<div class="line">registry.emplace&lt;MyPanelState&gt;(panel0, MyPanelState{0})</div>
<div class="line"> </div>
<div class="line">auto panel1 = ui::add_panel(registry,&quot;panel with x = 1&quot;,panel_fn);</div>
<div class="line">registry.emplace&lt;MyPanelState&gt;(panel1, MyPanelState{1})</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md29"></a>
Viewports</h1>
<p >Viewports are implemented as entities with <code>ViewportComponent</code> component. Those referenced in <code>ViewportPanel</code> are rendered to screen, otherwise they are rendered off-screen. There is always one <b>focused</b> <code>ViewportPanel</code> (identified by the context variable <code>FocusedViewportPanel</code>).</p>
<p >See <code><a class="el" href="components_2_viewport_8h_source.html">components/Viewport.h</a></code> and <code><a class="el" href="utils_2_viewport_8h_source.html">utils/viewport.h</a></code> for utility functions related to viewport, viewport panels and cameras.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
Entity visibility</h2>
<p >Each <code>ViewportComponent</code> has <code>visible_layers</code> and <code>hidden_layers</code> that control which entities can be renderer in this viewport (see <a href="#layer"><code>Layer</code> component</a> for details).</p>
<p >The default viewport shows only <code>DefaultLayers::DefaultLayer</code></p>
<h2><a class="anchor" id="autotoc_md31"></a>
Multi viewport</h2>
<p >Additional viewports can be created by calling </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">ui::Entity camera_entity = add_camera(ui::Registry &amp;, ui::Camera camera); </div>
<div class="line">// or use get_focused_camera_entity(ui::Registry &amp;)  to reuse current camera</div>
<div class="line"> </div>
<div class="line">// Creates an offscreen viewport with the specified camera</div>
<div class="line">ui::Entity viewport_entity = add_viewport(ui::Registry &amp;, ui::Entity camera_entity)</div>
<div class="line"> </div>
<div class="line">// Creates a UI panel that shows the viewport</div>
<div class="line">ui::Entity viewport_entity = add_viewport_panel(ui::Registry &amp;, const std::string &amp; name, ui::Entity viewport_entity);</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md33"></a>
Entity Component System</h1>
<p >For more information about the ECS architecture, see:</p><ul>
<li><a href="https://medium.com/ingeniouslysimple/entities-components-and-systems-89c31464240d">What you need to know about ECS</a> for quick overview</li>
<li><a href="https://www.youtube.com/watch?v=W3aieHjyNvw">Overwatch Gameplay Architecture - GDC Talk</a> for a good example of usage and design considerations.</li>
<li><a href="https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system">entt Crash Course</a> for overview of the underlying <code>entt</code> library</li>
<li><a href="https://skypjack.github.io/2019-06-25-ecs-baf-part-4/">ECS Back and Forth</a> for more details about ECS design, in particular hierarchies</li>
<li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.1/manual/index.html">Unity ECS documentation</a> for Unity's version of ECS</li>
</ul>
<h2><a class="anchor" id="autotoc_md34"></a>
Registry</h2>
<p >The <code>Viewer</code> uses a <code>Registry</code> (alias for <code>entt::registry</code>) to store all entities and their data. To manipulate entities and their components directly, use the object: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto &amp; registry = viewer.registry();</div>
</div><!-- fragment --><p> <code>Viewer</code> class exposes API that simplifies interaction with the <code>Registry</code>, e.g. <code>Viewer::show_mesh</code>.</p>
<h2><a class="anchor" id="autotoc_md35"></a>
Entity</h2>
<p >Unique identifier - it's just that. It's used to identify a unique "object" or "entity". Lagrange UI defines a <code>Entity</code> alias. Internally implemented as <code>std::uint32_t</code>.</p>
<p >To create a new entity, use: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">Entity new_entity = registry.create();</div>
</div><!-- fragment --><p >To destroy: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">registry.destroy(entity);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36"></a>
Components</h2>
<p >Any data that is attached to an <code>Entity</code>. Uniquely identified by template typename <code>&lt;T&gt;</code> and <code>Entity</code>.</p>
<p >Components <b>don't have logic, that means no code</b>. They only store data and implicitly define behavior. Ideally, the components should be <code>structs</code> with no functions. However, it may be beneficial to have setters/getters as member functions in some cases.</p>
<p >To attach a component of type <code>MyComponent</code> to an entity : </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// When it doesn&#39;t exist</div>
<div class="line">registry.emplace&lt;MyComponent&gt;(entity, MyComponent(42))</div>
<div class="line"> </div>
<div class="line">// When it might exist already</div>
<div class="line">registry.emplace_or_replace&lt;MyComponent&gt;(entity, MyComponent(42))</div>
</div><!-- fragment --><p >To retrieve a component: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// If it exists already</div>
<div class="line">MyComponent &amp; c = registry.get&lt;MyComponent&gt;(entity);</div>
<div class="line"> </div>
<div class="line">// If you&#39;re not sure it exists</div>
<div class="line">MyComponent * c = registry.try_get&lt;MyComponent&gt;(entity);</div>
<div class="line">//or </div>
<div class="line">if(registry.all_of&lt;MyComponent&gt;()){</div>
<div class="line">    MyComponent&amp; c = registry.get&lt;MyComponent&gt;(entity);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md37"></a>
Tag Components</h3>
<p >"Empty" components may be used to tag entities, e.g. <code>Selected</code>, <code>Hovered</code>, etc. These types however must have non-zero size: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct Hidden {</div>
<div class="line">    bool dummy;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md38"></a>
Systems</h2>
<p >Systems are the logic of the application. They are defined as functions that iterate over entities that have specified components only. For example, running this system: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">registry.view&lt;Velocity, Position&gt;().each([](Entity e, Velocity &amp; velocity, Transform &amp; transform){</div>
<div class="line">    transform.local = Eigen::Translation3f(velocity) * transform.local;</div>
<div class="line">});</div>
</div><!-- fragment --><p> will iterate over all entities that have both <code>Velocity</code> and <code>Transform</code> and apply the velocity vector to the transform.</p>
<p >Lagrange UI defines <code>System</code> as alias to <code>std::function&lt;void(Registry&amp;)&gt;</code>, that is, a function that does something with the <code>Registry</code>. Typically these will be defined as: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">System my_system = [](Registry &amp;w){</div>
<div class="line">    w.view&lt;Component1, Component2, ...&gt;.each([](Entity e, Component1 &amp; c1, Component2 &amp; c2, ...){</div>
<div class="line">        //</div>
<div class="line">    });</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md39"></a>
Context variables</h2>
<p >Systems <b>do not have data</b>. However, it's often useful to have some state associated with a given system, e.g. for caching. Sometimes it's useful that this state be shared among several systems. Instead of storing this state in some single instance of a component, we can use <em>context</em> variables. These can be thought of as <em>singleton</em> components - only one instance of a <code>Type</code> can exist at a given time.</p>
<p ><code>InputState</code> is such a <em>singleton</em> component. At the beginning of the frame, it is filled with key/mouse information, including last mouse position, mouse delta, active keybinds, etc.: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">void update_input_system(Registry &amp; registry){</div>
<div class="line">    InputState &amp; input_state =  registry.ctx_or_set&lt;InputState&gt;();</div>
<div class="line">    input_state.mouse.position = ...</div>
<div class="line">    input_state.mouse.delta = ...</div>
<div class="line">    input_state.keybinds.update(...);</div>
<div class="line">}</div>
</div><!-- fragment --><p >It can then be used by any other system down the line: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">void print_mouse_position(Registry &amp; registry){</div>
<div class="line">    const auto &amp; input_state = registry.ctx&lt;InputState&gt;();</div>
<div class="line"> </div>
<div class="line">    lagrange::logger().info(&quot;Mouse position: {}&quot;, input_state.mouse_pos);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md40"></a>
Design considerations</h2>
<p >Rules to follow when designing components and systems:</p><ul>
<li>Components have no functions, only data</li>
<li>Systems have no data</li>
<li>State associated with systems is stored as context variable (<code>registry.ctx&lt;T&gt;()</code>)</li>
</ul>
<p ><em>TODO: const Systems / const views</em></p>
<h1><a class="anchor" id="autotoc_md41"></a>
Customizing Lagrange UI</h1>
<p >TODO: add more details and examples. In the meantime, refer to files named <code>default_{}</code> to see how the UI registers the default types and functionality.</p>
<h2><a class="anchor" id="autotoc_md42"></a>
Components</h2>
<p >You may add any time of component using <code>registry.emplace&lt;ComponentType&gt;(entity)</code>. However to enable more advanced features, you may register the components in the UI:</p>
<p ><code>register_component&lt;T&gt;</code></p><ul>
<li>enables reflection</li>
<li>enables runtime add/clone/move of components</li>
</ul>
<p ><code>register_component_widget&lt;T&gt;</code></p><ul>
<li>defines ImGui code to render</li>
<li>enables drag-and-drop</li>
</ul>
<h2><a class="anchor" id="autotoc_md43"></a>
Tools</h2>
<p ><em>TBD</em></p>
<p ><code>register_element_type&lt;E&gt;</code> (Object/Facet/Edge/Vertex/...)</p>
<p ><code>register_tool&lt;E,T&gt;</code> (Select/Translate/Rotate/Scale/...)</p>
<h2><a class="anchor" id="autotoc_md44"></a>
Geometry</h2>
<p >Lagrange meshes must be registered to work. By default, only the <code>TriangleMesh3Df</code> and <code>TriangleMesh3D</code> are registered.</p>
<p ><code>ui::register_mesh_type&lt;MeshType&gt;()</code></p>
<h2><a class="anchor" id="autotoc_md45"></a>
Rendering</h2>
<h3><a class="anchor" id="autotoc_md46"></a>
Shader and Material properties</h3>
<p >Material properties can be defined in the shader using the following syntax:</p>
<div class="fragment"><div class="line">#pragma property NAME &quot;DISPLAY NAME&quot; TYPE(DEFAULT VALUE AND/OR RANGE) [TAG1, TAG2]</div>
</div><!-- fragment --><p >For example: </p><div class="fragment"><div class="line">//Defines a 2D texture property with the default value of rgba(0.7,0.7,0.7,1) if no texture is bound</div>
<div class="line">#pragma property material_base_color &quot;Base Color&quot; Texture2D(0.7,0.7,0.7,1) </div>
<div class="line">//Defines a 2D texture property with the default value of red=0.4 if no texture is bound</div>
<div class="line">#pragma property material_roughness &quot;Roughness&quot; Texture2D(0.4)</div>
<div class="line">//Defines a 2D texture property with the default value of red=0.1 if no texture is bound</div>
<div class="line">#pragma property material_metallic &quot;Metallic&quot; Texture2D(0.1)</div>
<div class="line">//Defines a 2D texture property that is to be interpreted as normal texture</div>
<div class="line">#pragma property material_normal &quot;Normal&quot; Texture2D [normal]</div>
<div class="line">//Defines a float property, with the default value of 1 and range 0,1</div>
<div class="line">#pragma property material_opacity &quot;Opacity&quot; float(1,0,1) </div>
</div><!-- fragment --><p >The pragmas are parsed whenever a shader is loaded and replaced with: </p><div class="fragment"><div class="line">uniform TYPE NAME = DEFAULT_VALUE</div>
</div><!-- fragment --><p> In case of <code>Texture2D</code>, these uniforms are generated: </p><div class="fragment"><div class="line">uniform sampler2D NAME;</div>
<div class="line">uniform bool NAME_texture_bound = false;</div>
<div class="line">uniform VEC_TYPE NAME_default_value = DEFAULT_VALUE;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md47"></a>
Examples</h1>
<p >Refer to <code>modules/ui/examples</code>. Build Lagrange with <code>-DLAGRANGE_EXAMPLES=On</code>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>

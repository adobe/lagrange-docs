<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lagrange: lagrange Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lagrange
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">lagrange Namespace Reference<div class="ingroups"><a class="el" href="group__module-core.html">Core Module</a> &raquo; <a class="el" href="group__group-utils.html">Utilites</a> &raquo; <a class="el" href="group__group-utils-assert.html">Assert and errors</a> &#124; <a class="el" href="group__module-core.html">Core Module</a> &raquo; <a class="el" href="group__group-utils.html">Utilites</a> &raquo; <a class="el" href="group__group-utils-misc.html">Miscellaneous</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Main namespace for Lagrange.  
<a href="namespacelagrange.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacelagrange_1_1internal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html">internal</a></td></tr>
<tr class="memdesc:namespacelagrange_1_1internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">nullptr_t, size_t, ptrdiff_t basic_ostream bad_weak_ptr extent, remove_extent, is_array, is_void, common_type move, forward, swap <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelagrange_1_1io"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1io.html">io</a></td></tr>
<tr class="memdesc:namespacelagrange_1_1io"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> input/output. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelagrange_1_1partitioning"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1partitioning.html">partitioning</a></td></tr>
<tr class="memdesc:namespacelagrange_1_1partitioning"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> partitioning using METIS. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelagrange_1_1raycasting"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1raycasting.html">raycasting</a></td></tr>
<tr class="memdesc:namespacelagrange_1_1raycasting"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raycasting operations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelagrange_1_1ui"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1ui.html">ui</a></td></tr>
<tr class="memdesc:namespacelagrange_1_1ui"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lagrange UI <a class="el" href="classlagrange_1_1ui_1_1_viewer.html" title="Viewer use systems() to add functions that should be called every frame use registry() or util functi...">Viewer</a> and mini 3D engine. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_acting_mesh_geometry.html">ActingMeshGeometry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_adjacency_list.html">AdjacencyList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjacency list.  <a href="classlagrange_1_1_adjacency_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_attribute.html">Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived attribute class that stores the actual information.  <a href="classlagrange_1_1_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_attribute_base.html">AttributeBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base handle for attributes.  <a href="classlagrange_1_1_attribute_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_attributes.html">Attributes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legacy attribute class.  <a href="classlagrange_1_1_attributes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_backward_mesh_mapping.html">BackwardMeshMapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_bad_cast_error.html">BadCastError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception of this type is thrown when a <a class="el" href="group__group-utils-misc.html#ga2a5fd2842da78b90fdc7b959aec8036a" title="Perform safe cast from SourceType to TargetType, where &quot;safe&quot; means:">lagrange::safe_cast&lt;&gt;</a> fails.  <a href="structlagrange_1_1_bad_cast_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_bit_field.html">BitField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit field utility class.  <a href="classlagrange_1_1_bit_field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_component_options.html">ComponentOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to control connected components computation.  <a href="structlagrange_1_1_component_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_compute_bordered_components_output.html">ComputeBorderedComponentsOutput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_compute_mesh_centroid_output.html">ComputeMeshCentroidOutput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_compute_pointcloud_p_c_a_output.html">ComputePointcloudPCAOutput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_connectivity.html">Connectivity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1copy__on__write__ptr.html">copy_on_write_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle type with copy-on-write semantics.  <a href="classlagrange_1_1copy__on__write__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_corner_normal_options.html">CornerNormalOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing per-corner mesh normals.  <a href="structlagrange_1_1_corner_normal_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_disjoint_sets.html">DisjointSets</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjoint sets computation.  <a href="classlagrange_1_1_disjoint_sets.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_edge_type.html">EdgeType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_error.html">Error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base exception for errors thrown by Lagrange functions.  <a href="structlagrange_1_1_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_exact_predicates.html">ExactPredicates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_exact_predicates_shewchuk.html">ExactPredicatesShewchuk</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_facet_normal_options.html">FacetNormalOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing per-facet mesh normals.  <a href="structlagrange_1_1_facet_normal_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_forward_mesh_mapping.html">ForwardMeshMapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1function__ref.html">function_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight non-owning reference to a callable.  <a href="classlagrange_1_1function__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1function__ref_3_01_r_07_args_8_8_8_08_4.html">function_ref&lt; R(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for function types.  <a href="classlagrange_1_1function__ref_3_01_r_07_args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_genuine_mesh_geometry.html">GenuineMeshGeometry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_indexed_attribute.html">IndexedAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived attribute class that stores the actual information.  <a href="classlagrange_1_1_indexed_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_indexed_attributes.html">IndexedAttributes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legacy indexed attribute class.  <a href="classlagrange_1_1_indexed_attributes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_marching_triangles_output.html">MarchingTrianglesOutput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_mesh_base.html">MeshBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_mesh_geometry.html">MeshGeometry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_mesh_mapping.html">MeshMapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_mesh_navigation.html">MeshNavigation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to navigate elements of a mesh.  <a href="classlagrange_1_1_mesh_navigation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_mesh_topology.html">MeshTopology</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_mesh_trait.html">MeshTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structlagrange_1_1_mesh_trait.html" title="MeshTrait class provide compiler check for different mesh types.">MeshTrait</a> class provide compiler check for different mesh types.  <a href="structlagrange_1_1_mesh_trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_normal_options.html">NormalOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing indexed mesh normals.  <a href="structlagrange_1_1_normal_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_progress_callback.html">ProgressCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple thread-safe progress callback.  <a href="classlagrange_1_1_progress_callback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_sample_points_on_surface_output.html">SamplePointsOnSurfaceOutput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_scoped_log_level.html">ScopedLogLevel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the level of logger to something else in a scope.  <a href="classlagrange_1_1_scoped_log_level.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_scoped_timer.html">ScopedTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to a <a class="el" href="classlagrange_1_1_verbose_timer.html" title="Creates a verbose timer that prints after tock().">VerboseTimer</a>, but uses RAII to call tick()/tock().  <a href="classlagrange_1_1_scoped_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_select_facets_by_normal_similarity_parameters.html">SelectFacetsByNormalSimilarityParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a seed vertex, selects faces around it based on the change in triangle normals.  <a href="structlagrange_1_1_select_facets_by_normal_similarity_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared span with ownership tracking.  <a href="classlagrange_1_1_shared_span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_silent_multi_timer.html">SilentMultiTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A timer that keeps track of a total time as well as intervals.  <a href="classlagrange_1_1_silent_multi_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_silent_timer.html">SilentTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A timer that does not print after <a class="el" href="classlagrange_1_1_silent_timer.html#afaaa29b2d16059bbf5580e31995959fa" title="Stops the timer.">tock()</a>  <a href="classlagrange_1_1_silent_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_small_vector.html">SmallVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hybrid vector that uses the stack upto a maximum size, and the heap beyond that.  <a href="classlagrange_1_1_small_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_stack_set.html">StackSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack-allocated set with a maximum size.  <a href="structlagrange_1_1_stack_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_stack_vector.html">StackVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack-allocated vector with a maximum size.  <a href="structlagrange_1_1_stack_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_static_assertable_bool.html">StaticAssertableBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilers might complain about static_assert(false, "").  <a href="structlagrange_1_1_static_assertable_bool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A general purpose polygonal mesh class.  <a href="classlagrange_1_1_surface_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_tangent_bitangent_options.html">TangentBitangentOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing tangent and bitangent vectors.  <a href="structlagrange_1_1_tangent_bitangent_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_tangent_bitangent_result.html">TangentBitangentResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type of the compute_tangent_bitangent function.  <a href="structlagrange_1_1_tangent_bitangent_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1value__ptr.html">value_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer with value semantics.  <a href="classlagrange_1_1value__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_verbose_timer.html">VerboseTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a verbose timer that prints after <a class="el" href="classlagrange_1_1_verbose_timer.html#afaaa29b2d16059bbf5580e31995959fa" title="Stops the timer.">tock()</a>.  <a href="classlagrange_1_1_verbose_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_vertex_normal_options.html">VertexNormalOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing per-vertex mesh normals.  <a href="structlagrange_1_1_vertex_normal_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_vertex_valence_options.html">VertexValenceOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing vertex valence.  <a href="structlagrange_1_1_vertex_valence_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4d115376c2c766084ef808c837348fc3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> = uint32_t</td></tr>
<tr class="memdesc:ga4d115376c2c766084ef808c837348fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identified to be used to access an attribute.  <a href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">More...</a><br /></td></tr>
<tr class="separator:ga4d115376c2c766084ef808c837348fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685260342ca315f0b8e7446451da169e"><td class="memItemLeft" align="right" valign="top"><a id="a685260342ca315f0b8e7446451da169e" name="a685260342ca315f0b8e7446451da169e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vertices2D</b> = Eigen::Matrix&lt; double, Eigen::Dynamic, 2, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a685260342ca315f0b8e7446451da169e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0b6a4ad19f223f6d3d9200dcc82f9b"><td class="memItemLeft" align="right" valign="top"><a id="a3a0b6a4ad19f223f6d3d9200dcc82f9b" name="a3a0b6a4ad19f223f6d3d9200dcc82f9b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vertices3D</b> = Eigen::Matrix&lt; double, Eigen::Dynamic, 3, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a3a0b6a4ad19f223f6d3d9200dcc82f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9ffb89f38d3683845a8342a6f0a6c7"><td class="memItemLeft" align="right" valign="top"><a id="a7e9ffb89f38d3683845a8342a6f0a6c7" name="a7e9ffb89f38d3683845a8342a6f0a6c7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vertices2Df</b> = Eigen::Matrix&lt; float, Eigen::Dynamic, 2, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a7e9ffb89f38d3683845a8342a6f0a6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964925a1e0d7b9a75fd9eb46c71393a8"><td class="memItemLeft" align="right" valign="top"><a id="a964925a1e0d7b9a75fd9eb46c71393a8" name="a964925a1e0d7b9a75fd9eb46c71393a8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vertices3Df</b> = Eigen::Matrix&lt; float, Eigen::Dynamic, 3, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a964925a1e0d7b9a75fd9eb46c71393a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be6a2aaeb5bdb3585f3510c76997b27"><td class="memItemLeft" align="right" valign="top"><a id="a2be6a2aaeb5bdb3585f3510c76997b27" name="a2be6a2aaeb5bdb3585f3510c76997b27"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Triangles</b> = Eigen::Matrix&lt; int, Eigen::Dynamic, 3, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a2be6a2aaeb5bdb3585f3510c76997b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51268241563f19baad026a6b2382305e"><td class="memItemLeft" align="right" valign="top"><a id="a51268241563f19baad026a6b2382305e" name="a51268241563f19baad026a6b2382305e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Quads</b> = Eigen::Matrix&lt; int, Eigen::Dynamic, 4, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a51268241563f19baad026a6b2382305e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9f1a605ef2c933bcf16289cbd6e192"><td class="memItemLeft" align="right" valign="top"><a id="a6c9f1a605ef2c933bcf16289cbd6e192" name="a6c9f1a605ef2c933bcf16289cbd6e192"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TriangleMesh3D</b> = <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; Vertices3D, Triangles &gt;</td></tr>
<tr class="separator:a6c9f1a605ef2c933bcf16289cbd6e192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b076d81dc0046b803f3a5c4ba63c9f"><td class="memItemLeft" align="right" valign="top"><a id="a79b076d81dc0046b803f3a5c4ba63c9f" name="a79b076d81dc0046b803f3a5c4ba63c9f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TriangleMesh2D</b> = <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; Vertices2D, Triangles &gt;</td></tr>
<tr class="separator:a79b076d81dc0046b803f3a5c4ba63c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600a7bbb6195ed3043597c1d4ade30d3"><td class="memItemLeft" align="right" valign="top"><a id="a600a7bbb6195ed3043597c1d4ade30d3" name="a600a7bbb6195ed3043597c1d4ade30d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TriangleMesh3Df</b> = <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; Vertices3Df, Triangles &gt;</td></tr>
<tr class="separator:a600a7bbb6195ed3043597c1d4ade30d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa025ed072fe904ba06dedf1fb57ad54f"><td class="memItemLeft" align="right" valign="top"><a id="aa025ed072fe904ba06dedf1fb57ad54f" name="aa025ed072fe904ba06dedf1fb57ad54f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TriangleMesh2Df</b> = <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; Vertices2Df, Triangles &gt;</td></tr>
<tr class="separator:aa025ed072fe904ba06dedf1fb57ad54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16562b5e2fc77636e6e8f2595cd2a3f"><td class="memItemLeft" align="right" valign="top"><a id="ae16562b5e2fc77636e6e8f2595cd2a3f" name="ae16562b5e2fc77636e6e8f2595cd2a3f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>QuadMesh3D</b> = <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; Vertices3D, Quads &gt;</td></tr>
<tr class="separator:ae16562b5e2fc77636e6e8f2595cd2a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968bc0e88fe1cab05d913526f9fea53d"><td class="memItemLeft" align="right" valign="top"><a id="a968bc0e88fe1cab05d913526f9fea53d" name="a968bc0e88fe1cab05d913526f9fea53d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>QuadMesh2D</b> = <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; Vertices2D, Quads &gt;</td></tr>
<tr class="separator:a968bc0e88fe1cab05d913526f9fea53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152724149e96e25020eef571e2629eea"><td class="memItemLeft" align="right" valign="top"><a id="a152724149e96e25020eef571e2629eea" name="a152724149e96e25020eef571e2629eea"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>QuadMesh3Df</b> = <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; Vertices3Df, Quads &gt;</td></tr>
<tr class="separator:a152724149e96e25020eef571e2629eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736341f28297ce085621f3e4d5051e44"><td class="memItemLeft" align="right" valign="top"><a id="a736341f28297ce085621f3e4d5051e44" name="a736341f28297ce085621f3e4d5051e44"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>QuadMesh2Df</b> = <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; Vertices2Df, Quads &gt;</td></tr>
<tr class="separator:a736341f28297ce085621f3e4d5051e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35d40a4baad35b6d7000f599079342f"><td class="memTemplParams" colspan="2"><a id="aa35d40a4baad35b6d7000f599079342f" name="aa35d40a4baad35b6d7000f599079342f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa35d40a4baad35b6d7000f599079342f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ScalarOf</b> = typename T::Scalar</td></tr>
<tr class="separator:aa35d40a4baad35b6d7000f599079342f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9254db782b791e7de3433eb42485b2f5"><td class="memTemplParams" colspan="2"><a id="a9254db782b791e7de3433eb42485b2f5" name="a9254db782b791e7de3433eb42485b2f5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9254db782b791e7de3433eb42485b2f5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IndexOf</b> = typename T::Index</td></tr>
<tr class="separator:a9254db782b791e7de3433eb42485b2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591a8df096dc1678f994e253656c3069"><td class="memTemplParams" colspan="2"><a id="a591a8df096dc1678f994e253656c3069" name="a591a8df096dc1678f994e253656c3069"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a591a8df096dc1678f994e253656c3069"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>VertexArrayOf</b> = typename T::VertexArray</td></tr>
<tr class="separator:a591a8df096dc1678f994e253656c3069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1340896dc32f7417914bfe57992e82ff"><td class="memTemplParams" colspan="2"><a id="a1340896dc32f7417914bfe57992e82ff" name="a1340896dc32f7417914bfe57992e82ff"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1340896dc32f7417914bfe57992e82ff"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FacetArrayOf</b> = typename T::FacetArray</td></tr>
<tr class="separator:a1340896dc32f7417914bfe57992e82ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb15c71ed630fa908bb10535b3d50d2"><td class="memTemplParams" colspan="2"><a id="a7eb15c71ed630fa908bb10535b3d50d2" name="a7eb15c71ed630fa908bb10535b3d50d2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7eb15c71ed630fa908bb10535b3d50d2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AttributeArrayOf</b> = typename T::AttributeArray</td></tr>
<tr class="separator:a7eb15c71ed630fa908bb10535b3d50d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f35915880c96f07f2bc8aad6ec7df7"><td class="memTemplParams" colspan="2"><a id="a24f35915880c96f07f2bc8aad6ec7df7" name="a24f35915880c96f07f2bc8aad6ec7df7"></a>
template&lt;typename Index , typename T &gt; </td></tr>
<tr class="memitem:a24f35915880c96f07f2bc8aad6ec7df7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EdgeMap</b> = std::unordered_map&lt; <a class="el" href="classlagrange_1_1_edge_type.html">EdgeType</a>&lt; Index &gt;, T &gt;</td></tr>
<tr class="separator:a24f35915880c96f07f2bc8aad6ec7df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fec32f0aedbd1c570292781e1955dd0"><td class="memTemplParams" colspan="2"><a id="a8fec32f0aedbd1c570292781e1955dd0" name="a8fec32f0aedbd1c570292781e1955dd0"></a>
template&lt;typename Index &gt; </td></tr>
<tr class="memitem:a8fec32f0aedbd1c570292781e1955dd0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EdgeSet</b> = std::unordered_set&lt; <a class="el" href="classlagrange_1_1_edge_type.html">EdgeType</a>&lt; Index &gt; &gt;</td></tr>
<tr class="separator:a8fec32f0aedbd1c570292781e1955dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2696d72bb64b4580c878fc4831c5fddd"><td class="memTemplParams" colspan="2"><a id="a2696d72bb64b4580c878fc4831c5fddd" name="a2696d72bb64b4580c878fc4831c5fddd"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a2696d72bb64b4580c878fc4831c5fddd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EdgeFacetMap</b> = std::unordered_map&lt; <a class="el" href="classlagrange_1_1_edge_type.html">EdgeType</a>&lt; typename MeshType::Index &gt;, std::vector&lt; typename MeshType::Index &gt; &gt;</td></tr>
<tr class="separator:a2696d72bb64b4580c878fc4831c5fddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14fdcd2cded8fe91f52ae25c03ba1a61"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>SurfaceMesh32f</b> = <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; float, uint32_t &gt;</td></tr>
<tr class="separator:ga14fdcd2cded8fe91f52ae25c03ba1a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae53afb315b7aa7b237fe61639c5f3227"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>SurfaceMesh32d</b> = <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; double, uint32_t &gt;</td></tr>
<tr class="separator:gae53afb315b7aa7b237fe61639c5f3227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15b6f3435ad8ad0593054364df6e909f"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>SurfaceMesh64f</b> = <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; float, uint64_t &gt;</td></tr>
<tr class="separator:ga15b6f3435ad8ad0593054364df6e909f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc7cff3b1e7e97b39b157971776ae8c5"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>SurfaceMesh64d</b> = <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; double, uint64_t &gt;</td></tr>
<tr class="separator:gadc7cff3b1e7e97b39b157971776ae8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4afead0b9ccc53fe4fca896787595d26"><td class="memTemplParams" colspan="2">template&lt;class T , ::nonstd::span_lite::extent_t Extent = ::nonstd::dynamic_extent&gt; </td></tr>
<tr class="memitem:ga4afead0b9ccc53fe4fca896787595d26"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a> = ::nonstd::span&lt; T, Extent &gt;</td></tr>
<tr class="memdesc:ga4afead0b9ccc53fe4fca896787595d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bounds-safe view for sequences of objects.  <a href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">More...</a><br /></td></tr>
<tr class="separator:ga4afead0b9ccc53fe4fca896787595d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb877375676ff54953d8d36fe1df9240"><td class="memItemLeft" align="right" valign="top"><a id="abb877375676ff54953d8d36fe1df9240" name="abb877375676ff54953d8d36fe1df9240"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>timestamp_type</b> = std::chrono::time_point&lt; std::chrono::steady_clock &gt;</td></tr>
<tr class="separator:abb877375676ff54953d8d36fe1df9240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs</div></td></tr>
<tr class="memitem:ga6344979b33dfbf6508e97dadab610258"><td class="memTemplParams" colspan="2">
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga6344979b33dfbf6508e97dadab610258"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RowMatrix</b> = Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;</td></tr>
<tr class="memdesc:ga6344979b33dfbf6508e97dadab610258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for row-major Eigen matrices. <br /></td></tr>
<tr class="separator:ga6344979b33dfbf6508e97dadab610258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06ca3172e4577c726eaf8d2ab26a1ab5"><td class="memTemplParams" colspan="2">
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga06ca3172e4577c726eaf8d2ab26a1ab5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RowMatrixView</b> = Eigen::Map&lt; <a class="el" href="group__group-surfacemesh-views.html#ga6344979b33dfbf6508e97dadab610258">RowMatrix</a>&lt; Scalar &gt;, Eigen::Unaligned &gt;</td></tr>
<tr class="memdesc:ga06ca3172e4577c726eaf8d2ab26a1ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for row-major matrix views. <br /></td></tr>
<tr class="separator:ga06ca3172e4577c726eaf8d2ab26a1ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe9823dfafe170f84504176f997c1d8c"><td class="memTemplParams" colspan="2">
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:gafe9823dfafe170f84504176f997c1d8c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstRowMatrixView</b> = Eigen::Map&lt; const <a class="el" href="group__group-surfacemesh-views.html#ga6344979b33dfbf6508e97dadab610258">RowMatrix</a>&lt; Scalar &gt;, Eigen::Unaligned &gt;</td></tr>
<tr class="memdesc:gafe9823dfafe170f84504176f997c1d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for row-major const matrix view. <br /></td></tr>
<tr class="separator:gafe9823dfafe170f84504176f997c1d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fed807d227a1b730ca7ebcc01d897e2"><td class="memTemplParams" colspan="2">
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga0fed807d227a1b730ca7ebcc01d897e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Vector</b> = Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:ga0fed807d227a1b730ca7ebcc01d897e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for one-dimensional column Eigen vectors. <br /></td></tr>
<tr class="separator:ga0fed807d227a1b730ca7ebcc01d897e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373c385fbf8ee25f008de6d6575118ab"><td class="memTemplParams" colspan="2">
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga373c385fbf8ee25f008de6d6575118ab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>VectorView</b> = Eigen::Map&lt; <a class="el" href="group__group-surfacemesh-views.html#ga0fed807d227a1b730ca7ebcc01d897e2">Vector</a>&lt; Scalar &gt;, Eigen::Unaligned &gt;</td></tr>
<tr class="memdesc:ga373c385fbf8ee25f008de6d6575118ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for row-major vector view. <br /></td></tr>
<tr class="separator:ga373c385fbf8ee25f008de6d6575118ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8801fb865cd458d4db0c42de4bd9130a"><td class="memTemplParams" colspan="2">
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga8801fb865cd458d4db0c42de4bd9130a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstVectorView</b> = Eigen::Map&lt; const <a class="el" href="group__group-surfacemesh-views.html#ga0fed807d227a1b730ca7ebcc01d897e2">Vector</a>&lt; Scalar &gt;, Eigen::Unaligned &gt;</td></tr>
<tr class="memdesc:ga8801fb865cd458d4db0c42de4bd9130a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for row-major const vector view. <br /></td></tr>
<tr class="separator:ga8801fb865cd458d4db0c42de4bd9130a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9d8ab208822bab9987e9652dda49d89a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> : int { <br />
&#160;&#160;<a class="el" href="group__group-surfacemesh-attr.html#gga9d8ab208822bab9987e9652dda49d89aad013c4439c3e09308d6b2eef2a4025ae">Vertex</a> = (1 &lt;&lt; 0)
, <a class="el" href="group__group-surfacemesh-attr.html#gga9d8ab208822bab9987e9652dda49d89aa9b112d86d52178fe18e47e14bb6aeb35">Facet</a> = (1 &lt;&lt; 1)
, <a class="el" href="group__group-surfacemesh-attr.html#gga9d8ab208822bab9987e9652dda49d89aa7f0bc3a17ff45e6a7c3fe52b35db1888">Edge</a> = (1 &lt;&lt; 2)
, <a class="el" href="group__group-surfacemesh-attr.html#gga9d8ab208822bab9987e9652dda49d89aab9925c71d0b2b9131518c35c9ebbad92">Corner</a> = (1 &lt;&lt; 3)
, <br />
&#160;&#160;<a class="el" href="group__group-surfacemesh-attr.html#gga9d8ab208822bab9987e9652dda49d89aa050889cfb2c606473596b8f70f702769">Value</a> = (1 &lt;&lt; 4)
, <a class="el" href="group__group-surfacemesh-attr.html#gga9d8ab208822bab9987e9652dda49d89aa93747573a820d43208a296f9f56bf54e">Indexed</a> = (1 &lt;&lt; 5)
<br />
 }</td></tr>
<tr class="memdesc:ga9d8ab208822bab9987e9652dda49d89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of element to which the attribute is attached.  <a href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">More...</a><br /></td></tr>
<tr class="separator:ga9d8ab208822bab9987e9652dda49d89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35b5eb426384b257452ee0ffdb732c27"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#ga35b5eb426384b257452ee0ffdb732c27">AttributeUsage</a> { <br />
&#160;&#160;<a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27a57dea6f5039281b7fee517fc43bf3110">Vector</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27af60357a8d17e45793298323f1b372a74">Scalar</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27a960b44c579bc2f6818d2daaf9e4c16f0">Normal</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27a541671cb1be09d76a84ba1a873ec3fc8">Tangent</a>
, <br />
&#160;&#160;<a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27ae3e73a4b6e7cfd12008a35f6a051b319">Bitangent</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27acb5feb1b7314637725a2e73bdc9f7295">Color</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27adeaa2adbeb26802ae61609c3f3642d82">UV</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27a7302d7da6a3804b1edf63b4b16198d80">VertexIndex</a>
, <br />
&#160;&#160;<a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27aa3dfb9f32b810b4277c5c8387d7f03f5">FacetIndex</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27a63222a2d9c46a34b875c078c757da2e8">CornerIndex</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27a7e0536ad6c15bf05bf40e8876b1a5c10">EdgeIndex</a>
<br />
 }</td></tr>
<tr class="memdesc:ga35b5eb426384b257452ee0ffdb732c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Usage tag indicating how the attribute should behave under mesh transformations.  <a href="group__group-surfacemesh-attr.html#ga35b5eb426384b257452ee0ffdb732c27">More...</a><br /></td></tr>
<tr class="separator:ga35b5eb426384b257452ee0ffdb732c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga809dfcec94612491ec5be8bb8614ceab"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#ga809dfcec94612491ec5be8bb8614ceab">AttributeCreatePolicy</a> { <a class="el" href="group__group-surfacemesh-attr.html#gga809dfcec94612491ec5be8bb8614ceabafc443f72fcb562a73b40af34ddb599a3">ErrorIfReserved</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga809dfcec94612491ec5be8bb8614ceaba9eb6b78a99cdb6ffd3d40d18621d9f80">Force</a>
 }</td></tr>
<tr class="memdesc:ga809dfcec94612491ec5be8bb8614ceab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for attribute creation with reserved attribute names.  <a href="group__group-surfacemesh-attr.html#ga809dfcec94612491ec5be8bb8614ceab">More...</a><br /></td></tr>
<tr class="separator:ga809dfcec94612491ec5be8bb8614ceab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee0f51b5f793101c19bd6dede5db7a7a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#gaee0f51b5f793101c19bd6dede5db7a7a">AttributeGrowthPolicy</a> { <a class="el" href="group__group-surfacemesh-attr.html#ggaee0f51b5f793101c19bd6dede5db7a7aa9e7163ae7c790d007e084e24693b2303">ErrorIfExternal</a>
, <a class="el" href="group__group-surfacemesh-attr.html#ggaee0f51b5f793101c19bd6dede5db7a7aaf12086c39414ec9b8b89727ad02fb40e">AllowWithinCapacity</a>
, <a class="el" href="group__group-surfacemesh-attr.html#ggaee0f51b5f793101c19bd6dede5db7a7aaef773dc1e1097301a1bf955bfa9857ec">WarnAndCopy</a>
, <a class="el" href="group__group-surfacemesh-attr.html#ggaee0f51b5f793101c19bd6dede5db7a7aae1ed7e29bdcf7fc9d30c50447e35ab92">SilentCopy</a>
 }</td></tr>
<tr class="memdesc:gaee0f51b5f793101c19bd6dede5db7a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for growing external attribute buffers.  <a href="group__group-surfacemesh-attr.html#gaee0f51b5f793101c19bd6dede5db7a7a">More...</a><br /></td></tr>
<tr class="separator:gaee0f51b5f793101c19bd6dede5db7a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3018d576f81897e1712c3601b9625cb9"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#ga3018d576f81897e1712c3601b9625cb9">AttributeWritePolicy</a> { <a class="el" href="group__group-surfacemesh-attr.html#gga3018d576f81897e1712c3601b9625cb9a61eb7df0ff95cbd596ba2a4c7ee06b32">ErrorIfReadOnly</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga3018d576f81897e1712c3601b9625cb9aef773dc1e1097301a1bf955bfa9857ec">WarnAndCopy</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga3018d576f81897e1712c3601b9625cb9ae1ed7e29bdcf7fc9d30c50447e35ab92">SilentCopy</a>
 }</td></tr>
<tr class="memdesc:ga3018d576f81897e1712c3601b9625cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for attempting to write to read-only external buffers.  <a href="group__group-surfacemesh-attr.html#ga3018d576f81897e1712c3601b9625cb9">More...</a><br /></td></tr>
<tr class="separator:ga3018d576f81897e1712c3601b9625cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade3ae5b7e72e9d4f92f29c6563551c10"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#gade3ae5b7e72e9d4f92f29c6563551c10">AttributeExportPolicy</a> { <a class="el" href="group__group-surfacemesh-attr.html#ggade3ae5b7e72e9d4f92f29c6563551c10afe72de1001d465db9eb6ce5cb874c2cb">CopyIfExternal</a>
, <a class="el" href="group__group-surfacemesh-attr.html#ggade3ae5b7e72e9d4f92f29c6563551c10a9a526f6dc0d4d6aef1f368972f20d13e">KeepExternalPtr</a>
, <a class="el" href="group__group-surfacemesh-attr.html#ggade3ae5b7e72e9d4f92f29c6563551c10a9e7163ae7c790d007e084e24693b2303">ErrorIfExternal</a>
 }</td></tr>
<tr class="memdesc:gade3ae5b7e72e9d4f92f29c6563551c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for exporting attributes that are views onto external buffers.  <a href="group__group-surfacemesh-attr.html#gade3ae5b7e72e9d4f92f29c6563551c10">More...</a><br /></td></tr>
<tr class="separator:gade3ae5b7e72e9d4f92f29c6563551c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga450ef027eac01dd93a89a15ff55de63f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#ga450ef027eac01dd93a89a15ff55de63f">AttributeCopyPolicy</a> { <a class="el" href="group__group-surfacemesh-attr.html#gga450ef027eac01dd93a89a15ff55de63fafe72de1001d465db9eb6ce5cb874c2cb">CopyIfExternal</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga450ef027eac01dd93a89a15ff55de63fa9a526f6dc0d4d6aef1f368972f20d13e">KeepExternalPtr</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga450ef027eac01dd93a89a15ff55de63fa9e7163ae7c790d007e084e24693b2303">ErrorIfExternal</a>
 }</td></tr>
<tr class="memdesc:ga450ef027eac01dd93a89a15ff55de63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for copying attribute that are views onto external buffers.  <a href="group__group-surfacemesh-attr.html#ga450ef027eac01dd93a89a15ff55de63f">More...</a><br /></td></tr>
<tr class="separator:ga450ef027eac01dd93a89a15ff55de63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad17b213b11e78aeb807ad3ece7e67e84"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#gad17b213b11e78aeb807ad3ece7e67e84">AttributeDeletePolicy</a> { <a class="el" href="group__group-surfacemesh-attr.html#ggad17b213b11e78aeb807ad3ece7e67e84afc443f72fcb562a73b40af34ddb599a3">ErrorIfReserved</a>
, <a class="el" href="group__group-surfacemesh-attr.html#ggad17b213b11e78aeb807ad3ece7e67e84a9eb6b78a99cdb6ffd3d40d18621d9f80">Force</a>
 }</td></tr>
<tr class="memdesc:gad17b213b11e78aeb807ad3ece7e67e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for attribute deletion of reserved attribute names.  <a href="group__group-surfacemesh-attr.html#gad17b213b11e78aeb807ad3ece7e67e84">More...</a><br /></td></tr>
<tr class="separator:gad17b213b11e78aeb807ad3ece7e67e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa88e833ed770762b02e187f0c2377d3d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gaa88e833ed770762b02e187f0c2377d3d">NormalWeightingType</a> : char { <a class="el" href="group__group-surfacemesh-utils.html#ggaa88e833ed770762b02e187f0c2377d3daf19516d11f2946f894070e92fcb56b6d">Uniform</a> = 0
, <a class="el" href="group__group-surfacemesh-utils.html#ggaa88e833ed770762b02e187f0c2377d3da84f023fc44b6b158de6ccc157c8dab06">CornerTriangleArea</a> = 1
, <a class="el" href="group__group-surfacemesh-utils.html#ggaa88e833ed770762b02e187f0c2377d3da45f4ce6c3306644b1efe333f4f8d6929">Angle</a> = 2
 }</td></tr>
<tr class="memdesc:gaa88e833ed770762b02e187f0c2377d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighting types for averaging corner normals around a vertex.  <a href="group__group-surfacemesh-utils.html#gaa88e833ed770762b02e187f0c2377d3d">More...</a><br /></td></tr>
<tr class="separator:gaa88e833ed770762b02e187f0c2377d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga12026ae46c9a750646928c51111bfeb8"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><b>invalid_attribute_id</b> ()</td></tr>
<tr class="memdesc:ga12026ae46c9a750646928c51111bfeb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid attribute id. <br /></td></tr>
<tr class="separator:ga12026ae46c9a750646928c51111bfeb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643b55e8fe1a55b2929a382a6fbff5db"><td class="memTemplParams" colspan="2"><a id="a643b55e8fe1a55b2929a382a6fbff5db" name="a643b55e8fe1a55b2929a382a6fbff5db"></a>
template&lt;typename AttributeArray , typename Archive &gt; </td></tr>
<tr class="memitem:a643b55e8fe1a55b2929a382a6fbff5db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (<a class="el" href="classlagrange_1_1_attributes.html">Attributes</a>&lt; AttributeArray &gt; &amp;attributes, Archive &amp;ar)</td></tr>
<tr class="separator:a643b55e8fe1a55b2929a382a6fbff5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535c468ff905d0f8c09462bc7a913982"><td class="memTemplParams" colspan="2"><a id="a535c468ff905d0f8c09462bc7a913982" name="a535c468ff905d0f8c09462bc7a913982"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a535c468ff905d0f8c09462bc7a913982"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_vertex_attribute_to_corner_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;attr_name)</td></tr>
<tr class="separator:a535c468ff905d0f8c09462bc7a913982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d3f1006acb9096cfe8f96eccc24b56"><td class="memTemplParams" colspan="2"><a id="a44d3f1006acb9096cfe8f96eccc24b56" name="a44d3f1006acb9096cfe8f96eccc24b56"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a44d3f1006acb9096cfe8f96eccc24b56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_facet_attribute_to_corner_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;attr_name)</td></tr>
<tr class="separator:a44d3f1006acb9096cfe8f96eccc24b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f991d0041a01d7f7dc5baeb9f4e752"><td class="memTemplParams" colspan="2"><a id="ab8f991d0041a01d7f7dc5baeb9f4e752" name="ab8f991d0041a01d7f7dc5baeb9f4e752"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:ab8f991d0041a01d7f7dc5baeb9f4e752"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_corner_attribute_to_vertex_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;attr_name)</td></tr>
<tr class="separator:ab8f991d0041a01d7f7dc5baeb9f4e752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fa5947b548ed15c4e6676733d1ac8d"><td class="memTemplParams" colspan="2"><a id="a79fa5947b548ed15c4e6676733d1ac8d" name="a79fa5947b548ed15c4e6676733d1ac8d"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a79fa5947b548ed15c4e6676733d1ac8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_corner_attribute_to_facet_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;attr_name)</td></tr>
<tr class="separator:a79fa5947b548ed15c4e6676733d1ac8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e390a3c92031203bf01b18cc2a3b6f1"><td class="memTemplParams" colspan="2"><a id="a8e390a3c92031203bf01b18cc2a3b6f1" name="a8e390a3c92031203bf01b18cc2a3b6f1"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a8e390a3c92031203bf01b18cc2a3b6f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_vertex_attribute_to_indexed_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;attr_name)</td></tr>
<tr class="separator:a8e390a3c92031203bf01b18cc2a3b6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a03be2d44108192b648a81003418397"><td class="memTemplParams" colspan="2"><a id="a1a03be2d44108192b648a81003418397" name="a1a03be2d44108192b648a81003418397"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a1a03be2d44108192b648a81003418397"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_facet_attribute_to_indexed_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;attr_name)</td></tr>
<tr class="separator:a1a03be2d44108192b648a81003418397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716d498be9ab2952f08c8822f9004b1a"><td class="memTemplParams" colspan="2"><a id="a716d498be9ab2952f08c8822f9004b1a" name="a716d498be9ab2952f08c8822f9004b1a"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a716d498be9ab2952f08c8822f9004b1a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_corner_attribute_to_indexed_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;attr_name)</td></tr>
<tr class="separator:a716d498be9ab2952f08c8822f9004b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0beec98c173d929bc4c73e2b4a40d1"><td class="memTemplParams" colspan="2"><a id="a3a0beec98c173d929bc4c73e2b4a40d1" name="a3a0beec98c173d929bc4c73e2b4a40d1"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a3a0beec98c173d929bc4c73e2b4a40d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_indexed_attribute_to_vertex_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;attr_name)</td></tr>
<tr class="separator:a3a0beec98c173d929bc4c73e2b4a40d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a594d6e6924f29e7a77ba0e64566e13"><td class="memTemplParams" colspan="2"><a id="a0a594d6e6924f29e7a77ba0e64566e13" name="a0a594d6e6924f29e7a77ba0e64566e13"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a0a594d6e6924f29e7a77ba0e64566e13"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_indexed_attribute_to_facet_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;attr_name)</td></tr>
<tr class="separator:a0a594d6e6924f29e7a77ba0e64566e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192d38cc86914a66ef36031351c4be15"><td class="memTemplParams" colspan="2"><a id="a192d38cc86914a66ef36031351c4be15" name="a192d38cc86914a66ef36031351c4be15"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a192d38cc86914a66ef36031351c4be15"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_indexed_attribute_to_corner_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;attr_name)</td></tr>
<tr class="separator:a192d38cc86914a66ef36031351c4be15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1415024ce537125d1d9b6552826a9249"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a1415024ce537125d1d9b6552826a9249"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a1415024ce537125d1d9b6552826a9249">condense_indexed_attribute</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;attr_name, const std::string &amp;new_attr_name=&quot;&quot;)</td></tr>
<tr class="memdesc:a1415024ce537125d1d9b6552826a9249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condense indexed attribute reduces the attribute value array size by eliminating locally duplicate attribute values.  <a href="namespacelagrange.html#a1415024ce537125d1d9b6552826a9249">More...</a><br /></td></tr>
<tr class="separator:a1415024ce537125d1d9b6552826a9249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa99f663256ca870e0bb5468a8085ee"><td class="memTemplParams" colspan="2"><a id="adfa99f663256ca870e0bb5468a8085ee" name="adfa99f663256ca870e0bb5468a8085ee"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:adfa99f663256ca870e0bb5468a8085ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eval_as_vertex_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;attribute_name, const std::function&lt; typename MeshType::Scalar(typename MeshType::Index v_idx)&gt; &amp;func, bool parallel=true)</td></tr>
<tr class="separator:adfa99f663256ca870e0bb5468a8085ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4305cd881f9dcfdde012ed495e9d1e9"><td class="memTemplParams" colspan="2"><a id="ae4305cd881f9dcfdde012ed495e9d1e9" name="ae4305cd881f9dcfdde012ed495e9d1e9"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:ae4305cd881f9dcfdde012ed495e9d1e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eval_as_vertex_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;attribute_name, const std::function&lt; typename MeshType::Scalar(const typename MeshType::VertexType &amp;V)&gt; &amp;func, bool parallel=true)</td></tr>
<tr class="separator:ae4305cd881f9dcfdde012ed495e9d1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657a6cf2f1d65367c287c2f62b8d40ee"><td class="memTemplParams" colspan="2"><a id="a657a6cf2f1d65367c287c2f62b8d40ee" name="a657a6cf2f1d65367c287c2f62b8d40ee"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a657a6cf2f1d65367c287c2f62b8d40ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eval_as_vertex_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;attribute_name, const std::function&lt; typename MeshType::Scalar(typename MeshType::Scalar x, typename MeshType::Scalar y, typename MeshType::Scalar z)&gt; &amp;func, bool parallel=true)</td></tr>
<tr class="separator:a657a6cf2f1d65367c287c2f62b8d40ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969e7aa038c5697c75090a5b1d0d3da8"><td class="memTemplParams" colspan="2"><a id="a969e7aa038c5697c75090a5b1d0d3da8" name="a969e7aa038c5697c75090a5b1d0d3da8"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a969e7aa038c5697c75090a5b1d0d3da8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eval_as_facet_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;attribute_name, const std::function&lt; typename MeshType::Scalar(typename MeshType::Index f_idx)&gt; &amp;func, bool parallel=true)</td></tr>
<tr class="separator:a969e7aa038c5697c75090a5b1d0d3da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63b14b6aeb71330673dce7cbf000d9e"><td class="memTemplParams" colspan="2"><a id="ae63b14b6aeb71330673dce7cbf000d9e" name="ae63b14b6aeb71330673dce7cbf000d9e"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:ae63b14b6aeb71330673dce7cbf000d9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eval_as_edge_attribute_new</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;attribute_name, const std::function&lt; typename MeshType::Scalar(typename MeshType::Index e_idx)&gt; &amp;func, bool parallel=true)</td></tr>
<tr class="separator:ae63b14b6aeb71330673dce7cbf000d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014a11528075f815af5a2cb07e5c93bf"><td class="memTemplParams" colspan="2"><a id="a014a11528075f815af5a2cb07e5c93bf" name="a014a11528075f815af5a2cb07e5c93bf"></a>
template&lt;typename Index &gt; </td></tr>
<tr class="memitem:a014a11528075f815af5a2cb07e5c93bf"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invert_mapping</b> (const std::vector&lt; Index &gt; &amp;map, Index target_count)</td></tr>
<tr class="separator:a014a11528075f815af5a2cb07e5c93bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5438d2745a4b05d0b5e1bc3bf1261a"><td class="memTemplParams" colspan="2"><a id="ada5438d2745a4b05d0b5e1bc3bf1261a" name="ada5438d2745a4b05d0b5e1bc3bf1261a"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:ada5438d2745a4b05d0b5e1bc3bf1261a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_mesh_mapping.html">MeshMapping</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invert_mapping</b> (const <a class="el" href="structlagrange_1_1_mesh_mapping.html">MeshMapping</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; &amp;map1, const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;target_mesh)</td></tr>
<tr class="separator:ada5438d2745a4b05d0b5e1bc3bf1261a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98476692343c19ce307dd5da1f3bd694"><td class="memTemplParams" colspan="2"><a id="a98476692343c19ce307dd5da1f3bd694" name="a98476692343c19ce307dd5da1f3bd694"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a98476692343c19ce307dd5da1f3bd694"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_attributes</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;from, <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;to, const <a class="el" href="structlagrange_1_1_backward_mesh_mapping.html">BackwardMeshMapping</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; &amp;map)</td></tr>
<tr class="separator:a98476692343c19ce307dd5da1f3bd694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52727eedf93d894521e52dfcf417cd0"><td class="memTemplParams" colspan="2"><a id="af52727eedf93d894521e52dfcf417cd0" name="af52727eedf93d894521e52dfcf417cd0"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:af52727eedf93d894521e52dfcf417cd0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_attributes</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;from, <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;to, const <a class="el" href="structlagrange_1_1_forward_mesh_mapping.html">ForwardMeshMapping</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; &amp;map)</td></tr>
<tr class="separator:af52727eedf93d894521e52dfcf417cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514fae15ed942cdab4fc0a1220ea3169"><td class="memTemplParams" colspan="2"><a id="a514fae15ed942cdab4fc0a1220ea3169" name="a514fae15ed942cdab4fc0a1220ea3169"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a514fae15ed942cdab4fc0a1220ea3169"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_attributes</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;from, <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;to, const std::vector&lt; typename MeshType::Index &gt; &amp;backward_vertex_mapping={}, const std::vector&lt; typename MeshType::Index &gt; &amp;backward_facet_mapping={})</td></tr>
<tr class="separator:a514fae15ed942cdab4fc0a1220ea3169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0728605a2525399540a3addb19c48c95"><td class="memTemplParams" colspan="2"><a id="a0728605a2525399540a3addb19c48c95" name="a0728605a2525399540a3addb19c48c95"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a0728605a2525399540a3addb19c48c95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_corner_attributes</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;from, <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;to)</td></tr>
<tr class="separator:a0728605a2525399540a3addb19c48c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09dd4f44f064fcfd7129547ca1fd4ac"><td class="memTemplParams" colspan="2"><a id="ab09dd4f44f064fcfd7129547ca1fd4ac" name="ab09dd4f44f064fcfd7129547ca1fd4ac"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:ab09dd4f44f064fcfd7129547ca1fd4ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_corner_attributes</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;from, <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;to, const std::vector&lt; typename MeshType::Index &gt; &amp;facet_map)</td></tr>
<tr class="separator:ab09dd4f44f064fcfd7129547ca1fd4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b89b3664ce9d5798a39261951a6879"><td class="memTemplParams" colspan="2"><a id="aa3b89b3664ce9d5798a39261951a6879" name="aa3b89b3664ce9d5798a39261951a6879"></a>
template&lt;typename MeshType1 , typename MeshType2 &gt; </td></tr>
<tr class="memitem:aa3b89b3664ce9d5798a39261951a6879"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_facet_attributes</b> (const MeshType1 &amp;from, MeshType2 &amp;to, const std::vector&lt; typename MeshType1::Index &gt; &amp;facet_map={})</td></tr>
<tr class="separator:aa3b89b3664ce9d5798a39261951a6879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed38f781331cef8bcf7d8ee2890e40f"><td class="memTemplParams" colspan="2"><a id="abed38f781331cef8bcf7d8ee2890e40f" name="abed38f781331cef8bcf7d8ee2890e40f"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:abed38f781331cef8bcf7d8ee2890e40f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_indexed_attributes</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;from, <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;to)</td></tr>
<tr class="separator:abed38f781331cef8bcf7d8ee2890e40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5b3028564ba5b507ac2f90b2a7893d"><td class="memTemplParams" colspan="2"><a id="aeb5b3028564ba5b507ac2f90b2a7893d" name="aeb5b3028564ba5b507ac2f90b2a7893d"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:aeb5b3028564ba5b507ac2f90b2a7893d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_indexed_attributes</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;from, <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;to, const std::vector&lt; typename MeshType::Index &gt; &amp;facet_map)</td></tr>
<tr class="separator:aeb5b3028564ba5b507ac2f90b2a7893d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b13a37f155855e652733d7c751aae5c"><td class="memTemplParams" colspan="2"><a id="a3b13a37f155855e652733d7c751aae5c" name="a3b13a37f155855e652733d7c751aae5c"></a>
template&lt;typename MeshType1 , typename MeshType2 &gt; </td></tr>
<tr class="memitem:a3b13a37f155855e652733d7c751aae5c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_vertex_attributes</b> (const MeshType1 &amp;from, MeshType2 &amp;to, const std::vector&lt; typename MeshType1::Index &gt; &amp;vertex_map={})</td></tr>
<tr class="separator:a3b13a37f155855e652733d7c751aae5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d978337ab3baddfc3c63395ea21167e"><td class="memTemplParams" colspan="2"><a id="a1d978337ab3baddfc3c63395ea21167e" name="a1d978337ab3baddfc3c63395ea21167e"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a1d978337ab3baddfc3c63395ea21167e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rename_vertex_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;old_name, const std::string &amp;new_name)</td></tr>
<tr class="separator:a1d978337ab3baddfc3c63395ea21167e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44662b10e04bbffdd85073790c367399"><td class="memTemplParams" colspan="2"><a id="a44662b10e04bbffdd85073790c367399" name="a44662b10e04bbffdd85073790c367399"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a44662b10e04bbffdd85073790c367399"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rename_facet_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;old_name, const std::string &amp;new_name)</td></tr>
<tr class="separator:a44662b10e04bbffdd85073790c367399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce7304ed72fefa5264201b0cbeddeb0"><td class="memTemplParams" colspan="2"><a id="abce7304ed72fefa5264201b0cbeddeb0" name="abce7304ed72fefa5264201b0cbeddeb0"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:abce7304ed72fefa5264201b0cbeddeb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rename_corner_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;old_name, const std::string &amp;new_name)</td></tr>
<tr class="separator:abce7304ed72fefa5264201b0cbeddeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b3dc923ab913f7b2baee2eeb4daa7f"><td class="memTemplParams" colspan="2"><a id="ad2b3dc923ab913f7b2baee2eeb4daa7f" name="ad2b3dc923ab913f7b2baee2eeb4daa7f"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:ad2b3dc923ab913f7b2baee2eeb4daa7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rename_edge_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;old_name, const std::string &amp;new_name)</td></tr>
<tr class="separator:ad2b3dc923ab913f7b2baee2eeb4daa7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4ccc3c06beeff28b62ea193a5351a2"><td class="memTemplParams" colspan="2"><a id="abd4ccc3c06beeff28b62ea193a5351a2" name="abd4ccc3c06beeff28b62ea193a5351a2"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:abd4ccc3c06beeff28b62ea193a5351a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rename_indexed_attribute</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;old_name, const std::string &amp;new_name)</td></tr>
<tr class="separator:abd4ccc3c06beeff28b62ea193a5351a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634f14b2682ed9274b1a71a92ac369c2"><td class="memTemplParams" colspan="2"><a id="a634f14b2682ed9274b1a71a92ac369c2" name="a634f14b2682ed9274b1a71a92ac369c2"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a634f14b2682ed9274b1a71a92ac369c2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unify_corner_indices</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::vector&lt; std::string &gt; &amp;indexed_attribute_names, std::vector&lt; typename MeshType::Index &gt; &amp;corner_to_unified_index) -&gt; typename MeshType::Index</td></tr>
<tr class="memdesc:a634f14b2682ed9274b1a71a92ac369c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a mapping from mesh corner to a unified index buffer that can be used for positions and all attributes listed in the variable indexed_attribute_names. <br /></td></tr>
<tr class="separator:a634f14b2682ed9274b1a71a92ac369c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c96924879ca0c7a4ff7c71ca41be10"><td class="memTemplParams" colspan="2"><a id="a70c96924879ca0c7a4ff7c71ca41be10" name="a70c96924879ca0c7a4ff7c71ca41be10"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a70c96924879ca0c7a4ff7c71ca41be10"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unify_index_buffer</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::vector&lt; std::string &gt; &amp;indexed_attribute_names)</td></tr>
<tr class="memdesc:a70c96924879ca0c7a4ff7c71ca41be10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a mesh with unified index buffer for positions and all attributes listed in the variable indexed_attribute_names. <br /></td></tr>
<tr class="separator:a70c96924879ca0c7a4ff7c71ca41be10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6ac800f4af8759f6e33c75293f3303"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedC , typename DerivedE , typename DerivedN &gt; </td></tr>
<tr class="memitem:aba6ac800f4af8759f6e33c75293f3303"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#aba6ac800f4af8759f6e33c75293f3303">chain_corners_around_edges</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;facets, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;corner_to_edge, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;edge_to_corner, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;next_corner_around_edge)</td></tr>
<tr class="memdesc:aba6ac800f4af8759f6e33c75293f3303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chains facet corners around edges of a mesh.  <a href="namespacelagrange.html#aba6ac800f4af8759f6e33c75293f3303">More...</a><br /></td></tr>
<tr class="separator:aba6ac800f4af8759f6e33c75293f3303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399123992e37392b20e51735a796d2e1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedE , typename DerivedN &gt; </td></tr>
<tr class="memitem:a399123992e37392b20e51735a796d2e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a399123992e37392b20e51735a796d2e1">chain_corners_around_vertices</a> (typename DerivedF::Scalar num_vertices, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;facets, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;vertex_to_corner, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;next_corner_around_vertex)</td></tr>
<tr class="memdesc:a399123992e37392b20e51735a796d2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chains facet corners around vertices of a mesh.  <a href="namespacelagrange.html#a399123992e37392b20e51735a796d2e1">More...</a><br /></td></tr>
<tr class="separator:a399123992e37392b20e51735a796d2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b77aa6ef7c915c306034bc5f873d69"><td class="memTemplParams" colspan="2">template&lt;typename Index , typename Allocator  = std::list&lt;EdgeType&lt;Index&gt;&gt;&gt; </td></tr>
<tr class="memitem:a51b77aa6ef7c915c306034bc5f873d69"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::list&lt; Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a51b77aa6ef7c915c306034bc5f873d69">chain_edges</a> (const Allocator &amp;edges, bool close_loop=false)</td></tr>
<tr class="memdesc:a51b77aa6ef7c915c306034bc5f873d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain directed edges into either simple linear chain or simple loops.  <a href="namespacelagrange.html#a51b77aa6ef7c915c306034bc5f873d69">More...</a><br /></td></tr>
<tr class="separator:a51b77aa6ef7c915c306034bc5f873d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db43e2c8ec4b75143e325eeb22d0731"><td class="memTemplParams" colspan="2">template&lt;typename Index , typename Allocator  = std::vector&lt;EdgeType&lt;Index&gt;&gt;&gt; </td></tr>
<tr class="memitem:a5db43e2c8ec4b75143e325eeb22d0731"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a5db43e2c8ec4b75143e325eeb22d0731">chain_undirected_edges</a> (const Allocator &amp;edges, bool close_loop=false)</td></tr>
<tr class="memdesc:a5db43e2c8ec4b75143e325eeb22d0731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain undirected edges into chains and loops.  <a href="namespacelagrange.html#a5db43e2c8ec4b75143e325eeb22d0731">More...</a><br /></td></tr>
<tr class="separator:a5db43e2c8ec4b75143e325eeb22d0731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef73c002aad703ba18464d55e6b70c4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedE , typename DerivedO &gt; </td></tr>
<tr class="memitem:a4ef73c002aad703ba18464d55e6b70c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a4ef73c002aad703ba18464d55e6b70c4">chain_edges_into_simple_loops</a> (const Eigen::MatrixBase&lt; DerivedE &gt; &amp;edges, std::vector&lt; std::vector&lt; typename DerivedE::Scalar &gt; &gt; &amp;output, Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;remaining_edges)</td></tr>
<tr class="memdesc:a4ef73c002aad703ba18464d55e6b70c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain edges into simple loops by cutting "ears" progressively from the digraph.  <a href="namespacelagrange.html#a4ef73c002aad703ba18464d55e6b70c4">More...</a><br /></td></tr>
<tr class="separator:a4ef73c002aad703ba18464d55e6b70c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga363707c2e65474638292c738c072868c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga363707c2e65474638292c738c072868c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga363707c2e65474638292c738c072868c">combine_meshes</a> (std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; * &gt; meshes, bool preserve_attributes=true)</td></tr>
<tr class="memdesc:ga363707c2e65474638292c738c072868c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine multiple meshes into a single mesh.  <a href="group__group-surfacemesh-utils.html#ga363707c2e65474638292c738c072868c">More...</a><br /></td></tr>
<tr class="separator:ga363707c2e65474638292c738c072868c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07291901c4f594454dfafb0764f4dad5"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga07291901c4f594454dfafb0764f4dad5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga07291901c4f594454dfafb0764f4dad5">combine_meshes</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &gt; meshes, bool preserve_attributes=true)</td></tr>
<tr class="memdesc:ga07291901c4f594454dfafb0764f4dad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine multiple meshes into a single mesh.  <a href="group__group-surfacemesh-utils.html#ga07291901c4f594454dfafb0764f4dad5">More...</a><br /></td></tr>
<tr class="separator:ga07291901c4f594454dfafb0764f4dad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e874e29c25e3a587a9352147e36772d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga9e874e29c25e3a587a9352147e36772d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga9e874e29c25e3a587a9352147e36772d">combine_meshes</a> (size_t num_meshes, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;(size_t)&gt; get_mesh, bool preserve_attributes=true)</td></tr>
<tr class="memdesc:ga9e874e29c25e3a587a9352147e36772d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine multiple meshes into a single mesh.  <a href="group__group-surfacemesh-utils.html#ga9e874e29c25e3a587a9352147e36772d">More...</a><br /></td></tr>
<tr class="separator:ga9e874e29c25e3a587a9352147e36772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596b1dcf8071e6db70a89205248de29e"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a596b1dcf8071e6db70a89205248de29e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a596b1dcf8071e6db70a89205248de29e">move_data</a> (Eigen::DenseBase&lt; Derived1 &gt; &amp;from, Eigen::DenseBase&lt; Derived2 &gt; &amp;to)</td></tr>
<tr class="memdesc:a596b1dcf8071e6db70a89205248de29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move data from one Eigen obj to another.  <a href="namespacelagrange.html#a596b1dcf8071e6db70a89205248de29e">More...</a><br /></td></tr>
<tr class="separator:a596b1dcf8071e6db70a89205248de29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27570b092da991a8e36c8fe8747a33dd"><td class="memTemplParams" colspan="2"><a id="a27570b092da991a8e36c8fe8747a33dd" name="a27570b092da991a8e36c8fe8747a33dd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a27570b092da991a8e36c8fe8747a33dd"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_shared_ptr</b> (std::unique_ptr&lt; T &gt; &amp;&amp;ptr)</td></tr>
<tr class="memdesc:a27570b092da991a8e36c8fe8747a33dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for automatic type deduction for unique_ptr to shared_ptr conversion. <br /></td></tr>
<tr class="separator:a27570b092da991a8e36c8fe8747a33dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531e4540e0c06856419af02817540e1a"><td class="memTemplParams" colspan="2"><a id="a531e4540e0c06856419af02817540e1a" name="a531e4540e0c06856419af02817540e1a"></a>
template&lt;typename PointType &gt; </td></tr>
<tr class="memitem:a531e4540e0c06856419af02817540e1a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_barycentric_coordinates</b> (const Eigen::MatrixBase&lt; PointType &gt; &amp;v0, const Eigen::MatrixBase&lt; PointType &gt; &amp;v1, const Eigen::MatrixBase&lt; PointType &gt; &amp;v2, const Eigen::MatrixBase&lt; PointType &gt; &amp;p) -&gt; Eigen::Matrix&lt; typename PointType::Scalar, 3, 1 &gt;</td></tr>
<tr class="separator:a531e4540e0c06856419af02817540e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad253ff882a7b1575007e0248d133ca06"><td class="memTemplParams" colspan="2"><a id="ad253ff882a7b1575007e0248d133ca06" name="ad253ff882a7b1575007e0248d133ca06"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:ad253ff882a7b1575007e0248d133ca06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_compute_bordered_components_output.html">ComputeBorderedComponentsOutput</a>&lt; typename MeshType::Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_bordered_components</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::vector&lt; bool &gt; &amp;is_edge_passable)</td></tr>
<tr class="separator:ad253ff882a7b1575007e0248d133ca06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafedc8c0d66af62d6f3d540465c0018c6"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gafedc8c0d66af62d6f3d540465c0018c6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gafedc8c0d66af62d6f3d540465c0018c6">compute_components</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_component_options.html">ComponentOptions</a> options={})</td></tr>
<tr class="memdesc:gafedc8c0d66af62d6f3d540465c0018c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute connected components of an input mesh.  <a href="group__group-surfacemesh-utils.html#gafedc8c0d66af62d6f3d540465c0018c6">More...</a><br /></td></tr>
<tr class="separator:gafedc8c0d66af62d6f3d540465c0018c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72621a5c87d3f495ea90004d8361e54b"><td class="memTemplParams" colspan="2"><a id="a72621a5c87d3f495ea90004d8361e54b" name="a72621a5c87d3f495ea90004d8361e54b"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a72621a5c87d3f495ea90004d8361e54b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_dihedral_angles</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="separator:a72621a5c87d3f495ea90004d8361e54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec0711a4ce084365257bba2f48a4f6b"><td class="memTemplParams" colspan="2"><a id="a2ec0711a4ce084365257bba2f48a4f6b" name="a2ec0711a4ce084365257bba2f48a4f6b"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a2ec0711a4ce084365257bba2f48a4f6b"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; std::pair&lt; typename MeshType::Index, typename MeshType::Scalar &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_dijkstra_distance</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, typename MeshType::Index seed_facet_id, const Eigen::Matrix&lt; typename MeshType::Scalar, 3, 1 &gt; &amp;bc, typename MeshType::Scalar radius=0.0)</td></tr>
<tr class="separator:a2ec0711a4ce084365257bba2f48a4f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904b8b9e92eb32c9482afd84dc824e0e"><td class="memTemplParams" colspan="2"><a id="a904b8b9e92eb32c9482afd84dc824e0e" name="a904b8b9e92eb32c9482afd84dc824e0e"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a904b8b9e92eb32c9482afd84dc824e0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_edge_lengths</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="separator:a904b8b9e92eb32c9482afd84dc824e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3681a43a3486bd6a6f04ef43ffc44f41"><td class="memTemplParams" colspan="2"><a id="a3681a43a3486bd6a6f04ef43ffc44f41" name="a3681a43a3486bd6a6f04ef43ffc44f41"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a3681a43a3486bd6a6f04ef43ffc44f41"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_euler</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="separator:a3681a43a3486bd6a6f04ef43ffc44f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9835bf23b960be3fa3b6f975286b22bc"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a9835bf23b960be3fa3b6f975286b22bc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a9835bf23b960be3fa3b6f975286b22bc">compute_facet_area_raw</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh) -&gt; AttributeArrayOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;</td></tr>
<tr class="memdesc:a9835bf23b960be3fa3b6f975286b22bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the facet areas.  <a href="namespacelagrange.html#a9835bf23b960be3fa3b6f975286b22bc">More...</a><br /></td></tr>
<tr class="separator:a9835bf23b960be3fa3b6f975286b22bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a6397294320512fc58eec12cf5ae33"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:ab6a6397294320512fc58eec12cf5ae33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ab6a6397294320512fc58eec12cf5ae33">compute_facet_area</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="memdesc:ab6a6397294320512fc58eec12cf5ae33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the facet areas.  <a href="namespacelagrange.html#ab6a6397294320512fc58eec12cf5ae33">More...</a><br /></td></tr>
<tr class="separator:ab6a6397294320512fc58eec12cf5ae33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435ef10e7db480d7518a0a151c6e6a94"><td class="memTemplParams" colspan="2">template&lt;typename DerivedUV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a435ef10e7db480d7518a0a151c6e6a94"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename DerivedUV::Scalar, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a435ef10e7db480d7518a0a151c6e6a94">compute_uv_area_raw</a> (const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;uv, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;triangles)</td></tr>
<tr class="memdesc:a435ef10e7db480d7518a0a151c6e6a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the uv areas.  <a href="namespacelagrange.html#a435ef10e7db480d7518a0a151c6e6a94">More...</a><br /></td></tr>
<tr class="separator:a435ef10e7db480d7518a0a151c6e6a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50e835144b2dd2ad5df9848293c8b097"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga50e835144b2dd2ad5df9848293c8b097"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga50e835144b2dd2ad5df9848293c8b097">compute_facet_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_facet_normal_options.html">FacetNormalOptions</a> options={})</td></tr>
<tr class="memdesc:ga50e835144b2dd2ad5df9848293c8b097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute facet normals.  <a href="group__group-surfacemesh-utils.html#ga50e835144b2dd2ad5df9848293c8b097">More...</a><br /></td></tr>
<tr class="separator:ga50e835144b2dd2ad5df9848293c8b097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa206c248b9cde673400c6c87cdecdc1e"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> , typename Cloud , typename Indices &gt; </td></tr>
<tr class="memitem:aa206c248b9cde673400c6c87cdecdc1e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#aa206c248b9cde673400c6c87cdecdc1e">compute_lift_operator_from_sampling</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const Cloud &amp;closest_points, const Indices &amp;element_indices)</td></tr>
<tr class="memdesc:aa206c248b9cde673400c6c87cdecdc1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This compute the sparse bilinear map from mesh vertex attributes to point cloud attributes.  <a href="namespacelagrange.html#aa206c248b9cde673400c6c87cdecdc1e">More...</a><br /></td></tr>
<tr class="separator:aa206c248b9cde673400c6c87cdecdc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91612133420080167e84167a8bb139c4"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> , typename ClosestPoints &gt; </td></tr>
<tr class="memitem:a91612133420080167e84167a8bb139c4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a91612133420080167e84167a8bb139c4">compute_lift_operator_from_projections</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const ClosestPoints &amp;projections)</td></tr>
<tr class="memdesc:a91612133420080167e84167a8bb139c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This compute the sparse bilinear map from mesh vertex attributes to point cloud attributes.  <a href="namespacelagrange.html#a91612133420080167e84167a8bb139c4">More...</a><br /></td></tr>
<tr class="separator:a91612133420080167e84167a8bb139c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18da076b770da8ab68e8ef63f1796c0c"><td class="memTemplParams" colspan="2"><a id="a18da076b770da8ab68e8ef63f1796c0c" name="a18da076b770da8ab68e8ef63f1796c0c"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a18da076b770da8ab68e8ef63f1796c0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_compute_mesh_centroid_output.html">ComputeMeshCentroidOutput</a>&lt; typename MeshType::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_mesh_centroid</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh_ref, const typename MeshType::IndexList &amp;active_facets=typename MeshType::IndexList())</td></tr>
<tr class="separator:a18da076b770da8ab68e8ef63f1796c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedb47dc16b45f83e511c9725b1c1c54"><td class="memTemplParams" colspan="2"><a id="adedb47dc16b45f83e511c9725b1c1c54" name="adedb47dc16b45f83e511c9725b1c1c54"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:adedb47dc16b45f83e511c9725b1c1c54"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename MeshType::Scalar, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_mesh_covariance</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh_ref, const typename MeshType::VertexType &amp;center, const typename MeshType::IndexList &amp;active_facets=typename MeshType::IndexList())</td></tr>
<tr class="separator:adedb47dc16b45f83e511c9725b1c1c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1dc948d0cb8aa8b7759e34a34df7bc"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga0d1dc948d0cb8aa8b7759e34a34df7bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga0d1dc948d0cb8aa8b7759e34a34df7bc">compute_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; bool(Index)&gt; is_edge_smooth, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; cone_vertices={}, <a class="el" href="structlagrange_1_1_normal_options.html">NormalOptions</a> options={})</td></tr>
<tr class="memdesc:ga0d1dc948d0cb8aa8b7759e34a34df7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute smooth normals based on specified sharp edges and cone vertices.  <a href="group__group-surfacemesh-utils.html#ga0d1dc948d0cb8aa8b7759e34a34df7bc">More...</a><br /></td></tr>
<tr class="separator:ga0d1dc948d0cb8aa8b7759e34a34df7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe91547f24b4936c8feddd9b74b1aa02"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gabe91547f24b4936c8feddd9b74b1aa02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gabe91547f24b4936c8feddd9b74b1aa02">compute_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; bool(Index, Index)&gt; is_edge_smooth, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; cone_vertices={}, <a class="el" href="structlagrange_1_1_normal_options.html">NormalOptions</a> options={})</td></tr>
<tr class="memdesc:gabe91547f24b4936c8feddd9b74b1aa02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute smooth normals based on specified sharp edges and cone vertices.  <a href="group__group-surfacemesh-utils.html#gabe91547f24b4936c8feddd9b74b1aa02">More...</a><br /></td></tr>
<tr class="separator:gabe91547f24b4936c8feddd9b74b1aa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga668cc68bd27510b1bec92cf8dbe0e362"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga668cc68bd27510b1bec92cf8dbe0e362"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga668cc68bd27510b1bec92cf8dbe0e362">compute_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Scalar feature_angle_threshold, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; cone_vertices={}, <a class="el" href="structlagrange_1_1_normal_options.html">NormalOptions</a> options={})</td></tr>
<tr class="memdesc:ga668cc68bd27510b1bec92cf8dbe0e362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute smooth normal based on specified dihedral angle threshold and cone vertices.  <a href="group__group-surfacemesh-utils.html#ga668cc68bd27510b1bec92cf8dbe0e362">More...</a><br /></td></tr>
<tr class="separator:ga668cc68bd27510b1bec92cf8dbe0e362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277e71c6ccbc8a351cdf53a17333fdef"><td class="memTemplParams" colspan="2"><a id="a277e71c6ccbc8a351cdf53a17333fdef" name="a277e71c6ccbc8a351cdf53a17333fdef"></a>
template&lt;typename Derived1 &gt; </td></tr>
<tr class="memitem:a277e71c6ccbc8a351cdf53a17333fdef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_compute_pointcloud_p_c_a_output.html">ComputePointcloudPCAOutput</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_pointcloud_pca</b> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;points, const bool should_shift_centeroid, const bool should_normalize)</td></tr>
<tr class="separator:a277e71c6ccbc8a351cdf53a17333fdef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0b89e21157c268e2931da3910bc2930"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gac0b89e21157c268e2931da3910bc2930"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_tangent_bitangent_result.html">TangentBitangentResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gac0b89e21157c268e2931da3910bc2930">compute_tangent_bitangent</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_tangent_bitangent_options.html">TangentBitangentOptions</a> options={})</td></tr>
<tr class="memdesc:gac0b89e21157c268e2931da3910bc2930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mesh tangent and bitangent vectors orthogonal to the input mesh normals.  <a href="group__group-surfacemesh-utils.html#gac0b89e21157c268e2931da3910bc2930">More...</a><br /></td></tr>
<tr class="separator:gac0b89e21157c268e2931da3910bc2930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11deb081022f3bfef8d2b527fb605f21"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a11deb081022f3bfef8d2b527fb605f21"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a11deb081022f3bfef8d2b527fb605f21">compute_uv_distortion</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="memdesc:a11deb081022f3bfef8d2b527fb605f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the distortion of mapping from 3D triangular mesh to UV domain.  <a href="namespacelagrange.html#a11deb081022f3bfef8d2b527fb605f21">More...</a><br /></td></tr>
<tr class="separator:a11deb081022f3bfef8d2b527fb605f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c1ac1ec1658273f6e6bb312dd2b0718"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga8c1ac1ec1658273f6e6bb312dd2b0718"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga8c1ac1ec1658273f6e6bb312dd2b0718">compute_vertex_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_vertex_normal_options.html">VertexNormalOptions</a> options={})</td></tr>
<tr class="memdesc:ga8c1ac1ec1658273f6e6bb312dd2b0718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute per-vertex normals based on specified weighting type.  <a href="group__group-surfacemesh-utils.html#ga8c1ac1ec1658273f6e6bb312dd2b0718">More...</a><br /></td></tr>
<tr class="separator:ga8c1ac1ec1658273f6e6bb312dd2b0718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a2a7d7f5165ef7f5433ef67efad4306"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga6a2a7d7f5165ef7f5433ef67efad4306"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga6a2a7d7f5165ef7f5433ef67efad4306">compute_vertex_valence</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_vertex_valence_options.html">VertexValenceOptions</a> options={})</td></tr>
<tr class="memdesc:ga6a2a7d7f5165ef7f5433ef67efad4306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vertex valence.  <a href="group__group-surfacemesh-utils.html#ga6a2a7d7f5165ef7f5433ef67efad4306">More...</a><br /></td></tr>
<tr class="separator:ga6a2a7d7f5165ef7f5433ef67efad4306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga203af050581e879b52d339558b788a08"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga203af050581e879b52d339558b788a08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_adjacency_list.html">AdjacencyList</a>&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga203af050581e879b52d339558b788a08">compute_vertex_vertex_adjacency</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga203af050581e879b52d339558b788a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vertex-vertex adjacency information.  <a href="group__group-surfacemesh-utils.html#ga203af050581e879b52d339558b788a08">More...</a><br /></td></tr>
<tr class="separator:ga203af050581e879b52d339558b788a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa13892cc06d31d64e6613c3e48785591"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gaa13892cc06d31d64e6613c3e48785591"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gaa13892cc06d31d64e6613c3e48785591">compute_weighted_corner_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_corner_normal_options.html">CornerNormalOptions</a> option={})</td></tr>
<tr class="memdesc:gaa13892cc06d31d64e6613c3e48785591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute corner normals.  <a href="group__group-surfacemesh-utils.html#gaa13892cc06d31d64e6613c3e48785591">More...</a><br /></td></tr>
<tr class="separator:gaa13892cc06d31d64e6613c3e48785591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15165d8222baf73660ae90093c73bc62"><td class="memTemplParams" colspan="2"><a id="a15165d8222baf73660ae90093c73bc62" name="a15165d8222baf73660ae90093c73bc62"></a>
template&lt;typename GeometryType &gt; </td></tr>
<tr class="memitem:a15165d8222baf73660ae90093c73bc62"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_connectivity.html">Connectivity</a>&lt; GeometryType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_connectivity</b> (const GeometryType &amp;geometry)</td></tr>
<tr class="separator:a15165d8222baf73660ae90093c73bc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34583bdda68644dcd9c7175ce179735"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedC &gt; </td></tr>
<tr class="memitem:ad34583bdda68644dcd9c7175ce179735"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ad34583bdda68644dcd9c7175ce179735">corner_to_edge_mapping</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C2E)</td></tr>
<tr class="memdesc:ad34583bdda68644dcd9c7175ce179735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a mapping from mesh corners (k*f+i) to unique edge ids.  <a href="namespacelagrange.html#ad34583bdda68644dcd9c7175ce179735">More...</a><br /></td></tr>
<tr class="separator:ad34583bdda68644dcd9c7175ce179735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89c020d34ca2baf555d24beb0023062"><td class="memTemplParams" colspan="2"><a id="aa89c020d34ca2baf555d24beb0023062" name="aa89c020d34ca2baf555d24beb0023062"></a>
template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:aa89c020d34ca2baf555d24beb0023062"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; DerivedV, DerivedF &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_empty_mesh</b> ()</td></tr>
<tr class="separator:aa89c020d34ca2baf555d24beb0023062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dff747c765bd02e34d420ab60c30358"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a5dff747c765bd02e34d420ab60c30358"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a5dff747c765bd02e34d420ab60c30358">create_mesh</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;vertices, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;facets)</td></tr>
<tr class="memdesc:a5dff747c765bd02e34d420ab60c30358"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function create a new mesh given the vertex and facet arrays by copying data into the <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object.  <a href="namespacelagrange.html#a5dff747c765bd02e34d420ab60c30358">More...</a><br /></td></tr>
<tr class="separator:a5dff747c765bd02e34d420ab60c30358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09136a41b52bcbc4f39fc5c62f64e50f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a09136a41b52bcbc4f39fc5c62f64e50f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; DerivedV, DerivedF &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a09136a41b52bcbc4f39fc5c62f64e50f">create_mesh</a> (Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&amp;vertices, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&amp;facets)</td></tr>
<tr class="memdesc:a09136a41b52bcbc4f39fc5c62f64e50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function create a new mesh given the vertex and facet arrays by moving data into the <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object.  <a href="namespacelagrange.html#a09136a41b52bcbc4f39fc5c62f64e50f">More...</a><br /></td></tr>
<tr class="separator:a09136a41b52bcbc4f39fc5c62f64e50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fab68ec28d0bc476bfb139549db822"><td class="memTemplParams" colspan="2"><a id="a88fab68ec28d0bc476bfb139549db822" name="a88fab68ec28d0bc476bfb139549db822"></a>
template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a88fab68ec28d0bc476bfb139549db822"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; DerivedV, DerivedF &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_mesh</b> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;vertices, Eigen::MatrixBase&lt; DerivedF &gt; &amp;&amp;facets)</td></tr>
<tr class="separator:a88fab68ec28d0bc476bfb139549db822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8918eb55e4dc6664e469cb9229464206"><td class="memTemplParams" colspan="2"><a id="a8918eb55e4dc6664e469cb9229464206" name="a8918eb55e4dc6664e469cb9229464206"></a>
template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a8918eb55e4dc6664e469cb9229464206"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; DerivedV, DerivedF &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_mesh</b> (Eigen::MatrixBase&lt; DerivedV &gt; &amp;&amp;vertices, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;facets)</td></tr>
<tr class="separator:a8918eb55e4dc6664e469cb9229464206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe650b7cf9ca2f348fbf4791d148706"><td class="memTemplParams" colspan="2">template&lt;typename VertexArray , typename FacetArray &gt; </td></tr>
<tr class="memitem:abfe650b7cf9ca2f348fbf4791d148706"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#abfe650b7cf9ca2f348fbf4791d148706">wrap_with_mesh</a> (const Eigen::MatrixBase&lt; VertexArray &gt; &amp;vertices, const Eigen::MatrixBase&lt; FacetArray &gt; &amp;facets)</td></tr>
<tr class="memdesc:abfe650b7cf9ca2f348fbf4791d148706"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method creates a <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object that wraps around vertices and facets.  <a href="namespacelagrange.html#abfe650b7cf9ca2f348fbf4791d148706">More...</a><br /></td></tr>
<tr class="separator:abfe650b7cf9ca2f348fbf4791d148706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88df16eeb7c20eb43ec2f45eda44106"><td class="memTemplParams" colspan="2"><a id="af88df16eeb7c20eb43ec2f45eda44106" name="af88df16eeb7c20eb43ec2f45eda44106"></a>
template&lt;typename VertexArray , typename FacetArray &gt; </td></tr>
<tr class="memitem:af88df16eeb7c20eb43ec2f45eda44106"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wrap_with_mesh</b> (const Eigen::MatrixBase&lt; VertexArray &gt; &amp;&amp;, const Eigen::MatrixBase&lt; FacetArray &gt; &amp;&amp;)</td></tr>
<tr class="separator:af88df16eeb7c20eb43ec2f45eda44106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1c0cae95505eb5a40b85ed795f1bf7"><td class="memTemplParams" colspan="2"><a id="aac1c0cae95505eb5a40b85ed795f1bf7" name="aac1c0cae95505eb5a40b85ed795f1bf7"></a>
template&lt;typename VertexArray , typename FacetArray &gt; </td></tr>
<tr class="memitem:aac1c0cae95505eb5a40b85ed795f1bf7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wrap_with_mesh</b> (const Eigen::MatrixBase&lt; VertexArray &gt; &amp;, const Eigen::MatrixBase&lt; FacetArray &gt; &amp;&amp;)</td></tr>
<tr class="separator:aac1c0cae95505eb5a40b85ed795f1bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0af21be643059e9e33a2b7e09cbbce"><td class="memTemplParams" colspan="2"><a id="a8b0af21be643059e9e33a2b7e09cbbce" name="a8b0af21be643059e9e33a2b7e09cbbce"></a>
template&lt;typename VertexArray , typename FacetArray &gt; </td></tr>
<tr class="memitem:a8b0af21be643059e9e33a2b7e09cbbce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wrap_with_mesh</b> (const Eigen::MatrixBase&lt; VertexArray &gt; &amp;&amp;, const Eigen::MatrixBase&lt; FacetArray &gt; &amp;)</td></tr>
<tr class="separator:a8b0af21be643059e9e33a2b7e09cbbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8bcd4939a21ed624de2c6d9fd281eb"><td class="memItemLeft" align="right" valign="top"><a id="a3e8bcd4939a21ed624de2c6d9fd281eb" name="a3e8bcd4939a21ed624de2c6d9fd281eb"></a>
std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">TriangleMesh3D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>create_cube</b> ()</td></tr>
<tr class="separator:a3e8bcd4939a21ed624de2c6d9fd281eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9413b6be0c30efd8eaf93d8b30c6b058"><td class="memItemLeft" align="right" valign="top"><a id="a9413b6be0c30efd8eaf93d8b30c6b058" name="a9413b6be0c30efd8eaf93d8b30c6b058"></a>
std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">TriangleMesh3D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>create_quad</b> (bool with_center_vertex)</td></tr>
<tr class="separator:a9413b6be0c30efd8eaf93d8b30c6b058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d0f9c1a4c8b1d92aaecbdb8e825a8a"><td class="memItemLeft" align="right" valign="top"><a id="ac5d0f9c1a4c8b1d92aaecbdb8e825a8a" name="ac5d0f9c1a4c8b1d92aaecbdb8e825a8a"></a>
std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">TriangleMesh3D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>create_sphere</b> (double refine_order=2)</td></tr>
<tr class="separator:ac5d0f9c1a4c8b1d92aaecbdb8e825a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cdafa30dddf4bc9f22b481579f9615"><td class="memTemplParams" colspan="2"><a id="a70cdafa30dddf4bc9f22b481579f9615" name="a70cdafa30dddf4bc9f22b481579f9615"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a70cdafa30dddf4bc9f22b481579f9615"><td class="memTemplItemLeft" align="right" valign="top">EdgeFacetMap&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_edge_facet_map_in_active_facets</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::unordered_set&lt; typename MeshType::Index &gt; &amp;active_facets)</td></tr>
<tr class="separator:a70cdafa30dddf4bc9f22b481579f9615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01cfa23660cbbc1151d3816d7acdfc20"><td class="memTemplParams" colspan="2"><a id="a01cfa23660cbbc1151d3816d7acdfc20" name="a01cfa23660cbbc1151d3816d7acdfc20"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a01cfa23660cbbc1151d3816d7acdfc20"><td class="memTemplItemLeft" align="right" valign="top">EdgeFacetMap&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_edge_facet_map_in_active_vertices</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::unordered_set&lt; typename MeshType::Index &gt; &amp;active_vertices)</td></tr>
<tr class="separator:a01cfa23660cbbc1151d3816d7acdfc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf0999f20e8aa0f9e6d2a2fe6c17cd2"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:abbf0999f20e8aa0f9e6d2a2fe6c17cd2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; typename MeshType::Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#abbf0999f20e8aa0f9e6d2a2fe6c17cd2">extract_boundary_loops</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="memdesc:abbf0999f20e8aa0f9e6d2a2fe6c17cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract boundary loops.  <a href="namespacelagrange.html#abbf0999f20e8aa0f9e6d2a2fe6c17cd2">More...</a><br /></td></tr>
<tr class="separator:abbf0999f20e8aa0f9e6d2a2fe6c17cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3fc8c7a1b0d2860cdeb8d8e2fcec4c"><td class="memTemplParams" colspan="2"><a id="aba3fc8c7a1b0d2860cdeb8d8e2fcec4c" name="aba3fc8c7a1b0d2860cdeb8d8e2fcec4c"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:aba3fc8c7a1b0d2860cdeb8d8e2fcec4c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>extract_component_submeshes</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, std::vector&lt; std::vector&lt; typename MeshType::Index &gt; &gt; *vertex_mappings=nullptr, std::vector&lt; std::vector&lt; typename MeshType::Index &gt; &gt; *facet_mappings=nullptr)</td></tr>
<tr class="separator:aba3fc8c7a1b0d2860cdeb8d8e2fcec4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edea6eb3aad4001f99691a5a29d7158"><td class="memTemplParams" colspan="2"><a id="a0edea6eb3aad4001f99691a5a29d7158" name="a0edea6eb3aad4001f99691a5a29d7158"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> , typename Index &gt; </td></tr>
<tr class="memitem:a0edea6eb3aad4001f99691a5a29d7158"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>extract_submeshes</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;facet_groups, std::vector&lt; std::vector&lt; Index &gt; &gt; *vertex_mappings=nullptr, std::vector&lt; std::vector&lt; Index &gt; &gt; *facet_mappings=nullptr)</td></tr>
<tr class="separator:a0edea6eb3aad4001f99691a5a29d7158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc1411b0b8fc2bfae9aae5d5bb29931"><td class="memTemplParams" colspan="2"><a id="a5fc1411b0b8fc2bfae9aae5d5bb29931" name="a5fc1411b0b8fc2bfae9aae5d5bb29931"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> , typename Index &gt; </td></tr>
<tr class="memitem:a5fc1411b0b8fc2bfae9aae5d5bb29931"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>extract_submesh</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::vector&lt; Index &gt; &amp;selected_facets, std::vector&lt; Index &gt; *vertex_mapping=nullptr, std::vector&lt; Index &gt; *facet_mapping=nullptr)</td></tr>
<tr class="separator:a5fc1411b0b8fc2bfae9aae5d5bb29931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db722a97001dc3f5618f31db239aeb6"><td class="memTemplParams" colspan="2"><a id="a7db722a97001dc3f5618f31db239aeb6" name="a7db722a97001dc3f5618f31db239aeb6"></a>
template&lt;typename _VertexArray , typename _FacetArray , typename Archive &gt; </td></tr>
<tr class="memitem:a7db722a97001dc3f5618f31db239aeb6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (std::shared_ptr&lt; <a class="el" href="classlagrange_1_1_mesh_geometry.html">MeshGeometry</a>&lt; _VertexArray, _FacetArray &gt; &gt; &amp;geometry, Archive &amp;ar)</td></tr>
<tr class="separator:a7db722a97001dc3f5618f31db239aeb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3fafb51e675e82180cf15b45ab63f7"><td class="memTemplParams" colspan="2"><a id="afd3fafb51e675e82180cf15b45ab63f7" name="afd3fafb51e675e82180cf15b45ab63f7"></a>
template&lt;typename DerivedF &gt; </td></tr>
<tr class="memitem:afd3fafb51e675e82180cf15b45ab63f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_edge_type.html">EdgeType</a>&lt; typename DerivedF::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_opposite_edge</b> (const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;facets, typename DerivedF::Scalar fid, typename DerivedF::Scalar vid)</td></tr>
<tr class="separator:afd3fafb51e675e82180cf15b45ab63f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97e3b3adabf67bc7d3650ed14214ddaa"><td class="memItemLeft" align="right" valign="top">spdlog::logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-logger.html#ga97e3b3adabf67bc7d3650ed14214ddaa">logger</a> ()</td></tr>
<tr class="memdesc:ga97e3b3adabf67bc7d3650ed14214ddaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current logger.  <a href="group__group-logger.html#ga97e3b3adabf67bc7d3650ed14214ddaa">More...</a><br /></td></tr>
<tr class="separator:ga97e3b3adabf67bc7d3650ed14214ddaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f17bae29eab16304d0f5a71f383ae15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-logger.html#ga8f17bae29eab16304d0f5a71f383ae15">set_logger</a> (std::shared_ptr&lt; spdlog::logger &gt; <a class="el" href="group__group-logger.html#ga97e3b3adabf67bc7d3650ed14214ddaa">logger</a>)</td></tr>
<tr class="memdesc:ga8f17bae29eab16304d0f5a71f383ae15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup a logger object to be used by Lagrange.  <a href="group__group-logger.html#ga8f17bae29eab16304d0f5a71f383ae15">More...</a><br /></td></tr>
<tr class="separator:ga8f17bae29eab16304d0f5a71f383ae15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51ee322b2cbe6d36fe651b3a6c3b016"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> , typename ValueFn &gt; </td></tr>
<tr class="memitem:aa51ee322b2cbe6d36fe651b3a6c3b016"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_marching_triangles_output.html">MarchingTrianglesOutput</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#aa51ee322b2cbe6d36fe651b3a6c3b016">marching_triangles_general</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh_ref, ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; isovalue, const ValueFn &amp;get_value)</td></tr>
<tr class="memdesc:aa51ee322b2cbe6d36fe651b3a6c3b016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform marching triangles to extract isocontour on a field defined as the linear interpolation of values provided by the <code>get_value</code> function.  <a href="namespacelagrange.html#aa51ee322b2cbe6d36fe651b3a6c3b016">More...</a><br /></td></tr>
<tr class="separator:aa51ee322b2cbe6d36fe651b3a6c3b016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d040cdabfc1e30a4b49bce76d33951"><td class="memTemplParams" colspan="2"><a id="a46d040cdabfc1e30a4b49bce76d33951" name="a46d040cdabfc1e30a4b49bce76d33951"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a46d040cdabfc1e30a4b49bce76d33951"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_marching_triangles_output.html">MarchingTrianglesOutput</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>marching_triangles</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh_ref, const typename MeshType::Scalar isovalue, const std::string vertex_attribute_name, const typename MeshType::Index attribute_col_index=0)</td></tr>
<tr class="separator:a46d040cdabfc1e30a4b49bce76d33951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfb354b3bbbbf57858696d3ecd9b9a9"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a9dfb354b3bbbbf57858696d3ecd9b9a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_marching_triangles_output.html">MarchingTrianglesOutput</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a9dfb354b3bbbbf57858696d3ecd9b9a9">marching_triangles_indexed</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh_ref, const typename MeshType::Scalar isovalue, const std::string indexed_attribute_name, const typename MeshType::Index attribute_col_index=0)</td></tr>
<tr class="memdesc:a9dfb354b3bbbbf57858696d3ecd9b9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform marching triangles to extract isocontours on a field defined as the linear interpolation of an indexed attribute.  <a href="namespacelagrange.html#a9dfb354b3bbbbf57858696d3ecd9b9a9">More...</a><br /></td></tr>
<tr class="separator:a9dfb354b3bbbbf57858696d3ecd9b9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af647006c4fc4e0b1c0b12edb5938c6be"><td class="memTemplParams" colspan="2"><a id="af647006c4fc4e0b1c0b12edb5938c6be" name="af647006c4fc4e0b1c0b12edb5938c6be"></a>
template&lt;typename _VertexArray , typename _FacetArray , typename Archive &gt; </td></tr>
<tr class="memitem:af647006c4fc4e0b1c0b12edb5938c6be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (<a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; _VertexArray, _FacetArray &gt; &amp;mesh, Archive &amp;ar)</td></tr>
<tr class="separator:af647006c4fc4e0b1c0b12edb5938c6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c713bb92572ae9d774b15c70e5d7b2c"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a0c713bb92572ae9d774b15c70e5d7b2c"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a0c713bb92572ae9d774b15c70e5d7b2c">close_small_holes</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, size_t max_hole_size)</td></tr>
<tr class="memdesc:a0c713bb92572ae9d774b15c70e5d7b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close small topological holes.  <a href="namespacelagrange.html#a0c713bb92572ae9d774b15c70e5d7b2c">More...</a><br /></td></tr>
<tr class="separator:a0c713bb92572ae9d774b15c70e5d7b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adc3699819a2561aa851032f55258bb"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a0adc3699819a2561aa851032f55258bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a0adc3699819a2561aa851032f55258bb">detect_degenerate_triangles</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="memdesc:a0adc3699819a2561aa851032f55258bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a per-facet attribute indicating whether the given facet is degenerate.  <a href="namespacelagrange.html#a0adc3699819a2561aa851032f55258bb">More...</a><br /></td></tr>
<tr class="separator:a0adc3699819a2561aa851032f55258bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c8e0e1f395eaf592ea4f5dfedb45ed"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a73c8e0e1f395eaf592ea4f5dfedb45ed"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a73c8e0e1f395eaf592ea4f5dfedb45ed">is_vertex_manifold</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="memdesc:a73c8e0e1f395eaf592ea4f5dfedb45ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the input mesh is vertex manifold for all vertices.  <a href="namespacelagrange.html#a73c8e0e1f395eaf592ea4f5dfedb45ed">More...</a><br /></td></tr>
<tr class="separator:a73c8e0e1f395eaf592ea4f5dfedb45ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3518ef6f65b91c6c00242ce35ecca33f"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a3518ef6f65b91c6c00242ce35ecca33f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a3518ef6f65b91c6c00242ce35ecca33f">remove_degenerate_triangles</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="memdesc:a3518ef6f65b91c6c00242ce35ecca33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all exactly degenerate triangles.  <a href="namespacelagrange.html#a3518ef6f65b91c6c00242ce35ecca33f">More...</a><br /></td></tr>
<tr class="separator:a3518ef6f65b91c6c00242ce35ecca33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f2984c59adaa383c9c14699503a6c0"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a00f2984c59adaa383c9c14699503a6c0"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a00f2984c59adaa383c9c14699503a6c0">remove_duplicate_facets</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="memdesc:a00f2984c59adaa383c9c14699503a6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal all duplicate facets from the mesh.  <a href="namespacelagrange.html#a00f2984c59adaa383c9c14699503a6c0">More...</a><br /></td></tr>
<tr class="separator:a00f2984c59adaa383c9c14699503a6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea9552f344f9f4f84cb57b13b583eeb"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a1ea9552f344f9f4f84cb57b13b583eeb"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a1ea9552f344f9f4f84cb57b13b583eeb">remove_duplicate_vertices</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::vector&lt; std::string &gt; &amp;vertex_attribute_names, const std::vector&lt; std::string &gt; &amp;indexed_attribute_names={})</td></tr>
<tr class="memdesc:a1ea9552f344f9f4f84cb57b13b583eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicated vertices.  <a href="namespacelagrange.html#a1ea9552f344f9f4f84cb57b13b583eeb">More...</a><br /></td></tr>
<tr class="separator:a1ea9552f344f9f4f84cb57b13b583eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaac1f982b99fdb3f355b30efed7b53"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:aacaac1f982b99fdb3f355b30efed7b53"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#aacaac1f982b99fdb3f355b30efed7b53">remove_duplicate_vertices</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::string &amp;key_name=&quot;&quot;, bool with_uv=true)</td></tr>
<tr class="memdesc:aacaac1f982b99fdb3f355b30efed7b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all duplicate vertices for mesh.  <a href="namespacelagrange.html#aacaac1f982b99fdb3f355b30efed7b53">More...</a><br /></td></tr>
<tr class="separator:aacaac1f982b99fdb3f355b30efed7b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7bfe9f6780d0347feb6d41140d4c5b"><td class="memTemplParams" colspan="2"><a id="a5a7bfe9f6780d0347feb6d41140d4c5b" name="a5a7bfe9f6780d0347feb6d41140d4c5b"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a5a7bfe9f6780d0347feb6d41140d4c5b"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>remove_isolated_vertices</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="separator:a5a7bfe9f6780d0347feb6d41140d4c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4226507435e9b10a93fff49a955e1a"><td class="memTemplParams" colspan="2"><a id="a6d4226507435e9b10a93fff49a955e1a" name="a6d4226507435e9b10a93fff49a955e1a"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a6d4226507435e9b10a93fff49a955e1a"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>remove_null_area_triangles</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="separator:a6d4226507435e9b10a93fff49a955e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e10dd93d158ad5a813ff9f415d7fd0"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:aa6e10dd93d158ad5a813ff9f415d7fd0"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#aa6e10dd93d158ad5a813ff9f415d7fd0">remove_short_edges</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;in_mesh, typename MeshType::Scalar tol=0.0)</td></tr>
<tr class="memdesc:aa6e10dd93d158ad5a813ff9f415d7fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove edges shorter than a given tolerance.  <a href="namespacelagrange.html#aa6e10dd93d158ad5a813ff9f415d7fd0">More...</a><br /></td></tr>
<tr class="separator:aa6e10dd93d158ad5a813ff9f415d7fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac083d62b0fe406d945b0d9963b9da382"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:ac083d62b0fe406d945b0d9963b9da382"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ac083d62b0fe406d945b0d9963b9da382">remove_topologically_degenerate_triangles</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="memdesc:ac083d62b0fe406d945b0d9963b9da382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove topologically degenerate triangles.  <a href="namespacelagrange.html#ac083d62b0fe406d945b0d9963b9da382">More...</a><br /></td></tr>
<tr class="separator:ac083d62b0fe406d945b0d9963b9da382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8396650df2a1598801c64a1ec427eb6e"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a8396650df2a1598801c64a1ec427eb6e"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a8396650df2a1598801c64a1ec427eb6e">resolve_nonmanifoldness</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="memdesc:a8396650df2a1598801c64a1ec427eb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve <b>all</b> non-manifold edges and vertices in the mesh.  <a href="namespacelagrange.html#a8396650df2a1598801c64a1ec427eb6e">More...</a><br /></td></tr>
<tr class="separator:a8396650df2a1598801c64a1ec427eb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6edd3e50dbecc0dde32eb22a529e48"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a6b6edd3e50dbecc0dde32eb22a529e48"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a6b6edd3e50dbecc0dde32eb22a529e48">resolve_vertex_nonmanifoldness</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="memdesc:a6b6edd3e50dbecc0dde32eb22a529e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove nonmanifold vertices topologically by pulling disconnected 1-ring neighborhood apart.  <a href="namespacelagrange.html#a6b6edd3e50dbecc0dde32eb22a529e48">More...</a><br /></td></tr>
<tr class="separator:a6b6edd3e50dbecc0dde32eb22a529e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75a276e1cd7deb3e900d4d803ca7a18"><td class="memTemplParams" colspan="2"><a id="ae75a276e1cd7deb3e900d4d803ca7a18" name="ae75a276e1cd7deb3e900d4d803ca7a18"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:ae75a276e1cd7deb3e900d4d803ca7a18"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>split_long_edges</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, typename MeshType::Scalar sq_tol, bool recursive=false)</td></tr>
<tr class="separator:ae75a276e1cd7deb3e900d4d803ca7a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39496828533d9280a13d62a61809b5e2"><td class="memTemplParams" colspan="2">template&lt;typename VertexArray , typename Index &gt; </td></tr>
<tr class="memitem:a39496828533d9280a13d62a61809b5e2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; Index, 3, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a39496828533d9280a13d62a61809b5e2">split_triangle</a> (const VertexArray &amp;vertices, const std::vector&lt; Index &gt; &amp;chain, const Index v0, const Index v1, const Index v2)</td></tr>
<tr class="memdesc:a39496828533d9280a13d62a61809b5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split triangle into smaller triangles based on the chain of spliting points.  <a href="namespacelagrange.html#a39496828533d9280a13d62a61809b5e2">More...</a><br /></td></tr>
<tr class="separator:a39496828533d9280a13d62a61809b5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5fc3fc93e8d973bcc534398eeb0aa9"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index , typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:abb5fc3fc93e8d973bcc534398eeb0aa9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#abb5fc3fc93e8d973bcc534398eeb0aa9">to_surface_mesh_copy</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="memdesc:abb5fc3fc93e8d973bcc534398eeb0aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a legacy mesh object to a surface mesh object.  <a href="namespacelagrange.html#abb5fc3fc93e8d973bcc534398eeb0aa9">More...</a><br /></td></tr>
<tr class="separator:abb5fc3fc93e8d973bcc534398eeb0aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ad17ee5b7475decfbaf17fcfa63d65"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index , typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a68ad17ee5b7475decfbaf17fcfa63d65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a68ad17ee5b7475decfbaf17fcfa63d65">to_surface_mesh_wrap</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&amp;mesh)</td></tr>
<tr class="memdesc:a68ad17ee5b7475decfbaf17fcfa63d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a legacy mesh object as a surface mesh object.  <a href="namespacelagrange.html#a68ad17ee5b7475decfbaf17fcfa63d65">More...</a><br /></td></tr>
<tr class="separator:a68ad17ee5b7475decfbaf17fcfa63d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac349d354b36d62bc2efeb93dd2b7f078"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ac349d354b36d62bc2efeb93dd2b7f078"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ac349d354b36d62bc2efeb93dd2b7f078">to_legacy_mesh</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ac349d354b36d62bc2efeb93dd2b7f078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a surface mesh object to a legacy mesh object.  <a href="namespacelagrange.html#ac349d354b36d62bc2efeb93dd2b7f078">More...</a><br /></td></tr>
<tr class="separator:ac349d354b36d62bc2efeb93dd2b7f078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897193df6b6fb8692c97e481b6b291c0"><td class="memTemplParams" colspan="2"><a id="a897193df6b6fb8692c97e481b6b291c0" name="a897193df6b6fb8692c97e481b6b291c0"></a>
template&lt;typename _VertexArray , typename _FacetArray , typename Archive &gt; </td></tr>
<tr class="memitem:a897193df6b6fb8692c97e481b6b291c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (<a class="el" href="classlagrange_1_1_mesh_geometry.html">MeshGeometry</a>&lt; _VertexArray, _FacetArray &gt; &amp;geometry, Archive &amp;ar)</td></tr>
<tr class="separator:a897193df6b6fb8692c97e481b6b291c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf07b7ee38e3c92577a3cdc9a7bb38479"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gaf07b7ee38e3c92577a3cdc9a7bb38479"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gaf07b7ee38e3c92577a3cdc9a7bb38479">normalize_mesh</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:gaf07b7ee38e3c92577a3cdc9a7bb38479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a mesh to fit in a unit box centered at the origin.  <a href="group__group-surfacemesh-utils.html#gaf07b7ee38e3c92577a3cdc9a7bb38479">More...</a><br /></td></tr>
<tr class="separator:gaf07b7ee38e3c92577a3cdc9a7bb38479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad46e0464a61ba9b6c5fd7948af53c304"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gad46e0464a61ba9b6c5fd7948af53c304"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gad46e0464a61ba9b6c5fd7948af53c304">normalize_meshes</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; * &gt; meshes)</td></tr>
<tr class="memdesc:gad46e0464a61ba9b6c5fd7948af53c304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a list of meshes to fit in a unit box centered at the origin.  <a href="group__group-surfacemesh-utils.html#gad46e0464a61ba9b6c5fd7948af53c304">More...</a><br /></td></tr>
<tr class="separator:gad46e0464a61ba9b6c5fd7948af53c304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dfaf475743676c129c2db26ae1fb51"><td class="memTemplParams" colspan="2">template&lt;typename VertexArray , typename FacetArray &gt; </td></tr>
<tr class="memitem:a49dfaf475743676c129c2db26ae1fb51"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a49dfaf475743676c129c2db26ae1fb51">orient_outward</a> (<a class="el" href="classlagrange_1_1_mesh.html">lagrange::Mesh</a>&lt; VertexArray, FacetArray &gt; &amp;mesh, bool positive=true)</td></tr>
<tr class="memdesc:a49dfaf475743676c129c2db26ae1fb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient the facets of a mesh so that the signed volume of each connected component is positive or negative.  <a href="namespacelagrange.html#a49dfaf475743676c129c2db26ae1fb51">More...</a><br /></td></tr>
<tr class="separator:a49dfaf475743676c129c2db26ae1fb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea147d93f72ed7e9c28a99c1a7c87958"><td class="memTemplParams" colspan="2">template&lt;typename PointType &gt; </td></tr>
<tr class="memitem:aea147d93f72ed7e9c28a99c1a7c87958"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#aea147d93f72ed7e9c28a99c1a7c87958">point_on_segment</a> (const Eigen::MatrixBase&lt; PointType &gt; &amp;p, const Eigen::MatrixBase&lt; PointType &gt; &amp;a, const Eigen::MatrixBase&lt; PointType &gt; &amp;b)</td></tr>
<tr class="memdesc:aea147d93f72ed7e9c28a99c1a7c87958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a point lies exactly on a segment [a,b] using exact predicates.  <a href="namespacelagrange.html#aea147d93f72ed7e9c28a99c1a7c87958">More...</a><br /></td></tr>
<tr class="separator:aea147d93f72ed7e9c28a99c1a7c87958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603da7b6f652a1a756e604275c3dd58c"><td class="memTemplParams" colspan="2">template&lt;typename PointType &gt; </td></tr>
<tr class="memitem:a603da7b6f652a1a756e604275c3dd58c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a603da7b6f652a1a756e604275c3dd58c">point_segment_squared_distance</a> (const Eigen::MatrixBase&lt; PointType &gt; &amp;point, const Eigen::MatrixBase&lt; PointType &gt; &amp;V0, const Eigen::MatrixBase&lt; PointType &gt; &amp;V1, Eigen::PlainObjectBase&lt; PointType &gt; &amp;closest_point, ScalarOf&lt; PointType &gt; &amp;lambda0, ScalarOf&lt; PointType &gt; &amp;lambda1) -&gt; ScalarOf&lt; PointType &gt;</td></tr>
<tr class="memdesc:a603da7b6f652a1a756e604275c3dd58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the point closest to a given point in a nd segment.  <a href="namespacelagrange.html#a603da7b6f652a1a756e604275c3dd58c">More...</a><br /></td></tr>
<tr class="separator:a603da7b6f652a1a756e604275c3dd58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af812f411ba6d6dd28ec8d24e2e498c09"><td class="memTemplParams" colspan="2">template&lt;typename PointType &gt; </td></tr>
<tr class="memitem:af812f411ba6d6dd28ec8d24e2e498c09"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#af812f411ba6d6dd28ec8d24e2e498c09">point_segment_squared_distance</a> (const Eigen::MatrixBase&lt; PointType &gt; &amp;point, const Eigen::MatrixBase&lt; PointType &gt; &amp;V0, const Eigen::MatrixBase&lt; PointType &gt; &amp;V1) -&gt; ScalarOf&lt; PointType &gt;</td></tr>
<tr class="memdesc:af812f411ba6d6dd28ec8d24e2e498c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the point closest to a given point in a nd segment.  <a href="namespacelagrange.html#af812f411ba6d6dd28ec8d24e2e498c09">More...</a><br /></td></tr>
<tr class="separator:af812f411ba6d6dd28ec8d24e2e498c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4867c7a72016dba819a9c4e8fe8477f3"><td class="memTemplParams" colspan="2">template&lt;typename PointType &gt; </td></tr>
<tr class="memitem:a4867c7a72016dba819a9c4e8fe8477f3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a4867c7a72016dba819a9c4e8fe8477f3">point_triangle_squared_distance</a> (const Eigen::MatrixBase&lt; PointType &gt; &amp;point, const Eigen::MatrixBase&lt; PointType &gt; &amp;V0, const Eigen::MatrixBase&lt; PointType &gt; &amp;V1, const Eigen::MatrixBase&lt; PointType &gt; &amp;V2, Eigen::PlainObjectBase&lt; PointType &gt; &amp;closest_point, ScalarOf&lt; PointType &gt; &amp;lambda0, ScalarOf&lt; PointType &gt; &amp;lambda1, ScalarOf&lt; PointType &gt; &amp;lambda2) -&gt; ScalarOf&lt; PointType &gt;</td></tr>
<tr class="memdesc:a4867c7a72016dba819a9c4e8fe8477f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the point closest to a given point in a nd triangle.  <a href="namespacelagrange.html#a4867c7a72016dba819a9c4e8fe8477f3">More...</a><br /></td></tr>
<tr class="separator:a4867c7a72016dba819a9c4e8fe8477f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd65792fde835f9448cbf14aec20298"><td class="memTemplParams" colspan="2">template&lt;typename PointType &gt; </td></tr>
<tr class="memitem:a5cd65792fde835f9448cbf14aec20298"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a5cd65792fde835f9448cbf14aec20298">point_triangle_squared_distance</a> (const Eigen::MatrixBase&lt; PointType &gt; &amp;point, const Eigen::MatrixBase&lt; PointType &gt; &amp;V0, const Eigen::MatrixBase&lt; PointType &gt; &amp;V1, const Eigen::MatrixBase&lt; PointType &gt; &amp;V2) -&gt; ScalarOf&lt; PointType &gt;</td></tr>
<tr class="memdesc:a5cd65792fde835f9448cbf14aec20298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the squared distance between a point and a nd triangle.  <a href="namespacelagrange.html#a5cd65792fde835f9448cbf14aec20298">More...</a><br /></td></tr>
<tr class="separator:a5cd65792fde835f9448cbf14aec20298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e627afa63acfb3eeb8e11dd72f9192"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a97e627afa63acfb3eeb8e11dd72f9192"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a97e627afa63acfb3eeb8e11dd72f9192">reorder_mesh_vertices</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const typename MeshType::IndexList &amp;forward_mapping)</td></tr>
<tr class="memdesc:a97e627afa63acfb3eeb8e11dd72f9192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders (possibly with shrinking) the vertices in the mesh.  <a href="namespacelagrange.html#a97e627afa63acfb3eeb8e11dd72f9192">More...</a><br /></td></tr>
<tr class="separator:a97e627afa63acfb3eeb8e11dd72f9192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a43f24d6988a6794a64f2196c67177"><td class="memTemplParams" colspan="2"><a id="a77a43f24d6988a6794a64f2196c67177" name="a77a43f24d6988a6794a64f2196c67177"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a77a43f24d6988a6794a64f2196c67177"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_sample_points_on_surface_output.html">SamplePointsOnSurfaceOutput</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sample_points_on_surface</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const typename MeshType::Index approx_num_points, const typename MeshType::IndexList &amp;active_facets)</td></tr>
<tr class="separator:a77a43f24d6988a6794a64f2196c67177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0142b3528632baf40b3a4f0bce242db"><td class="memTemplParams" colspan="2"><a id="af0142b3528632baf40b3a4f0bce242db" name="af0142b3528632baf40b3a4f0bce242db"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:af0142b3528632baf40b3a4f0bce242db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_sample_points_on_surface_output.html">SamplePointsOnSurfaceOutput</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sample_points_on_surface</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const typename MeshType::Index approx_num_points, const std::vector&lt; bool &gt; &amp;is_facet_active)</td></tr>
<tr class="separator:af0142b3528632baf40b3a4f0bce242db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a120dda47aeef083102d8909a05ed23"><td class="memTemplParams" colspan="2"><a id="a9a120dda47aeef083102d8909a05ed23" name="a9a120dda47aeef083102d8909a05ed23"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a9a120dda47aeef083102d8909a05ed23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_sample_points_on_surface_output.html">SamplePointsOnSurfaceOutput</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sample_points_on_surface</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const typename MeshType::Index approx_num_points)</td></tr>
<tr class="separator:a9a120dda47aeef083102d8909a05ed23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44a7fb1273eea585592c9eaa83e9cef"><td class="memTemplParams" colspan="2"><a id="ab44a7fb1273eea585592c9eaa83e9cef" name="ab44a7fb1273eea585592c9eaa83e9cef"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:ab44a7fb1273eea585592c9eaa83e9cef"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>select_facets_by_normal_similarity</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const typename MeshType::Index seed_facet_id, const <a class="el" href="structlagrange_1_1_select_facets_by_normal_similarity_parameters.html">SelectFacetsByNormalSimilarityParameters</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; &amp;parameters)</td></tr>
<tr class="separator:ab44a7fb1273eea585592c9eaa83e9cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551d394ef62a5c5b7bc1ed9d5bb791ce"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> , typename Point3D &gt; </td></tr>
<tr class="memitem:a551d394ef62a5c5b7bc1ed9d5bb791ce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a551d394ef62a5c5b7bc1ed9d5bb791ce">select_facets_in_frustum</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;n0, const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;p0, const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;n1, const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;p1, const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;n2, const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;p2, const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;n3, const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;p3, bool greedy=false)</td></tr>
<tr class="memdesc:a551d394ef62a5c5b7bc1ed9d5bb791ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select all facets that intersect the cone/frustrum bounded by 4 planes defined by (n_i, p_i), where n_i is the plane normal and p_i is a point on the plane.  <a href="namespacelagrange.html#a551d394ef62a5c5b7bc1ed9d5bb791ce">More...</a><br /></td></tr>
<tr class="separator:a551d394ef62a5c5b7bc1ed9d5bb791ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1792d2f3110525eca0fac87988584e82"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a1792d2f3110525eca0fac87988584e82"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a1792d2f3110525eca0fac87988584e82">thicken_and_close_mesh</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;input_mesh, Eigen::Matrix&lt; ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;, 3, 1 &gt; direction, ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; offset_amount, ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; mirror_amount, typename MeshType::Index num_segments=1)</td></tr>
<tr class="memdesc:a1792d2f3110525eca0fac87988584e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thicken a mesh by offsetting it in a fixed direction.  <a href="namespacelagrange.html#a1792d2f3110525eca0fac87988584e82">More...</a><br /></td></tr>
<tr class="separator:a1792d2f3110525eca0fac87988584e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1b8edd4573422f27af875ab25bf0ed"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a9b1b8edd4573422f27af875ab25bf0ed"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a9b1b8edd4573422f27af875ab25bf0ed">thicken_and_close_mesh</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;input_mesh, ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; offset_amount, typename MeshType::Index num_segments=1)</td></tr>
<tr class="memdesc:a9b1b8edd4573422f27af875ab25bf0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thicken a mesh vertices along normals, and close the shape into a thick 3D solid.  <a href="namespacelagrange.html#a9b1b8edd4573422f27af875ab25bf0ed">More...</a><br /></td></tr>
<tr class="separator:a9b1b8edd4573422f27af875ab25bf0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48af6105ece8a970755870c73af73ddd"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga48af6105ece8a970755870c73af73ddd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga48af6105ece8a970755870c73af73ddd">triangulate_polygonal_facets</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga48af6105ece8a970755870c73af73ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulate polygonal facets of a mesh using a prescribed set of rules.  <a href="group__group-surfacemesh-utils.html#ga48af6105ece8a970755870c73af73ddd">More...</a><br /></td></tr>
<tr class="separator:ga48af6105ece8a970755870c73af73ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0eeb4d96ed545aadd3b6bf27ed631c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-utils-assert.html#gaf0eeb4d96ed545aadd3b6bf27ed631c6">set_breakpoint_enabled</a> (bool enabled)</td></tr>
<tr class="memdesc:gaf0eeb4d96ed545aadd3b6bf27ed631c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether to trigger a debugger breakpoint on assert failure.  <a href="group__group-utils-assert.html#gaf0eeb4d96ed545aadd3b6bf27ed631c6">More...</a><br /></td></tr>
<tr class="separator:gaf0eeb4d96ed545aadd3b6bf27ed631c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1d763e905c12a114bb94a8f38227094"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-utils-assert.html#gac1d763e905c12a114bb94a8f38227094">is_breakpoint_enabled</a> ()</td></tr>
<tr class="memdesc:gac1d763e905c12a114bb94a8f38227094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether to trigger a debugger breakpoint on assert failure.  <a href="group__group-utils-assert.html#gac1d763e905c12a114bb94a8f38227094">More...</a><br /></td></tr>
<tr class="separator:gac1d763e905c12a114bb94a8f38227094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82afecd46baab6fadf8dfa8d7dbea5ec"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>trigger_breakpoint</b> ()</td></tr>
<tr class="memdesc:ga82afecd46baab6fadf8dfa8d7dbea5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call to explicitly trigger a debugger breakpoint. <br /></td></tr>
<tr class="separator:ga82afecd46baab6fadf8dfa8d7dbea5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fa47832a47c910f51b99004c3bc165f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-utils-assert.html#ga3fa47832a47c910f51b99004c3bc165f">assertion_failed</a> (const char *function, const char *file, unsigned int line, const char *condition, std::string_view message)</td></tr>
<tr class="memdesc:ga3fa47832a47c910f51b99004c3bc165f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called in case of an assertion failure.  <a href="group__group-utils-assert.html#ga3fa47832a47c910f51b99004c3bc165f">More...</a><br /></td></tr>
<tr class="separator:ga3fa47832a47c910f51b99004c3bc165f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19b64389774c826a71abae902e0b46b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga19b64389774c826a71abae902e0b46b9">enable_fpe</a> ()</td></tr>
<tr class="memdesc:ga19b64389774c826a71abae902e0b46b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable floating-point exceptions (useful for debugging).  <a href="group__group-utils-misc.html#ga19b64389774c826a71abae902e0b46b9">More...</a><br /></td></tr>
<tr class="separator:ga19b64389774c826a71abae902e0b46b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe7e2f24aa07f2b2e38829ef368a0f59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#gabe7e2f24aa07f2b2e38829ef368a0f59">disable_fpe</a> ()</td></tr>
<tr class="memdesc:gabe7e2f24aa07f2b2e38829ef368a0f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable previously-enabled fpe.  <a href="group__group-utils-misc.html#gabe7e2f24aa07f2b2e38829ef368a0f59">More...</a><br /></td></tr>
<tr class="separator:gabe7e2f24aa07f2b2e38829ef368a0f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf41b927eb9281c28666f47b3f04d887c"><td class="memTemplParams" colspan="2">
template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:gaf41b927eb9281c28666f47b3f04d887c"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;lhs, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gaf41b927eb9281c28666f47b3f04d887c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the referred callables of <code>lhs</code> and <code>rhs</code>. <br /></td></tr>
<tr class="separator:gaf41b927eb9281c28666f47b3f04d887c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7338ffd0742e51046ac43879b3f1a44c"><td class="memTemplParams" colspan="2">
template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:ga7338ffd0742e51046ac43879b3f1a44c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>function_ref</b> (R(*)(Args...)) -&gt; <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt;</td></tr>
<tr class="memdesc:ga7338ffd0742e51046ac43879b3f1a44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce <a class="el" href="classlagrange_1_1function__ref.html" title="A lightweight non-owning reference to a callable.">function_ref</a> type from a function pointer. <br /></td></tr>
<tr class="separator:ga7338ffd0742e51046ac43879b3f1a44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093f51ba753b715f88611bf43dc25a89"><td class="memTemplParams" colspan="2"><a id="a093f51ba753b715f88611bf43dc25a89" name="a093f51ba753b715f88611bf43dc25a89"></a>
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a093f51ba753b715f88611bf43dc25a89"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sqr_minimum_distance</b> (const Eigen::Vector2&lt; Scalar &gt; &amp;a, const Eigen::Vector2&lt; Scalar &gt; &amp;b, const Eigen::Vector2&lt; Scalar &gt; &amp;p)</td></tr>
<tr class="memdesc:a093f51ba753b715f88611bf43dc25a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared minimum distance between 2d line segment ab and point p. <br /></td></tr>
<tr class="separator:a093f51ba753b715f88611bf43dc25a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e9df5173515c23f1218ff2388212a5"><td class="memTemplParams" colspan="2"><a id="ab2e9df5173515c23f1218ff2388212a5" name="ab2e9df5173515c23f1218ff2388212a5"></a>
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ab2e9df5173515c23f1218ff2388212a5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Vector2&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>triangle_circumcenter</b> (const Eigen::Vector2&lt; Scalar &gt; &amp;p1, const Eigen::Vector2&lt; Scalar &gt; &amp;p2, const Eigen::Vector2&lt; Scalar &gt; &amp;p3)</td></tr>
<tr class="separator:ab2e9df5173515c23f1218ff2388212a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad434bb442f4626b686930e83f389bcdd"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int _Rows, int _Cols&gt; </td></tr>
<tr class="memitem:ad434bb442f4626b686930e83f389bcdd"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ad434bb442f4626b686930e83f389bcdd">cos_angle_between</a> (const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v1, const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v2)</td></tr>
<tr class="memdesc:ad434bb442f4626b686930e83f389bcdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cosine of the angle between two 3d vectors.  <a href="namespacelagrange.html#ad434bb442f4626b686930e83f389bcdd">More...</a><br /></td></tr>
<tr class="separator:ad434bb442f4626b686930e83f389bcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a080c8d39846139d94e3f0f3640b73"><td class="memTemplParams" colspan="2"><a id="ab2a080c8d39846139d94e3f0f3640b73" name="ab2a080c8d39846139d94e3f0f3640b73"></a>
template&lt;typename Scalar , int _Rows, int _Cols&gt; </td></tr>
<tr class="memitem:ab2a080c8d39846139d94e3f0f3640b73"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><b>angle_between</b> (const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v1, const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v2)</td></tr>
<tr class="memdesc:ab2a080c8d39846139d94e3f0f3640b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the angle between two 3d vectors. <br /></td></tr>
<tr class="separator:ab2a080c8d39846139d94e3f0f3640b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2be8e67fb8aad9e857a7569a9c8477c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int _Rows, int _Cols&gt; </td></tr>
<tr class="memitem:ad2be8e67fb8aad9e857a7569a9c8477c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ad2be8e67fb8aad9e857a7569a9c8477c">project_on_line</a> (const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v1, const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v2)</td></tr>
<tr class="memdesc:ad2be8e67fb8aad9e857a7569a9c8477c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the vector v1 on the line defined by its vector v2.  <a href="namespacelagrange.html#ad2be8e67fb8aad9e857a7569a9c8477c">More...</a><br /></td></tr>
<tr class="separator:ad2be8e67fb8aad9e857a7569a9c8477c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e84808ffea64e176275f0a37d7f1bf"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int _Rows, int _Cols&gt; </td></tr>
<tr class="memitem:a79e84808ffea64e176275f0a37d7f1bf"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a79e84808ffea64e176275f0a37d7f1bf">project_on_plane</a> (const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v, const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;n)</td></tr>
<tr class="memdesc:a79e84808ffea64e176275f0a37d7f1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the vector on the plane defined by its normal n.  <a href="namespacelagrange.html#a79e84808ffea64e176275f0a37d7f1bf">More...</a><br /></td></tr>
<tr class="separator:a79e84808ffea64e176275f0a37d7f1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1439f4d3fc69cbd0e01f22c15f474415"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int _Rows, int _Cols&gt; </td></tr>
<tr class="memitem:a1439f4d3fc69cbd0e01f22c15f474415"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a1439f4d3fc69cbd0e01f22c15f474415">projected_cos_angle_between</a> (const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v1, const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v2, const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;n)</td></tr>
<tr class="memdesc:a1439f4d3fc69cbd0e01f22c15f474415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the angle between the vectors v1 and v2 projected on the plane defined by its normal n.  <a href="namespacelagrange.html#a1439f4d3fc69cbd0e01f22c15f474415">More...</a><br /></td></tr>
<tr class="separator:a1439f4d3fc69cbd0e01f22c15f474415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89990d08ad7825dd7562410acc88828f"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int _Rows, int _Cols&gt; </td></tr>
<tr class="memitem:a89990d08ad7825dd7562410acc88828f"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a89990d08ad7825dd7562410acc88828f">projected_angle_between</a> (const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v1, const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v2, const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;n)</td></tr>
<tr class="memdesc:a89990d08ad7825dd7562410acc88828f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the angle between the vectors v1 and v2 projected on the plane defined by its normal n.  <a href="namespacelagrange.html#a89990d08ad7825dd7562410acc88828f">More...</a><br /></td></tr>
<tr class="separator:a89990d08ad7825dd7562410acc88828f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144de9ee10e82ef7c48e7278ce2db05d"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a144de9ee10e82ef7c48e7278ce2db05d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a144de9ee10e82ef7c48e7278ce2db05d">vector_between</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, typename MeshType::Index v1, typename MeshType::Index v2)</td></tr>
<tr class="memdesc:a144de9ee10e82ef7c48e7278ce2db05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector from v1 to v2.  <a href="namespacelagrange.html#a144de9ee10e82ef7c48e7278ce2db05d">More...</a><br /></td></tr>
<tr class="separator:a144de9ee10e82ef7c48e7278ce2db05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3bf1a4299c328b1b7eaa4411b64fe0"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aba3bf1a4299c328b1b7eaa4411b64fe0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#aba3bf1a4299c328b1b7eaa4411b64fe0">orthogonal_frame</a> (const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;x, Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;y, Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;z)</td></tr>
<tr class="memdesc:aba3bf1a4299c328b1b7eaa4411b64fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an orthogonal frame given a single vector.  <a href="namespacelagrange.html#aba3bf1a4299c328b1b7eaa4411b64fe0">More...</a><br /></td></tr>
<tr class="separator:aba3bf1a4299c328b1b7eaa4411b64fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bcf428c70e279f7c3b8dce0f0ad88eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1bcf428c70e279f7c3b8dce0f0ad88eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga1bcf428c70e279f7c3b8dce0f0ad88eb">invalid</a> ()</td></tr>
<tr class="memdesc:ga1bcf428c70e279f7c3b8dce0f0ad88eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can use <a class="el" href="group__group-utils-misc.html#ga1bcf428c70e279f7c3b8dce0f0ad88eb" title="You can use invalid&lt;T&gt;() to get a value that can represent &quot;invalid&quot; values, such as indices.">invalid&lt;T&gt;()</a> to get a value that can represent "invalid" values, such as indices.  <a href="group__group-utils-misc.html#ga1bcf428c70e279f7c3b8dce0f0ad88eb">More...</a><br /></td></tr>
<tr class="separator:ga1bcf428c70e279f7c3b8dce0f0ad88eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68084717e646e9a6073e533d0b83a2b7"><td class="memTemplParams" colspan="2">template&lt;typename Index &gt; </td></tr>
<tr class="memitem:ga68084717e646e9a6073e533d0b83a2b7"><td class="memTemplItemLeft" align="right" valign="top">internal::Range&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga68084717e646e9a6073e533d0b83a2b7">range</a> (Index end)</td></tr>
<tr class="memdesc:ga68084717e646e9a6073e533d0b83a2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable object representing the range [0, end).  <a href="group__group-utils-misc.html#ga68084717e646e9a6073e533d0b83a2b7">More...</a><br /></td></tr>
<tr class="separator:ga68084717e646e9a6073e533d0b83a2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga140b5693eb5f63b5e2470a300aeded12"><td class="memTemplParams" colspan="2">template&lt;typename Index &gt; </td></tr>
<tr class="memitem:ga140b5693eb5f63b5e2470a300aeded12"><td class="memTemplItemLeft" align="right" valign="top">internal::Range&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga140b5693eb5f63b5e2470a300aeded12">range</a> (Index begin, Index end)</td></tr>
<tr class="memdesc:ga140b5693eb5f63b5e2470a300aeded12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable object representing the range [begin, end).  <a href="group__group-utils-misc.html#ga140b5693eb5f63b5e2470a300aeded12">More...</a><br /></td></tr>
<tr class="separator:ga140b5693eb5f63b5e2470a300aeded12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0be357120afca3098d989abf97e72b13"><td class="memTemplParams" colspan="2">template&lt;typename Index &gt; </td></tr>
<tr class="memitem:ga0be357120afca3098d989abf97e72b13"><td class="memTemplItemLeft" align="right" valign="top">internal::SparseRange&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga0be357120afca3098d989abf97e72b13">range_sparse</a> (Index max, const std::vector&lt; Index &gt; &amp;active)</td></tr>
<tr class="memdesc:ga0be357120afca3098d989abf97e72b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable object representing a subset of the range [0, max).  <a href="group__group-utils-misc.html#ga0be357120afca3098d989abf97e72b13">More...</a><br /></td></tr>
<tr class="separator:ga0be357120afca3098d989abf97e72b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a5fd2842da78b90fdc7b959aec8036a"><td class="memTemplParams" colspan="2">template&lt;typename TargetType , typename SourceType &gt; </td></tr>
<tr class="memitem:ga2a5fd2842da78b90fdc7b959aec8036a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga2a5fd2842da78b90fdc7b959aec8036a">safe_cast</a> (SourceType value) -&gt; std::enable_if_t&lt;!std::is_same&lt; SourceType, TargetType &gt;::value, TargetType &gt;</td></tr>
<tr class="memdesc:ga2a5fd2842da78b90fdc7b959aec8036a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform safe cast from <code>SourceType</code> to <code>TargetType</code>, where "safe" means:  <a href="group__group-utils-misc.html#ga2a5fd2842da78b90fdc7b959aec8036a">More...</a><br /></td></tr>
<tr class="separator:ga2a5fd2842da78b90fdc7b959aec8036a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc269c3b8c38c2bd7d2aea52f839665e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafc269c3b8c38c2bd7d2aea52f839665e"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#gafc269c3b8c38c2bd7d2aea52f839665e">safe_cast</a> (T value)</td></tr>
<tr class="memdesc:gafc269c3b8c38c2bd7d2aea52f839665e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe cast specialization for TargetType == SourceType.  <a href="group__group-utils-misc.html#gafc269c3b8c38c2bd7d2aea52f839665e">More...</a><br /></td></tr>
<tr class="separator:gafc269c3b8c38c2bd7d2aea52f839665e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b9c7dcbee65083d841afc5d71c40a73"><td class="memTemplParams" colspan="2">template&lt;typename TargetType &gt; </td></tr>
<tr class="memitem:ga7b9c7dcbee65083d841afc5d71c40a73"><td class="memTemplItemLeft" align="right" valign="top">constexpr TargetType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga7b9c7dcbee65083d841afc5d71c40a73">safe_cast</a> (bool value)</td></tr>
<tr class="memdesc:ga7b9c7dcbee65083d841afc5d71c40a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe cast specialization for bool.  <a href="group__group-utils-misc.html#ga7b9c7dcbee65083d841afc5d71c40a73">More...</a><br /></td></tr>
<tr class="separator:ga7b9c7dcbee65083d841afc5d71c40a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7c68fbe6cdda70f6be758396ddf9e2e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gae7c68fbe6cdda70f6be758396ddf9e2e"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#gae7c68fbe6cdda70f6be758396ddf9e2e">safe_cast_enum</a> (const U u)</td></tr>
<tr class="memdesc:gae7c68fbe6cdda70f6be758396ddf9e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casting an enum to scalar and vice versa.  <a href="group__group-utils-misc.html#gae7c68fbe6cdda70f6be758396ddf9e2e">More...</a><br /></td></tr>
<tr class="separator:gae7c68fbe6cdda70f6be758396ddf9e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7964d08c7668de8c554fb249e3f6c84"><td class="memTemplParams" colspan="2">template&lt;typename Callback &gt; </td></tr>
<tr class="memitem:gaa7964d08c7668de8c554fb249e3f6c84"><td class="memTemplItemLeft" align="right" valign="top">sg_detail::scope_guard&lt; Callback &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#gaa7964d08c7668de8c554fb249e3f6c84">make_scope_guard</a> (Callback &amp;&amp;callback) noexcept(std::is_nothrow_constructible&lt; Callback, Callback &amp;&amp; &gt;::value)</td></tr>
<tr class="memdesc:gaa7964d08c7668de8c554fb249e3f6c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a scope guard around a callable object.  <a href="group__group-utils-misc.html#gaa7964d08c7668de8c554fb249e3f6c84">More...</a><br /></td></tr>
<tr class="separator:gaa7964d08c7668de8c554fb249e3f6c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c028e62a13f2bce6d3775809cf47125"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:ga6c028e62a13f2bce6d3775809cf47125"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga6c028e62a13f2bce6d3775809cf47125">make_shared_span</a> (const std::shared_ptr&lt; Y &gt; &amp;r, T *element_ptr, size_t size)</td></tr>
<tr class="memdesc:ga6c028e62a13f2bce6d3775809cf47125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Created a <a class="el" href="classlagrange_1_1_shared_span.html" title="Shared span with ownership tracking.">SharedSpan</a> object around an internal buffer of a parent object.  <a href="group__group-utils-misc.html#ga6c028e62a13f2bce6d3775809cf47125">More...</a><br /></td></tr>
<tr class="separator:ga6c028e62a13f2bce6d3775809cf47125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a9d101295f775d612f2f787ce5b141"><td class="memTemplParams" colspan="2"><a id="a93a9d101295f775d612f2f787ce5b141" name="a93a9d101295f775d612f2f787ce5b141"></a>
template&lt;typename Scalar , size_t N, typename Derived &gt; </td></tr>
<tr class="memitem:a93a9d101295f775d612f2f787ce5b141"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vector_to_eigen</b> (const std::vector&lt; std::array&lt; Scalar, N &gt; &gt; &amp;from, Eigen::PlainObjectBase&lt; Derived &gt; &amp;to)</td></tr>
<tr class="separator:a93a9d101295f775d612f2f787ce5b141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241945529ef8e008a75d2b2db2da3394"><td class="memTemplParams" colspan="2"><a id="a241945529ef8e008a75d2b2db2da3394" name="a241945529ef8e008a75d2b2db2da3394"></a>
template&lt;typename Scalar , typename Derived &gt; </td></tr>
<tr class="memitem:a241945529ef8e008a75d2b2db2da3394"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vector_to_eigen</b> (const std::vector&lt; std::pair&lt; Scalar, Scalar &gt; &gt; &amp;from, Eigen::PlainObjectBase&lt; Derived &gt; &amp;to)</td></tr>
<tr class="separator:a241945529ef8e008a75d2b2db2da3394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51aa606bf897eab7e5495ce51e1a1189"><td class="memTemplParams" colspan="2"><a id="a51aa606bf897eab7e5495ce51e1a1189" name="a51aa606bf897eab7e5495ce51e1a1189"></a>
template&lt;typename Scalar , int N, typename Derived &gt; </td></tr>
<tr class="memitem:a51aa606bf897eab7e5495ce51e1a1189"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vector_to_eigen</b> (const std::vector&lt; Eigen::Matrix&lt; Scalar, N, 1 &gt; &gt; &amp;from, Eigen::PlainObjectBase&lt; Derived &gt; &amp;to)</td></tr>
<tr class="separator:a51aa606bf897eab7e5495ce51e1a1189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f849a1e96e476db66c8472e228e082d"><td class="memTemplParams" colspan="2"><a id="a2f849a1e96e476db66c8472e228e082d" name="a2f849a1e96e476db66c8472e228e082d"></a>
template&lt;typename Scalar , int N, typename Derived &gt; </td></tr>
<tr class="memitem:a2f849a1e96e476db66c8472e228e082d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vector_to_eigen</b> (const std::vector&lt; Eigen::Matrix&lt; Scalar, 1, N &gt; &gt; &amp;from, Eigen::PlainObjectBase&lt; Derived &gt; &amp;to)</td></tr>
<tr class="separator:a2f849a1e96e476db66c8472e228e082d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8420bcc9a858abb46644e9d6f46c98"><td class="memTemplParams" colspan="2"><a id="a7d8420bcc9a858abb46644e9d6f46c98" name="a7d8420bcc9a858abb46644e9d6f46c98"></a>
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a7d8420bcc9a858abb46644e9d6f46c98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vector_to_eigen</b> (const std::vector&lt; Scalar &gt; &amp;from, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;to)</td></tr>
<tr class="separator:a7d8420bcc9a858abb46644e9d6f46c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a15a5b1e4d369cad084130ac4382e00"><td class="memTemplParams" colspan="2"><a id="a9a15a5b1e4d369cad084130ac4382e00" name="a9a15a5b1e4d369cad084130ac4382e00"></a>
template&lt;typename Scalar , typename Derived &gt; </td></tr>
<tr class="memitem:a9a15a5b1e4d369cad084130ac4382e00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>flat_vector_to_eigen</b> (const std::vector&lt; Scalar &gt; &amp;from, Eigen::PlainObjectBase&lt; Derived &gt; &amp;to, size_t rows, size_t cols, int row_major_flag=Eigen::RowMajor)</td></tr>
<tr class="separator:a9a15a5b1e4d369cad084130ac4382e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae219c941ca38f67b61e7492efd52f66f"><td class="memTemplParams" colspan="2"><a id="ae219c941ca38f67b61e7492efd52f66f" name="ae219c941ca38f67b61e7492efd52f66f"></a>
template&lt;typename Derived , typename Scalar , size_t N&gt; </td></tr>
<tr class="memitem:ae219c941ca38f67b61e7492efd52f66f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eigen_to_vector</b> (const Eigen::MatrixBase&lt; Derived &gt; &amp;from, std::vector&lt; std::array&lt; Scalar, N &gt; &gt; &amp;to)</td></tr>
<tr class="separator:ae219c941ca38f67b61e7492efd52f66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213dfb0a4eafb3d84b52c52e2fb4bc9c"><td class="memTemplParams" colspan="2"><a id="a213dfb0a4eafb3d84b52c52e2fb4bc9c" name="a213dfb0a4eafb3d84b52c52e2fb4bc9c"></a>
template&lt;typename Derived , typename Scalar &gt; </td></tr>
<tr class="memitem:a213dfb0a4eafb3d84b52c52e2fb4bc9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eigen_to_vector</b> (const Eigen::MatrixBase&lt; Derived &gt; &amp;from, std::vector&lt; std::pair&lt; Scalar, Scalar &gt; &gt; &amp;to)</td></tr>
<tr class="separator:a213dfb0a4eafb3d84b52c52e2fb4bc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7379547b30927f1f52a297665054e8fc"><td class="memTemplParams" colspan="2"><a id="a7379547b30927f1f52a297665054e8fc" name="a7379547b30927f1f52a297665054e8fc"></a>
template&lt;typename Derived , typename Scalar &gt; </td></tr>
<tr class="memitem:a7379547b30927f1f52a297665054e8fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eigen_to_flat_vector</b> (const Eigen::MatrixBase&lt; Derived &gt; &amp;from, std::vector&lt; Scalar &gt; &amp;to, int row_major_flag=Eigen::RowMajor)</td></tr>
<tr class="separator:a7379547b30927f1f52a297665054e8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2f13bef4d8b9c7c6b2dc61b87d95bd4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#gad2f13bef4d8b9c7c6b2dc61b87d95bd4">string_split</a> (const std::string &amp;str, char delimiter)</td></tr>
<tr class="memdesc:gad2f13bef4d8b9c7c6b2dc61b87d95bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a std::string using a prescribed delimiter.  <a href="group__group-utils-misc.html#gad2f13bef4d8b9c7c6b2dc61b87d95bd4">More...</a><br /></td></tr>
<tr class="separator:gad2f13bef4d8b9c7c6b2dc61b87d95bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebb929afb5049cc3aaaabd296f556ac3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#gaebb929afb5049cc3aaaabd296f556ac3">starts_with</a> (std::string_view str, std::string_view prefix)</td></tr>
<tr class="memdesc:gaebb929afb5049cc3aaaabd296f556ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the string begins with the given prefix.  <a href="group__group-utils-misc.html#gaebb929afb5049cc3aaaabd296f556ac3">More...</a><br /></td></tr>
<tr class="separator:gaebb929afb5049cc3aaaabd296f556ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eef11056e4525af0cd41aeb98869cbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga8eef11056e4525af0cd41aeb98869cbb">ends_with</a> (std::string_view str, std::string_view suffix)</td></tr>
<tr class="memdesc:ga8eef11056e4525af0cd41aeb98869cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the string ends with the given suffix.  <a href="group__group-utils-misc.html#ga8eef11056e4525af0cd41aeb98869cbb">More...</a><br /></td></tr>
<tr class="separator:ga8eef11056e4525af0cd41aeb98869cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace21fe897e9a93ce34d7f21264db19b4"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:gace21fe897e9a93ce34d7f21264db19b4"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#gace21fe897e9a93ce34d7f21264db19b4">string_format</a> (const std::string &amp;format, <a class="el" href="struct_args.html">Args</a> &amp;&amp;... args)</td></tr>
<tr class="memdesc:gace21fe897e9a93ce34d7f21264db19b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format args according to the format string fmt, and return the result as a string.  <a href="group__group-utils-misc.html#gace21fe897e9a93ce34d7f21264db19b4">More...</a><br /></td></tr>
<tr class="separator:gace21fe897e9a93ce34d7f21264db19b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b59f354d4ecb669d3b0c571508a4c02"><td class="memItemLeft" align="right" valign="top"><a id="a4b59f354d4ecb669d3b0c571508a4c02" name="a4b59f354d4ecb669d3b0c571508a4c02"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_timestamp</b> (timestamp_type *t)</td></tr>
<tr class="separator:a4b59f354d4ecb669d3b0c571508a4c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab225ccbdd4d897c358bdfd26323b1ec2"><td class="memItemLeft" align="right" valign="top"><a id="ab225ccbdd4d897c358bdfd26323b1ec2" name="ab225ccbdd4d897c358bdfd26323b1ec2"></a>
timestamp_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_timestamp</b> ()</td></tr>
<tr class="separator:ab225ccbdd4d897c358bdfd26323b1ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64480f6ea7b88e8b10600495b7cde27a"><td class="memItemLeft" align="right" valign="top"><a id="a64480f6ea7b88e8b10600495b7cde27a" name="a64480f6ea7b88e8b10600495b7cde27a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>timestamp_diff_in_seconds</b> (timestamp_type start, timestamp_type end)</td></tr>
<tr class="separator:a64480f6ea7b88e8b10600495b7cde27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799bd813d1c7a4506253381f66d8315e"><td class="memItemLeft" align="right" valign="top"><a id="a799bd813d1c7a4506253381f66d8315e" name="a799bd813d1c7a4506253381f66d8315e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>timestamp_diff_in_seconds</b> (timestamp_type start)</td></tr>
<tr class="separator:a799bd813d1c7a4506253381f66d8315e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9bf3ea770e7954ffd59b6c35620110"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aeb9bf3ea770e7954ffd59b6c35620110"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#aeb9bf3ea770e7954ffd59b6c35620110">to_degrees</a> (Scalar rad=1)</td></tr>
<tr class="memdesc:aeb9bf3ea770e7954ffd59b6c35620110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert radians to degrees.  <a href="namespacelagrange.html#aeb9bf3ea770e7954ffd59b6c35620110">More...</a><br /></td></tr>
<tr class="separator:aeb9bf3ea770e7954ffd59b6c35620110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ecfc247da42a513952056dfc91da59"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a47ecfc247da42a513952056dfc91da59"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a47ecfc247da42a513952056dfc91da59">to_radians</a> (Scalar deg=1)</td></tr>
<tr class="memdesc:a47ecfc247da42a513952056dfc91da59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert degrees to radians.  <a href="namespacelagrange.html#a47ecfc247da42a513952056dfc91da59">More...</a><br /></td></tr>
<tr class="separator:a47ecfc247da42a513952056dfc91da59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc89f1c5d3d14cf0fc6a584d204ad27"><td class="memTemplParams" colspan="2"><a id="a3cc89f1c5d3d14cf0fc6a584d204ad27" name="a3cc89f1c5d3d14cf0fc6a584d204ad27"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3cc89f1c5d3d14cf0fc6a584d204ad27"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sign</b> (T val)</td></tr>
<tr class="memdesc:a3cc89f1c5d3d14cf0fc6a584d204ad27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sign of the value Returns either -1, 0, or 1. <br /></td></tr>
<tr class="separator:a3cc89f1c5d3d14cf0fc6a584d204ad27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cf8d410e6e6c0686b0d618c52811c7"><td class="memTemplParams" colspan="2"><a id="af8cf8d410e6e6c0686b0d618c52811c7" name="af8cf8d410e6e6c0686b0d618c52811c7"></a>
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:af8cf8d410e6e6c0686b0d618c52811c7"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gaussian</b> (Scalar x, Scalar sigma, Scalar center=0)</td></tr>
<tr class="memdesc:af8cf8d410e6e6c0686b0d618c52811c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple evaluation of Gaussian function. <br /></td></tr>
<tr class="separator:af8cf8d410e6e6c0686b0d618c52811c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae65678934fe4afb9cedc9b9d68d9010b"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:gae65678934fe4afb9cedc9b9d68d9010b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1value__ptr.html">value_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#gae65678934fe4afb9cedc9b9d68d9010b">make_value_ptr</a> (<a class="el" href="struct_args.html">Args</a> &amp;&amp;... args)</td></tr>
<tr class="memdesc:gae65678934fe4afb9cedc9b9d68d9010b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a <a class="el" href="classlagrange_1_1value__ptr.html" title="Smart pointer with value semantics.">value_ptr</a> for a given type.  <a href="group__group-utils-misc.html#gae65678934fe4afb9cedc9b9d68d9010b">More...</a><br /></td></tr>
<tr class="separator:gae65678934fe4afb9cedc9b9d68d9010b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223700c80e7178fcc96ecc0a77cb1d3c"><td class="memTemplParams" colspan="2"><a id="a223700c80e7178fcc96ecc0a77cb1d3c" name="a223700c80e7178fcc96ecc0a77cb1d3c"></a>
template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a223700c80e7178fcc96ecc0a77cb1d3c"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_vertex_based_components</b> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id)</td></tr>
<tr class="separator:a223700c80e7178fcc96ecc0a77cb1d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff6de1eb7f1daab11efe393ee97af7e"><td class="memTemplParams" colspan="2"><a id="aeff6de1eb7f1daab11efe393ee97af7e" name="aeff6de1eb7f1daab11efe393ee97af7e"></a>
template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:aeff6de1eb7f1daab11efe393ee97af7e"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_edge_based_components</b> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id)</td></tr>
<tr class="separator:aeff6de1eb7f1daab11efe393ee97af7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32edc074e3e366c1748b3a27ea86caed"><td class="memItemLeft" align="right" valign="top"><a id="a32edc074e3e366c1748b3a27ea86caed" name="a32edc074e3e366c1748b3a27ea86caed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>exactinit</b> ()</td></tr>
<tr class="separator:a32edc074e3e366c1748b3a27ea86caed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470edfec66c1daf6a93d8bf89e3b19b1"><td class="memItemLeft" align="right" valign="top"><a id="a470edfec66c1daf6a93d8bf89e3b19b1" name="a470edfec66c1daf6a93d8bf89e3b19b1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>orient2d</b> (const double *pa, const double *pb, const double *pc)</td></tr>
<tr class="separator:a470edfec66c1daf6a93d8bf89e3b19b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf73d04c4474542b76738ae76ed4108"><td class="memItemLeft" align="right" valign="top"><a id="aadf73d04c4474542b76738ae76ed4108" name="aadf73d04c4474542b76738ae76ed4108"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>orient3d</b> (const double *pa, const double *pb, const double *pc, const double *pd)</td></tr>
<tr class="separator:aadf73d04c4474542b76738ae76ed4108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6627afe7c9ba9102c6b685ab06210915"><td class="memItemLeft" align="right" valign="top"><a id="a6627afe7c9ba9102c6b685ab06210915" name="a6627afe7c9ba9102c6b685ab06210915"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>incircle</b> (const double *pa, const double *pb, const double *pc, const double *pd)</td></tr>
<tr class="separator:a6627afe7c9ba9102c6b685ab06210915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9571364444451ce6f5ae2c8618d4546"><td class="memItemLeft" align="right" valign="top"><a id="ae9571364444451ce6f5ae2c8618d4546" name="ae9571364444451ce6f5ae2c8618d4546"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>insphere</b> (const double *pa, const double *pb, const double *pc, const double *pd, const double *pe)</td></tr>
<tr class="separator:ae9571364444451ce6f5ae2c8618d4546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cb49e171d7ff37856b7c3abd308db9"><td class="memItemLeft" align="right" valign="top"><a id="af7cb49e171d7ff37856b7c3abd308db9" name="af7cb49e171d7ff37856b7c3abd308db9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>grow_expansion</b> (int elen, REAL *e, REAL b, REAL *h)</td></tr>
<tr class="separator:af7cb49e171d7ff37856b7c3abd308db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac580370c622dfff9c89629768b9a3a"><td class="memItemLeft" align="right" valign="top"><a id="adac580370c622dfff9c89629768b9a3a" name="adac580370c622dfff9c89629768b9a3a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>grow_expansion_zeroelim</b> (int elen, REAL *e, REAL b, REAL *h)</td></tr>
<tr class="separator:adac580370c622dfff9c89629768b9a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebdd2e9b7180cdaa87ca8909ef65cdf"><td class="memItemLeft" align="right" valign="top"><a id="acebdd2e9b7180cdaa87ca8909ef65cdf" name="acebdd2e9b7180cdaa87ca8909ef65cdf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>expansion_sum</b> (int elen, REAL *e, int flen, REAL *f, REAL *h)</td></tr>
<tr class="separator:acebdd2e9b7180cdaa87ca8909ef65cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af419ba290454a72f1b89c9e2d123b72d"><td class="memItemLeft" align="right" valign="top"><a id="af419ba290454a72f1b89c9e2d123b72d" name="af419ba290454a72f1b89c9e2d123b72d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>expansion_sum_zeroelim1</b> (int elen, REAL *e, int flen, REAL *f, REAL *h)</td></tr>
<tr class="separator:af419ba290454a72f1b89c9e2d123b72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb78d6ae312acf7fcd7e7970eddc89b"><td class="memItemLeft" align="right" valign="top"><a id="a1cb78d6ae312acf7fcd7e7970eddc89b" name="a1cb78d6ae312acf7fcd7e7970eddc89b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>expansion_sum_zeroelim2</b> (int elen, REAL *e, int flen, REAL *f, REAL *h)</td></tr>
<tr class="separator:a1cb78d6ae312acf7fcd7e7970eddc89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cd7170efbbf4149999f439f206be26"><td class="memItemLeft" align="right" valign="top"><a id="a44cd7170efbbf4149999f439f206be26" name="a44cd7170efbbf4149999f439f206be26"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fast_expansion_sum</b> (int elen, REAL *e, int flen, REAL *f, REAL *h)</td></tr>
<tr class="separator:a44cd7170efbbf4149999f439f206be26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64673461af45e1586f7aefb47ed4ef25"><td class="memItemLeft" align="right" valign="top"><a id="a64673461af45e1586f7aefb47ed4ef25" name="a64673461af45e1586f7aefb47ed4ef25"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fast_expansion_sum_zeroelim</b> (int elen, REAL *e, int flen, REAL *f, REAL *h)</td></tr>
<tr class="separator:a64673461af45e1586f7aefb47ed4ef25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b0c401591fd2be96b3c2a257aec861"><td class="memItemLeft" align="right" valign="top"><a id="a65b0c401591fd2be96b3c2a257aec861" name="a65b0c401591fd2be96b3c2a257aec861"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>linear_expansion_sum</b> (int elen, REAL *e, int flen, REAL *f, REAL *h)</td></tr>
<tr class="separator:a65b0c401591fd2be96b3c2a257aec861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4b50e5ae757901eaf9dfb78fd03af6"><td class="memItemLeft" align="right" valign="top"><a id="a9a4b50e5ae757901eaf9dfb78fd03af6" name="a9a4b50e5ae757901eaf9dfb78fd03af6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>linear_expansion_sum_zeroelim</b> (int elen, REAL *e, int flen, REAL *f, REAL *h)</td></tr>
<tr class="separator:a9a4b50e5ae757901eaf9dfb78fd03af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb674c1e31af3bf58f172ec347795b0b"><td class="memItemLeft" align="right" valign="top"><a id="acb674c1e31af3bf58f172ec347795b0b" name="acb674c1e31af3bf58f172ec347795b0b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>scale_expansion</b> (int elen, REAL *e, REAL b, REAL *h)</td></tr>
<tr class="separator:acb674c1e31af3bf58f172ec347795b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0c55a70f71c5b896db28185b33309c"><td class="memItemLeft" align="right" valign="top"><a id="a4e0c55a70f71c5b896db28185b33309c" name="a4e0c55a70f71c5b896db28185b33309c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>scale_expansion_zeroelim</b> (int elen, REAL *e, REAL b, REAL *h)</td></tr>
<tr class="separator:a4e0c55a70f71c5b896db28185b33309c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305c33ae3747afe47af0d7b00efa677c"><td class="memItemLeft" align="right" valign="top"><a id="a305c33ae3747afe47af0d7b00efa677c" name="a305c33ae3747afe47af0d7b00efa677c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>compress</b> (int elen, REAL *e, REAL *h)</td></tr>
<tr class="separator:a305c33ae3747afe47af0d7b00efa677c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eddc14cd1fc3964b34c32b51ba7ed33"><td class="memItemLeft" align="right" valign="top"><a id="a1eddc14cd1fc3964b34c32b51ba7ed33" name="a1eddc14cd1fc3964b34c32b51ba7ed33"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>estimate</b> (int elen, REAL *e)</td></tr>
<tr class="separator:a1eddc14cd1fc3964b34c32b51ba7ed33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6878e4dbfe9027ca701a91aef233c3"><td class="memItemLeft" align="right" valign="top"><a id="a7e6878e4dbfe9027ca701a91aef233c3" name="a7e6878e4dbfe9027ca701a91aef233c3"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient2dfast</b> (REAL *pa, REAL *pb, REAL *pc)</td></tr>
<tr class="separator:a7e6878e4dbfe9027ca701a91aef233c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49a8b11f5ea093258592bb7052e1157"><td class="memItemLeft" align="right" valign="top"><a id="ad49a8b11f5ea093258592bb7052e1157" name="ad49a8b11f5ea093258592bb7052e1157"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient2dexact</b> (REAL *pa, REAL *pb, REAL *pc)</td></tr>
<tr class="separator:ad49a8b11f5ea093258592bb7052e1157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f876ab2fa840b2a15f9027034330ccf"><td class="memItemLeft" align="right" valign="top"><a id="a1f876ab2fa840b2a15f9027034330ccf" name="a1f876ab2fa840b2a15f9027034330ccf"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient2dslow</b> (REAL *pa, REAL *pb, REAL *pc)</td></tr>
<tr class="separator:a1f876ab2fa840b2a15f9027034330ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1234c0b1c6cb47168bb1b3bc469db09"><td class="memItemLeft" align="right" valign="top"><a id="ac1234c0b1c6cb47168bb1b3bc469db09" name="ac1234c0b1c6cb47168bb1b3bc469db09"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient2dadapt</b> (const REAL *pa, const REAL *pb, const REAL *pc, REAL detsum)</td></tr>
<tr class="separator:ac1234c0b1c6cb47168bb1b3bc469db09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58202917935652184ce61d401eb76fc2"><td class="memItemLeft" align="right" valign="top"><a id="a58202917935652184ce61d401eb76fc2" name="a58202917935652184ce61d401eb76fc2"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient2d</b> (const REAL *pa, const REAL *pb, const REAL *pc)</td></tr>
<tr class="separator:a58202917935652184ce61d401eb76fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0094977725046c81f719e83ec2c2ee"><td class="memItemLeft" align="right" valign="top"><a id="afb0094977725046c81f719e83ec2c2ee" name="afb0094977725046c81f719e83ec2c2ee"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient3dfast</b> (REAL *pa, REAL *pb, REAL *pc, REAL *pd)</td></tr>
<tr class="separator:afb0094977725046c81f719e83ec2c2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08cf7d017c778cc0d72ea92a8b86ddf"><td class="memItemLeft" align="right" valign="top"><a id="aa08cf7d017c778cc0d72ea92a8b86ddf" name="aa08cf7d017c778cc0d72ea92a8b86ddf"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient3dexact</b> (REAL *pa, REAL *pb, REAL *pc, REAL *pd)</td></tr>
<tr class="separator:aa08cf7d017c778cc0d72ea92a8b86ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a70c945687ea156d87a366ebb846f6"><td class="memItemLeft" align="right" valign="top"><a id="aa2a70c945687ea156d87a366ebb846f6" name="aa2a70c945687ea156d87a366ebb846f6"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient3dslow</b> (REAL *pa, REAL *pb, REAL *pc, REAL *pd)</td></tr>
<tr class="separator:aa2a70c945687ea156d87a366ebb846f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8a7925cf37855362d8f8921d8a9bac"><td class="memItemLeft" align="right" valign="top"><a id="a6a8a7925cf37855362d8f8921d8a9bac" name="a6a8a7925cf37855362d8f8921d8a9bac"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient3dadapt</b> (const REAL *pa, const REAL *pb, const REAL *pc, const REAL *pd, REAL permanent)</td></tr>
<tr class="separator:a6a8a7925cf37855362d8f8921d8a9bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9363881d06575bbf2db880682d774919"><td class="memItemLeft" align="right" valign="top"><a id="a9363881d06575bbf2db880682d774919" name="a9363881d06575bbf2db880682d774919"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient3d</b> (const REAL *pa, const REAL *pb, const REAL *pc, const REAL *pd)</td></tr>
<tr class="separator:a9363881d06575bbf2db880682d774919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8e97eac9a834f678f95becfd3669dd"><td class="memItemLeft" align="right" valign="top"><a id="a6b8e97eac9a834f678f95becfd3669dd" name="a6b8e97eac9a834f678f95becfd3669dd"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>incirclefast</b> (REAL *pa, REAL *pb, REAL *pc, REAL *pd)</td></tr>
<tr class="separator:a6b8e97eac9a834f678f95becfd3669dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcee429b2a640a145140fd0fae825105"><td class="memItemLeft" align="right" valign="top"><a id="abcee429b2a640a145140fd0fae825105" name="abcee429b2a640a145140fd0fae825105"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>incircleexact</b> (REAL *pa, REAL *pb, REAL *pc, REAL *pd)</td></tr>
<tr class="separator:abcee429b2a640a145140fd0fae825105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac967abb6551518b4e801053f6f719d5e"><td class="memItemLeft" align="right" valign="top"><a id="ac967abb6551518b4e801053f6f719d5e" name="ac967abb6551518b4e801053f6f719d5e"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>incircleslow</b> (REAL *pa, REAL *pb, REAL *pc, REAL *pd)</td></tr>
<tr class="separator:ac967abb6551518b4e801053f6f719d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f75e2731400cad35258f91b60cb5b7"><td class="memItemLeft" align="right" valign="top"><a id="a92f75e2731400cad35258f91b60cb5b7" name="a92f75e2731400cad35258f91b60cb5b7"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>incircleadapt</b> (const REAL *pa, const REAL *pb, const REAL *pc, const REAL *pd, REAL permanent)</td></tr>
<tr class="separator:a92f75e2731400cad35258f91b60cb5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b521b4e3179ff75a9ff8b4575ba8a9"><td class="memItemLeft" align="right" valign="top"><a id="a82b521b4e3179ff75a9ff8b4575ba8a9" name="a82b521b4e3179ff75a9ff8b4575ba8a9"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>incircle</b> (const REAL *pa, const REAL *pb, const REAL *pc, const REAL *pd)</td></tr>
<tr class="separator:a82b521b4e3179ff75a9ff8b4575ba8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158ea63a802157ba627f16897d75c973"><td class="memItemLeft" align="right" valign="top"><a id="a158ea63a802157ba627f16897d75c973" name="a158ea63a802157ba627f16897d75c973"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>inspherefast</b> (REAL *pa, REAL *pb, REAL *pc, REAL *pd, REAL *pe)</td></tr>
<tr class="separator:a158ea63a802157ba627f16897d75c973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26840a9da46ab07ab066e73cb8ea21c"><td class="memItemLeft" align="right" valign="top"><a id="ad26840a9da46ab07ab066e73cb8ea21c" name="ad26840a9da46ab07ab066e73cb8ea21c"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>insphereexact</b> (const REAL *pa, const REAL *pb, const REAL *pc, const REAL *pd, const REAL *pe)</td></tr>
<tr class="separator:ad26840a9da46ab07ab066e73cb8ea21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ad1a62c55f593bbd02d7cc45cc624d"><td class="memItemLeft" align="right" valign="top"><a id="a62ad1a62c55f593bbd02d7cc45cc624d" name="a62ad1a62c55f593bbd02d7cc45cc624d"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>insphereslow</b> (REAL *pa, REAL *pb, REAL *pc, REAL *pd, REAL *pe)</td></tr>
<tr class="separator:a62ad1a62c55f593bbd02d7cc45cc624d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561195d75fce8ca635fa290176b703d5"><td class="memItemLeft" align="right" valign="top"><a id="a561195d75fce8ca635fa290176b703d5" name="a561195d75fce8ca635fa290176b703d5"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>insphereadapt</b> (const REAL *pa, const REAL *pb, const REAL *pc, const REAL *pd, const REAL *pe, REAL permanent)</td></tr>
<tr class="separator:a561195d75fce8ca635fa290176b703d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5d5eff1af12dbe5f40292a7cfe6aec"><td class="memItemLeft" align="right" valign="top"><a id="afa5d5eff1af12dbe5f40292a7cfe6aec" name="afa5d5eff1af12dbe5f40292a7cfe6aec"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>insphere</b> (const REAL *pa, const REAL *pb, const REAL *pc, const REAL *pd, const REAL *pe)</td></tr>
<tr class="separator:afa5d5eff1af12dbe5f40292a7cfe6aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970b81a3e9b0d1a44f3adc7e2cdf580c"><td class="memTemplParams" colspan="2"><a id="a970b81a3e9b0d1a44f3adc7e2cdf580c" name="a970b81a3e9b0d1a44f3adc7e2cdf580c"></a>
template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a970b81a3e9b0d1a44f3adc7e2cdf580c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>append_triangles_from_quad</b> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Index f, std::vector&lt; Index &gt; &amp;new_to_old_corners, std::vector&lt; Index &gt; &amp;new_to_old_facets)</td></tr>
<tr class="separator:a970b81a3e9b0d1a44f3adc7e2cdf580c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d3207563ee43d0a8f882300041c935"><td class="memTemplParams" colspan="2"><a id="a10d3207563ee43d0a8f882300041c935" name="a10d3207563ee43d0a8f882300041c935"></a>
template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a10d3207563ee43d0a8f882300041c935"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Vector3&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>facet_normal</b> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Index f)</td></tr>
<tr class="separator:a10d3207563ee43d0a8f882300041c935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03e8e86e41f5c73dc585d8a25c96fed"><td class="memTemplParams" colspan="2"><a id="ae03e8e86e41f5c73dc585d8a25c96fed" name="ae03e8e86e41f5c73dc585d8a25c96fed"></a>
template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ae03e8e86e41f5c73dc585d8a25c96fed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_best_2d_axes</b> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Index f)</td></tr>
<tr class="separator:ae03e8e86e41f5c73dc585d8a25c96fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bece44818b45f6d459fd145debfc2a"><td class="memTemplParams" colspan="2"><a id="a43bece44818b45f6d459fd145debfc2a" name="a43bece44818b45f6d459fd145debfc2a"></a>
template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a43bece44818b45f6d459fd145debfc2a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>append_triangles_from_polygon</b> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Index f, std::vector&lt; std::array&lt; Scalar, 2 &gt; &gt; &amp;polygon, <a class="el" href="classlagrange_1_1mapbox_1_1detail_1_1_earcut.html">mapbox::detail::Earcut</a>&lt; Index &gt; &amp;earcut, std::vector&lt; Index &gt; &amp;new_to_old_corners, std::vector&lt; Index &gt; &amp;new_to_old_facets)</td></tr>
<tr class="separator:a43bece44818b45f6d459fd145debfc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543dd5597eb971f6bc033d98c43668e0"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedE &gt; </td></tr>
<tr class="memitem:a543dd5597eb971f6bc033d98c43668e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a543dd5597eb971f6bc033d98c43668e0">save_graph_off</a> (const fs::path &amp;filename, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E)</td></tr>
<tr class="memdesc:a543dd5597eb971f6bc033d98c43668e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a 2D undirected graph (V,E) using off format.  <a href="namespacelagrange.html#a543dd5597eb971f6bc033d98c43668e0">More...</a><br /></td></tr>
<tr class="separator:a543dd5597eb971f6bc033d98c43668e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d4d2d6a7e5f4ad401de8e767baa007"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedE &gt; </td></tr>
<tr class="memitem:ab9d4d2d6a7e5f4ad401de8e767baa007"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ab9d4d2d6a7e5f4ad401de8e767baa007">save_graph</a> (const fs::path &amp;filename, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E)</td></tr>
<tr class="memdesc:ab9d4d2d6a7e5f4ad401de8e767baa007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a 2D undirected graph (V,E) based on filename extension.  <a href="namespacelagrange.html#ab9d4d2d6a7e5f4ad401de8e767baa007">More...</a><br /></td></tr>
<tr class="separator:ab9d4d2d6a7e5f4ad401de8e767baa007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Sequential iteration for read operations</div></td></tr>
<tr class="memitem:gadce8815f774af555e6df4bd17b315395"><td class="memTemplParams" colspan="2">template&lt;std::underlying_type_t&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; mask = BitField&lt;AttributeElement&gt;::all(), typename Visitor , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gadce8815f774af555e6df4bd17b315395"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-iterate.html#gadce8815f774af555e6df4bd17b315395">seq_foreach_named_attribute_read</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Visitor &amp;&amp;vis)</td></tr>
<tr class="memdesc:gadce8815f774af555e6df4bd17b315395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to each attribute of a mesh.  <a href="group__group-surfacemesh-iterate.html#gadce8815f774af555e6df4bd17b315395">More...</a><br /></td></tr>
<tr class="separator:gadce8815f774af555e6df4bd17b315395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7507438bc2c5f741096049ea1fa2d2c"><td class="memTemplParams" colspan="2">template&lt;std::underlying_type_t&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; mask = BitField&lt;AttributeElement&gt;::all(), typename Visitor , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gaa7507438bc2c5f741096049ea1fa2d2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-iterate.html#gaa7507438bc2c5f741096049ea1fa2d2c">seq_foreach_attribute_read</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Visitor &amp;&amp;vis)</td></tr>
<tr class="memdesc:gaa7507438bc2c5f741096049ea1fa2d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to each attribute of a mesh.  <a href="group__group-surfacemesh-iterate.html#gaa7507438bc2c5f741096049ea1fa2d2c">More...</a><br /></td></tr>
<tr class="separator:gaa7507438bc2c5f741096049ea1fa2d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Sequential iteration for write operations</div></td></tr>
<tr class="memitem:gab5aca7a09a5cfc56594012cb11f5a0f6"><td class="memTemplParams" colspan="2">template&lt;std::underlying_type_t&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; mask = BitField&lt;AttributeElement&gt;::all(), typename Visitor , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gab5aca7a09a5cfc56594012cb11f5a0f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-iterate.html#gab5aca7a09a5cfc56594012cb11f5a0f6">seq_foreach_named_attribute_write</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Visitor &amp;&amp;vis)</td></tr>
<tr class="memdesc:gab5aca7a09a5cfc56594012cb11f5a0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to each attribute of a mesh.  <a href="group__group-surfacemesh-iterate.html#gab5aca7a09a5cfc56594012cb11f5a0f6">More...</a><br /></td></tr>
<tr class="separator:gab5aca7a09a5cfc56594012cb11f5a0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f02ece66717b468c535f9fe363e1d76"><td class="memTemplParams" colspan="2">template&lt;std::underlying_type_t&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; mask = BitField&lt;AttributeElement&gt;::all(), typename Visitor , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga5f02ece66717b468c535f9fe363e1d76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-iterate.html#ga5f02ece66717b468c535f9fe363e1d76">seq_foreach_attribute_write</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Visitor &amp;&amp;vis)</td></tr>
<tr class="memdesc:ga5f02ece66717b468c535f9fe363e1d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to each attribute of a mesh.  <a href="group__group-surfacemesh-iterate.html#ga5f02ece66717b468c535f9fe363e1d76">More...</a><br /></td></tr>
<tr class="separator:ga5f02ece66717b468c535f9fe363e1d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Parallel iteration for read operations</div></td></tr>
<tr class="memitem:gade068c96e01f887e149c982f8179b6bf"><td class="memTemplParams" colspan="2">template&lt;std::underlying_type_t&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; mask = BitField&lt;AttributeElement&gt;::all(), typename Visitor , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gade068c96e01f887e149c982f8179b6bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-iterate.html#gade068c96e01f887e149c982f8179b6bf">par_foreach_named_attribute_read</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Visitor &amp;&amp;vis)</td></tr>
<tr class="memdesc:gade068c96e01f887e149c982f8179b6bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function in parallel to each attribute of a mesh.  <a href="group__group-surfacemesh-iterate.html#gade068c96e01f887e149c982f8179b6bf">More...</a><br /></td></tr>
<tr class="separator:gade068c96e01f887e149c982f8179b6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf17ea3ab86409dcf90bdf2cb9d7fd830"><td class="memTemplParams" colspan="2">template&lt;std::underlying_type_t&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; mask = BitField&lt;AttributeElement&gt;::all(), typename Visitor , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gaf17ea3ab86409dcf90bdf2cb9d7fd830"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-iterate.html#gaf17ea3ab86409dcf90bdf2cb9d7fd830">par_foreach_attribute_read</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Visitor &amp;&amp;vis)</td></tr>
<tr class="memdesc:gaf17ea3ab86409dcf90bdf2cb9d7fd830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function in parallel to each attribute of a mesh.  <a href="group__group-surfacemesh-iterate.html#gaf17ea3ab86409dcf90bdf2cb9d7fd830">More...</a><br /></td></tr>
<tr class="separator:gaf17ea3ab86409dcf90bdf2cb9d7fd830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Parallel iteration for write operations</div></td></tr>
<tr class="memitem:ga0eeb72cbb5e00739721bdd9b2c1dd1f8"><td class="memTemplParams" colspan="2">template&lt;std::underlying_type_t&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; mask = BitField&lt;AttributeElement&gt;::all(), typename Visitor , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga0eeb72cbb5e00739721bdd9b2c1dd1f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-iterate.html#ga0eeb72cbb5e00739721bdd9b2c1dd1f8">par_foreach_named_attribute_write</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Visitor &amp;&amp;vis)</td></tr>
<tr class="memdesc:ga0eeb72cbb5e00739721bdd9b2c1dd1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function in parallel to each attribute of a mesh.  <a href="group__group-surfacemesh-iterate.html#ga0eeb72cbb5e00739721bdd9b2c1dd1f8">More...</a><br /></td></tr>
<tr class="separator:ga0eeb72cbb5e00739721bdd9b2c1dd1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8327da1903fcb919d87b7fd6b7ea479"><td class="memTemplParams" colspan="2">template&lt;std::underlying_type_t&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; mask = BitField&lt;AttributeElement&gt;::all(), typename Visitor , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gab8327da1903fcb919d87b7fd6b7ea479"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-iterate.html#gab8327da1903fcb919d87b7fd6b7ea479">par_foreach_attribute_write</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Visitor &amp;&amp;vis)</td></tr>
<tr class="memdesc:gab8327da1903fcb919d87b7fd6b7ea479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function in parallel to each attribute of a mesh.  <a href="group__group-surfacemesh-iterate.html#gab8327da1903fcb919d87b7fd6b7ea479">More...</a><br /></td></tr>
<tr class="separator:gab8327da1903fcb919d87b7fd6b7ea479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Attribute remapping</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Mapping attributes between different element types.</p>
<ul>
<li>When mapping indexed to value attributes, values are duplicated for each corner, since otherwise the mapping corner -&gt; value would be lost.</li>
<li>When mapping value to indexed attributes, the size of the value buffer must be equal to the number of corners. The values are not deduplicated in the new indexed attribute. </li>
</ul>
</div></td></tr>
<tr class="memitem:gad7a1e90b26e460f8b9afc7efbca95cc4"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gad7a1e90b26e460f8b9afc7efbca95cc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr-utils.html#gad7a1e90b26e460f8b9afc7efbca95cc4">map_attribute</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id, std::string_view new_name, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> new_element)</td></tr>
<tr class="memdesc:gad7a1e90b26e460f8b9afc7efbca95cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map attribute values to a new attribute with a different element type.  <a href="group__group-surfacemesh-attr-utils.html#gad7a1e90b26e460f8b9afc7efbca95cc4">More...</a><br /></td></tr>
<tr class="separator:gad7a1e90b26e460f8b9afc7efbca95cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38348fa42743d4cb72a1a2975483acc1"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga38348fa42743d4cb72a1a2975483acc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr-utils.html#ga38348fa42743d4cb72a1a2975483acc1">map_attribute</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view old_name, std::string_view new_name, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> new_element)</td></tr>
<tr class="memdesc:ga38348fa42743d4cb72a1a2975483acc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map attribute values to a new attribute with a different element type.  <a href="group__group-surfacemesh-attr-utils.html#ga38348fa42743d4cb72a1a2975483acc1">More...</a><br /></td></tr>
<tr class="separator:ga38348fa42743d4cb72a1a2975483acc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd6500c173df1a5bc53e2c9b32e08309"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gacd6500c173df1a5bc53e2c9b32e08309"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr-utils.html#gacd6500c173df1a5bc53e2c9b32e08309">map_attribute_in_place</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> new_element)</td></tr>
<tr class="memdesc:gacd6500c173df1a5bc53e2c9b32e08309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map attribute values to a different element type.  <a href="group__group-surfacemesh-attr-utils.html#gacd6500c173df1a5bc53e2c9b32e08309">More...</a><br /></td></tr>
<tr class="separator:gacd6500c173df1a5bc53e2c9b32e08309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a2e525bede1624580d71782861b0cd6"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga4a2e525bede1624580d71782861b0cd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr-utils.html#ga4a2e525bede1624580d71782861b0cd6">map_attribute_in_place</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> new_element)</td></tr>
<tr class="memdesc:ga4a2e525bede1624580d71782861b0cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map attribute values to a different element type.  <a href="group__group-surfacemesh-attr-utils.html#ga4a2e525bede1624580d71782861b0cd6">More...</a><br /></td></tr>
<tr class="separator:ga4a2e525bede1624580d71782861b0cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Index buffer unification</div></td></tr>
<tr class="memitem:gae8deb2977d6d78e0b8e3a9a7773b6c72"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gae8deb2977d6d78e0b8e3a9a7773b6c72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr-utils.html#gae8deb2977d6d78e0b8e3a9a7773b6c72">unify_index_buffer</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const std::vector&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> &gt; &amp;attribute_ids={})</td></tr>
<tr class="memdesc:gae8deb2977d6d78e0b8e3a9a7773b6c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unify index buffers of the input <code>mesh</code> for all attributes specified in <code>attribute_ids</code>.  <a href="group__group-surfacemesh-attr-utils.html#gae8deb2977d6d78e0b8e3a9a7773b6c72">More...</a><br /></td></tr>
<tr class="separator:gae8deb2977d6d78e0b8e3a9a7773b6c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40817d91add1d124cc9f362f019d1f0c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga40817d91add1d124cc9f362f019d1f0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr-utils.html#ga40817d91add1d124cc9f362f019d1f0c">unify_named_index_buffer</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const std::vector&lt; std::string_view &gt; &amp;attribute_names)</td></tr>
<tr class="memdesc:ga40817d91add1d124cc9f362f019d1f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-surfacemesh-attr-utils.html#ga40817d91add1d124cc9f362f019d1f0c">More...</a><br /></td></tr>
<tr class="separator:ga40817d91add1d124cc9f362f019d1f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5386fd92d0f0b425828b32d3e399eca8"><td class="memTemplParams" colspan="2"><a id="a5386fd92d0f0b425828b32d3e399eca8" name="a5386fd92d0f0b425828b32d3e399eca8"></a>
template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a5386fd92d0f0b425828b32d3e399eca8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structlagrange_1_1_stack_set.html">StackSet</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structlagrange_1_1_stack_set.html">StackSet</a>&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="separator:a5386fd92d0f0b425828b32d3e399eca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6c2fec5574044bb48e577e570bfd3676"><td class="memTemplParams" colspan="2"><a id="a6c2fec5574044bb48e577e570bfd3676" name="a6c2fec5574044bb48e577e570bfd3676"></a>
template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a6c2fec5574044bb48e577e570bfd3676"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structlagrange_1_1_stack_vector.html">StackVector</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structlagrange_1_1_stack_vector.html">StackVector</a>&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="separator:a6c2fec5574044bb48e577e570bfd3676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Generic attribute views</div></td></tr>
<tr class="memitem:gaf2e0d4ab50ffdc84c4431d699f6741fe"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:gaf2e0d4ab50ffdc84c4431d699f6741fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga06ca3172e4577c726eaf8d2ab26a1ab5">RowMatrixView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#gaf2e0d4ab50ffdc84c4431d699f6741fe">matrix_ref</a> (<a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp;attribute)</td></tr>
<tr class="memdesc:gaf2e0d4ab50ffdc84c4431d699f6741fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writable view of a given attribute in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#gaf2e0d4ab50ffdc84c4431d699f6741fe">More...</a><br /></td></tr>
<tr class="separator:gaf2e0d4ab50ffdc84c4431d699f6741fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ae9d0742709686405adad75e20e8bc8"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ga0ae9d0742709686405adad75e20e8bc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#gafe9823dfafe170f84504176f997c1d8c">ConstRowMatrixView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga0ae9d0742709686405adad75e20e8bc8">matrix_view</a> (const <a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp;attribute)</td></tr>
<tr class="memdesc:ga0ae9d0742709686405adad75e20e8bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only view of a given attribute in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#ga0ae9d0742709686405adad75e20e8bc8">More...</a><br /></td></tr>
<tr class="separator:ga0ae9d0742709686405adad75e20e8bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fe8e6f4f2ff0c10903d49ec085e541a"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ga1fe8e6f4f2ff0c10903d49ec085e541a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga373c385fbf8ee25f008de6d6575118ab">VectorView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga1fe8e6f4f2ff0c10903d49ec085e541a">vector_ref</a> (<a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp;attribute)</td></tr>
<tr class="memdesc:ga1fe8e6f4f2ff0c10903d49ec085e541a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writable view of a scalar attribute in the form of an Eigen vector.  <a href="group__group-surfacemesh-views.html#ga1fe8e6f4f2ff0c10903d49ec085e541a">More...</a><br /></td></tr>
<tr class="separator:ga1fe8e6f4f2ff0c10903d49ec085e541a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga217fb9661440df5dd7025d26cfeaf4d6"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ga217fb9661440df5dd7025d26cfeaf4d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga8801fb865cd458d4db0c42de4bd9130a">ConstVectorView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga217fb9661440df5dd7025d26cfeaf4d6">vector_view</a> (const <a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp;attribute)</td></tr>
<tr class="memdesc:ga217fb9661440df5dd7025d26cfeaf4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only view of a scalar attribute in the form of an Eigen vector.  <a href="group__group-surfacemesh-views.html#ga217fb9661440df5dd7025d26cfeaf4d6">More...</a><br /></td></tr>
<tr class="separator:ga217fb9661440df5dd7025d26cfeaf4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c3faebd019aa5400b5c97d8558f5f21"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ga8c3faebd019aa5400b5c97d8558f5f21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga06ca3172e4577c726eaf8d2ab26a1ab5">RowMatrixView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga8c3faebd019aa5400b5c97d8558f5f21">reshaped_ref</a> (<a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp;attribute, size_t num_cols)</td></tr>
<tr class="memdesc:ga8c3faebd019aa5400b5c97d8558f5f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writable view of a given single-channel attribute in the form of an Eigen matrix with a prescribed number of columns.  <a href="group__group-surfacemesh-views.html#ga8c3faebd019aa5400b5c97d8558f5f21">More...</a><br /></td></tr>
<tr class="separator:ga8c3faebd019aa5400b5c97d8558f5f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85cdda0a43cfba607a3145feebcdb5c8"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ga85cdda0a43cfba607a3145feebcdb5c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#gafe9823dfafe170f84504176f997c1d8c">ConstRowMatrixView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga85cdda0a43cfba607a3145feebcdb5c8">reshaped_view</a> (const <a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp;attribute, size_t num_cols)</td></tr>
<tr class="memdesc:ga85cdda0a43cfba607a3145feebcdb5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only view of a given single-channel attribute in the form of an Eigen matrix with a prescribed number of columns.  <a href="group__group-surfacemesh-views.html#ga85cdda0a43cfba607a3145feebcdb5c8">More...</a><br /></td></tr>
<tr class="separator:ga85cdda0a43cfba607a3145feebcdb5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Generic attribute views (mesh)</div></td></tr>
<tr class="memitem:ga4bef44f19fd375bf20e21bfecba3012d"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga4bef44f19fd375bf20e21bfecba3012d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga06ca3172e4577c726eaf8d2ab26a1ab5">RowMatrixView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga4bef44f19fd375bf20e21bfecba3012d">attribute_matrix_ref</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view name)</td></tr>
<tr class="memdesc:ga4bef44f19fd375bf20e21bfecba3012d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writable view of a mesh attribute in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#ga4bef44f19fd375bf20e21bfecba3012d">More...</a><br /></td></tr>
<tr class="separator:ga4bef44f19fd375bf20e21bfecba3012d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66fb9a3cd6aa7916b0be5316e4c5b735"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga66fb9a3cd6aa7916b0be5316e4c5b735"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga06ca3172e4577c726eaf8d2ab26a1ab5">RowMatrixView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga66fb9a3cd6aa7916b0be5316e4c5b735">attribute_matrix_ref</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id)</td></tr>
<tr class="memdesc:ga66fb9a3cd6aa7916b0be5316e4c5b735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writable view of a mesh attribute in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#ga66fb9a3cd6aa7916b0be5316e4c5b735">More...</a><br /></td></tr>
<tr class="separator:ga66fb9a3cd6aa7916b0be5316e4c5b735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eac5d03d3893046ab95ea62407c4dd7"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga0eac5d03d3893046ab95ea62407c4dd7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#gafe9823dfafe170f84504176f997c1d8c">ConstRowMatrixView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga0eac5d03d3893046ab95ea62407c4dd7">attribute_matrix_view</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view name)</td></tr>
<tr class="memdesc:ga0eac5d03d3893046ab95ea62407c4dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only view of a mesh attribute in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#ga0eac5d03d3893046ab95ea62407c4dd7">More...</a><br /></td></tr>
<tr class="separator:ga0eac5d03d3893046ab95ea62407c4dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7515287d007f73bb5e32388420ac7c9e"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga7515287d007f73bb5e32388420ac7c9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#gafe9823dfafe170f84504176f997c1d8c">ConstRowMatrixView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga7515287d007f73bb5e32388420ac7c9e">attribute_matrix_view</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id)</td></tr>
<tr class="memdesc:ga7515287d007f73bb5e32388420ac7c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only view of a mesh attribute in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#ga7515287d007f73bb5e32388420ac7c9e">More...</a><br /></td></tr>
<tr class="separator:ga7515287d007f73bb5e32388420ac7c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5edab3687afa62046eaf874ceae232f8"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga5edab3687afa62046eaf874ceae232f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga373c385fbf8ee25f008de6d6575118ab">VectorView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga5edab3687afa62046eaf874ceae232f8">attribute_vector_ref</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view name)</td></tr>
<tr class="memdesc:ga5edab3687afa62046eaf874ceae232f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writable view of a mesh attribute in the form of an Eigen vector.  <a href="group__group-surfacemesh-views.html#ga5edab3687afa62046eaf874ceae232f8">More...</a><br /></td></tr>
<tr class="separator:ga5edab3687afa62046eaf874ceae232f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cb1140345c1029da1566dc095aabb4a"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga2cb1140345c1029da1566dc095aabb4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga373c385fbf8ee25f008de6d6575118ab">VectorView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga2cb1140345c1029da1566dc095aabb4a">attribute_vector_ref</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id)</td></tr>
<tr class="memdesc:ga2cb1140345c1029da1566dc095aabb4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writable view of a mesh attribute in the form of an Eigen vector.  <a href="group__group-surfacemesh-views.html#ga2cb1140345c1029da1566dc095aabb4a">More...</a><br /></td></tr>
<tr class="separator:ga2cb1140345c1029da1566dc095aabb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ff70d67260c645c51ea43c8d95de74"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gad4ff70d67260c645c51ea43c8d95de74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga8801fb865cd458d4db0c42de4bd9130a">ConstVectorView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#gad4ff70d67260c645c51ea43c8d95de74">attribute_vector_view</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view name)</td></tr>
<tr class="memdesc:gad4ff70d67260c645c51ea43c8d95de74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only view of a mesh attribute in the form of an Eigen vector.  <a href="group__group-surfacemesh-views.html#gad4ff70d67260c645c51ea43c8d95de74">More...</a><br /></td></tr>
<tr class="separator:gad4ff70d67260c645c51ea43c8d95de74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga397ee663ce6493e1acba89814482c971"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga397ee663ce6493e1acba89814482c971"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga8801fb865cd458d4db0c42de4bd9130a">ConstVectorView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga397ee663ce6493e1acba89814482c971">attribute_vector_view</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id)</td></tr>
<tr class="memdesc:ga397ee663ce6493e1acba89814482c971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only view of a mesh attribute in the form of an Eigen vector.  <a href="group__group-surfacemesh-views.html#ga397ee663ce6493e1acba89814482c971">More...</a><br /></td></tr>
<tr class="separator:ga397ee663ce6493e1acba89814482c971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Specific attribute views</div></td></tr>
<tr class="memitem:ga6b51e5a79a66e11c3dff4c1d68015c1c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga6b51e5a79a66e11c3dff4c1d68015c1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga06ca3172e4577c726eaf8d2ab26a1ab5">RowMatrixView</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga6b51e5a79a66e11c3dff4c1d68015c1c">vertex_ref</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga6b51e5a79a66e11c3dff4c1d68015c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writable view of the mesh vertices in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#ga6b51e5a79a66e11c3dff4c1d68015c1c">More...</a><br /></td></tr>
<tr class="separator:ga6b51e5a79a66e11c3dff4c1d68015c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e034be5f010e6956225e15059825146"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga2e034be5f010e6956225e15059825146"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#gafe9823dfafe170f84504176f997c1d8c">ConstRowMatrixView</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga2e034be5f010e6956225e15059825146">vertex_view</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga2e034be5f010e6956225e15059825146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only view of the mesh vertices in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#ga2e034be5f010e6956225e15059825146">More...</a><br /></td></tr>
<tr class="separator:ga2e034be5f010e6956225e15059825146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8c34105b292c12cff41b1dec4bca137"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gae8c34105b292c12cff41b1dec4bca137"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga06ca3172e4577c726eaf8d2ab26a1ab5">RowMatrixView</a>&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#gae8c34105b292c12cff41b1dec4bca137">facet_ref</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:gae8c34105b292c12cff41b1dec4bca137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writable view of a mesh facets in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#gae8c34105b292c12cff41b1dec4bca137">More...</a><br /></td></tr>
<tr class="separator:gae8c34105b292c12cff41b1dec4bca137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a158f542405b5b869533b691f18ed8d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga8a158f542405b5b869533b691f18ed8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#gafe9823dfafe170f84504176f997c1d8c">ConstRowMatrixView</a>&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga8a158f542405b5b869533b691f18ed8d">facet_view</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga8a158f542405b5b869533b691f18ed8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only view of a mesh facets in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#ga8a158f542405b5b869533b691f18ed8d">More...</a><br /></td></tr>
<tr class="separator:ga8a158f542405b5b869533b691f18ed8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Main namespace for Lagrange. </p>
<p >This header exposes functionality of previously registered mesh types To register new mesh type, include &lt;<a class="el" href="mesh_8impl_8h_source.html">lagrange/ui/utils/mesh.impl.h</a>&gt; and call register_mesh_type&lt;MeshType&gt;</p>
<p >Events triggered by the default systems Use <code>ui::on&lt;Event&gt;(registry, [](Event&amp; e){})</code> to register a listener Use <code><a class="el" href="namespacelagrange_1_1ui.html#a10a00b0fae97d776cea0b0cc54a74206" title="Trigger an event of type Event.">ui::publish</a>&lt;Event&gt;(registry, args ...)</code> to trigger a custom event See &lt;<a class="el" href="events_8h_source.html">lagrange/ui/utils/events.h</a>&gt; for more details.</p>
<p >Private methods.</p>
<p >Utility functions that don't belong anywhere else.</p>
<p >Evaluates a function for each mesh element and stores the result as an attribute.</p>
<p >Consider refactoring this file if it becomes too big, or categories emerge. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a1415024ce537125d1d9b6552826a9249" name="a1415024ce537125d1d9b6552826a9249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1415024ce537125d1d9b6552826a9249">&#9670;&nbsp;</a></span>condense_indexed_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lagrange::condense_indexed_attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attr_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_attr_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Condense indexed attribute reduces the attribute value array size by eliminating locally duplicate attribute values. </p>
<p >Comparison operator for index pairs. Return true iff the first index pair is less than the second one lexicographically. This method assumes AttributeArray is row major.</p>
<p >Equality comparison operator between index pairs.</p>

</div>
</div>
<a id="aba6ac800f4af8759f6e33c75293f3303" name="aba6ac800f4af8759f6e33c75293f3303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6ac800f4af8759f6e33c75293f3303">&#9670;&nbsp;</a></span>chain_corners_around_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lagrange::chain_corners_around_edges </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>corner_to_edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_to_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>next_corner_around_edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chains facet corners around edges of a mesh. </p>
<p >The mesh is assumed have polygonal faces of constant degree k. There are #C = #F * k facet corners in this mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">facets</td><td>#F x k array of facet indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">corner_to_edge</td><td>#C x 1 array mapping facet corners to edge indices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">edge_to_corner</td><td>#E x 1 array of first facet corner in the chain starting from a given edge. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next_corner_around_edge</td><td>#C x 1 array of next facet corner in the chain at a given facet corner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedF</td><td>Type of facet array. </td></tr>
    <tr><td class="paramname">DerivedC</td><td>Type of corner to edge vector. </td></tr>
    <tr><td class="paramname">DerivedE</td><td>Type of edge to corner vector. </td></tr>
    <tr><td class="paramname">DerivedN</td><td>Type of next corner vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a399123992e37392b20e51735a796d2e1" name="a399123992e37392b20e51735a796d2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399123992e37392b20e51735a796d2e1">&#9670;&nbsp;</a></span>chain_corners_around_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lagrange::chain_corners_around_vertices </td>
          <td>(</td>
          <td class="paramtype">typename DerivedF::Scalar&#160;</td>
          <td class="paramname"><em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_to_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>next_corner_around_vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chains facet corners around vertices of a mesh. </p>
<p >The mesh is assumed have polygonal faces of constant degree k. There are #C = #F * k facet corners in this mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_vertices</td><td>Number of vertices in the mesh. This information is necessary since there may be isolated vertices, and thus computing it from the facet array may be misleading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facets</td><td>#F x k array of facet indices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vertex_to_corner</td><td>#E x 1 array of first facet corner in the chain starting from a given vertex. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next_corner_around_vertex</td><td>#C x 1 array of next facet corner in the chain at a given facet corner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedF</td><td>Type of facet array. </td></tr>
    <tr><td class="paramname">DerivedE</td><td>Type of vertex to corner vector. </td></tr>
    <tr><td class="paramname">DerivedN</td><td>Type of next corner vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51b77aa6ef7c915c306034bc5f873d69" name="a51b77aa6ef7c915c306034bc5f873d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b77aa6ef7c915c306034bc5f873d69">&#9670;&nbsp;</a></span>chain_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::list&lt; Index &gt; &gt; lagrange::chain_edges </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>close_loop</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chain directed edges into either simple linear chain or simple loops. </p>
<p >A simple use case is to input the rim edges around a vertex. This method will return the boundary loops of the 1-ring neighborhood. If the vertex is locally manifold, only a single chain will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>The set of input edges. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">close_loop</td><td>Whether to mark closed loops by setting the first and last vertex to be the same.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set of edge chains/loops.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the edges forms a complex graphs with nodes of valence more than 2, the extracted chains may not be simple. </dd></dl>
<p >Extend a chain of vertices from the end based on adjacency list stored in next.</p>
<p >Extend a chain of vertices from the front based on adjacency list stored in prev.</p>

</div>
</div>
<a id="a5db43e2c8ec4b75143e325eeb22d0731" name="a5db43e2c8ec4b75143e325eeb22d0731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db43e2c8ec4b75143e325eeb22d0731">&#9670;&nbsp;</a></span>chain_undirected_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; Index &gt; &gt; lagrange::chain_undirected_edges </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>close_loop</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chain undirected edges into chains and loops. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>The set of input undirected edges. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">close_loop</td><td>Whether to mark closed loops by setting the first and last vertex to be the same.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set of edge chains/loops.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Any vertices with more than 2 connected edges will serve as stopping vertices for the chain growing algorithm. </dd></dl>

</div>
</div>
<a id="a4ef73c002aad703ba18464d55e6b70c4" name="a4ef73c002aad703ba18464d55e6b70c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef73c002aad703ba18464d55e6b70c4">&#9670;&nbsp;</a></span>chain_edges_into_simple_loops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lagrange::chain_edges_into_simple_loops </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; typename DerivedE::Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;&#160;</td>
          <td class="paramname"><em>remaining_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chain edges into simple loops by cutting "ears" progressively from the digraph. </p>
<p >An ear is defined as a simple cycle with at most 1 vertex of degree &gt; 2. The input digraph can contain "dangling" vertices (vertices with degree_in != degree_out). If the graph cannot be pruned by removing ears, then the list of remaining edges that cannot be pruned is returned in the remaining_edges output variable (e.g., a chain of "8" that loops back to itself).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edges</td><td>#EI x 2 array of oriented edges in the input digraph. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Output list of loops. Each loop is an array of edge indices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">remaining_edges</td><td>#EO x 2 array of oriented edges that could not be pruned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedE</td><td>Input edge matrix type. </td></tr>
    <tr><td class="paramname">DerivedO</td><td>Output edge matrix type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, False otherwise. </dd></dl>

</div>
</div>
<a id="a596b1dcf8071e6db70a89205248de29e" name="a596b1dcf8071e6db70a89205248de29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596b1dcf8071e6db70a89205248de29e">&#9670;&nbsp;</a></span>move_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lagrange::move_data </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move data from one Eigen obj to another. </p>
<p >Both objects will be in valid state after the move. </p>

</div>
</div>
<a id="a9835bf23b960be3fa3b6f975286b22bc" name="a9835bf23b960be3fa3b6f975286b22bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9835bf23b960be3fa3b6f975286b22bc">&#9670;&nbsp;</a></span>compute_facet_area_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto lagrange::compute_facet_area_raw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> -&gt; AttributeArrayOf&lt;<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the facet areas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Input mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#F x 1 array of facet areas. </dd></dl>

</div>
</div>
<a id="ab6a6397294320512fc58eec12cf5ae33" name="ab6a6397294320512fc58eec12cf5ae33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a6397294320512fc58eec12cf5ae33">&#9670;&nbsp;</a></span>compute_facet_area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lagrange::compute_facet_area </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the facet areas. </p>
<p >The result is stored as a new facet attribute <code>area</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>Input mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a435ef10e7db480d7518a0a151c6e6a94" name="a435ef10e7db480d7518a0a151c6e6a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435ef10e7db480d7518a0a151c6e6a94">&#9670;&nbsp;</a></span>compute_uv_area_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; typename DerivedUV::Scalar, Eigen::Dynamic, 1 &gt; lagrange::compute_uv_area_raw </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;&#160;</td>
          <td class="paramname"><em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the uv areas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uv</td><td>UV vertex positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triangles</td><td>UV triangle indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedUV</td><td>Matrix type of UV vertex positions. </td></tr>
    <tr><td class="paramname">DerivedF</td><td>Matrix type of UV triangle indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#F x 1 array or triangle areas. </dd></dl>

</div>
</div>
<a id="aa206c248b9cde673400c6c87cdecdc1e" name="aa206c248b9cde673400c6c87cdecdc1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa206c248b9cde673400c6c87cdecdc1e">&#9670;&nbsp;</a></span>compute_lift_operator_from_sampling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto lagrange::compute_lift_operator_from_sampling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Cloud &amp;&#160;</td>
          <td class="paramname"><em>closest_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Indices &amp;&#160;</td>
          <td class="paramname"><em>element_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This compute the sparse bilinear map from mesh vertex attributes to point cloud attributes. </p>
<p >Input points are supposed to lie on facets on the input mesh. Each row of element_indices is a input triangle index of which the point at the same row is supposed to lie. It uses barycentric coordinates on each triangle to fill in coeffs of a sparse matrix which is then returned. This bilinear sparse mapping (a.k.a. the returned sparse matrix) can used extend mesh defined fields to fields defined in R^3. This is useful for interpolating positions or scalar curvatures to a sampled point cloud for example. This is suited for use with sampling functions like random_sample_uniform that naturally build the third arg.</p>
<dl class="section return"><dt>Returns</dt><dd>Sparse n*m matrix, where n is the number of vertex in the input mesh and m is the number of vertex in the input point cloud. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Input triangular mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">closest_points</td><td>Input point cloud. should lie on input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element_indices</td><td>Input mesh triangle indices for each point of the input point cloud. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91612133420080167e84167a8bb139c4" name="a91612133420080167e84167a8bb139c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91612133420080167e84167a8bb139c4">&#9670;&nbsp;</a></span>compute_lift_operator_from_projections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto lagrange::compute_lift_operator_from_projections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ClosestPoints &amp;&#160;</td>
          <td class="paramname"><em>projections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This compute the sparse bilinear map from mesh vertex attributes to point cloud attributes. </p>
<p >It uses barycentric coordinates on each triangle to fill in coeffs of a sparse matrix which is then returned. This bilinear sparse mapping (a.k.a. the returned sparse matrix) can used extend mesh defined fields to fields defined in R^3. This is useful for interpolating positions or scalar curvatures to a sampled point cloud for example. This is suited for use with bvh structure whose data return by batch_query can be used as the second arg.</p>
<dl class="section return"><dt>Returns</dt><dd>Sparse n*m matrix, where n is the number of vertex in the input mesh and m is the number of vertex in the input point cloud. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input triangular mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projections</td><td>projections data returned by a call to BVH batch_query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11deb081022f3bfef8d2b527fb605f21" name="a11deb081022f3bfef8d2b527fb605f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11deb081022f3bfef8d2b527fb605f21">&#9670;&nbsp;</a></span>compute_uv_distortion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lagrange::compute_uv_distortion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the distortion of mapping from 3D triangular mesh to UV domain. </p>
<p >Let f : R^2 -&gt; R^2 represent the mapping, and let F = grad(f) be the deformation gradient. The distortion measure is defined as |F|^2 / det(F), where |F| is the Frobenius norm of the matrix and det(F) is its determinant.</p>
<p >See Conformal AMIPS 2D energy: <a href="https://cs.nyu.edu/~panozzo/papers/SLIM2017.pdf">https://cs.nyu.edu/~panozzo/papers/SLIM2017.pdf</a>. </p>

</div>
</div>
<a id="ad34583bdda68644dcd9c7175ce179735" name="ad34583bdda68644dcd9c7175ce179735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34583bdda68644dcd9c7175ce179735">&#9670;&nbsp;</a></span>corner_to_edge_mapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Index corner_to_edge_mapping </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C2E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a mapping from mesh corners (k*f+i) to unique edge ids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F x k matrix of facet indices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C2E</td><td>#F*k vector of unique edge ids per corner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedF</td><td>Type of facet array. </td></tr>
    <tr><td class="paramname">DerivedC</td><td>Type of corner to edge vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of unique edges created. </dd></dl>

</div>
</div>
<a id="a5dff747c765bd02e34d420ab60c30358" name="a5dff747c765bd02e34d420ab60c30358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dff747c765bd02e34d420ab60c30358">&#9670;&nbsp;</a></span>create_mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto lagrange::create_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>facets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function create a new mesh given the vertex and facet arrays by copying data into the <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object. </p>
<p >Both arrays can be of type <code>Eigen::Matrix</code> or <code>Eigen::Map</code>. </p>

</div>
</div>
<a id="a09136a41b52bcbc4f39fc5c62f64e50f" name="a09136a41b52bcbc4f39fc5c62f64e50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09136a41b52bcbc4f39fc5c62f64e50f">&#9670;&nbsp;</a></span>create_mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; DerivedV, DerivedF &gt; &gt; lagrange::create_mesh </td>
          <td>(</td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>facets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function create a new mesh given the vertex and facet arrays by moving data into the <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object. </p>
<p >Both arrays must be of type <code>Eigen::Matrix</code>. </p>

</div>
</div>
<a id="abfe650b7cf9ca2f348fbf4791d148706" name="abfe650b7cf9ca2f348fbf4791d148706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe650b7cf9ca2f348fbf4791d148706">&#9670;&nbsp;</a></span>wrap_with_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto lagrange::wrap_with_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; VertexArray &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; FacetArray &gt; &amp;&#160;</td>
          <td class="paramname"><em>facets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method creates a <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object that wraps around vertices and facets. </p>
<p >Warning: vertices and facets are referenced instead of copied, and thus they have to be valid throughout the duration of the lifetime of the object. It is the user's responsibility of ensure it is the case. </p>

</div>
</div>
<a id="abbf0999f20e8aa0f9e6d2a2fe6c17cd2" name="abbf0999f20e8aa0f9e6d2a2fe6c17cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf0999f20e8aa0f9e6d2a2fe6c17cd2">&#9670;&nbsp;</a></span>extract_boundary_loops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; typename MeshType::Index &gt; &gt; lagrange::extract_boundary_loops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract boundary loops. </p>
<p >Returns an array of loops. Each loop is an array of vertex indices. Note that loop.front() == loop.back() if the loop is closed.</p>
<p >Precondition: I am assuming the loops are simple (each vertex in a loop is adjacent to 2 and only 2 edges). Requiring the mesh to be manifold is a sufficient but not necessary condition for the boundary loops to be simple. </p>

</div>
</div>
<a id="aa51ee322b2cbe6d36fe651b3a6c3b016" name="aa51ee322b2cbe6d36fe651b3a6c3b016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51ee322b2cbe6d36fe651b3a6c3b016">&#9670;&nbsp;</a></span>marching_triangles_general()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlagrange_1_1_marching_triangles_output.html">MarchingTrianglesOutput</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; lagrange::marching_triangles_general </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td>
          <td class="paramname"><em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueFn &amp;&#160;</td>
          <td class="paramname"><em>get_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform marching triangles to extract isocontour on a field defined as the linear interpolation of values provided by the <code>get_value</code> function. </p>
<p >Adapted from <a href="https://www.cs.ubc.ca/~rbridson/download/common_2008_nov_12.tar.gz">https://www.cs.ubc.ca/~rbridson/download/common_2008_nov_12.tar.gz</a> (code released to the <b>public domain</b> by Robert Bridson)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh_ref</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isovalue</td><td>The isovalue of the field at which to contour. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">get_value</td><td>A function that takes the facet id and a local corner id and returns the field value at that corner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted isocontour. </dd></dl>

</div>
</div>
<a id="a9dfb354b3bbbbf57858696d3ecd9b9a9" name="a9dfb354b3bbbbf57858696d3ecd9b9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dfb354b3bbbbf57858696d3ecd9b9a9">&#9670;&nbsp;</a></span>marching_triangles_indexed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlagrange_1_1_marching_triangles_output.html">MarchingTrianglesOutput</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; lagrange::marching_triangles_indexed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename MeshType::Scalar&#160;</td>
          <td class="paramname"><em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>indexed_attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename MeshType::Index&#160;</td>
          <td class="paramname"><em>attribute_col_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform marching triangles to extract isocontours on a field defined as the linear interpolation of an indexed attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh_ref</td><td>The input triangle mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isovalue</td><td>The isovalue of the field at which to contour. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indexed_attribute_name</td><td>The indexed attribute name defining the field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attribute_col_index</td><td>The attribute channel to use (for vector attributes only). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted isocontour.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The indexed attribute can be used to define fields with discontinuities. However, result may contain artifacts if the desired iso-contour passes through such discontiuity. </dd></dl>

</div>
</div>
<a id="a0c713bb92572ae9d774b15c70e5d7b2c" name="a0c713bb92572ae9d774b15c70e5d7b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c713bb92572ae9d774b15c70e5d7b2c">&#9670;&nbsp;</a></span>close_small_holes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; lagrange::close_small_holes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_hole_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close small topological holes. </p>
<p >For holes with &gt; 3 vertices, inserts a vertex at the barycenter of the hole polygon. If a hole is not a simple polygon, we attempt to turn it into simple polygons by cutting ears.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Remap attribute. For now all input mesh attributes are dropped.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Input mesh whose holes to close. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_hole_size</td><td>Maximum number of vertices on a hole to be closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new mesh with the holes closed. </dd></dl>

</div>
</div>
<a id="a0adc3699819a2561aa851032f55258bb" name="a0adc3699819a2561aa851032f55258bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0adc3699819a2561aa851032f55258bb">&#9670;&nbsp;</a></span>detect_degenerate_triangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lagrange::detect_degenerate_triangles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a per-facet attribute indicating whether the given facet is degenerate. </p>
<p >Arguments: mesh: A <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> pointer.</p>
<p >Returns: Nothing, but a facet attribute named "is_degenerate" is added to the mesh. </p>

</div>
</div>
<a id="a73c8e0e1f395eaf592ea4f5dfedb45ed" name="a73c8e0e1f395eaf592ea4f5dfedb45ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c8e0e1f395eaf592ea4f5dfedb45ed">&#9670;&nbsp;</a></span>is_vertex_manifold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lagrange::is_vertex_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the input mesh is vertex manifold for all vertices. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Use <code>mesh.is_vertex_manifold()</code> instead. </dd></dl>

</div>
</div>
<a id="a3518ef6f65b91c6c00242ce35ecca33f" name="a3518ef6f65b91c6c00242ce35ecca33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3518ef6f65b91c6c00242ce35ecca33f">&#9670;&nbsp;</a></span>remove_degenerate_triangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; lagrange::remove_degenerate_triangles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all exactly degenerate triangles. </p>
<p >Arguments: input_mesh</p>
<p >Returns: output_mesh without any exactly degenerate triangles.</p>
<p >All vertex and facet attributes are mapped over. </p>

</div>
</div>
<a id="a00f2984c59adaa383c9c14699503a6c0" name="a00f2984c59adaa383c9c14699503a6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f2984c59adaa383c9c14699503a6c0">&#9670;&nbsp;</a></span>remove_duplicate_facets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; lagrange::remove_duplicate_facets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removal all duplicate facets from the mesh. </p>
<p >Arguments: input_mesh</p>
<p >Returns: output_mesh without any duplicate facets.</p>
<p >All vertex/facet/corner attributes are mapped from the input to the output. For facet/corner attributes, only the attributes for one of the duplicate facets are used in the output. The ordering of the facets may change even if the input contains no duplicate facets. </p>

</div>
</div>
<a id="a1ea9552f344f9f4f84cb57b13b583eeb" name="a1ea9552f344f9f4f84cb57b13b583eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea9552f344f9f4f84cb57b13b583eeb">&#9670;&nbsp;</a></span>remove_duplicate_vertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; lagrange::remove_duplicate_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_attribute_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexed_attribute_names</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove duplicated vertices. </p>
<p >Two vertices are duplicates of each other iff they share the same vertex coordinates and have the same attribute values for the specified vertex and indexed attributes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Input triangle mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_attribute_names</td><td>A vector of vertex attributes that serve as keys. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indexed_attribute_names</td><td>A vector of indexed attributes that serve as keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new mesh without duplicate vertices. All attributes are transferred to the output mesh. </dd></dl>

</div>
</div>
<a id="aacaac1f982b99fdb3f355b30efed7b53" name="aacaac1f982b99fdb3f355b30efed7b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacaac1f982b99fdb3f355b30efed7b53">&#9670;&nbsp;</a></span>remove_duplicate_vertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; lagrange::remove_duplicate_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key_name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_uv</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all duplicate vertices for mesh. </p>
<p >Arguments: input_mesh key_name: Name of the key vertex attribute. Only merge two vertices if they have the same coordinates and the same key value.</p>
<p >Returns: output_mesh without any duplicate vertices.</p>
<p >All vertex and facet attributes are mapped from input to the output. The output_mesh's vertices are a subset of input_mesh's vertices. The output_mesh's facets are the same as input_mesh's except vertices maybe reindex. </p>

</div>
</div>
<a id="aa6e10dd93d158ad5a813ff9f415d7fd0" name="aa6e10dd93d158ad5a813ff9f415d7fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e10dd93d158ad5a813ff9f415d7fd0">&#9670;&nbsp;</a></span>remove_short_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; lagrange::remove_short_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>in_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::Scalar&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove edges shorter than a given tolerance. </p>
<p >Arguments: mesh: input mesh. tol: edges with length &lt;= tol will be removed.</p>
<p >Returns: An output mesh without edge &lt;= tol. </p>

</div>
</div>
<a id="ac083d62b0fe406d945b0d9963b9da382" name="ac083d62b0fe406d945b0d9963b9da382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac083d62b0fe406d945b0d9963b9da382">&#9670;&nbsp;</a></span>remove_topologically_degenerate_triangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; lagrange::remove_topologically_degenerate_triangles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove topologically degenerate triangles. </p>
<p >Arguments: input_mesh</p>
<p >Returns: output_mesh without any topologically degnerate facets.</p>
<p >All vertex and facet attributes are mapped over. The output_mesh's vertices are exactly the same as input_mesh's vertices. The output_mesh's facets are a subset of input_mesh's facets. </p>

</div>
</div>
<a id="a8396650df2a1598801c64a1ec427eb6e" name="a8396650df2a1598801c64a1ec427eb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8396650df2a1598801c64a1ec427eb6e">&#9670;&nbsp;</a></span>resolve_nonmanifoldness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; lagrange::resolve_nonmanifoldness </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve <b>all</b> non-manifold edges and vertices in the mesh. </p>
<p >Arguments: mesh: The input mesh.</p>
<p >Returns: A mesh same as the input mesh except non-manifold vertices and edges are pulled apart topologically. </p>
<p >Return true iff Edge e is consistently oriented with the specified facet.</p>
<p >This method assumes e is a valid edge in the facet.</p>
<p >Return true iff facets around an edge are <b>inconsistently</b> oriented. E.g. f0: * [0, 1, 2] and f1: [1, 2, 3], with e=[1, 2]</p>
<dl class="section note"><dt>Note</dt><dd>: This method does not depend on the orientaiton of the edge e. This method also assumes the edge <code>ei</code> has exactly 2 adjacent facets.</dd></dl>
<p>Return true iff f0 and f1 are consistantly oriented with respect to edge ei. This is <b>almost</b> the same as <code>is_inconsistently_oriented</code>. With <code>f0</code> and <code>f1</code> specified, this version can work with non-manifold edges.</p>
<p >Return true iff edge e has more than 2 incident facets or it has exactly 2 incident facet but they are inconsistently oriented.</p>

</div>
</div>
<a id="a6b6edd3e50dbecc0dde32eb22a529e48" name="a6b6edd3e50dbecc0dde32eb22a529e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6edd3e50dbecc0dde32eb22a529e48">&#9670;&nbsp;</a></span>resolve_vertex_nonmanifoldness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; lagrange::resolve_vertex_nonmanifoldness </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove nonmanifold vertices topologically by pulling disconnected 1-ring neighborhood apart. </p>
<p >Warning: This function assumes the input mesh contains <b>no</b> nonmanifold edges or inconsistently oriented triangles. If that is not the case, consider using <code><a class="el" href="namespacelagrange.html#a8396650df2a1598801c64a1ec427eb6e" title="Resolve all non-manifold edges and vertices in the mesh.">lagrange::resolve_nonmanifoldness()</a></code> instead. </p>

</div>
</div>
<a id="a39496828533d9280a13d62a61809b5e2" name="a39496828533d9280a13d62a61809b5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39496828533d9280a13d62a61809b5e2">&#9670;&nbsp;</a></span>split_triangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::Matrix&lt; Index, 3, 1 &gt; &gt; lagrange::split_triangle </td>
          <td>(</td>
          <td class="paramtype">const VertexArray &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split triangle into smaller triangles based on the chain of spliting points. </p>
<p >Arguments: vertices: list of vertices that contains all 3 corner of the triangle and all splitting points. chain: A chain of indices into vertices that iterates all splitting points and corners in counterclockwise order. v0: index into chain that represents corner 0. v1: index into chain that represents corner 1. v2: index into chain that represents corner 2.</p>
<p >Returns: facets: output facets. </p>

</div>
</div>
<a id="abb5fc3fc93e8d973bcc534398eeb0aa9" name="abb5fc3fc93e8d973bcc534398eeb0aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5fc3fc93e8d973bcc534398eeb0aa9">&#9670;&nbsp;</a></span>to_surface_mesh_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; to_surface_mesh_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a legacy mesh object to a surface mesh object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Output mesh scalar type. Must be either float or double. </td></tr>
    <tr><td class="paramname">Index</td><td>Output mesh index type. Must be either uint32_t or uint64_t. </td></tr>
    <tr><td class="paramname">MeshType</td><td>Input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New mesh object. </dd></dl>

</div>
</div>
<a id="a68ad17ee5b7475decfbaf17fcfa63d65" name="a68ad17ee5b7475decfbaf17fcfa63d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ad17ee5b7475decfbaf17fcfa63d65">&#9670;&nbsp;</a></span>to_surface_mesh_wrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; to_surface_mesh_wrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap a legacy mesh object as a surface mesh object. </p>
<p >The mesh scalar &amp; index types must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object to convert. The mesh object must be a lvalue reference (no temporary).</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Output mesh scalar type. Must be either float or double. </td></tr>
    <tr><td class="paramname">Index</td><td>Output mesh index type. Must be either uint32_t or uint64_t. </td></tr>
    <tr><td class="paramname">MeshType</td><td>Input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New mesh object. </dd></dl>

</div>
</div>
<a id="ac349d354b36d62bc2efeb93dd2b7f078" name="ac349d354b36d62bc2efeb93dd2b7f078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac349d354b36d62bc2efeb93dd2b7f078">&#9670;&nbsp;</a></span>to_legacy_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; to_legacy_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a surface mesh object to a legacy mesh object. </p>
<p >The mesh must be a regular mesh object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>Output mesh type. </td></tr>
    <tr><td class="paramname">Scalar</td><td>Input mesh scalar type. Must be either float or double. </td></tr>
    <tr><td class="paramname">Index</td><td>Input mesh index type. Must be either uint32_t or uint64_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New mesh object. </dd></dl>

</div>
</div>
<a id="a49dfaf475743676c129c2db26ae1fb51" name="a49dfaf475743676c129c2db26ae1fb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49dfaf475743676c129c2db26ae1fb51">&#9670;&nbsp;</a></span>orient_outward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lagrange::orient_outward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">lagrange::Mesh</a>&lt; VertexArray, FacetArray &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>positive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orient the facets of a mesh so that the signed volume of each connected component is positive or negative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> whose facets needs to be re-oriented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">positive</td><td>Orient to have positive signed volume.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VertexArray</td><td>Type of vertex array. </td></tr>
    <tr><td class="paramname">FacetArray</td><td>Type of facet array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea147d93f72ed7e9c28a99c1a7c87958" name="aea147d93f72ed7e9c28a99c1a7c87958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea147d93f72ed7e9c28a99c1a7c87958">&#9670;&nbsp;</a></span>point_on_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lagrange::point_on_segment </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a point lies exactly on a segment [a,b] using exact predicates. </p>
<p >If the points are collinear, each individual coordinate is examined to determine if the query point lies inside the segment or outside of it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Query point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First segment endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second segment endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>Point type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the query point lies exactly on the segment, False otherwise. </dd></dl>

</div>
</div>
<a id="a603da7b6f652a1a756e604275c3dd58c" name="a603da7b6f652a1a756e604275c3dd58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603da7b6f652a1a756e604275c3dd58c">&#9670;&nbsp;</a></span>point_segment_squared_distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto lagrange::point_segment_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>closest_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ScalarOf&lt;PointType&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the point closest to a given point in a nd segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>the query point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V0</td><td>first extremity of the segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>second extremity of the segment </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest_point</td><td>the point closest to <code>point</code> in the segment [<code>V0</code>, <code>V1</code>] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lambda0</td><td>barycentric coordinate of the closest point relative to <code>V0</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lambda1</td><td>barycentric coordinate of the closest point relative to <code>V1</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>the class that represents the points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the squared distance between the point and the segment [<code>V0</code>, <code>V1</code>] </dd></dl>

</div>
</div>
<a id="af812f411ba6d6dd28ec8d24e2e498c09" name="af812f411ba6d6dd28ec8d24e2e498c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af812f411ba6d6dd28ec8d24e2e498c09">&#9670;&nbsp;</a></span>point_segment_squared_distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto lagrange::point_segment_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ScalarOf&lt;PointType&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the point closest to a given point in a nd segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>the query point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V0</td><td>first extremity of the segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>second extremity of the segment</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>the class that represents the points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the squared distance between the point and the segment [<code>V0</code>, <code>V1</code>] </dd></dl>

</div>
</div>
<a id="a4867c7a72016dba819a9c4e8fe8477f3" name="a4867c7a72016dba819a9c4e8fe8477f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4867c7a72016dba819a9c4e8fe8477f3">&#9670;&nbsp;</a></span>point_triangle_squared_distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto lagrange::point_triangle_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>closest_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ScalarOf&lt;PointType&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the point closest to a given point in a nd triangle. </p>
<p >See <a href="http://www.geometrictools.com/LibMathematics/Distance/Distance.html">http://www.geometrictools.com/LibMathematics/Distance/Distance.html</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>the query point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V0</td><td>first vertex of the triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>second vertex of the triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V2</td><td>third vertex of the triangle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest_point</td><td>the point closest to <code>point</code> in the triangle (<code>V0</code>, <code>V1</code>, <code>V2</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lambda0</td><td>barycentric coordinate of the closest point relative to <code>V0</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lambda1</td><td>barycentric coordinate of the closest point relative to <code>V1</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lambda2</td><td>barycentric coordinate of the closest point relative to <code>V2</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>the class that represents the points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the squared distance between the point and the triangle (<code>V0</code>, <code>V1</code>, <code>V2</code>) </dd></dl>

</div>
</div>
<a id="a5cd65792fde835f9448cbf14aec20298" name="a5cd65792fde835f9448cbf14aec20298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd65792fde835f9448cbf14aec20298">&#9670;&nbsp;</a></span>point_triangle_squared_distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto lagrange::point_triangle_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ScalarOf&lt;PointType&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the squared distance between a point and a nd triangle. </p>
<p >See <a href="http://www.geometrictools.com/LibMathematics/Distance/Distance.html">http://www.geometrictools.com/LibMathematics/Distance/Distance.html</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>the query point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V0</td><td>first vertex of the triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>second vertex of the triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V2</td><td>third vertex of the triangle</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>the class that represents the points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the squared distance between the point and the triangle (<code>V0</code>, <code>V1</code>, <code>V2</code>) </dd></dl>

</div>
</div>
<a id="a97e627afa63acfb3eeb8e11dd72f9192" name="a97e627afa63acfb3eeb8e11dd72f9192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e627afa63acfb3eeb8e11dd72f9192">&#9670;&nbsp;</a></span>reorder_mesh_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; lagrange::reorder_mesh_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename MeshType::IndexList &amp;&#160;</td>
          <td class="paramname"><em>forward_mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders (possibly with shrinking) the vertices in the mesh. </p>
<p >Arguments: input_mesh forward_mapping: old2new mapping for the vertices in the mesh. forward_mapping[i] == INVALID or i -&gt; vertex i will remain as is forward_mapping[i] = j, vertex i will be remapped to j if two vertices map to the same new index, they will be merged. ''Forward_mapping must be surjective''</p>
<p >Returns: output_mesh with the vertices merged.</p>
<p >NOTES: All vertex and facet attributes are mapped from input to the output. The output_mesh's facets are the same as input_mesh's. The output_mesh's vertices are the same or a subset of the input_mesh's vertices. This is not a clean-up routine as-is. DEGENRATE facets can be present in the result. </p>

</div>
</div>
<a id="a551d394ef62a5c5b7bc1ed9d5bb791ce" name="a551d394ef62a5c5b7bc1ed9d5bb791ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551d394ef62a5c5b7bc1ed9d5bb791ce">&#9670;&nbsp;</a></span>select_facets_in_frustum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lagrange::select_facets_in_frustum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>n0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>n3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>greedy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select all facets that intersect the cone/frustrum bounded by 4 planes defined by (n_i, p_i), where n_i is the plane normal and p_i is a point on the plane. </p>
<p >When <code>greedy</code> is true, return as soon as the first facet is selected.</p>
<p >When <code>greedy</code> is false, check all facets and store the result in a facet attribute named <code>is_selected</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ni</td><td>normal vector of plane i. </td></tr>
    <tr><td class="paramname">pi</td><td>a point on plane i. </td></tr>
    <tr><td class="paramname">greedy</td><td>whether to stop as soon as the first facet is selected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether any facet is selected. </dd></dl>

</div>
</div>
<a id="a1792d2f3110525eca0fac87988584e82" name="a1792d2f3110525eca0fac87988584e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1792d2f3110525eca0fac87988584e82">&#9670;&nbsp;</a></span>thicken_and_close_mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; lagrange::thicken_and_close_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>input_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;, 3, 1 &gt;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td>
          <td class="paramname"><em>offset_amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td>
          <td class="paramname"><em>mirror_amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::Index&#160;</td>
          <td class="paramname"><em>num_segments</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thicken a mesh by offsetting it in a fixed direction. </p>
<p >Close the shape into a thick 3D solid. The mesh is assumed to have a disk topology. Input mesh vertices are duplicated and projected onto a target plane and can be additionally mirrored wrt to this plane.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_mesh</td><td>Input mesh, assumed to have a disk topology. Must have edge information included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>Offset direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset_amount</td><td>Coordinate along the direction vector to project onto. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mirror_amount</td><td>Mirror amount (between -1 and 1). -1 means fully mirrored, 0 means flat region, and 1 means fully translated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>Number of segments the stitched are should be split in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mesh of the offset and closed surface. </dd></dl>

</div>
</div>
<a id="a9b1b8edd4573422f27af875ab25bf0ed" name="a9b1b8edd4573422f27af875ab25bf0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1b8edd4573422f27af875ab25bf0ed">&#9670;&nbsp;</a></span>thicken_and_close_mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; lagrange::thicken_and_close_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>input_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td>
          <td class="paramname"><em>offset_amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::Index&#160;</td>
          <td class="paramname"><em>num_segments</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thicken a mesh vertices along normals, and close the shape into a thick 3D solid. </p>
<p >This function makes no assumption on the shape's topology and will apply its effect nicely to any surface, even those that have no holes (e.g. a solid sphere will become a hollow sphere with a solid shell).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_mesh</td><td>Input mesh. Must have edge information included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset_amount</td><td>Coordinate along the direction vector to project onto. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>Number of segments the stitched are should be split in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mesh of the offset and closed surface. </dd></dl>

</div>
</div>
<a id="ad434bb442f4626b686930e83f389bcdd" name="ad434bb442f4626b686930e83f389bcdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad434bb442f4626b686930e83f389bcdd">&#9670;&nbsp;</a></span>cos_angle_between()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar lagrange::cos_angle_between </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the cosine of the angle between two 3d vectors. </p>
<p >Assumes both vectors are normalized (unit vector). </p>

</div>
</div>
<a id="ad2be8e67fb8aad9e857a7569a9c8477c" name="ad2be8e67fb8aad9e857a7569a9c8477c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2be8e67fb8aad9e857a7569a9c8477c">&#9670;&nbsp;</a></span>project_on_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; lagrange::project_on_line </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project the vector v1 on the line defined by its vector v2. </p>
<p >Assumes the vector v2 is normalized (unit vector). </p>

</div>
</div>
<a id="a79e84808ffea64e176275f0a37d7f1bf" name="a79e84808ffea64e176275f0a37d7f1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e84808ffea64e176275f0a37d7f1bf">&#9670;&nbsp;</a></span>project_on_plane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; lagrange::project_on_plane </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project the vector on the plane defined by its normal n. </p>
<p >Assumes the normal n is a unit vector. </p>

</div>
</div>
<a id="a1439f4d3fc69cbd0e01f22c15f474415" name="a1439f4d3fc69cbd0e01f22c15f474415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1439f4d3fc69cbd0e01f22c15f474415">&#9670;&nbsp;</a></span>projected_cos_angle_between()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar lagrange::projected_cos_angle_between </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the angle between the vectors v1 and v2 projected on the plane defined by its normal n. </p>
<p >Assumes the normal n is a unit vector. </p>

</div>
</div>
<a id="a89990d08ad7825dd7562410acc88828f" name="a89990d08ad7825dd7562410acc88828f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89990d08ad7825dd7562410acc88828f">&#9670;&nbsp;</a></span>projected_angle_between()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar lagrange::projected_angle_between </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the angle between the vectors v1 and v2 projected on the plane defined by its normal n. </p>
<p >Assumes the normal n is a unit vector. </p>

</div>
</div>
<a id="a144de9ee10e82ef7c48e7278ce2db05d" name="a144de9ee10e82ef7c48e7278ce2db05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144de9ee10e82ef7c48e7278ce2db05d">&#9670;&nbsp;</a></span>vector_between()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto lagrange::vector_between </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::Index&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::Index&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vector from v1 to v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>first vertex index (from). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>second vertex index (to)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 3D vector </dd></dl>

</div>
</div>
<a id="aba3bf1a4299c328b1b7eaa4411b64fe0" name="aba3bf1a4299c328b1b7eaa4411b64fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3bf1a4299c328b1b7eaa4411b64fe0">&#9670;&nbsp;</a></span>orthogonal_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lagrange::orthogonal_frame </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an orthogonal frame given a single vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>First vector of the frame. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>Second vector of the frame. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">z</td><td>Third vector of the frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Scalar type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb9bf3ea770e7954ffd59b6c35620110" name="aeb9bf3ea770e7954ffd59b6c35620110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9bf3ea770e7954ffd59b6c35620110">&#9670;&nbsp;</a></span>to_degrees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar lagrange::to_degrees </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>rad</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert radians to degrees. </p>
<p >Use either as to_degrees(x) or x * <a class="el" href="namespacelagrange.html#aeb9bf3ea770e7954ffd59b6c35620110" title="Convert radians to degrees.">to_degrees&lt;double&gt;()</a>; </p>

</div>
</div>
<a id="a47ecfc247da42a513952056dfc91da59" name="a47ecfc247da42a513952056dfc91da59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ecfc247da42a513952056dfc91da59">&#9670;&nbsp;</a></span>to_radians()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar lagrange::to_radians </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>deg</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert degrees to radians. </p>
<p >Use either as to_degrees(x) or x * <a class="el" href="namespacelagrange.html#aeb9bf3ea770e7954ffd59b6c35620110" title="Convert radians to degrees.">to_degrees&lt;double&gt;()</a>; </p>

</div>
</div>
<a id="a543dd5597eb971f6bc033d98c43668e0" name="a543dd5597eb971f6bc033d98c43668e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543dd5597eb971f6bc033d98c43668e0">&#9670;&nbsp;</a></span>save_graph_off()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lagrange::save_graph_off </td>
          <td>(</td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a 2D undirected graph (V,E) using off format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Target filename path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V x 2 array of vertices positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E x 2 array of edge indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>Vertex array type. </td></tr>
    <tr><td class="paramname">DerivedE</td><td>Edge array type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9d4d2d6a7e5f4ad401de8e767baa007" name="ab9d4d2d6a7e5f4ad401de8e767baa007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d4d2d6a7e5f4ad401de8e767baa007">&#9670;&nbsp;</a></span>save_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lagrange::save_graph </td>
          <td>(</td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a 2D undirected graph (V,E) based on filename extension. </p>
<p >For now only .off is supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Target filename path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V x 2 array of vertices positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E x 2 array of edge indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>Vertex array type. </td></tr>
    <tr><td class="paramname">DerivedE</td><td>Edge array type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>

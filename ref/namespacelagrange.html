<!-- HTML header for doxygen 1.9.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lagrange: lagrange Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Lagrange
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacelagrange.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">lagrange Namespace Reference<div class="ingroups"><a class="el" href="group__module-core.html">Core Module</a> &raquo; <a class="el" href="group__group-utils.html">Utilites</a> &raquo; <a class="el" href="group__group-utils-assert.html">Assert and errors</a> &#124; <a class="el" href="group__module-core.html">Core Module</a> &raquo; <a class="el" href="group__group-utils.html">Utilites</a> &raquo; <a class="el" href="group__group-utils-misc.html">Miscellaneous</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Main namespace for Lagrange.  
<a href="namespacelagrange.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacelagrange_1_1internal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html">internal</a></td></tr>
<tr class="memdesc:namespacelagrange_1_1internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">nullptr_t, size_t, ptrdiff_t basic_ostream bad_weak_ptr extent, remove_extent, is_array, is_void, common_type move, forward, swap <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelagrange_1_1io"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1io.html">io</a></td></tr>
<tr class="memdesc:namespacelagrange_1_1io"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> input/output. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelagrange_1_1partitioning"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1partitioning.html">partitioning</a></td></tr>
<tr class="memdesc:namespacelagrange_1_1partitioning"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> partitioning using METIS. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelagrange_1_1raycasting"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1raycasting.html">raycasting</a></td></tr>
<tr class="memdesc:namespacelagrange_1_1raycasting"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raycasting operations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelagrange_1_1ui"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1ui.html">ui</a></td></tr>
<tr class="memdesc:namespacelagrange_1_1ui"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lagrange UI <a class="el" href="classlagrange_1_1ui_1_1_viewer.html" title="Viewer use systems() to add functions that should be called every frame use registry() or util functi...">Viewer</a> and mini 3D engine. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_acting_mesh_geometry.html">ActingMeshGeometry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_adjacency_list.html">AdjacencyList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjacency list.  <a href="classlagrange_1_1_adjacency_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_attribute.html">Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived attribute class that stores the actual information.  <a href="classlagrange_1_1_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_attribute_base.html">AttributeBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base handle for attributes.  <a href="classlagrange_1_1_attribute_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_attribute_name.html">AttributeName</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_attributes.html">Attributes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legacy attribute class.  <a href="classlagrange_1_1_attributes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_bad_cast_error.html">BadCastError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception of this type is thrown when a <a class="el" href="group__group-utils-misc.html#gafc5798c28b15e46d20d0234b72c4ef63" title="Perform safe cast from SourceType to TargetType, where &quot;safe&quot; means:">lagrange::safe_cast&lt;&gt;</a> fails.  <a href="structlagrange_1_1_bad_cast_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_bit_field.html">BitField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit field utility class.  <a href="classlagrange_1_1_bit_field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_chain_edges_options.html">ChainEdgesOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple loop is defined as a set of connected edges whose starting and ending vertex is the same.  <a href="structlagrange_1_1_chain_edges_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_chain_edges_result.html">ChainEdgesResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result struct holding the loops and chains extracted from a set of edges.  <a href="structlagrange_1_1_chain_edges_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_component_options.html">ComponentOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to control connected components computation.  <a href="structlagrange_1_1_component_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_compute_bordered_components_output.html">ComputeBorderedComponentsOutput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_compute_pointcloud_p_c_a_output.html">ComputePointcloudPCAOutput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_connectivity.html">Connectivity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1copy__on__write__ptr.html">copy_on_write_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle type with copy-on-write semantics.  <a href="classlagrange_1_1copy__on__write__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_corner_normal_options.html">CornerNormalOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing per-corner mesh normals.  <a href="structlagrange_1_1_corner_normal_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_dihedral_angle_options.html">DihedralAngleOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing dihedral angles.  <a href="structlagrange_1_1_dihedral_angle_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_dijkstra_distance_options.html">DijkstraDistanceOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for compute_dijkstra_distance.  <a href="structlagrange_1_1_dijkstra_distance_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_disjoint_sets.html">DisjointSets</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjoint sets computation.  <a href="classlagrange_1_1_disjoint_sets.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_edge_length_options.html">EdgeLengthOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_edge_type.html">EdgeType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_error.html">Error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base exception for errors thrown by Lagrange functions.  <a href="structlagrange_1_1_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_exact_predicates.html">ExactPredicates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_exact_predicates_shewchuk.html">ExactPredicatesShewchuk</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_facet_area_options.html">FacetAreaOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing per-facet area.  <a href="structlagrange_1_1_facet_area_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_facet_centroid_options.html">FacetCentroidOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing per-facet centroid.  <a href="structlagrange_1_1_facet_centroid_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_facet_normal_options.html">FacetNormalOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing per-facet mesh normals.  <a href="structlagrange_1_1_facet_normal_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1function__ref.html">function_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight non-owning reference to a callable.  <a href="classlagrange_1_1function__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1function__ref_3_01_r_07_args_8_8_8_08_4.html">function_ref&lt; R(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for function types.  <a href="classlagrange_1_1function__ref_3_01_r_07_args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_genuine_mesh_geometry.html">GenuineMeshGeometry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_indexed_attribute.html">IndexedAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived attribute class that stores the actual information.  <a href="classlagrange_1_1_indexed_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_indexed_attributes.html">IndexedAttributes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legacy indexed attribute class.  <a href="classlagrange_1_1_indexed_attributes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_marching_triangles_output.html">MarchingTrianglesOutput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_mesh_area_options.html">MeshAreaOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing mesh area.  <a href="structlagrange_1_1_mesh_area_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_mesh_base.html">MeshBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_mesh_centroid_options.html">MeshCentroidOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing mesh centroid.  <a href="structlagrange_1_1_mesh_centroid_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_mesh_geometry.html">MeshGeometry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_mesh_navigation.html">MeshNavigation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to navigate elements of a mesh.  <a href="classlagrange_1_1_mesh_navigation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_mesh_trait.html">MeshTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structlagrange_1_1_mesh_trait.html" title="MeshTrait class provide compiler check for different mesh types.">MeshTrait</a> class provide compiler check for different mesh types.  <a href="structlagrange_1_1_mesh_trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_normal_options.html">NormalOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing indexed mesh normals.  <a href="structlagrange_1_1_normal_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_ordered_pair_hash.html">OrderedPairHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an order-dependent hash of a pair of values.  <a href="structlagrange_1_1_ordered_pair_hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_ordered_pair_hash_3_01std_1_1pair_3_01_u_00_01_v_01_4_01_4.html">OrderedPairHash&lt; std::pair&lt; U, V &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_progress_callback.html">ProgressCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple thread-safe progress callback.  <a href="classlagrange_1_1_progress_callback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_remap_vertices_options.html">RemapVerticesOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap vertices options.  <a href="structlagrange_1_1_remap_vertices_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_remove_duplicate_vertices_options.html">RemoveDuplicateVerticesOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for remove_duplicate_vertices.  <a href="structlagrange_1_1_remove_duplicate_vertices_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_remove_null_area_facets_options.html">RemoveNullAreaFacetsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for remove_null_area_facets.  <a href="structlagrange_1_1_remove_null_area_facets_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_sample_points_on_surface_output.html">SamplePointsOnSurfaceOutput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_scoped_log_level.html">ScopedLogLevel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the level of logger to something else in a scope.  <a href="classlagrange_1_1_scoped_log_level.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_scoped_timer.html">ScopedTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to a <a class="el" href="classlagrange_1_1_verbose_timer.html" title="Creates a verbose timer that prints after tock().">VerboseTimer</a>, but uses RAII to call tick()/tock().  <a href="classlagrange_1_1_scoped_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_select_facets_by_normal_similarity_parameters.html">SelectFacetsByNormalSimilarityParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a seed vertex, selects faces around it based on the change in triangle normals.  <a href="structlagrange_1_1_select_facets_by_normal_similarity_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_separate_by_components_options.html">SeparateByComponentsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option settings for <code>separate_by_components</code>.  <a href="structlagrange_1_1_separate_by_components_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_separate_by_facet_groups_options.html">SeparateByFacetGroupsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option settings for <code>separate_by_facet_groups</code>.  <a href="structlagrange_1_1_separate_by_facet_groups_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared span with ownership tracking.  <a href="classlagrange_1_1_shared_span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_silent_multi_timer.html">SilentMultiTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A timer that keeps track of a total time as well as intervals.  <a href="classlagrange_1_1_silent_multi_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_silent_timer.html">SilentTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A timer that does not print after <a class="el" href="classlagrange_1_1_silent_timer.html#afaaa29b2d16059bbf5580e31995959fa" title="Stops the timer.">tock()</a>  <a href="classlagrange_1_1_silent_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_small_vector.html">SmallVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hybrid vector that uses the stack upto a maximum size, and the heap beyond that.  <a href="classlagrange_1_1_small_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_stack_set.html">StackSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack-allocated set with a maximum size.  <a href="structlagrange_1_1_stack_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_stack_vector.html">StackVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack-allocated vector with a maximum size.  <a href="structlagrange_1_1_stack_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_static_assertable_bool.html">StaticAssertableBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilers might complain about static_assert(false, "").  <a href="structlagrange_1_1_static_assertable_bool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_submesh_options.html">SubmeshOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for extract submesh.  <a href="structlagrange_1_1_submesh_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A general purpose polygonal mesh class.  <a href="classlagrange_1_1_surface_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_tangent_bitangent_options.html">TangentBitangentOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing tangent and bitangent vectors.  <a href="structlagrange_1_1_tangent_bitangent_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_tangent_bitangent_result.html">TangentBitangentResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type of the compute_tangent_bitangent function.  <a href="structlagrange_1_1_tangent_bitangent_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_u_v_distortion_options.html">UVDistortionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for compute uv distortion.  <a href="structlagrange_1_1_u_v_distortion_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1value__ptr.html">value_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer with value semantics.  <a href="classlagrange_1_1value__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1_verbose_timer.html">VerboseTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a verbose timer that prints after <a class="el" href="classlagrange_1_1_verbose_timer.html#afaaa29b2d16059bbf5580e31995959fa" title="Stops the timer.">tock()</a>.  <a href="classlagrange_1_1_verbose_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_vertex_normal_options.html">VertexNormalOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing per-vertex mesh normals.  <a href="structlagrange_1_1_vertex_normal_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1_vertex_valence_options.html">VertexValenceOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option struct for computing vertex valence.  <a href="structlagrange_1_1_vertex_valence_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4d115376c2c766084ef808c837348fc3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> = uint32_t</td></tr>
<tr class="memdesc:ga4d115376c2c766084ef808c837348fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identified to be used to access an attribute.  <a href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">More...</a><br /></td></tr>
<tr class="separator:ga4d115376c2c766084ef808c837348fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685260342ca315f0b8e7446451da169e"><td class="memItemLeft" align="right" valign="top"><a id="a685260342ca315f0b8e7446451da169e" name="a685260342ca315f0b8e7446451da169e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vertices2D</b> = Eigen::Matrix&lt; double, Eigen::Dynamic, 2, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a685260342ca315f0b8e7446451da169e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0b6a4ad19f223f6d3d9200dcc82f9b"><td class="memItemLeft" align="right" valign="top"><a id="a3a0b6a4ad19f223f6d3d9200dcc82f9b" name="a3a0b6a4ad19f223f6d3d9200dcc82f9b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vertices3D</b> = Eigen::Matrix&lt; double, Eigen::Dynamic, 3, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a3a0b6a4ad19f223f6d3d9200dcc82f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9ffb89f38d3683845a8342a6f0a6c7"><td class="memItemLeft" align="right" valign="top"><a id="a7e9ffb89f38d3683845a8342a6f0a6c7" name="a7e9ffb89f38d3683845a8342a6f0a6c7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vertices2Df</b> = Eigen::Matrix&lt; float, Eigen::Dynamic, 2, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a7e9ffb89f38d3683845a8342a6f0a6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964925a1e0d7b9a75fd9eb46c71393a8"><td class="memItemLeft" align="right" valign="top"><a id="a964925a1e0d7b9a75fd9eb46c71393a8" name="a964925a1e0d7b9a75fd9eb46c71393a8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vertices3Df</b> = Eigen::Matrix&lt; float, Eigen::Dynamic, 3, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a964925a1e0d7b9a75fd9eb46c71393a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be6a2aaeb5bdb3585f3510c76997b27"><td class="memItemLeft" align="right" valign="top"><a id="a2be6a2aaeb5bdb3585f3510c76997b27" name="a2be6a2aaeb5bdb3585f3510c76997b27"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Triangles</b> = Eigen::Matrix&lt; int, Eigen::Dynamic, 3, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a2be6a2aaeb5bdb3585f3510c76997b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51268241563f19baad026a6b2382305e"><td class="memItemLeft" align="right" valign="top"><a id="a51268241563f19baad026a6b2382305e" name="a51268241563f19baad026a6b2382305e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Quads</b> = Eigen::Matrix&lt; int, Eigen::Dynamic, 4, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a51268241563f19baad026a6b2382305e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9f1a605ef2c933bcf16289cbd6e192"><td class="memItemLeft" align="right" valign="top"><a id="a6c9f1a605ef2c933bcf16289cbd6e192" name="a6c9f1a605ef2c933bcf16289cbd6e192"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TriangleMesh3D</b> = <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; Vertices3D, Triangles &gt;</td></tr>
<tr class="separator:a6c9f1a605ef2c933bcf16289cbd6e192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b076d81dc0046b803f3a5c4ba63c9f"><td class="memItemLeft" align="right" valign="top"><a id="a79b076d81dc0046b803f3a5c4ba63c9f" name="a79b076d81dc0046b803f3a5c4ba63c9f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TriangleMesh2D</b> = <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; Vertices2D, Triangles &gt;</td></tr>
<tr class="separator:a79b076d81dc0046b803f3a5c4ba63c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600a7bbb6195ed3043597c1d4ade30d3"><td class="memItemLeft" align="right" valign="top"><a id="a600a7bbb6195ed3043597c1d4ade30d3" name="a600a7bbb6195ed3043597c1d4ade30d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TriangleMesh3Df</b> = <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; Vertices3Df, Triangles &gt;</td></tr>
<tr class="separator:a600a7bbb6195ed3043597c1d4ade30d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa025ed072fe904ba06dedf1fb57ad54f"><td class="memItemLeft" align="right" valign="top"><a id="aa025ed072fe904ba06dedf1fb57ad54f" name="aa025ed072fe904ba06dedf1fb57ad54f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TriangleMesh2Df</b> = <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; Vertices2Df, Triangles &gt;</td></tr>
<tr class="separator:aa025ed072fe904ba06dedf1fb57ad54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16562b5e2fc77636e6e8f2595cd2a3f"><td class="memItemLeft" align="right" valign="top"><a id="ae16562b5e2fc77636e6e8f2595cd2a3f" name="ae16562b5e2fc77636e6e8f2595cd2a3f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>QuadMesh3D</b> = <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; Vertices3D, Quads &gt;</td></tr>
<tr class="separator:ae16562b5e2fc77636e6e8f2595cd2a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968bc0e88fe1cab05d913526f9fea53d"><td class="memItemLeft" align="right" valign="top"><a id="a968bc0e88fe1cab05d913526f9fea53d" name="a968bc0e88fe1cab05d913526f9fea53d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>QuadMesh2D</b> = <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; Vertices2D, Quads &gt;</td></tr>
<tr class="separator:a968bc0e88fe1cab05d913526f9fea53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152724149e96e25020eef571e2629eea"><td class="memItemLeft" align="right" valign="top"><a id="a152724149e96e25020eef571e2629eea" name="a152724149e96e25020eef571e2629eea"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>QuadMesh3Df</b> = <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; Vertices3Df, Quads &gt;</td></tr>
<tr class="separator:a152724149e96e25020eef571e2629eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736341f28297ce085621f3e4d5051e44"><td class="memItemLeft" align="right" valign="top"><a id="a736341f28297ce085621f3e4d5051e44" name="a736341f28297ce085621f3e4d5051e44"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>QuadMesh2Df</b> = <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; Vertices2Df, Quads &gt;</td></tr>
<tr class="separator:a736341f28297ce085621f3e4d5051e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35d40a4baad35b6d7000f599079342f"><td class="memTemplParams" colspan="2"><a id="aa35d40a4baad35b6d7000f599079342f" name="aa35d40a4baad35b6d7000f599079342f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa35d40a4baad35b6d7000f599079342f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ScalarOf</b> = typename T::Scalar</td></tr>
<tr class="separator:aa35d40a4baad35b6d7000f599079342f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9254db782b791e7de3433eb42485b2f5"><td class="memTemplParams" colspan="2"><a id="a9254db782b791e7de3433eb42485b2f5" name="a9254db782b791e7de3433eb42485b2f5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9254db782b791e7de3433eb42485b2f5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IndexOf</b> = typename T::Index</td></tr>
<tr class="separator:a9254db782b791e7de3433eb42485b2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591a8df096dc1678f994e253656c3069"><td class="memTemplParams" colspan="2"><a id="a591a8df096dc1678f994e253656c3069" name="a591a8df096dc1678f994e253656c3069"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a591a8df096dc1678f994e253656c3069"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>VertexArrayOf</b> = typename T::VertexArray</td></tr>
<tr class="separator:a591a8df096dc1678f994e253656c3069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1340896dc32f7417914bfe57992e82ff"><td class="memTemplParams" colspan="2"><a id="a1340896dc32f7417914bfe57992e82ff" name="a1340896dc32f7417914bfe57992e82ff"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1340896dc32f7417914bfe57992e82ff"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FacetArrayOf</b> = typename T::FacetArray</td></tr>
<tr class="separator:a1340896dc32f7417914bfe57992e82ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb15c71ed630fa908bb10535b3d50d2"><td class="memTemplParams" colspan="2"><a id="a7eb15c71ed630fa908bb10535b3d50d2" name="a7eb15c71ed630fa908bb10535b3d50d2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7eb15c71ed630fa908bb10535b3d50d2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AttributeArrayOf</b> = typename T::AttributeArray</td></tr>
<tr class="separator:a7eb15c71ed630fa908bb10535b3d50d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f35915880c96f07f2bc8aad6ec7df7"><td class="memTemplParams" colspan="2"><a id="a24f35915880c96f07f2bc8aad6ec7df7" name="a24f35915880c96f07f2bc8aad6ec7df7"></a>
template&lt;typename Index , typename T &gt; </td></tr>
<tr class="memitem:a24f35915880c96f07f2bc8aad6ec7df7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EdgeMap</b> = std::unordered_map&lt; <a class="el" href="classlagrange_1_1_edge_type.html">EdgeType</a>&lt; Index &gt;, T &gt;</td></tr>
<tr class="separator:a24f35915880c96f07f2bc8aad6ec7df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fec32f0aedbd1c570292781e1955dd0"><td class="memTemplParams" colspan="2"><a id="a8fec32f0aedbd1c570292781e1955dd0" name="a8fec32f0aedbd1c570292781e1955dd0"></a>
template&lt;typename Index &gt; </td></tr>
<tr class="memitem:a8fec32f0aedbd1c570292781e1955dd0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EdgeSet</b> = std::unordered_set&lt; <a class="el" href="classlagrange_1_1_edge_type.html">EdgeType</a>&lt; Index &gt; &gt;</td></tr>
<tr class="separator:a8fec32f0aedbd1c570292781e1955dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2696d72bb64b4580c878fc4831c5fddd"><td class="memTemplParams" colspan="2"><a id="a2696d72bb64b4580c878fc4831c5fddd" name="a2696d72bb64b4580c878fc4831c5fddd"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a2696d72bb64b4580c878fc4831c5fddd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EdgeFacetMap</b> = std::unordered_map&lt; <a class="el" href="classlagrange_1_1_edge_type.html">EdgeType</a>&lt; typename MeshType::Index &gt;, std::vector&lt; typename MeshType::Index &gt; &gt;</td></tr>
<tr class="separator:a2696d72bb64b4580c878fc4831c5fddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14fdcd2cded8fe91f52ae25c03ba1a61"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>SurfaceMesh32f</b> = <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; float, uint32_t &gt;</td></tr>
<tr class="separator:ga14fdcd2cded8fe91f52ae25c03ba1a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae53afb315b7aa7b237fe61639c5f3227"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>SurfaceMesh32d</b> = <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; double, uint32_t &gt;</td></tr>
<tr class="separator:gae53afb315b7aa7b237fe61639c5f3227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15b6f3435ad8ad0593054364df6e909f"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>SurfaceMesh64f</b> = <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; float, uint64_t &gt;</td></tr>
<tr class="separator:ga15b6f3435ad8ad0593054364df6e909f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc7cff3b1e7e97b39b157971776ae8c5"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>SurfaceMesh64d</b> = <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; double, uint64_t &gt;</td></tr>
<tr class="separator:gadc7cff3b1e7e97b39b157971776ae8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4afead0b9ccc53fe4fca896787595d26"><td class="memTemplParams" colspan="2">template&lt;class T , span_CONFIG_EXTENT_TYPE Extent = ::nonstd::dynamic_extent&gt; </td></tr>
<tr class="memitem:ga4afead0b9ccc53fe4fca896787595d26"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a> = ::nonstd::span&lt; T, Extent &gt;</td></tr>
<tr class="memdesc:ga4afead0b9ccc53fe4fca896787595d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bounds-safe view for sequences of objects.  <a href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">More...</a><br /></td></tr>
<tr class="separator:ga4afead0b9ccc53fe4fca896787595d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb877375676ff54953d8d36fe1df9240"><td class="memItemLeft" align="right" valign="top"><a id="abb877375676ff54953d8d36fe1df9240" name="abb877375676ff54953d8d36fe1df9240"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>timestamp_type</b> = std::chrono::time_point&lt; std::chrono::steady_clock &gt;</td></tr>
<tr class="separator:abb877375676ff54953d8d36fe1df9240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs</div></td></tr>
<tr class="memitem:ga6344979b33dfbf6508e97dadab610258"><td class="memTemplParams" colspan="2">
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga6344979b33dfbf6508e97dadab610258"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RowMatrix</b> = Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;</td></tr>
<tr class="memdesc:ga6344979b33dfbf6508e97dadab610258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for row-major Eigen matrices. <br /></td></tr>
<tr class="separator:ga6344979b33dfbf6508e97dadab610258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06ca3172e4577c726eaf8d2ab26a1ab5"><td class="memTemplParams" colspan="2">
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga06ca3172e4577c726eaf8d2ab26a1ab5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RowMatrixView</b> = Eigen::Map&lt; <a class="el" href="group__group-surfacemesh-views.html#ga6344979b33dfbf6508e97dadab610258">RowMatrix</a>&lt; Scalar &gt;, Eigen::Unaligned &gt;</td></tr>
<tr class="memdesc:ga06ca3172e4577c726eaf8d2ab26a1ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for row-major matrix views. <br /></td></tr>
<tr class="separator:ga06ca3172e4577c726eaf8d2ab26a1ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdf68813d2c56704e10b6ba3c5b9aa6d"><td class="memTemplParams" colspan="2">
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:gabdf68813d2c56704e10b6ba3c5b9aa6d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstRowMatrixView</b> = const Eigen::Map&lt; const <a class="el" href="group__group-surfacemesh-views.html#ga6344979b33dfbf6508e97dadab610258">RowMatrix</a>&lt; Scalar &gt;, Eigen::Unaligned &gt;</td></tr>
<tr class="memdesc:gabdf68813d2c56704e10b6ba3c5b9aa6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for row-major const matrix view. <br /></td></tr>
<tr class="separator:gabdf68813d2c56704e10b6ba3c5b9aa6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fed807d227a1b730ca7ebcc01d897e2"><td class="memTemplParams" colspan="2">
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga0fed807d227a1b730ca7ebcc01d897e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Vector</b> = Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:ga0fed807d227a1b730ca7ebcc01d897e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for one-dimensional column Eigen vectors. <br /></td></tr>
<tr class="separator:ga0fed807d227a1b730ca7ebcc01d897e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373c385fbf8ee25f008de6d6575118ab"><td class="memTemplParams" colspan="2">
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ga373c385fbf8ee25f008de6d6575118ab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>VectorView</b> = Eigen::Map&lt; <a class="el" href="group__group-surfacemesh-views.html#ga0fed807d227a1b730ca7ebcc01d897e2">Vector</a>&lt; Scalar &gt;, Eigen::Unaligned &gt;</td></tr>
<tr class="memdesc:ga373c385fbf8ee25f008de6d6575118ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for row-major vector view. <br /></td></tr>
<tr class="separator:ga373c385fbf8ee25f008de6d6575118ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4f42fe9cfd8b46f3f4a0c81ab791c1f"><td class="memTemplParams" colspan="2">
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:gab4f42fe9cfd8b46f3f4a0c81ab791c1f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstVectorView</b> = const Eigen::Map&lt; const <a class="el" href="group__group-surfacemesh-views.html#ga0fed807d227a1b730ca7ebcc01d897e2">Vector</a>&lt; Scalar &gt;, Eigen::Unaligned &gt;</td></tr>
<tr class="memdesc:gab4f42fe9cfd8b46f3f4a0c81ab791c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for row-major const vector view. <br /></td></tr>
<tr class="separator:gab4f42fe9cfd8b46f3f4a0c81ab791c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9d8ab208822bab9987e9652dda49d89a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> : int { <br />
&#160;&#160;<a class="el" href="group__group-surfacemesh-attr.html#gga9d8ab208822bab9987e9652dda49d89aad013c4439c3e09308d6b2eef2a4025ae">Vertex</a> = (1 &lt;&lt; 0)
, <a class="el" href="group__group-surfacemesh-attr.html#gga9d8ab208822bab9987e9652dda49d89aa9b112d86d52178fe18e47e14bb6aeb35">Facet</a> = (1 &lt;&lt; 1)
, <a class="el" href="group__group-surfacemesh-attr.html#gga9d8ab208822bab9987e9652dda49d89aa7f0bc3a17ff45e6a7c3fe52b35db1888">Edge</a> = (1 &lt;&lt; 2)
, <a class="el" href="group__group-surfacemesh-attr.html#gga9d8ab208822bab9987e9652dda49d89aab9925c71d0b2b9131518c35c9ebbad92">Corner</a> = (1 &lt;&lt; 3)
, <br />
&#160;&#160;<a class="el" href="group__group-surfacemesh-attr.html#gga9d8ab208822bab9987e9652dda49d89aa050889cfb2c606473596b8f70f702769">Value</a> = (1 &lt;&lt; 4)
, <a class="el" href="group__group-surfacemesh-attr.html#gga9d8ab208822bab9987e9652dda49d89aa93747573a820d43208a296f9f56bf54e">Indexed</a> = (1 &lt;&lt; 5)
<br />
 }</td></tr>
<tr class="memdesc:ga9d8ab208822bab9987e9652dda49d89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of element to which the attribute is attached.  <a href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">More...</a><br /></td></tr>
<tr class="separator:ga9d8ab208822bab9987e9652dda49d89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35b5eb426384b257452ee0ffdb732c27"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#ga35b5eb426384b257452ee0ffdb732c27">AttributeUsage</a> { <br />
&#160;&#160;<a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27a57dea6f5039281b7fee517fc43bf3110">Vector</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27af60357a8d17e45793298323f1b372a74">Scalar</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27a960b44c579bc2f6818d2daaf9e4c16f0">Normal</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27a541671cb1be09d76a84ba1a873ec3fc8">Tangent</a>
, <br />
&#160;&#160;<a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27ae3e73a4b6e7cfd12008a35f6a051b319">Bitangent</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27acb5feb1b7314637725a2e73bdc9f7295">Color</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27adeaa2adbeb26802ae61609c3f3642d82">UV</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27a7302d7da6a3804b1edf63b4b16198d80">VertexIndex</a>
, <br />
&#160;&#160;<a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27aa3dfb9f32b810b4277c5c8387d7f03f5">FacetIndex</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27a63222a2d9c46a34b875c078c757da2e8">CornerIndex</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga35b5eb426384b257452ee0ffdb732c27a7e0536ad6c15bf05bf40e8876b1a5c10">EdgeIndex</a>
<br />
 }</td></tr>
<tr class="memdesc:ga35b5eb426384b257452ee0ffdb732c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Usage tag indicating how the attribute should behave under mesh transformations.  <a href="group__group-surfacemesh-attr.html#ga35b5eb426384b257452ee0ffdb732c27">More...</a><br /></td></tr>
<tr class="separator:ga35b5eb426384b257452ee0ffdb732c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga809dfcec94612491ec5be8bb8614ceab"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#ga809dfcec94612491ec5be8bb8614ceab">AttributeCreatePolicy</a> { <a class="el" href="group__group-surfacemesh-attr.html#gga809dfcec94612491ec5be8bb8614ceabafc443f72fcb562a73b40af34ddb599a3">ErrorIfReserved</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga809dfcec94612491ec5be8bb8614ceaba9eb6b78a99cdb6ffd3d40d18621d9f80">Force</a>
 }</td></tr>
<tr class="memdesc:ga809dfcec94612491ec5be8bb8614ceab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for attribute creation with reserved attribute names.  <a href="group__group-surfacemesh-attr.html#ga809dfcec94612491ec5be8bb8614ceab">More...</a><br /></td></tr>
<tr class="separator:ga809dfcec94612491ec5be8bb8614ceab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee0f51b5f793101c19bd6dede5db7a7a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#gaee0f51b5f793101c19bd6dede5db7a7a">AttributeGrowthPolicy</a> { <a class="el" href="group__group-surfacemesh-attr.html#ggaee0f51b5f793101c19bd6dede5db7a7aa9e7163ae7c790d007e084e24693b2303">ErrorIfExternal</a>
, <a class="el" href="group__group-surfacemesh-attr.html#ggaee0f51b5f793101c19bd6dede5db7a7aaf12086c39414ec9b8b89727ad02fb40e">AllowWithinCapacity</a>
, <a class="el" href="group__group-surfacemesh-attr.html#ggaee0f51b5f793101c19bd6dede5db7a7aaef773dc1e1097301a1bf955bfa9857ec">WarnAndCopy</a>
, <a class="el" href="group__group-surfacemesh-attr.html#ggaee0f51b5f793101c19bd6dede5db7a7aae1ed7e29bdcf7fc9d30c50447e35ab92">SilentCopy</a>
 }</td></tr>
<tr class="memdesc:gaee0f51b5f793101c19bd6dede5db7a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for growing external attribute buffers.  <a href="group__group-surfacemesh-attr.html#gaee0f51b5f793101c19bd6dede5db7a7a">More...</a><br /></td></tr>
<tr class="separator:gaee0f51b5f793101c19bd6dede5db7a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f2b557c48ed06d24e17c4da83b77ed6"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#ga7f2b557c48ed06d24e17c4da83b77ed6">AttributeShrinkPolicy</a> { <a class="el" href="group__group-surfacemesh-attr.html#gga7f2b557c48ed06d24e17c4da83b77ed6a9e7163ae7c790d007e084e24693b2303">ErrorIfExternal</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga7f2b557c48ed06d24e17c4da83b77ed6a410c5804c7d350b6891cb8c15fdf97e8">IgnoreIfExternal</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga7f2b557c48ed06d24e17c4da83b77ed6aef773dc1e1097301a1bf955bfa9857ec">WarnAndCopy</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga7f2b557c48ed06d24e17c4da83b77ed6ae1ed7e29bdcf7fc9d30c50447e35ab92">SilentCopy</a>
 }</td></tr>
<tr class="memdesc:ga7f2b557c48ed06d24e17c4da83b77ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for shrinking external attribute buffers.  <a href="group__group-surfacemesh-attr.html#ga7f2b557c48ed06d24e17c4da83b77ed6">More...</a><br /></td></tr>
<tr class="separator:ga7f2b557c48ed06d24e17c4da83b77ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3018d576f81897e1712c3601b9625cb9"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#ga3018d576f81897e1712c3601b9625cb9">AttributeWritePolicy</a> { <a class="el" href="group__group-surfacemesh-attr.html#gga3018d576f81897e1712c3601b9625cb9a61eb7df0ff95cbd596ba2a4c7ee06b32">ErrorIfReadOnly</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga3018d576f81897e1712c3601b9625cb9aef773dc1e1097301a1bf955bfa9857ec">WarnAndCopy</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga3018d576f81897e1712c3601b9625cb9ae1ed7e29bdcf7fc9d30c50447e35ab92">SilentCopy</a>
 }</td></tr>
<tr class="memdesc:ga3018d576f81897e1712c3601b9625cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for attempting to write to read-only external buffers.  <a href="group__group-surfacemesh-attr.html#ga3018d576f81897e1712c3601b9625cb9">More...</a><br /></td></tr>
<tr class="separator:ga3018d576f81897e1712c3601b9625cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade3ae5b7e72e9d4f92f29c6563551c10"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#gade3ae5b7e72e9d4f92f29c6563551c10">AttributeExportPolicy</a> { <a class="el" href="group__group-surfacemesh-attr.html#ggade3ae5b7e72e9d4f92f29c6563551c10afe72de1001d465db9eb6ce5cb874c2cb">CopyIfExternal</a>
, <a class="el" href="group__group-surfacemesh-attr.html#ggade3ae5b7e72e9d4f92f29c6563551c10a2bdb7937b8109f604fbf49e7c1ad1aa3">CopyIfUnmanaged</a>
, <a class="el" href="group__group-surfacemesh-attr.html#ggade3ae5b7e72e9d4f92f29c6563551c10a9a526f6dc0d4d6aef1f368972f20d13e">KeepExternalPtr</a>
, <a class="el" href="group__group-surfacemesh-attr.html#ggade3ae5b7e72e9d4f92f29c6563551c10a9e7163ae7c790d007e084e24693b2303">ErrorIfExternal</a>
 }</td></tr>
<tr class="memdesc:gade3ae5b7e72e9d4f92f29c6563551c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for exporting attributes that are views onto external buffers.  <a href="group__group-surfacemesh-attr.html#gade3ae5b7e72e9d4f92f29c6563551c10">More...</a><br /></td></tr>
<tr class="separator:gade3ae5b7e72e9d4f92f29c6563551c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga450ef027eac01dd93a89a15ff55de63f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#ga450ef027eac01dd93a89a15ff55de63f">AttributeCopyPolicy</a> { <a class="el" href="group__group-surfacemesh-attr.html#gga450ef027eac01dd93a89a15ff55de63fafe72de1001d465db9eb6ce5cb874c2cb">CopyIfExternal</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga450ef027eac01dd93a89a15ff55de63fa9a526f6dc0d4d6aef1f368972f20d13e">KeepExternalPtr</a>
, <a class="el" href="group__group-surfacemesh-attr.html#gga450ef027eac01dd93a89a15ff55de63fa9e7163ae7c790d007e084e24693b2303">ErrorIfExternal</a>
 }</td></tr>
<tr class="memdesc:ga450ef027eac01dd93a89a15ff55de63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for copying attribute that are views onto external buffers.  <a href="group__group-surfacemesh-attr.html#ga450ef027eac01dd93a89a15ff55de63f">More...</a><br /></td></tr>
<tr class="separator:ga450ef027eac01dd93a89a15ff55de63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad17b213b11e78aeb807ad3ece7e67e84"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr.html#gad17b213b11e78aeb807ad3ece7e67e84">AttributeDeletePolicy</a> { <a class="el" href="group__group-surfacemesh-attr.html#ggad17b213b11e78aeb807ad3ece7e67e84afc443f72fcb562a73b40af34ddb599a3">ErrorIfReserved</a>
, <a class="el" href="group__group-surfacemesh-attr.html#ggad17b213b11e78aeb807ad3ece7e67e84a9eb6b78a99cdb6ffd3d40d18621d9f80">Force</a>
 }</td></tr>
<tr class="memdesc:gad17b213b11e78aeb807ad3ece7e67e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for attribute deletion of reserved attribute names.  <a href="group__group-surfacemesh-attr.html#gad17b213b11e78aeb807ad3ece7e67e84">More...</a><br /></td></tr>
<tr class="separator:gad17b213b11e78aeb807ad3ece7e67e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadab1480827f4522cbf1f9e1d4c28db91"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gadab1480827f4522cbf1f9e1d4c28db91">DistortionMetric</a> { <br />
&#160;&#160;<a class="el" href="group__group-surfacemesh-utils.html#ggadab1480827f4522cbf1f9e1d4c28db91abac152b762896edff34ed668ae1a546f">Dirichlet</a>
, <a class="el" href="group__group-surfacemesh-utils.html#ggadab1480827f4522cbf1f9e1d4c28db91a541c024e21b5989aa74764f7c362dfd2">InverseDirichlet</a>
, <a class="el" href="group__group-surfacemesh-utils.html#ggadab1480827f4522cbf1f9e1d4c28db91a6043446227f6a89342620a00a131257f">SymmetricDirichlet</a>
, <b>AreaRatio</b>
, <br />
&#160;&#160;<a class="el" href="group__group-surfacemesh-utils.html#ggadab1480827f4522cbf1f9e1d4c28db91a16c8e070f0f6edd7ac0ae016e9bf2997">MIPS</a>
<br />
 }</td></tr>
<tr class="memdesc:gadab1480827f4522cbf1f9e1d4c28db91"><td class="mdescLeft">&#160;</td><td class="mdescRight">UV distortion metric type.  <a href="group__group-surfacemesh-utils.html#gadab1480827f4522cbf1f9e1d4c28db91">More...</a><br /></td></tr>
<tr class="separator:gadab1480827f4522cbf1f9e1d4c28db91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa88e833ed770762b02e187f0c2377d3d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gaa88e833ed770762b02e187f0c2377d3d">NormalWeightingType</a> : char { <a class="el" href="group__group-surfacemesh-utils.html#ggaa88e833ed770762b02e187f0c2377d3daf19516d11f2946f894070e92fcb56b6d">Uniform</a> = 0
, <a class="el" href="group__group-surfacemesh-utils.html#ggaa88e833ed770762b02e187f0c2377d3da84f023fc44b6b158de6ccc157c8dab06">CornerTriangleArea</a> = 1
, <a class="el" href="group__group-surfacemesh-utils.html#ggaa88e833ed770762b02e187f0c2377d3da45f4ce6c3306644b1efe333f4f8d6929">Angle</a> = 2
 }</td></tr>
<tr class="memdesc:gaa88e833ed770762b02e187f0c2377d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighting types for averaging corner normals around a vertex.  <a href="group__group-surfacemesh-utils.html#gaa88e833ed770762b02e187f0c2377d3d">More...</a><br /></td></tr>
<tr class="separator:gaa88e833ed770762b02e187f0c2377d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312f57b0318728667933d7254778058b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a312f57b0318728667933d7254778058b">ConnectivityType</a> { <a class="el" href="namespacelagrange.html#a312f57b0318728667933d7254778058bab22b929ba52471a02d18bb3a4e4472e6">Vertex</a>
, <a class="el" href="namespacelagrange.html#a312f57b0318728667933d7254778058bae4a297a0f76119a442c2595ac040673e">Edge</a>
 }</td></tr>
<tr class="memdesc:a312f57b0318728667933d7254778058b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type defines the condition when two facets are considered as "connected".  <a href="namespacelagrange.html#a312f57b0318728667933d7254778058b">More...</a><br /></td></tr>
<tr class="separator:a312f57b0318728667933d7254778058b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15e960c877b7516935402a9080b7e1a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#af15e960c877b7516935402a9080b7e1a">MappingPolicy</a> { <a class="el" href="namespacelagrange.html#af15e960c877b7516935402a9080b7e1aab1897515d548a960afe49ecf66a29021">Average</a>
, <a class="el" href="namespacelagrange.html#af15e960c877b7516935402a9080b7e1aa0e86b31f0ceff2268f199fa31e7b1369">KeepFirst</a>
, <a class="el" href="namespacelagrange.html#af15e960c877b7516935402a9080b7e1aa902b0d55fddef6f8d651fe1035b7d4bd">Error</a>
 }</td></tr>
<tr class="memdesc:af15e960c877b7516935402a9080b7e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping policy control the behavior when two or more elements are mapped into the same output element.  <a href="namespacelagrange.html#af15e960c877b7516935402a9080b7e1a">More...</a><br /></td></tr>
<tr class="separator:af15e960c877b7516935402a9080b7e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3046db4b0b7d22e2e82972cdb5fdd9f7"><td class="memItemLeft" align="right" valign="top"><a id="a3046db4b0b7d22e2e82972cdb5fdd9f7" name="a3046db4b0b7d22e2e82972cdb5fdd9f7"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>Orientation</b> : short { <b>Positive</b> = 1
, <b>Zero</b> = 0
, <b>Negative</b> = -1
 }</td></tr>
<tr class="separator:a3046db4b0b7d22e2e82972cdb5fdd9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaf6e674ed673001dca1c6390bc0e0fc9"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memItemRight" valign="bottom"><b>invalid_attribute_id</b> ()</td></tr>
<tr class="memdesc:gaaf6e674ed673001dca1c6390bc0e0fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid attribute id. <br /></td></tr>
<tr class="separator:gaaf6e674ed673001dca1c6390bc0e0fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540c0cc95b91cae8f14fa3fddafef3e2"><td class="memTemplParams" colspan="2"><a id="a540c0cc95b91cae8f14fa3fddafef3e2" name="a540c0cc95b91cae8f14fa3fddafef3e2"></a>
template&lt;typename AttributeArray , typename Archive &gt; </td></tr>
<tr class="memitem:a540c0cc95b91cae8f14fa3fddafef3e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (<a class="el" href="classlagrange_1_1_attributes.html">Attributes</a>&lt; AttributeArray &gt; &amp;attributes, Archive &amp;ar)</td></tr>
<tr class="separator:a540c0cc95b91cae8f14fa3fddafef3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad919806f4b5cd1dfc507fe3e9173a5f8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedC , typename DerivedE , typename DerivedN &gt; </td></tr>
<tr class="memitem:ad919806f4b5cd1dfc507fe3e9173a5f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ad919806f4b5cd1dfc507fe3e9173a5f8">chain_corners_around_edges</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;facets, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;corner_to_edge, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;edge_to_corner, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;next_corner_around_edge)</td></tr>
<tr class="memdesc:ad919806f4b5cd1dfc507fe3e9173a5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chains facet corners around edges of a mesh.  <a href="namespacelagrange.html#ad919806f4b5cd1dfc507fe3e9173a5f8">More...</a><br /></td></tr>
<tr class="separator:ad919806f4b5cd1dfc507fe3e9173a5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56e9b69f19b41be755dbe5a7d7f1897"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedE , typename DerivedN &gt; </td></tr>
<tr class="memitem:ae56e9b69f19b41be755dbe5a7d7f1897"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ae56e9b69f19b41be755dbe5a7d7f1897">chain_corners_around_vertices</a> (typename DerivedF::Scalar num_vertices, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;facets, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;vertex_to_corner, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;next_corner_around_vertex)</td></tr>
<tr class="memdesc:ae56e9b69f19b41be755dbe5a7d7f1897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chains facet corners around vertices of a mesh.  <a href="namespacelagrange.html#ae56e9b69f19b41be755dbe5a7d7f1897">More...</a><br /></td></tr>
<tr class="separator:ae56e9b69f19b41be755dbe5a7d7f1897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga363707c2e65474638292c738c072868c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga363707c2e65474638292c738c072868c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga363707c2e65474638292c738c072868c">combine_meshes</a> (std::initializer_list&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; * &gt; meshes, bool preserve_attributes=true)</td></tr>
<tr class="memdesc:ga363707c2e65474638292c738c072868c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine multiple meshes into a single mesh.  <a href="group__group-surfacemesh-utils.html#ga363707c2e65474638292c738c072868c">More...</a><br /></td></tr>
<tr class="separator:ga363707c2e65474638292c738c072868c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07291901c4f594454dfafb0764f4dad5"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga07291901c4f594454dfafb0764f4dad5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga07291901c4f594454dfafb0764f4dad5">combine_meshes</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &gt; meshes, bool preserve_attributes=true)</td></tr>
<tr class="memdesc:ga07291901c4f594454dfafb0764f4dad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine multiple meshes into a single mesh.  <a href="group__group-surfacemesh-utils.html#ga07291901c4f594454dfafb0764f4dad5">More...</a><br /></td></tr>
<tr class="separator:ga07291901c4f594454dfafb0764f4dad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e874e29c25e3a587a9352147e36772d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga9e874e29c25e3a587a9352147e36772d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga9e874e29c25e3a587a9352147e36772d">combine_meshes</a> (size_t num_meshes, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;(size_t)&gt; get_mesh, bool preserve_attributes=true)</td></tr>
<tr class="memdesc:ga9e874e29c25e3a587a9352147e36772d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine multiple meshes into a single mesh.  <a href="group__group-surfacemesh-utils.html#ga9e874e29c25e3a587a9352147e36772d">More...</a><br /></td></tr>
<tr class="separator:ga9e874e29c25e3a587a9352147e36772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f1c6cc55a36fae54bcd3723d8255e2"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a45f1c6cc55a36fae54bcd3723d8255e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a45f1c6cc55a36fae54bcd3723d8255e2">move_data</a> (Eigen::DenseBase&lt; Derived1 &gt; &amp;from, Eigen::DenseBase&lt; Derived2 &gt; &amp;to)</td></tr>
<tr class="memdesc:a45f1c6cc55a36fae54bcd3723d8255e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move data from one Eigen obj to another.  <a href="namespacelagrange.html#a45f1c6cc55a36fae54bcd3723d8255e2">More...</a><br /></td></tr>
<tr class="separator:a45f1c6cc55a36fae54bcd3723d8255e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d708c9fd9f08299ea623082bd61cb5e"><td class="memTemplParams" colspan="2"><a id="a3d708c9fd9f08299ea623082bd61cb5e" name="a3d708c9fd9f08299ea623082bd61cb5e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3d708c9fd9f08299ea623082bd61cb5e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_shared_ptr</b> (std::unique_ptr&lt; T &gt; &amp;&amp;ptr)</td></tr>
<tr class="memdesc:a3d708c9fd9f08299ea623082bd61cb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for automatic type deduction for unique_ptr to shared_ptr conversion. <br /></td></tr>
<tr class="separator:a3d708c9fd9f08299ea623082bd61cb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga579af81b3ee4ae244a8b5cb92fc76d5c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga579af81b3ee4ae244a8b5cb92fc76d5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga579af81b3ee4ae244a8b5cb92fc76d5c">compute_facet_area</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_facet_area_options.html">FacetAreaOptions</a> options={})</td></tr>
<tr class="memdesc:ga579af81b3ee4ae244a8b5cb92fc76d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute per-facet area.  <a href="group__group-surfacemesh-utils.html#ga579af81b3ee4ae244a8b5cb92fc76d5c">More...</a><br /></td></tr>
<tr class="separator:ga579af81b3ee4ae244a8b5cb92fc76d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8852c901ee9b6908389b24d03632306f"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index , int Dimension&gt; </td></tr>
<tr class="memitem:ga8852c901ee9b6908389b24d03632306f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga8852c901ee9b6908389b24d03632306f">compute_facet_area</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const Eigen::Transform&lt; Scalar, Dimension, Eigen::Affine &gt; &amp;transformation, <a class="el" href="structlagrange_1_1_facet_area_options.html">FacetAreaOptions</a> options={})</td></tr>
<tr class="memdesc:ga8852c901ee9b6908389b24d03632306f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute per-facet area.  <a href="group__group-surfacemesh-utils.html#ga8852c901ee9b6908389b24d03632306f">More...</a><br /></td></tr>
<tr class="separator:ga8852c901ee9b6908389b24d03632306f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga685d104f63c148710e7f8e3ffb2bb779"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga685d104f63c148710e7f8e3ffb2bb779"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga685d104f63c148710e7f8e3ffb2bb779">compute_mesh_area</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_mesh_area_options.html">MeshAreaOptions</a> options={})</td></tr>
<tr class="memdesc:ga685d104f63c148710e7f8e3ffb2bb779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mesh area.  <a href="group__group-surfacemesh-utils.html#ga685d104f63c148710e7f8e3ffb2bb779">More...</a><br /></td></tr>
<tr class="separator:ga685d104f63c148710e7f8e3ffb2bb779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3b913ec3b353ba77d4b71549e8079a1"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index , int Dimension&gt; </td></tr>
<tr class="memitem:gad3b913ec3b353ba77d4b71549e8079a1"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gad3b913ec3b353ba77d4b71549e8079a1">compute_mesh_area</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const Eigen::Transform&lt; Scalar, Dimension, Eigen::Affine &gt; &amp;transformation, <a class="el" href="structlagrange_1_1_mesh_area_options.html">MeshAreaOptions</a> options={})</td></tr>
<tr class="memdesc:gad3b913ec3b353ba77d4b71549e8079a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mesh area.  <a href="group__group-surfacemesh-utils.html#gad3b913ec3b353ba77d4b71549e8079a1">More...</a><br /></td></tr>
<tr class="separator:gad3b913ec3b353ba77d4b71549e8079a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9401f16e9e8981b93819bbee5aa846b5"><td class="memTemplParams" colspan="2"><a id="a9401f16e9e8981b93819bbee5aa846b5" name="a9401f16e9e8981b93819bbee5aa846b5"></a>
template&lt;typename PointType &gt; </td></tr>
<tr class="memitem:a9401f16e9e8981b93819bbee5aa846b5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_barycentric_coordinates</b> (const Eigen::MatrixBase&lt; PointType &gt; &amp;v0, const Eigen::MatrixBase&lt; PointType &gt; &amp;v1, const Eigen::MatrixBase&lt; PointType &gt; &amp;v2, const Eigen::MatrixBase&lt; PointType &gt; &amp;p) -&gt; Eigen::Matrix&lt; typename PointType::Scalar, 3, 1 &gt;</td></tr>
<tr class="separator:a9401f16e9e8981b93819bbee5aa846b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6392f539d615e76b93ce12034fd0f9"><td class="memTemplParams" colspan="2"><a id="a4d6392f539d615e76b93ce12034fd0f9" name="a4d6392f539d615e76b93ce12034fd0f9"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a4d6392f539d615e76b93ce12034fd0f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_compute_bordered_components_output.html">ComputeBorderedComponentsOutput</a>&lt; typename MeshType::Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_bordered_components</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::vector&lt; bool &gt; &amp;is_edge_passable)</td></tr>
<tr class="separator:a4d6392f539d615e76b93ce12034fd0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9362d326a1cbd65aca95f481bc2d5e3c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga9362d326a1cbd65aca95f481bc2d5e3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga9362d326a1cbd65aca95f481bc2d5e3c">compute_facet_centroid</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_facet_centroid_options.html">FacetCentroidOptions</a> options={})</td></tr>
<tr class="memdesc:ga9362d326a1cbd65aca95f481bc2d5e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute per-facet centroid.  <a href="group__group-surfacemesh-utils.html#ga9362d326a1cbd65aca95f481bc2d5e3c">More...</a><br /></td></tr>
<tr class="separator:ga9362d326a1cbd65aca95f481bc2d5e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae64040c03275b07fff5b820f2a61d0ba"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gae64040c03275b07fff5b820f2a61d0ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gae64040c03275b07fff5b820f2a61d0ba">compute_mesh_centroid</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; Scalar &gt; centroid, <a class="el" href="structlagrange_1_1_mesh_centroid_options.html">MeshCentroidOptions</a> options={})</td></tr>
<tr class="memdesc:gae64040c03275b07fff5b820f2a61d0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mesh centroid, where mesh centroid is defined as the weighted sum of facet centroids.  <a href="group__group-surfacemesh-utils.html#gae64040c03275b07fff5b820f2a61d0ba">More...</a><br /></td></tr>
<tr class="separator:gae64040c03275b07fff5b820f2a61d0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafedc8c0d66af62d6f3d540465c0018c6"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gafedc8c0d66af62d6f3d540465c0018c6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gafedc8c0d66af62d6f3d540465c0018c6">compute_components</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_component_options.html">ComponentOptions</a> options={})</td></tr>
<tr class="memdesc:gafedc8c0d66af62d6f3d540465c0018c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute connected components of an input mesh.  <a href="group__group-surfacemesh-utils.html#gafedc8c0d66af62d6f3d540465c0018c6">More...</a><br /></td></tr>
<tr class="separator:gafedc8c0d66af62d6f3d540465c0018c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab65464571f0034e009273ade90fcb4bf"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gab65464571f0034e009273ade90fcb4bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gab65464571f0034e009273ade90fcb4bf">compute_dihedral_angles</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const <a class="el" href="structlagrange_1_1_dihedral_angle_options.html">DihedralAngleOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:gab65464571f0034e009273ade90fcb4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes dihedral angles for each edge in the mesh.  <a href="group__group-surfacemesh-utils.html#gab65464571f0034e009273ade90fcb4bf">More...</a><br /></td></tr>
<tr class="separator:gab65464571f0034e009273ade90fcb4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cc672971ecc26849450a45db354f6b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a63cc672971ecc26849450a45db354f6b"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a63cc672971ecc26849450a45db354f6b">compute_dijkstra_distance</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const <a class="el" href="structlagrange_1_1_dijkstra_distance_options.html">DijkstraDistanceOptions</a>&lt; Scalar, Index &gt; &amp;options={})</td></tr>
<tr class="memdesc:a63cc672971ecc26849450a45db354f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes dijkstra distance from a seed facet.  <a href="namespacelagrange.html#a63cc672971ecc26849450a45db354f6b">More...</a><br /></td></tr>
<tr class="separator:a63cc672971ecc26849450a45db354f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58593e3709263771bc25ff51f473c92a"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga58593e3709263771bc25ff51f473c92a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga58593e3709263771bc25ff51f473c92a">compute_edge_lengths</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const <a class="el" href="structlagrange_1_1_edge_length_options.html">EdgeLengthOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:ga58593e3709263771bc25ff51f473c92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes edge lengths attribute.  <a href="group__group-surfacemesh-utils.html#ga58593e3709263771bc25ff51f473c92a">More...</a><br /></td></tr>
<tr class="separator:ga58593e3709263771bc25ff51f473c92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50e835144b2dd2ad5df9848293c8b097"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga50e835144b2dd2ad5df9848293c8b097"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga50e835144b2dd2ad5df9848293c8b097">compute_facet_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_facet_normal_options.html">FacetNormalOptions</a> options={})</td></tr>
<tr class="memdesc:ga50e835144b2dd2ad5df9848293c8b097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute facet normals.  <a href="group__group-surfacemesh-utils.html#ga50e835144b2dd2ad5df9848293c8b097">More...</a><br /></td></tr>
<tr class="separator:ga50e835144b2dd2ad5df9848293c8b097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa044d2770f886a9d400b161400c971b3"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> , typename Cloud , typename Indices &gt; </td></tr>
<tr class="memitem:aa044d2770f886a9d400b161400c971b3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#aa044d2770f886a9d400b161400c971b3">compute_lift_operator_from_sampling</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const Cloud &amp;closest_points, const Indices &amp;element_indices)</td></tr>
<tr class="memdesc:aa044d2770f886a9d400b161400c971b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This compute the sparse bilinear map from mesh vertex attributes to point cloud attributes.  <a href="namespacelagrange.html#aa044d2770f886a9d400b161400c971b3">More...</a><br /></td></tr>
<tr class="separator:aa044d2770f886a9d400b161400c971b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa066ff40e856a0b5dffac1b7e141ce6c"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> , typename ClosestPoints &gt; </td></tr>
<tr class="memitem:aa066ff40e856a0b5dffac1b7e141ce6c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#aa066ff40e856a0b5dffac1b7e141ce6c">compute_lift_operator_from_projections</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const ClosestPoints &amp;projections)</td></tr>
<tr class="memdesc:aa066ff40e856a0b5dffac1b7e141ce6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This compute the sparse bilinear map from mesh vertex attributes to point cloud attributes.  <a href="namespacelagrange.html#aa066ff40e856a0b5dffac1b7e141ce6c">More...</a><br /></td></tr>
<tr class="separator:aa066ff40e856a0b5dffac1b7e141ce6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b27dda974899d3a12042ab59a16f00"><td class="memTemplParams" colspan="2"><a id="a02b27dda974899d3a12042ab59a16f00" name="a02b27dda974899d3a12042ab59a16f00"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a02b27dda974899d3a12042ab59a16f00"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename MeshType::Scalar, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_mesh_covariance</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh_ref, const typename MeshType::VertexType &amp;center, const typename MeshType::IndexList &amp;active_facets=typename MeshType::IndexList())</td></tr>
<tr class="separator:a02b27dda974899d3a12042ab59a16f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1dc948d0cb8aa8b7759e34a34df7bc"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga0d1dc948d0cb8aa8b7759e34a34df7bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga0d1dc948d0cb8aa8b7759e34a34df7bc">compute_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; bool(Index)&gt; is_edge_smooth, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; cone_vertices={}, <a class="el" href="structlagrange_1_1_normal_options.html">NormalOptions</a> options={})</td></tr>
<tr class="memdesc:ga0d1dc948d0cb8aa8b7759e34a34df7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute smooth normals based on specified sharp edges and cone vertices.  <a href="group__group-surfacemesh-utils.html#ga0d1dc948d0cb8aa8b7759e34a34df7bc">More...</a><br /></td></tr>
<tr class="separator:ga0d1dc948d0cb8aa8b7759e34a34df7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe91547f24b4936c8feddd9b74b1aa02"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gabe91547f24b4936c8feddd9b74b1aa02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gabe91547f24b4936c8feddd9b74b1aa02">compute_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; bool(Index, Index)&gt; is_edge_smooth, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; cone_vertices={}, <a class="el" href="structlagrange_1_1_normal_options.html">NormalOptions</a> options={})</td></tr>
<tr class="memdesc:gabe91547f24b4936c8feddd9b74b1aa02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute smooth normals based on specified sharp edges and cone vertices.  <a href="group__group-surfacemesh-utils.html#gabe91547f24b4936c8feddd9b74b1aa02">More...</a><br /></td></tr>
<tr class="separator:gabe91547f24b4936c8feddd9b74b1aa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga668cc68bd27510b1bec92cf8dbe0e362"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga668cc68bd27510b1bec92cf8dbe0e362"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga668cc68bd27510b1bec92cf8dbe0e362">compute_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Scalar feature_angle_threshold, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; cone_vertices={}, <a class="el" href="structlagrange_1_1_normal_options.html">NormalOptions</a> options={})</td></tr>
<tr class="memdesc:ga668cc68bd27510b1bec92cf8dbe0e362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute smooth normal based on specified dihedral angle threshold and cone vertices.  <a href="group__group-surfacemesh-utils.html#ga668cc68bd27510b1bec92cf8dbe0e362">More...</a><br /></td></tr>
<tr class="separator:ga668cc68bd27510b1bec92cf8dbe0e362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a6fc0a020518f4c640b34e0112ee81"><td class="memTemplParams" colspan="2"><a id="ab6a6fc0a020518f4c640b34e0112ee81" name="ab6a6fc0a020518f4c640b34e0112ee81"></a>
template&lt;typename Derived1 &gt; </td></tr>
<tr class="memitem:ab6a6fc0a020518f4c640b34e0112ee81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_compute_pointcloud_p_c_a_output.html">ComputePointcloudPCAOutput</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_pointcloud_pca</b> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;points, const bool should_shift_centeroid, const bool should_normalize)</td></tr>
<tr class="separator:ab6a6fc0a020518f4c640b34e0112ee81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0b89e21157c268e2931da3910bc2930"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gac0b89e21157c268e2931da3910bc2930"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_tangent_bitangent_result.html">TangentBitangentResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gac0b89e21157c268e2931da3910bc2930">compute_tangent_bitangent</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_tangent_bitangent_options.html">TangentBitangentOptions</a> options={})</td></tr>
<tr class="memdesc:gac0b89e21157c268e2931da3910bc2930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mesh tangent and bitangent vectors orthogonal to the input mesh normals.  <a href="group__group-surfacemesh-utils.html#gac0b89e21157c268e2931da3910bc2930">More...</a><br /></td></tr>
<tr class="separator:gac0b89e21157c268e2931da3910bc2930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad96a9c0374e82142015e619d6cf3bf67"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gad96a9c0374e82142015e619d6cf3bf67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gad96a9c0374e82142015e619d6cf3bf67">compute_uv_distortion</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const <a class="el" href="structlagrange_1_1_u_v_distortion_options.html">UVDistortionOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:gad96a9c0374e82142015e619d6cf3bf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute uv distortion using the selected distortion measure.  <a href="group__group-surfacemesh-utils.html#gad96a9c0374e82142015e619d6cf3bf67">More...</a><br /></td></tr>
<tr class="separator:gad96a9c0374e82142015e619d6cf3bf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c124c65e79e319a4aefc92ccb5ce7f"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:aa9c124c65e79e319a4aefc92ccb5ce7f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int32_t, int32_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#aa9c124c65e79e319a4aefc92ccb5ce7f">compute_uv_tile_list</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:aa9c124c65e79e319a4aefc92ccb5ce7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the list of all UV tiles that a mesh's parametrization spans.  <a href="namespacelagrange.html#aa9c124c65e79e319a4aefc92ccb5ce7f">More...</a><br /></td></tr>
<tr class="separator:aa9c124c65e79e319a4aefc92ccb5ce7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c1ac1ec1658273f6e6bb312dd2b0718"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga8c1ac1ec1658273f6e6bb312dd2b0718"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga8c1ac1ec1658273f6e6bb312dd2b0718">compute_vertex_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_vertex_normal_options.html">VertexNormalOptions</a> options={})</td></tr>
<tr class="memdesc:ga8c1ac1ec1658273f6e6bb312dd2b0718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute per-vertex normals based on specified weighting type.  <a href="group__group-surfacemesh-utils.html#ga8c1ac1ec1658273f6e6bb312dd2b0718">More...</a><br /></td></tr>
<tr class="separator:ga8c1ac1ec1658273f6e6bb312dd2b0718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a2a7d7f5165ef7f5433ef67efad4306"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga6a2a7d7f5165ef7f5433ef67efad4306"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga6a2a7d7f5165ef7f5433ef67efad4306">compute_vertex_valence</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_vertex_valence_options.html">VertexValenceOptions</a> options={})</td></tr>
<tr class="memdesc:ga6a2a7d7f5165ef7f5433ef67efad4306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vertex valence.  <a href="group__group-surfacemesh-utils.html#ga6a2a7d7f5165ef7f5433ef67efad4306">More...</a><br /></td></tr>
<tr class="separator:ga6a2a7d7f5165ef7f5433ef67efad4306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga203af050581e879b52d339558b788a08"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga203af050581e879b52d339558b788a08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_adjacency_list.html">AdjacencyList</a>&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga203af050581e879b52d339558b788a08">compute_vertex_vertex_adjacency</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga203af050581e879b52d339558b788a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vertex-vertex adjacency information.  <a href="group__group-surfacemesh-utils.html#ga203af050581e879b52d339558b788a08">More...</a><br /></td></tr>
<tr class="separator:ga203af050581e879b52d339558b788a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa13892cc06d31d64e6613c3e48785591"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gaa13892cc06d31d64e6613c3e48785591"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gaa13892cc06d31d64e6613c3e48785591">compute_weighted_corner_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="structlagrange_1_1_corner_normal_options.html">CornerNormalOptions</a> option={})</td></tr>
<tr class="memdesc:gaa13892cc06d31d64e6613c3e48785591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute corner normals.  <a href="group__group-surfacemesh-utils.html#gaa13892cc06d31d64e6613c3e48785591">More...</a><br /></td></tr>
<tr class="separator:gaa13892cc06d31d64e6613c3e48785591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f768e5cde6773f82390f692bfc5335"><td class="memTemplParams" colspan="2"><a id="a14f768e5cde6773f82390f692bfc5335" name="a14f768e5cde6773f82390f692bfc5335"></a>
template&lt;typename GeometryType &gt; </td></tr>
<tr class="memitem:a14f768e5cde6773f82390f692bfc5335"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_connectivity.html">Connectivity</a>&lt; GeometryType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_connectivity</b> (const GeometryType &amp;geometry)</td></tr>
<tr class="separator:a14f768e5cde6773f82390f692bfc5335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34583bdda68644dcd9c7175ce179735"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedC &gt; </td></tr>
<tr class="memitem:ad34583bdda68644dcd9c7175ce179735"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ad34583bdda68644dcd9c7175ce179735">corner_to_edge_mapping</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C2E)</td></tr>
<tr class="memdesc:ad34583bdda68644dcd9c7175ce179735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a mapping from mesh corners (k*f+i) to unique edge ids.  <a href="namespacelagrange.html#ad34583bdda68644dcd9c7175ce179735">More...</a><br /></td></tr>
<tr class="separator:ad34583bdda68644dcd9c7175ce179735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81deba98a13efcfa8427fdba5b24413d"><td class="memTemplParams" colspan="2"><a id="a81deba98a13efcfa8427fdba5b24413d" name="a81deba98a13efcfa8427fdba5b24413d"></a>
template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a81deba98a13efcfa8427fdba5b24413d"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; DerivedV, DerivedF &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_empty_mesh</b> ()</td></tr>
<tr class="separator:a81deba98a13efcfa8427fdba5b24413d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a55c916bd22d4ee64baa54c4993344"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a01a55c916bd22d4ee64baa54c4993344"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a01a55c916bd22d4ee64baa54c4993344">create_mesh</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;vertices, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;facets)</td></tr>
<tr class="memdesc:a01a55c916bd22d4ee64baa54c4993344"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function create a new mesh given the vertex and facet arrays by copying data into the <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object.  <a href="namespacelagrange.html#a01a55c916bd22d4ee64baa54c4993344">More...</a><br /></td></tr>
<tr class="separator:a01a55c916bd22d4ee64baa54c4993344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5e551dc6fb8002b1263d47ce4aa8b8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a1b5e551dc6fb8002b1263d47ce4aa8b8"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; DerivedV, DerivedF &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a1b5e551dc6fb8002b1263d47ce4aa8b8">create_mesh</a> (Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&amp;vertices, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&amp;facets)</td></tr>
<tr class="memdesc:a1b5e551dc6fb8002b1263d47ce4aa8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function create a new mesh given the vertex and facet arrays by moving data into the <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object.  <a href="namespacelagrange.html#a1b5e551dc6fb8002b1263d47ce4aa8b8">More...</a><br /></td></tr>
<tr class="separator:a1b5e551dc6fb8002b1263d47ce4aa8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cb3f8d7609bdffc0e46f55b27ed4ab"><td class="memTemplParams" colspan="2"><a id="af5cb3f8d7609bdffc0e46f55b27ed4ab" name="af5cb3f8d7609bdffc0e46f55b27ed4ab"></a>
template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:af5cb3f8d7609bdffc0e46f55b27ed4ab"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; DerivedV, DerivedF &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_mesh</b> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;vertices, Eigen::MatrixBase&lt; DerivedF &gt; &amp;&amp;facets)</td></tr>
<tr class="separator:af5cb3f8d7609bdffc0e46f55b27ed4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6776dd40617b9a65a8e5ed66812711b"><td class="memTemplParams" colspan="2"><a id="ac6776dd40617b9a65a8e5ed66812711b" name="ac6776dd40617b9a65a8e5ed66812711b"></a>
template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:ac6776dd40617b9a65a8e5ed66812711b"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; DerivedV, DerivedF &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_mesh</b> (Eigen::MatrixBase&lt; DerivedV &gt; &amp;&amp;vertices, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;facets)</td></tr>
<tr class="separator:ac6776dd40617b9a65a8e5ed66812711b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14b46e06f926a32bb0cb2d0ce2052d3"><td class="memTemplParams" colspan="2">template&lt;typename VertexArray , typename FacetArray &gt; </td></tr>
<tr class="memitem:ae14b46e06f926a32bb0cb2d0ce2052d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ae14b46e06f926a32bb0cb2d0ce2052d3">wrap_with_mesh</a> (const Eigen::MatrixBase&lt; VertexArray &gt; &amp;vertices, const Eigen::MatrixBase&lt; FacetArray &gt; &amp;facets)</td></tr>
<tr class="memdesc:ae14b46e06f926a32bb0cb2d0ce2052d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method creates a <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object that wraps around vertices and facets.  <a href="namespacelagrange.html#ae14b46e06f926a32bb0cb2d0ce2052d3">More...</a><br /></td></tr>
<tr class="separator:ae14b46e06f926a32bb0cb2d0ce2052d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38beb2e00a358a1dc7960f5d54ed66c5"><td class="memTemplParams" colspan="2"><a id="a38beb2e00a358a1dc7960f5d54ed66c5" name="a38beb2e00a358a1dc7960f5d54ed66c5"></a>
template&lt;typename VertexArray , typename FacetArray &gt; </td></tr>
<tr class="memitem:a38beb2e00a358a1dc7960f5d54ed66c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wrap_with_mesh</b> (const Eigen::MatrixBase&lt; VertexArray &gt; &amp;&amp;, const Eigen::MatrixBase&lt; FacetArray &gt; &amp;&amp;)</td></tr>
<tr class="separator:a38beb2e00a358a1dc7960f5d54ed66c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca0ea842282fdf8bf06ea90bb193ca8"><td class="memTemplParams" colspan="2"><a id="abca0ea842282fdf8bf06ea90bb193ca8" name="abca0ea842282fdf8bf06ea90bb193ca8"></a>
template&lt;typename VertexArray , typename FacetArray &gt; </td></tr>
<tr class="memitem:abca0ea842282fdf8bf06ea90bb193ca8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wrap_with_mesh</b> (const Eigen::MatrixBase&lt; VertexArray &gt; &amp;, const Eigen::MatrixBase&lt; FacetArray &gt; &amp;&amp;)</td></tr>
<tr class="separator:abca0ea842282fdf8bf06ea90bb193ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc317ebb509e1424bd063d3b8161706"><td class="memTemplParams" colspan="2"><a id="a4fc317ebb509e1424bd063d3b8161706" name="a4fc317ebb509e1424bd063d3b8161706"></a>
template&lt;typename VertexArray , typename FacetArray &gt; </td></tr>
<tr class="memitem:a4fc317ebb509e1424bd063d3b8161706"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wrap_with_mesh</b> (const Eigen::MatrixBase&lt; VertexArray &gt; &amp;&amp;, const Eigen::MatrixBase&lt; FacetArray &gt; &amp;)</td></tr>
<tr class="separator:a4fc317ebb509e1424bd063d3b8161706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8bcd4939a21ed624de2c6d9fd281eb"><td class="memItemLeft" align="right" valign="top"><a id="a3e8bcd4939a21ed624de2c6d9fd281eb" name="a3e8bcd4939a21ed624de2c6d9fd281eb"></a>
std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">TriangleMesh3D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>create_cube</b> ()</td></tr>
<tr class="separator:a3e8bcd4939a21ed624de2c6d9fd281eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9413b6be0c30efd8eaf93d8b30c6b058"><td class="memItemLeft" align="right" valign="top"><a id="a9413b6be0c30efd8eaf93d8b30c6b058" name="a9413b6be0c30efd8eaf93d8b30c6b058"></a>
std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">TriangleMesh3D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>create_quad</b> (bool with_center_vertex)</td></tr>
<tr class="separator:a9413b6be0c30efd8eaf93d8b30c6b058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d0f9c1a4c8b1d92aaecbdb8e825a8a"><td class="memItemLeft" align="right" valign="top"><a id="ac5d0f9c1a4c8b1d92aaecbdb8e825a8a" name="ac5d0f9c1a4c8b1d92aaecbdb8e825a8a"></a>
std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">TriangleMesh3D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>create_sphere</b> (double refine_order=2)</td></tr>
<tr class="separator:ac5d0f9c1a4c8b1d92aaecbdb8e825a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4263d0946081ee8f33f546b059ddc20"><td class="memTemplParams" colspan="2"><a id="ae4263d0946081ee8f33f546b059ddc20" name="ae4263d0946081ee8f33f546b059ddc20"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:ae4263d0946081ee8f33f546b059ddc20"><td class="memTemplItemLeft" align="right" valign="top">EdgeFacetMap&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_edge_facet_map_in_active_facets</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::unordered_set&lt; typename MeshType::Index &gt; &amp;active_facets)</td></tr>
<tr class="separator:ae4263d0946081ee8f33f546b059ddc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3d091ecb1d19a756c33515db684a33"><td class="memTemplParams" colspan="2"><a id="a6d3d091ecb1d19a756c33515db684a33" name="a6d3d091ecb1d19a756c33515db684a33"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a6d3d091ecb1d19a756c33515db684a33"><td class="memTemplItemLeft" align="right" valign="top">EdgeFacetMap&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_edge_facet_map_in_active_vertices</b> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const std::unordered_set&lt; typename MeshType::Index &gt; &amp;active_vertices)</td></tr>
<tr class="separator:a6d3d091ecb1d19a756c33515db684a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab32ca760af612ea529943197c79f719b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gab32ca760af612ea529943197c79f719b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gab32ca760af612ea529943197c79f719b">extract_boundary_loops</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:gab32ca760af612ea529943197c79f719b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract boundary loops from a surface mesh.  <a href="group__group-surfacemesh-utils.html#gab32ca760af612ea529943197c79f719b">More...</a><br /></td></tr>
<tr class="separator:gab32ca760af612ea529943197c79f719b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f1b4f791ba72765e9c19df688bffd1c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga6f1b4f791ba72765e9c19df688bffd1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr-utils.html#ga6f1b4f791ba72765e9c19df688bffd1c">extract_submesh</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; selected_facets, const <a class="el" href="structlagrange_1_1_submesh_options.html">SubmeshOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:ga6f1b4f791ba72765e9c19df688bffd1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a submesh that consists of a subset of the facets of the source mesh.  <a href="group__group-surfacemesh-attr-utils.html#ga6f1b4f791ba72765e9c19df688bffd1c">More...</a><br /></td></tr>
<tr class="separator:ga6f1b4f791ba72765e9c19df688bffd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63beae4b47ee5f18e376307bf2c485eb"><td class="memTemplParams" colspan="2"><a id="a63beae4b47ee5f18e376307bf2c485eb" name="a63beae4b47ee5f18e376307bf2c485eb"></a>
template&lt;typename _VertexArray , typename _FacetArray , typename Archive &gt; </td></tr>
<tr class="memitem:a63beae4b47ee5f18e376307bf2c485eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (std::shared_ptr&lt; <a class="el" href="classlagrange_1_1_mesh_geometry.html">MeshGeometry</a>&lt; _VertexArray, _FacetArray &gt; &gt; &amp;geometry, Archive &amp;ar)</td></tr>
<tr class="separator:a63beae4b47ee5f18e376307bf2c485eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42a8925e209e6e0e308a65525991e91"><td class="memTemplParams" colspan="2"><a id="ad42a8925e209e6e0e308a65525991e91" name="ad42a8925e209e6e0e308a65525991e91"></a>
template&lt;typename DerivedF &gt; </td></tr>
<tr class="memitem:ad42a8925e209e6e0e308a65525991e91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_edge_type.html">EdgeType</a>&lt; typename DerivedF::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_opposite_edge</b> (const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;facets, typename DerivedF::Scalar fid, typename DerivedF::Scalar vid)</td></tr>
<tr class="separator:ad42a8925e209e6e0e308a65525991e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97e3b3adabf67bc7d3650ed14214ddaa"><td class="memItemLeft" align="right" valign="top">spdlog::logger &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-logger.html#ga97e3b3adabf67bc7d3650ed14214ddaa">logger</a> ()</td></tr>
<tr class="memdesc:ga97e3b3adabf67bc7d3650ed14214ddaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current logger.  <a href="group__group-logger.html#ga97e3b3adabf67bc7d3650ed14214ddaa">More...</a><br /></td></tr>
<tr class="separator:ga97e3b3adabf67bc7d3650ed14214ddaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f17bae29eab16304d0f5a71f383ae15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-logger.html#ga8f17bae29eab16304d0f5a71f383ae15">set_logger</a> (std::shared_ptr&lt; spdlog::logger &gt; <a class="el" href="group__group-logger.html#ga97e3b3adabf67bc7d3650ed14214ddaa">logger</a>)</td></tr>
<tr class="memdesc:ga8f17bae29eab16304d0f5a71f383ae15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup a logger object to be used by Lagrange.  <a href="group__group-logger.html#ga8f17bae29eab16304d0f5a71f383ae15">More...</a><br /></td></tr>
<tr class="separator:ga8f17bae29eab16304d0f5a71f383ae15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79f233ab5cedf00d807bc3f8c3c203e"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> , typename ValueFn &gt; </td></tr>
<tr class="memitem:aa79f233ab5cedf00d807bc3f8c3c203e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_marching_triangles_output.html">MarchingTrianglesOutput</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#aa79f233ab5cedf00d807bc3f8c3c203e">marching_triangles_general</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh_ref, ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; isovalue, const ValueFn &amp;get_value)</td></tr>
<tr class="memdesc:aa79f233ab5cedf00d807bc3f8c3c203e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform marching triangles to extract isocontour on a field defined as the linear interpolation of values provided by the <code>get_value</code> function.  <a href="namespacelagrange.html#aa79f233ab5cedf00d807bc3f8c3c203e">More...</a><br /></td></tr>
<tr class="separator:aa79f233ab5cedf00d807bc3f8c3c203e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654933a53da0ccbed66cfca5bc6f3de2"><td class="memTemplParams" colspan="2"><a id="a654933a53da0ccbed66cfca5bc6f3de2" name="a654933a53da0ccbed66cfca5bc6f3de2"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a654933a53da0ccbed66cfca5bc6f3de2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_marching_triangles_output.html">MarchingTrianglesOutput</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>marching_triangles</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh_ref, const typename MeshType::Scalar isovalue, const std::string vertex_attribute_name, const typename MeshType::Index attribute_col_index=0)</td></tr>
<tr class="separator:a654933a53da0ccbed66cfca5bc6f3de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303f43cd9a9728efee71e5b5d2534927"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a303f43cd9a9728efee71e5b5d2534927"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_marching_triangles_output.html">MarchingTrianglesOutput</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a303f43cd9a9728efee71e5b5d2534927">marching_triangles_indexed</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh_ref, const typename MeshType::Scalar isovalue, const std::string indexed_attribute_name, const typename MeshType::Index attribute_col_index=0)</td></tr>
<tr class="memdesc:a303f43cd9a9728efee71e5b5d2534927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform marching triangles to extract isocontours on a field defined as the linear interpolation of an indexed attribute.  <a href="namespacelagrange.html#a303f43cd9a9728efee71e5b5d2534927">More...</a><br /></td></tr>
<tr class="separator:a303f43cd9a9728efee71e5b5d2534927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6a4ba76d19d3abeb66fcdbd594f8a6"><td class="memTemplParams" colspan="2"><a id="aed6a4ba76d19d3abeb66fcdbd594f8a6" name="aed6a4ba76d19d3abeb66fcdbd594f8a6"></a>
template&lt;typename _VertexArray , typename _FacetArray , typename Archive &gt; </td></tr>
<tr class="memitem:aed6a4ba76d19d3abeb66fcdbd594f8a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (<a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; _VertexArray, _FacetArray &gt; &amp;mesh, Archive &amp;ar)</td></tr>
<tr class="separator:aed6a4ba76d19d3abeb66fcdbd594f8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88e5e2a3cb45c21980d4d676a08c8b3"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:ac88e5e2a3cb45c21980d4d676a08c8b3"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ac88e5e2a3cb45c21980d4d676a08c8b3">close_small_holes</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, size_t max_hole_size)</td></tr>
<tr class="memdesc:ac88e5e2a3cb45c21980d4d676a08c8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close small topological holes.  <a href="namespacelagrange.html#ac88e5e2a3cb45c21980d4d676a08c8b3">More...</a><br /></td></tr>
<tr class="separator:ac88e5e2a3cb45c21980d4d676a08c8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47e0b414a04c27b736ffb61985ae3e1"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ae47e0b414a04c27b736ffb61985ae3e1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ae47e0b414a04c27b736ffb61985ae3e1">detect_degenerate_facets</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ae47e0b414a04c27b736ffb61985ae3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects degenerate facets in a mesh.  <a href="namespacelagrange.html#ae47e0b414a04c27b736ffb61985ae3e1">More...</a><br /></td></tr>
<tr class="separator:ae47e0b414a04c27b736ffb61985ae3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fd3adb44b0b3a38ad087cb6f631b16"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:ad6fd3adb44b0b3a38ad087cb6f631b16"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ad6fd3adb44b0b3a38ad087cb6f631b16">remove_duplicate_facets</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="memdesc:ad6fd3adb44b0b3a38ad087cb6f631b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal all duplicate facets from the mesh.  <a href="namespacelagrange.html#ad6fd3adb44b0b3a38ad087cb6f631b16">More...</a><br /></td></tr>
<tr class="separator:ad6fd3adb44b0b3a38ad087cb6f631b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027de7d500f4a17245fa0f7450a1d433"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a027de7d500f4a17245fa0f7450a1d433"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a027de7d500f4a17245fa0f7450a1d433">remove_duplicate_vertices</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const <a class="el" href="structlagrange_1_1_remove_duplicate_vertices_options.html">RemoveDuplicateVerticesOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:a027de7d500f4a17245fa0f7450a1d433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicate vertices from a mesh.  <a href="namespacelagrange.html#a027de7d500f4a17245fa0f7450a1d433">More...</a><br /></td></tr>
<tr class="separator:a027de7d500f4a17245fa0f7450a1d433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c66ca364fc0c9eb6d9b63052fa80ab"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a52c66ca364fc0c9eb6d9b63052fa80ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a52c66ca364fc0c9eb6d9b63052fa80ab">remove_isolated_vertices</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:a52c66ca364fc0c9eb6d9b63052fa80ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes isolated vertices of a mesh.  <a href="namespacelagrange.html#a52c66ca364fc0c9eb6d9b63052fa80ab">More...</a><br /></td></tr>
<tr class="separator:a52c66ca364fc0c9eb6d9b63052fa80ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ed135d2a082f05bbbc207aa379459a"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ac0ed135d2a082f05bbbc207aa379459a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ac0ed135d2a082f05bbbc207aa379459a">remove_null_area_facets</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const <a class="el" href="structlagrange_1_1_remove_null_area_facets_options.html">RemoveNullAreaFacetsOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:ac0ed135d2a082f05bbbc207aa379459a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all facets with unsigned area &lt;= options.null_area_threshold.  <a href="namespacelagrange.html#ac0ed135d2a082f05bbbc207aa379459a">More...</a><br /></td></tr>
<tr class="separator:ac0ed135d2a082f05bbbc207aa379459a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221bf945904e20d8ba77a7661247a226"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a221bf945904e20d8ba77a7661247a226"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a221bf945904e20d8ba77a7661247a226">remove_short_edges</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;in_mesh, typename MeshType::Scalar tol=0.0)</td></tr>
<tr class="memdesc:a221bf945904e20d8ba77a7661247a226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove edges shorter than a given tolerance.  <a href="namespacelagrange.html#a221bf945904e20d8ba77a7661247a226">More...</a><br /></td></tr>
<tr class="separator:a221bf945904e20d8ba77a7661247a226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4e0328e98859931047b51f9096260e"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a9a4e0328e98859931047b51f9096260e"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a9a4e0328e98859931047b51f9096260e">remove_topologically_degenerate_triangles</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="memdesc:a9a4e0328e98859931047b51f9096260e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove topologically degenerate triangles.  <a href="namespacelagrange.html#a9a4e0328e98859931047b51f9096260e">More...</a><br /></td></tr>
<tr class="separator:a9a4e0328e98859931047b51f9096260e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7a74bc68094461dfaa0ee5914be465"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a1f7a74bc68094461dfaa0ee5914be465"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a1f7a74bc68094461dfaa0ee5914be465">resolve_nonmanifoldness</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="memdesc:a1f7a74bc68094461dfaa0ee5914be465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve <b>all</b> non-manifold edges and vertices in the mesh.  <a href="namespacelagrange.html#a1f7a74bc68094461dfaa0ee5914be465">More...</a><br /></td></tr>
<tr class="separator:a1f7a74bc68094461dfaa0ee5914be465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cab1ac1fad3b7dd8c0e5a816e2fa057"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a8cab1ac1fad3b7dd8c0e5a816e2fa057"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a8cab1ac1fad3b7dd8c0e5a816e2fa057">resolve_vertex_nonmanifoldness</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="memdesc:a8cab1ac1fad3b7dd8c0e5a816e2fa057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove nonmanifold vertices topologically by pulling disconnected 1-ring neighborhood apart.  <a href="namespacelagrange.html#a8cab1ac1fad3b7dd8c0e5a816e2fa057">More...</a><br /></td></tr>
<tr class="separator:a8cab1ac1fad3b7dd8c0e5a816e2fa057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f8e9652abdb671076d8eea295d2c27"><td class="memTemplParams" colspan="2"><a id="a10f8e9652abdb671076d8eea295d2c27" name="a10f8e9652abdb671076d8eea295d2c27"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a10f8e9652abdb671076d8eea295d2c27"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>split_long_edges</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, typename MeshType::Scalar sq_tol, bool recursive=false)</td></tr>
<tr class="separator:a10f8e9652abdb671076d8eea295d2c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9228a710975bd87aa58b98ac1d8fbc06"><td class="memTemplParams" colspan="2">template&lt;typename VertexArray , typename Index &gt; </td></tr>
<tr class="memitem:a9228a710975bd87aa58b98ac1d8fbc06"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; Index, 3, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a9228a710975bd87aa58b98ac1d8fbc06">split_triangle</a> (const VertexArray &amp;vertices, const std::vector&lt; Index &gt; &amp;chain, const Index v0, const Index v1, const Index v2)</td></tr>
<tr class="memdesc:a9228a710975bd87aa58b98ac1d8fbc06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split triangle into smaller triangles based on the chain of spliting points.  <a href="namespacelagrange.html#a9228a710975bd87aa58b98ac1d8fbc06">More...</a><br /></td></tr>
<tr class="separator:a9228a710975bd87aa58b98ac1d8fbc06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5fc3fc93e8d973bcc534398eeb0aa9"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index , typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:abb5fc3fc93e8d973bcc534398eeb0aa9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#abb5fc3fc93e8d973bcc534398eeb0aa9">to_surface_mesh_copy</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh)</td></tr>
<tr class="memdesc:abb5fc3fc93e8d973bcc534398eeb0aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a legacy mesh object to a surface mesh object.  <a href="namespacelagrange.html#abb5fc3fc93e8d973bcc534398eeb0aa9">More...</a><br /></td></tr>
<tr class="separator:abb5fc3fc93e8d973bcc534398eeb0aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ad17ee5b7475decfbaf17fcfa63d65"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index , typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a68ad17ee5b7475decfbaf17fcfa63d65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a68ad17ee5b7475decfbaf17fcfa63d65">to_surface_mesh_wrap</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&amp;mesh)</td></tr>
<tr class="memdesc:a68ad17ee5b7475decfbaf17fcfa63d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a legacy mesh object as a surface mesh object.  <a href="namespacelagrange.html#a68ad17ee5b7475decfbaf17fcfa63d65">More...</a><br /></td></tr>
<tr class="separator:a68ad17ee5b7475decfbaf17fcfa63d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac349d354b36d62bc2efeb93dd2b7f078"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ac349d354b36d62bc2efeb93dd2b7f078"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ac349d354b36d62bc2efeb93dd2b7f078">to_legacy_mesh</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ac349d354b36d62bc2efeb93dd2b7f078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a surface mesh object to a legacy mesh object.  <a href="namespacelagrange.html#ac349d354b36d62bc2efeb93dd2b7f078">More...</a><br /></td></tr>
<tr class="separator:ac349d354b36d62bc2efeb93dd2b7f078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d1858ee3052bb8908c966a00ec65d2"><td class="memTemplParams" colspan="2"><a id="a88d1858ee3052bb8908c966a00ec65d2" name="a88d1858ee3052bb8908c966a00ec65d2"></a>
template&lt;typename _VertexArray , typename _FacetArray , typename Archive &gt; </td></tr>
<tr class="memitem:a88d1858ee3052bb8908c966a00ec65d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (<a class="el" href="classlagrange_1_1_mesh_geometry.html">MeshGeometry</a>&lt; _VertexArray, _FacetArray &gt; &amp;geometry, Archive &amp;ar)</td></tr>
<tr class="separator:a88d1858ee3052bb8908c966a00ec65d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf07b7ee38e3c92577a3cdc9a7bb38479"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gaf07b7ee38e3c92577a3cdc9a7bb38479"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gaf07b7ee38e3c92577a3cdc9a7bb38479">normalize_mesh</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:gaf07b7ee38e3c92577a3cdc9a7bb38479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a mesh to fit in a unit box centered at the origin.  <a href="group__group-surfacemesh-utils.html#gaf07b7ee38e3c92577a3cdc9a7bb38479">More...</a><br /></td></tr>
<tr class="separator:gaf07b7ee38e3c92577a3cdc9a7bb38479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad46e0464a61ba9b6c5fd7948af53c304"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gad46e0464a61ba9b6c5fd7948af53c304"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#gad46e0464a61ba9b6c5fd7948af53c304">normalize_meshes</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; * &gt; meshes)</td></tr>
<tr class="memdesc:gad46e0464a61ba9b6c5fd7948af53c304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a list of meshes to fit in a unit box centered at the origin.  <a href="group__group-surfacemesh-utils.html#gad46e0464a61ba9b6c5fd7948af53c304">More...</a><br /></td></tr>
<tr class="separator:gad46e0464a61ba9b6c5fd7948af53c304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d4b75c350742efbcde9bab3781edcf"><td class="memTemplParams" colspan="2">template&lt;typename VertexArray , typename FacetArray &gt; </td></tr>
<tr class="memitem:ad4d4b75c350742efbcde9bab3781edcf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ad4d4b75c350742efbcde9bab3781edcf">orient_outward</a> (<a class="el" href="classlagrange_1_1_mesh.html">lagrange::Mesh</a>&lt; VertexArray, FacetArray &gt; &amp;mesh, bool positive=true)</td></tr>
<tr class="memdesc:ad4d4b75c350742efbcde9bab3781edcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient the facets of a mesh so that the signed volume of each connected component is positive or negative.  <a href="namespacelagrange.html#ad4d4b75c350742efbcde9bab3781edcf">More...</a><br /></td></tr>
<tr class="separator:ad4d4b75c350742efbcde9bab3781edcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bb6f1ff87f6aac0062ac21dba0f2349"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga4bb6f1ff87f6aac0062ac21dba0f2349"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga4bb6f1ff87f6aac0062ac21dba0f2349">permute_facets</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; new_to_old)</td></tr>
<tr class="memdesc:ga4bb6f1ff87f6aac0062ac21dba0f2349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder facets of a mesh based on a given permutation.  <a href="group__group-surfacemesh-utils.html#ga4bb6f1ff87f6aac0062ac21dba0f2349">More...</a><br /></td></tr>
<tr class="separator:ga4bb6f1ff87f6aac0062ac21dba0f2349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aea6bef4481de2ace23921d95fdc8fe"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga8aea6bef4481de2ace23921d95fdc8fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga8aea6bef4481de2ace23921d95fdc8fe">permute_vertices</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; new_to_old)</td></tr>
<tr class="memdesc:ga8aea6bef4481de2ace23921d95fdc8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder vertices of a mesh based on a given permutation.  <a href="group__group-surfacemesh-utils.html#ga8aea6bef4481de2ace23921d95fdc8fe">More...</a><br /></td></tr>
<tr class="separator:ga8aea6bef4481de2ace23921d95fdc8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78898b0da8d43677481cdc176f2391f8"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga78898b0da8d43677481cdc176f2391f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga78898b0da8d43677481cdc176f2391f8">remap_vertices</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; forward_mapping, <a class="el" href="structlagrange_1_1_remap_vertices_options.html">RemapVerticesOptions</a> options={})</td></tr>
<tr class="memdesc:ga78898b0da8d43677481cdc176f2391f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap vertices of a mesh based on provided forward mapping.  <a href="group__group-surfacemesh-utils.html#ga78898b0da8d43677481cdc176f2391f8">More...</a><br /></td></tr>
<tr class="separator:ga78898b0da8d43677481cdc176f2391f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34291a385d6e22b0262f00dcb21310c9"><td class="memTemplParams" colspan="2"><a id="a34291a385d6e22b0262f00dcb21310c9" name="a34291a385d6e22b0262f00dcb21310c9"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a34291a385d6e22b0262f00dcb21310c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_sample_points_on_surface_output.html">SamplePointsOnSurfaceOutput</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sample_points_on_surface</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const typename MeshType::Index approx_num_points, const typename MeshType::IndexList &amp;active_facets)</td></tr>
<tr class="separator:a34291a385d6e22b0262f00dcb21310c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81241201933f19e9132ccf6228a07087"><td class="memTemplParams" colspan="2"><a id="a81241201933f19e9132ccf6228a07087" name="a81241201933f19e9132ccf6228a07087"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a81241201933f19e9132ccf6228a07087"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_sample_points_on_surface_output.html">SamplePointsOnSurfaceOutput</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sample_points_on_surface</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const typename MeshType::Index approx_num_points, const std::vector&lt; bool &gt; &amp;is_facet_active)</td></tr>
<tr class="separator:a81241201933f19e9132ccf6228a07087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a6daa9c62e706c5acdd83e6ef21b8e"><td class="memTemplParams" colspan="2"><a id="a71a6daa9c62e706c5acdd83e6ef21b8e" name="a71a6daa9c62e706c5acdd83e6ef21b8e"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a71a6daa9c62e706c5acdd83e6ef21b8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_sample_points_on_surface_output.html">SamplePointsOnSurfaceOutput</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sample_points_on_surface</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const typename MeshType::Index approx_num_points)</td></tr>
<tr class="separator:a71a6daa9c62e706c5acdd83e6ef21b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bc8764fc5a64c99f00713d7b034580"><td class="memTemplParams" colspan="2">template&lt;typename PointType &gt; </td></tr>
<tr class="memitem:ac1bc8764fc5a64c99f00713d7b034580"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ac1bc8764fc5a64c99f00713d7b034580">segment_segment_squared_distance</a> (const Eigen::MatrixBase&lt; PointType &gt; &amp;U0, const Eigen::MatrixBase&lt; PointType &gt; &amp;U1, const Eigen::MatrixBase&lt; PointType &gt; &amp;V0, const Eigen::MatrixBase&lt; PointType &gt; &amp;V1, Eigen::PlainObjectBase&lt; PointType &gt; &amp;closest_pointU, Eigen::PlainObjectBase&lt; PointType &gt; &amp;closest_pointV, ScalarOf&lt; PointType &gt; &amp;lambdaU, ScalarOf&lt; PointType &gt; &amp;lambdaV) -&gt; ScalarOf&lt; PointType &gt;</td></tr>
<tr class="memdesc:ac1bc8764fc5a64c99f00713d7b034580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the squared distance between two N-d line segments, and the closest pair of points whose separation is this distance.  <a href="namespacelagrange.html#ac1bc8764fc5a64c99f00713d7b034580">More...</a><br /></td></tr>
<tr class="separator:ac1bc8764fc5a64c99f00713d7b034580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba79cf8e74106eadba2f4fcf6c29251"><td class="memTemplParams" colspan="2"><a id="a1ba79cf8e74106eadba2f4fcf6c29251" name="a1ba79cf8e74106eadba2f4fcf6c29251"></a>
template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a1ba79cf8e74106eadba2f4fcf6c29251"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>select_facets_by_normal_similarity</b> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const typename MeshType::Index seed_facet_id, const <a class="el" href="structlagrange_1_1_select_facets_by_normal_similarity_parameters.html">SelectFacetsByNormalSimilarityParameters</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; &amp;parameters)</td></tr>
<tr class="separator:a1ba79cf8e74106eadba2f4fcf6c29251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7192854f01f61a0e17c45e411265b648"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> , typename Point3D &gt; </td></tr>
<tr class="memitem:a7192854f01f61a0e17c45e411265b648"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a7192854f01f61a0e17c45e411265b648">select_facets_in_frustum</a> (<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;n0, const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;p0, const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;n1, const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;p1, const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;n2, const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;p2, const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;n3, const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;p3, bool greedy=false)</td></tr>
<tr class="memdesc:a7192854f01f61a0e17c45e411265b648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select all facets that intersect the cone/frustrum bounded by 4 planes defined by (n_i, p_i), where n_i is the plane normal and p_i is a point on the plane.  <a href="namespacelagrange.html#a7192854f01f61a0e17c45e411265b648">More...</a><br /></td></tr>
<tr class="separator:a7192854f01f61a0e17c45e411265b648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga954105400081aec257b861eabc11caa4"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga954105400081aec257b861eabc11caa4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr-utils.html#ga954105400081aec257b861eabc11caa4">separate_by_components</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const <a class="el" href="structlagrange_1_1_separate_by_components_options.html">SeparateByComponentsOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:ga954105400081aec257b861eabc11caa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separate a mesh by connected components.  <a href="group__group-surfacemesh-attr-utils.html#ga954105400081aec257b861eabc11caa4">More...</a><br /></td></tr>
<tr class="separator:ga954105400081aec257b861eabc11caa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a916fec3d88a2f142479beb6d1dabbc"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga3a916fec3d88a2f142479beb6d1dabbc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr-utils.html#ga3a916fec3d88a2f142479beb6d1dabbc">separate_by_facet_groups</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, size_t num_groups, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; facet_group_indices, const <a class="el" href="structlagrange_1_1_separate_by_facet_groups_options.html">SeparateByFacetGroupsOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:ga3a916fec3d88a2f142479beb6d1dabbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a set of submeshes based on facet groups.  <a href="group__group-surfacemesh-attr-utils.html#ga3a916fec3d88a2f142479beb6d1dabbc">More...</a><br /></td></tr>
<tr class="separator:ga3a916fec3d88a2f142479beb6d1dabbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bfc61d050dfff96cd48f72f4bd4b149"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga8bfc61d050dfff96cd48f72f4bd4b149"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr-utils.html#ga8bfc61d050dfff96cd48f72f4bd4b149">separate_by_facet_groups</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; facet_group_indices, const <a class="el" href="structlagrange_1_1_separate_by_facet_groups_options.html">SeparateByFacetGroupsOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:ga8bfc61d050dfff96cd48f72f4bd4b149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a set of submeshes based on facet groups.  <a href="group__group-surfacemesh-attr-utils.html#ga8bfc61d050dfff96cd48f72f4bd4b149">More...</a><br /></td></tr>
<tr class="separator:ga8bfc61d050dfff96cd48f72f4bd4b149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987e83dd82916a9347d04f1d45a7934e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga987e83dd82916a9347d04f1d45a7934e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr-utils.html#ga987e83dd82916a9347d04f1d45a7934e">separate_by_facet_groups</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, size_t num_groups, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; Index(Index)&gt; get_facet_group, const <a class="el" href="structlagrange_1_1_separate_by_facet_groups_options.html">SeparateByFacetGroupsOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:ga987e83dd82916a9347d04f1d45a7934e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a set of submeshes based on facet groups.  <a href="group__group-surfacemesh-attr-utils.html#ga987e83dd82916a9347d04f1d45a7934e">More...</a><br /></td></tr>
<tr class="separator:ga987e83dd82916a9347d04f1d45a7934e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e74586d94cbe3ec2e2e361b66d01faf"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a5e74586d94cbe3ec2e2e361b66d01faf"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a5e74586d94cbe3ec2e2e361b66d01faf">thicken_and_close_mesh</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;input_mesh, Eigen::Matrix&lt; ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;, 3, 1 &gt; direction, ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; offset_amount, ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; mirror_amount, typename MeshType::Index num_segments=1)</td></tr>
<tr class="memdesc:a5e74586d94cbe3ec2e2e361b66d01faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thicken a mesh by offsetting it in a fixed direction.  <a href="namespacelagrange.html#a5e74586d94cbe3ec2e2e361b66d01faf">More...</a><br /></td></tr>
<tr class="separator:a5e74586d94cbe3ec2e2e361b66d01faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392649a5d76a59dc2500d9b9d094c0ea"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a392649a5d76a59dc2500d9b9d094c0ea"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a392649a5d76a59dc2500d9b9d094c0ea">thicken_and_close_mesh</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;input_mesh, ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; offset_amount, typename MeshType::Index num_segments=1)</td></tr>
<tr class="memdesc:a392649a5d76a59dc2500d9b9d094c0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thicken a mesh vertices along normals, and close the shape into a thick 3D solid.  <a href="namespacelagrange.html#a392649a5d76a59dc2500d9b9d094c0ea">More...</a><br /></td></tr>
<tr class="separator:a392649a5d76a59dc2500d9b9d094c0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256e7ab23f324bc2f7fb5fd977405932"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a256e7ab23f324bc2f7fb5fd977405932"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a256e7ab23f324bc2f7fb5fd977405932">compute_euler</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:a256e7ab23f324bc2f7fb5fd977405932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Euler characteristic of a mesh.  <a href="namespacelagrange.html#a256e7ab23f324bc2f7fb5fd977405932">More...</a><br /></td></tr>
<tr class="separator:a256e7ab23f324bc2f7fb5fd977405932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7a15cae60d68a94bac4068de177b4a"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a8c7a15cae60d68a94bac4068de177b4a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a8c7a15cae60d68a94bac4068de177b4a">is_vertex_manifold</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:a8c7a15cae60d68a94bac4068de177b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a mesh is vertex-manifold.  <a href="namespacelagrange.html#a8c7a15cae60d68a94bac4068de177b4a">More...</a><br /></td></tr>
<tr class="separator:a8c7a15cae60d68a94bac4068de177b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52aec6a70ed2240fe977f81f393d1259"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a52aec6a70ed2240fe977f81f393d1259"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a52aec6a70ed2240fe977f81f393d1259">is_edge_manifold</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:a52aec6a70ed2240fe977f81f393d1259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a mesh is edge-manifold.  <a href="namespacelagrange.html#a52aec6a70ed2240fe977f81f393d1259">More...</a><br /></td></tr>
<tr class="separator:a52aec6a70ed2240fe977f81f393d1259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b70a6e7c30cd0524e2fc2490f280b69"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a4b70a6e7c30cd0524e2fc2490f280b69"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a4b70a6e7c30cd0524e2fc2490f280b69">is_manifold</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:a4b70a6e7c30cd0524e2fc2490f280b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a mesh is both vertex-manifold and edge-manifold.  <a href="namespacelagrange.html#a4b70a6e7c30cd0524e2fc2490f280b69">More...</a><br /></td></tr>
<tr class="separator:a4b70a6e7c30cd0524e2fc2490f280b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48af6105ece8a970755870c73af73ddd"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga48af6105ece8a970755870c73af73ddd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-utils.html#ga48af6105ece8a970755870c73af73ddd">triangulate_polygonal_facets</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga48af6105ece8a970755870c73af73ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulate polygonal facets of a mesh using a prescribed set of rules.  <a href="group__group-surfacemesh-utils.html#ga48af6105ece8a970755870c73af73ddd">More...</a><br /></td></tr>
<tr class="separator:ga48af6105ece8a970755870c73af73ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0eeb4d96ed545aadd3b6bf27ed631c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-utils-assert.html#gaf0eeb4d96ed545aadd3b6bf27ed631c6">set_breakpoint_enabled</a> (bool enabled)</td></tr>
<tr class="memdesc:gaf0eeb4d96ed545aadd3b6bf27ed631c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether to trigger a debugger breakpoint on assert failure.  <a href="group__group-utils-assert.html#gaf0eeb4d96ed545aadd3b6bf27ed631c6">More...</a><br /></td></tr>
<tr class="separator:gaf0eeb4d96ed545aadd3b6bf27ed631c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1d763e905c12a114bb94a8f38227094"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-utils-assert.html#gac1d763e905c12a114bb94a8f38227094">is_breakpoint_enabled</a> ()</td></tr>
<tr class="memdesc:gac1d763e905c12a114bb94a8f38227094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether to trigger a debugger breakpoint on assert failure.  <a href="group__group-utils-assert.html#gac1d763e905c12a114bb94a8f38227094">More...</a><br /></td></tr>
<tr class="separator:gac1d763e905c12a114bb94a8f38227094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82afecd46baab6fadf8dfa8d7dbea5ec"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>trigger_breakpoint</b> ()</td></tr>
<tr class="memdesc:ga82afecd46baab6fadf8dfa8d7dbea5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call to explicitly trigger a debugger breakpoint. <br /></td></tr>
<tr class="separator:ga82afecd46baab6fadf8dfa8d7dbea5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fa47832a47c910f51b99004c3bc165f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-utils-assert.html#ga3fa47832a47c910f51b99004c3bc165f">assertion_failed</a> (const char *function, const char *file, unsigned int line, const char *condition, std::string_view message)</td></tr>
<tr class="memdesc:ga3fa47832a47c910f51b99004c3bc165f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called in case of an assertion failure.  <a href="group__group-utils-assert.html#ga3fa47832a47c910f51b99004c3bc165f">More...</a><br /></td></tr>
<tr class="separator:ga3fa47832a47c910f51b99004c3bc165f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19b64389774c826a71abae902e0b46b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga19b64389774c826a71abae902e0b46b9">enable_fpe</a> ()</td></tr>
<tr class="memdesc:ga19b64389774c826a71abae902e0b46b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable floating-point exceptions (useful for debugging).  <a href="group__group-utils-misc.html#ga19b64389774c826a71abae902e0b46b9">More...</a><br /></td></tr>
<tr class="separator:ga19b64389774c826a71abae902e0b46b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe7e2f24aa07f2b2e38829ef368a0f59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#gabe7e2f24aa07f2b2e38829ef368a0f59">disable_fpe</a> ()</td></tr>
<tr class="memdesc:gabe7e2f24aa07f2b2e38829ef368a0f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable previously-enabled fpe.  <a href="group__group-utils-misc.html#gabe7e2f24aa07f2b2e38829ef368a0f59">More...</a><br /></td></tr>
<tr class="separator:gabe7e2f24aa07f2b2e38829ef368a0f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga626fd0cc926eb83e8adb607687c3c8e2"><td class="memTemplParams" colspan="2">
template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:ga626fd0cc926eb83e8adb607687c3c8e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;lhs, <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga626fd0cc926eb83e8adb607687c3c8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the referred callables of <code>lhs</code> and <code>rhs</code>. <br /></td></tr>
<tr class="separator:ga626fd0cc926eb83e8adb607687c3c8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdcfb06e9497d99667ce90201fa5c056"><td class="memTemplParams" colspan="2">
template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:gabdcfb06e9497d99667ce90201fa5c056"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>function_ref</b> (R(*)(Args...)) -&gt; <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt;</td></tr>
<tr class="memdesc:gabdcfb06e9497d99667ce90201fa5c056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce <a class="el" href="classlagrange_1_1function__ref.html" title="A lightweight non-owning reference to a callable.">function_ref</a> type from a function pointer. <br /></td></tr>
<tr class="separator:gabdcfb06e9497d99667ce90201fa5c056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a32187970858cfc546d8db05b5ca21"><td class="memTemplParams" colspan="2"><a id="a97a32187970858cfc546d8db05b5ca21" name="a97a32187970858cfc546d8db05b5ca21"></a>
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a97a32187970858cfc546d8db05b5ca21"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sqr_minimum_distance</b> (const Eigen::Vector2&lt; Scalar &gt; &amp;a, const Eigen::Vector2&lt; Scalar &gt; &amp;b, const Eigen::Vector2&lt; Scalar &gt; &amp;p)</td></tr>
<tr class="memdesc:a97a32187970858cfc546d8db05b5ca21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared minimum distance between 2d line segment ab and point p. <br /></td></tr>
<tr class="separator:a97a32187970858cfc546d8db05b5ca21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c3d440683e6e315a97296072b2c788"><td class="memTemplParams" colspan="2"><a id="a46c3d440683e6e315a97296072b2c788" name="a46c3d440683e6e315a97296072b2c788"></a>
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a46c3d440683e6e315a97296072b2c788"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Vector2&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>triangle_circumcenter</b> (const Eigen::Vector2&lt; Scalar &gt; &amp;p1, const Eigen::Vector2&lt; Scalar &gt; &amp;p2, const Eigen::Vector2&lt; Scalar &gt; &amp;p3)</td></tr>
<tr class="separator:a46c3d440683e6e315a97296072b2c788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b272a2ed8be41e680505c957dceac2"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int _Rows, int _Cols&gt; </td></tr>
<tr class="memitem:ac2b272a2ed8be41e680505c957dceac2"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ac2b272a2ed8be41e680505c957dceac2">cos_angle_between</a> (const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v1, const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v2)</td></tr>
<tr class="memdesc:ac2b272a2ed8be41e680505c957dceac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cosine of the angle between two 3d vectors.  <a href="namespacelagrange.html#ac2b272a2ed8be41e680505c957dceac2">More...</a><br /></td></tr>
<tr class="separator:ac2b272a2ed8be41e680505c957dceac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe3084745a587166766ba4f2d449b75"><td class="memTemplParams" colspan="2"><a id="acbe3084745a587166766ba4f2d449b75" name="acbe3084745a587166766ba4f2d449b75"></a>
template&lt;typename Scalar , int _Rows, int _Cols&gt; </td></tr>
<tr class="memitem:acbe3084745a587166766ba4f2d449b75"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><b>angle_between</b> (const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v1, const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v2)</td></tr>
<tr class="memdesc:acbe3084745a587166766ba4f2d449b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the angle between two 3d vectors. <br /></td></tr>
<tr class="separator:acbe3084745a587166766ba4f2d449b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d014fa874bb0ee627f729b81ba3065"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int _Rows, int _Cols&gt; </td></tr>
<tr class="memitem:aa1d014fa874bb0ee627f729b81ba3065"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#aa1d014fa874bb0ee627f729b81ba3065">project_on_line</a> (const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v1, const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v2)</td></tr>
<tr class="memdesc:aa1d014fa874bb0ee627f729b81ba3065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the vector v1 on the line defined by its vector v2.  <a href="namespacelagrange.html#aa1d014fa874bb0ee627f729b81ba3065">More...</a><br /></td></tr>
<tr class="separator:aa1d014fa874bb0ee627f729b81ba3065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774928c90a837bc834efbda24e4cf62a"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int _Rows, int _Cols&gt; </td></tr>
<tr class="memitem:a774928c90a837bc834efbda24e4cf62a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a774928c90a837bc834efbda24e4cf62a">project_on_plane</a> (const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v, const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;n)</td></tr>
<tr class="memdesc:a774928c90a837bc834efbda24e4cf62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the vector on the plane defined by its normal n.  <a href="namespacelagrange.html#a774928c90a837bc834efbda24e4cf62a">More...</a><br /></td></tr>
<tr class="separator:a774928c90a837bc834efbda24e4cf62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422d9aff461fac92045512a733336e16"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int _Rows, int _Cols&gt; </td></tr>
<tr class="memitem:a422d9aff461fac92045512a733336e16"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a422d9aff461fac92045512a733336e16">projected_cos_angle_between</a> (const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v1, const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v2, const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;n)</td></tr>
<tr class="memdesc:a422d9aff461fac92045512a733336e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the angle between the vectors v1 and v2 projected on the plane defined by its normal n.  <a href="namespacelagrange.html#a422d9aff461fac92045512a733336e16">More...</a><br /></td></tr>
<tr class="separator:a422d9aff461fac92045512a733336e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53daef46b0377ad840fd8f74f4d2d942"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int _Rows, int _Cols&gt; </td></tr>
<tr class="memitem:a53daef46b0377ad840fd8f74f4d2d942"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a53daef46b0377ad840fd8f74f4d2d942">projected_angle_between</a> (const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v1, const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;v2, const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;n)</td></tr>
<tr class="memdesc:a53daef46b0377ad840fd8f74f4d2d942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the angle between the vectors v1 and v2 projected on the plane defined by its normal n.  <a href="namespacelagrange.html#a53daef46b0377ad840fd8f74f4d2d942">More...</a><br /></td></tr>
<tr class="separator:a53daef46b0377ad840fd8f74f4d2d942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c72eb4eeff6cc742a7bfbbbe6c9337"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a98c72eb4eeff6cc742a7bfbbbe6c9337"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a98c72eb4eeff6cc742a7bfbbbe6c9337">vector_between</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh, typename MeshType::Index v1, typename MeshType::Index v2)</td></tr>
<tr class="memdesc:a98c72eb4eeff6cc742a7bfbbbe6c9337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector from v1 to v2.  <a href="namespacelagrange.html#a98c72eb4eeff6cc742a7bfbbbe6c9337">More...</a><br /></td></tr>
<tr class="separator:a98c72eb4eeff6cc742a7bfbbbe6c9337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b0f2917fb3bd337e8bbe09d221f4e3"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a14b0f2917fb3bd337e8bbe09d221f4e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a14b0f2917fb3bd337e8bbe09d221f4e3">orthogonal_frame</a> (const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;x, Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;y, Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;z)</td></tr>
<tr class="memdesc:a14b0f2917fb3bd337e8bbe09d221f4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an orthogonal frame given a single vector.  <a href="namespacelagrange.html#a14b0f2917fb3bd337e8bbe09d221f4e3">More...</a><br /></td></tr>
<tr class="separator:a14b0f2917fb3bd337e8bbe09d221f4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc213e8639504f32e944828c1634d13e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gabc213e8639504f32e944828c1634d13e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#gabc213e8639504f32e944828c1634d13e">hash_combine</a> (size_t &amp;seed, const T &amp;v)</td></tr>
<tr class="memdesc:gabc213e8639504f32e944828c1634d13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash an object <em>v</em> and combine it with an existing hash value <em>seed</em>.  <a href="group__group-utils-misc.html#gabc213e8639504f32e944828c1634d13e">More...</a><br /></td></tr>
<tr class="separator:gabc213e8639504f32e944828c1634d13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c3e5aabde25a440beb7fc174ab081df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6c3e5aabde25a440beb7fc174ab081df"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga6c3e5aabde25a440beb7fc174ab081df">invalid</a> ()</td></tr>
<tr class="memdesc:ga6c3e5aabde25a440beb7fc174ab081df"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can use <a class="el" href="group__group-utils-misc.html#ga6c3e5aabde25a440beb7fc174ab081df" title="You can use invalid&lt;T&gt;() to get a value that can represent &quot;invalid&quot; values, such as indices.">invalid&lt;T&gt;()</a> to get a value that can represent "invalid" values, such as indices.  <a href="group__group-utils-misc.html#ga6c3e5aabde25a440beb7fc174ab081df">More...</a><br /></td></tr>
<tr class="separator:ga6c3e5aabde25a440beb7fc174ab081df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ae6ac12cb08b0c98d8cb28938dbe6a"><td class="memTemplParams" colspan="2">template&lt;typename PointType &gt; </td></tr>
<tr class="memitem:ae9ae6ac12cb08b0c98d8cb28938dbe6a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ae9ae6ac12cb08b0c98d8cb28938dbe6a">point_on_segment</a> (const Eigen::MatrixBase&lt; PointType &gt; &amp;p, const Eigen::MatrixBase&lt; PointType &gt; &amp;a, const Eigen::MatrixBase&lt; PointType &gt; &amp;b)</td></tr>
<tr class="memdesc:ae9ae6ac12cb08b0c98d8cb28938dbe6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a point lies exactly on a segment [a,b] using exact predicates.  <a href="namespacelagrange.html#ae9ae6ac12cb08b0c98d8cb28938dbe6a">More...</a><br /></td></tr>
<tr class="separator:ae9ae6ac12cb08b0c98d8cb28938dbe6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2140a37f0d569beaf4878f9ab100f84f"><td class="memTemplParams" colspan="2">template&lt;typename PointType &gt; </td></tr>
<tr class="memitem:a2140a37f0d569beaf4878f9ab100f84f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a2140a37f0d569beaf4878f9ab100f84f">point_segment_squared_distance</a> (const Eigen::MatrixBase&lt; PointType &gt; &amp;point, const Eigen::MatrixBase&lt; PointType &gt; &amp;V0, const Eigen::MatrixBase&lt; PointType &gt; &amp;V1, Eigen::PlainObjectBase&lt; PointType &gt; &amp;closest_point, ScalarOf&lt; PointType &gt; &amp;lambda0, ScalarOf&lt; PointType &gt; &amp;lambda1) -&gt; ScalarOf&lt; PointType &gt;</td></tr>
<tr class="memdesc:a2140a37f0d569beaf4878f9ab100f84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the point closest to a given point in a nd segment.  <a href="namespacelagrange.html#a2140a37f0d569beaf4878f9ab100f84f">More...</a><br /></td></tr>
<tr class="separator:a2140a37f0d569beaf4878f9ab100f84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec127acd481e2443483e8243de40ca5"><td class="memTemplParams" colspan="2">template&lt;typename PointType &gt; </td></tr>
<tr class="memitem:a2ec127acd481e2443483e8243de40ca5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a2ec127acd481e2443483e8243de40ca5">point_segment_squared_distance</a> (const Eigen::MatrixBase&lt; PointType &gt; &amp;point, const Eigen::MatrixBase&lt; PointType &gt; &amp;V0, const Eigen::MatrixBase&lt; PointType &gt; &amp;V1) -&gt; ScalarOf&lt; PointType &gt;</td></tr>
<tr class="memdesc:a2ec127acd481e2443483e8243de40ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the point closest to a given point in a nd segment.  <a href="namespacelagrange.html#a2ec127acd481e2443483e8243de40ca5">More...</a><br /></td></tr>
<tr class="separator:a2ec127acd481e2443483e8243de40ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa226d603d77fc8036aaa59760a4067ff"><td class="memTemplParams" colspan="2">template&lt;typename PointType &gt; </td></tr>
<tr class="memitem:aa226d603d77fc8036aaa59760a4067ff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#aa226d603d77fc8036aaa59760a4067ff">point_triangle_squared_distance</a> (const Eigen::MatrixBase&lt; PointType &gt; &amp;point, const Eigen::MatrixBase&lt; PointType &gt; &amp;V0, const Eigen::MatrixBase&lt; PointType &gt; &amp;V1, const Eigen::MatrixBase&lt; PointType &gt; &amp;V2, Eigen::PlainObjectBase&lt; PointType &gt; &amp;closest_point, ScalarOf&lt; PointType &gt; &amp;lambda0, ScalarOf&lt; PointType &gt; &amp;lambda1, ScalarOf&lt; PointType &gt; &amp;lambda2) -&gt; ScalarOf&lt; PointType &gt;</td></tr>
<tr class="memdesc:aa226d603d77fc8036aaa59760a4067ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the point closest to a given point in a nd triangle.  <a href="namespacelagrange.html#aa226d603d77fc8036aaa59760a4067ff">More...</a><br /></td></tr>
<tr class="separator:aa226d603d77fc8036aaa59760a4067ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b00ad408ddd582aaa24613f799aa65"><td class="memTemplParams" colspan="2">template&lt;typename PointType &gt; </td></tr>
<tr class="memitem:a84b00ad408ddd582aaa24613f799aa65"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a84b00ad408ddd582aaa24613f799aa65">point_triangle_squared_distance</a> (const Eigen::MatrixBase&lt; PointType &gt; &amp;point, const Eigen::MatrixBase&lt; PointType &gt; &amp;V0, const Eigen::MatrixBase&lt; PointType &gt; &amp;V1, const Eigen::MatrixBase&lt; PointType &gt; &amp;V2) -&gt; ScalarOf&lt; PointType &gt;</td></tr>
<tr class="memdesc:a84b00ad408ddd582aaa24613f799aa65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the squared distance between a point and a nd triangle.  <a href="namespacelagrange.html#a84b00ad408ddd582aaa24613f799aa65">More...</a><br /></td></tr>
<tr class="separator:a84b00ad408ddd582aaa24613f799aa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158ad6f7a5217fcc67b5963f57d77ba9"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a158ad6f7a5217fcc67b5963f57d77ba9"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a158ad6f7a5217fcc67b5963f57d77ba9">quad_area_2d</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt; a, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt; b, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt; c, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt; d)</td></tr>
<tr class="memdesc:a158ad6f7a5217fcc67b5963f57d77ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute 2D quad signed area.  <a href="namespacelagrange.html#a158ad6f7a5217fcc67b5963f57d77ba9">More...</a><br /></td></tr>
<tr class="separator:a158ad6f7a5217fcc67b5963f57d77ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f789cf2a823e2d86eb5721012008de"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a44f789cf2a823e2d86eb5721012008de"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a44f789cf2a823e2d86eb5721012008de">quad_area_3d</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt; a, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt; b, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt; c, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt; d)</td></tr>
<tr class="memdesc:a44f789cf2a823e2d86eb5721012008de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute 3D quad area.  <a href="namespacelagrange.html#a44f789cf2a823e2d86eb5721012008de">More...</a><br /></td></tr>
<tr class="separator:a44f789cf2a823e2d86eb5721012008de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41568d17fc48cea4a31db0e40cd93cf8"><td class="memTemplParams" colspan="2">template&lt;typename Index &gt; </td></tr>
<tr class="memitem:ga41568d17fc48cea4a31db0e40cd93cf8"><td class="memTemplItemLeft" align="right" valign="top">internal::Range&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga41568d17fc48cea4a31db0e40cd93cf8">range</a> (Index end)</td></tr>
<tr class="memdesc:ga41568d17fc48cea4a31db0e40cd93cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable object representing the range [0, end).  <a href="group__group-utils-misc.html#ga41568d17fc48cea4a31db0e40cd93cf8">More...</a><br /></td></tr>
<tr class="separator:ga41568d17fc48cea4a31db0e40cd93cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ba35aa7abcc560046e54c7701a64283"><td class="memTemplParams" colspan="2">template&lt;typename Index &gt; </td></tr>
<tr class="memitem:ga2ba35aa7abcc560046e54c7701a64283"><td class="memTemplItemLeft" align="right" valign="top">internal::Range&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga2ba35aa7abcc560046e54c7701a64283">range</a> (Index begin, Index end)</td></tr>
<tr class="memdesc:ga2ba35aa7abcc560046e54c7701a64283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable object representing the range [begin, end).  <a href="group__group-utils-misc.html#ga2ba35aa7abcc560046e54c7701a64283">More...</a><br /></td></tr>
<tr class="separator:ga2ba35aa7abcc560046e54c7701a64283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0361fdaa740fe7284fe2b7b10072e955"><td class="memTemplParams" colspan="2">template&lt;typename Index &gt; </td></tr>
<tr class="memitem:ga0361fdaa740fe7284fe2b7b10072e955"><td class="memTemplItemLeft" align="right" valign="top">internal::SparseRange&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga0361fdaa740fe7284fe2b7b10072e955">range_sparse</a> (Index max, const std::vector&lt; Index &gt; &amp;active)</td></tr>
<tr class="memdesc:ga0361fdaa740fe7284fe2b7b10072e955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable object representing a subset of the range [0, max).  <a href="group__group-utils-misc.html#ga0361fdaa740fe7284fe2b7b10072e955">More...</a><br /></td></tr>
<tr class="separator:ga0361fdaa740fe7284fe2b7b10072e955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc5798c28b15e46d20d0234b72c4ef63"><td class="memTemplParams" colspan="2">template&lt;typename TargetType , typename SourceType &gt; </td></tr>
<tr class="memitem:gafc5798c28b15e46d20d0234b72c4ef63"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#gafc5798c28b15e46d20d0234b72c4ef63">safe_cast</a> (SourceType value) -&gt; std::enable_if_t&lt;!std::is_same&lt; SourceType, TargetType &gt;::value, TargetType &gt;</td></tr>
<tr class="memdesc:gafc5798c28b15e46d20d0234b72c4ef63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform safe cast from <code>SourceType</code> to <code>TargetType</code>, where "safe" means:  <a href="group__group-utils-misc.html#gafc5798c28b15e46d20d0234b72c4ef63">More...</a><br /></td></tr>
<tr class="separator:gafc5798c28b15e46d20d0234b72c4ef63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54c86a2c4172b91a725779d97cfad3a6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga54c86a2c4172b91a725779d97cfad3a6"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga54c86a2c4172b91a725779d97cfad3a6">safe_cast</a> (T value)</td></tr>
<tr class="memdesc:ga54c86a2c4172b91a725779d97cfad3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe cast specialization for TargetType == SourceType.  <a href="group__group-utils-misc.html#ga54c86a2c4172b91a725779d97cfad3a6">More...</a><br /></td></tr>
<tr class="separator:ga54c86a2c4172b91a725779d97cfad3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d32f8f700ebb2954e902b13944cb67b"><td class="memTemplParams" colspan="2">template&lt;typename TargetType &gt; </td></tr>
<tr class="memitem:ga5d32f8f700ebb2954e902b13944cb67b"><td class="memTemplItemLeft" align="right" valign="top">constexpr TargetType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga5d32f8f700ebb2954e902b13944cb67b">safe_cast</a> (bool value)</td></tr>
<tr class="memdesc:ga5d32f8f700ebb2954e902b13944cb67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe cast specialization for bool.  <a href="group__group-utils-misc.html#ga5d32f8f700ebb2954e902b13944cb67b">More...</a><br /></td></tr>
<tr class="separator:ga5d32f8f700ebb2954e902b13944cb67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99785544251e0424c9d08a688fe70838"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga99785544251e0424c9d08a688fe70838"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga99785544251e0424c9d08a688fe70838">safe_cast_enum</a> (const U u)</td></tr>
<tr class="memdesc:ga99785544251e0424c9d08a688fe70838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casting an enum to scalar and vice versa.  <a href="group__group-utils-misc.html#ga99785544251e0424c9d08a688fe70838">More...</a><br /></td></tr>
<tr class="separator:ga99785544251e0424c9d08a688fe70838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga473b5d2b31badd808124196a21ce0b45"><td class="memTemplParams" colspan="2">template&lt;typename Callback &gt; </td></tr>
<tr class="memitem:ga473b5d2b31badd808124196a21ce0b45"><td class="memTemplItemLeft" align="right" valign="top">sg_detail::scope_guard&lt; Callback &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga473b5d2b31badd808124196a21ce0b45">make_scope_guard</a> (Callback &amp;&amp;callback) noexcept(std::is_nothrow_constructible&lt; Callback, Callback &amp;&amp; &gt;::value)</td></tr>
<tr class="memdesc:ga473b5d2b31badd808124196a21ce0b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a scope guard around a callable object.  <a href="group__group-utils-misc.html#ga473b5d2b31badd808124196a21ce0b45">More...</a><br /></td></tr>
<tr class="separator:ga473b5d2b31badd808124196a21ce0b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29789b742f13c0dd6059b641aa7b29ab"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Y &gt; </td></tr>
<tr class="memitem:ga29789b742f13c0dd6059b641aa7b29ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_shared_span.html">SharedSpan</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga29789b742f13c0dd6059b641aa7b29ab">make_shared_span</a> (const std::shared_ptr&lt; Y &gt; &amp;r, T *element_ptr, size_t size)</td></tr>
<tr class="memdesc:ga29789b742f13c0dd6059b641aa7b29ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Created a <a class="el" href="classlagrange_1_1_shared_span.html" title="Shared span with ownership tracking.">SharedSpan</a> object around an internal buffer of a parent object.  <a href="group__group-utils-misc.html#ga29789b742f13c0dd6059b641aa7b29ab">More...</a><br /></td></tr>
<tr class="separator:ga29789b742f13c0dd6059b641aa7b29ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4289f211753d4bf02e37c2d3c55512"><td class="memTemplParams" colspan="2"><a id="afd4289f211753d4bf02e37c2d3c55512" name="afd4289f211753d4bf02e37c2d3c55512"></a>
template&lt;typename Scalar , size_t N, typename Derived &gt; </td></tr>
<tr class="memitem:afd4289f211753d4bf02e37c2d3c55512"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vector_to_eigen</b> (const std::vector&lt; std::array&lt; Scalar, N &gt; &gt; &amp;from, Eigen::PlainObjectBase&lt; Derived &gt; &amp;to)</td></tr>
<tr class="separator:afd4289f211753d4bf02e37c2d3c55512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e21f611b26b89868e0097e505554402"><td class="memTemplParams" colspan="2"><a id="a7e21f611b26b89868e0097e505554402" name="a7e21f611b26b89868e0097e505554402"></a>
template&lt;typename Scalar , typename Derived &gt; </td></tr>
<tr class="memitem:a7e21f611b26b89868e0097e505554402"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vector_to_eigen</b> (const std::vector&lt; std::pair&lt; Scalar, Scalar &gt; &gt; &amp;from, Eigen::PlainObjectBase&lt; Derived &gt; &amp;to)</td></tr>
<tr class="separator:a7e21f611b26b89868e0097e505554402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e6480b823ce11359d35f8f649ba6e5"><td class="memTemplParams" colspan="2"><a id="a32e6480b823ce11359d35f8f649ba6e5" name="a32e6480b823ce11359d35f8f649ba6e5"></a>
template&lt;typename Scalar , int N, typename Derived &gt; </td></tr>
<tr class="memitem:a32e6480b823ce11359d35f8f649ba6e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vector_to_eigen</b> (const std::vector&lt; Eigen::Matrix&lt; Scalar, N, 1 &gt; &gt; &amp;from, Eigen::PlainObjectBase&lt; Derived &gt; &amp;to)</td></tr>
<tr class="separator:a32e6480b823ce11359d35f8f649ba6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4185743b7015cd5efeab9f6d429c7c"><td class="memTemplParams" colspan="2"><a id="a1e4185743b7015cd5efeab9f6d429c7c" name="a1e4185743b7015cd5efeab9f6d429c7c"></a>
template&lt;typename Scalar , int N, typename Derived &gt; </td></tr>
<tr class="memitem:a1e4185743b7015cd5efeab9f6d429c7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vector_to_eigen</b> (const std::vector&lt; Eigen::Matrix&lt; Scalar, 1, N &gt; &gt; &amp;from, Eigen::PlainObjectBase&lt; Derived &gt; &amp;to)</td></tr>
<tr class="separator:a1e4185743b7015cd5efeab9f6d429c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271f025f380dd325fd2d3b39938b2494"><td class="memTemplParams" colspan="2"><a id="a271f025f380dd325fd2d3b39938b2494" name="a271f025f380dd325fd2d3b39938b2494"></a>
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a271f025f380dd325fd2d3b39938b2494"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vector_to_eigen</b> (const std::vector&lt; Scalar &gt; &amp;from, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;to)</td></tr>
<tr class="separator:a271f025f380dd325fd2d3b39938b2494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93775dd54d1ca00c7cfd6eb0e2f026e1"><td class="memTemplParams" colspan="2"><a id="a93775dd54d1ca00c7cfd6eb0e2f026e1" name="a93775dd54d1ca00c7cfd6eb0e2f026e1"></a>
template&lt;typename Scalar , typename Derived &gt; </td></tr>
<tr class="memitem:a93775dd54d1ca00c7cfd6eb0e2f026e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>flat_vector_to_eigen</b> (const std::vector&lt; Scalar &gt; &amp;from, Eigen::PlainObjectBase&lt; Derived &gt; &amp;to, size_t rows, size_t cols, int row_major_flag=Eigen::RowMajor)</td></tr>
<tr class="separator:a93775dd54d1ca00c7cfd6eb0e2f026e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87b066ea88ff77179038840ae1bb0ce"><td class="memTemplParams" colspan="2"><a id="ac87b066ea88ff77179038840ae1bb0ce" name="ac87b066ea88ff77179038840ae1bb0ce"></a>
template&lt;typename Derived , typename Scalar , size_t N&gt; </td></tr>
<tr class="memitem:ac87b066ea88ff77179038840ae1bb0ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eigen_to_vector</b> (const Eigen::MatrixBase&lt; Derived &gt; &amp;from, std::vector&lt; std::array&lt; Scalar, N &gt; &gt; &amp;to)</td></tr>
<tr class="separator:ac87b066ea88ff77179038840ae1bb0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc73dfd58b71e98f4c07d216fea7a1dc"><td class="memTemplParams" colspan="2"><a id="adc73dfd58b71e98f4c07d216fea7a1dc" name="adc73dfd58b71e98f4c07d216fea7a1dc"></a>
template&lt;typename Derived , typename Scalar &gt; </td></tr>
<tr class="memitem:adc73dfd58b71e98f4c07d216fea7a1dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eigen_to_vector</b> (const Eigen::MatrixBase&lt; Derived &gt; &amp;from, std::vector&lt; std::pair&lt; Scalar, Scalar &gt; &gt; &amp;to)</td></tr>
<tr class="separator:adc73dfd58b71e98f4c07d216fea7a1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae507fa7ddcefa3ebd984728963adb14d"><td class="memTemplParams" colspan="2"><a id="ae507fa7ddcefa3ebd984728963adb14d" name="ae507fa7ddcefa3ebd984728963adb14d"></a>
template&lt;typename Derived , typename Scalar &gt; </td></tr>
<tr class="memitem:ae507fa7ddcefa3ebd984728963adb14d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eigen_to_flat_vector</b> (const Eigen::MatrixBase&lt; Derived &gt; &amp;from, std::vector&lt; Scalar &gt; &amp;to, int row_major_flag=Eigen::RowMajor)</td></tr>
<tr class="separator:ae507fa7ddcefa3ebd984728963adb14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2f13bef4d8b9c7c6b2dc61b87d95bd4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#gad2f13bef4d8b9c7c6b2dc61b87d95bd4">string_split</a> (const std::string &amp;str, char delimiter)</td></tr>
<tr class="memdesc:gad2f13bef4d8b9c7c6b2dc61b87d95bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a std::string using a prescribed delimiter.  <a href="group__group-utils-misc.html#gad2f13bef4d8b9c7c6b2dc61b87d95bd4">More...</a><br /></td></tr>
<tr class="separator:gad2f13bef4d8b9c7c6b2dc61b87d95bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebb929afb5049cc3aaaabd296f556ac3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#gaebb929afb5049cc3aaaabd296f556ac3">starts_with</a> (std::string_view str, std::string_view prefix)</td></tr>
<tr class="memdesc:gaebb929afb5049cc3aaaabd296f556ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the string begins with the given prefix.  <a href="group__group-utils-misc.html#gaebb929afb5049cc3aaaabd296f556ac3">More...</a><br /></td></tr>
<tr class="separator:gaebb929afb5049cc3aaaabd296f556ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eef11056e4525af0cd41aeb98869cbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga8eef11056e4525af0cd41aeb98869cbb">ends_with</a> (std::string_view str, std::string_view suffix)</td></tr>
<tr class="memdesc:ga8eef11056e4525af0cd41aeb98869cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the string ends with the given suffix.  <a href="group__group-utils-misc.html#ga8eef11056e4525af0cd41aeb98869cbb">More...</a><br /></td></tr>
<tr class="separator:ga8eef11056e4525af0cd41aeb98869cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40b443ced6fb40c747991e41e12494f4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga40b443ced6fb40c747991e41e12494f4">to_lower</a> (std::string str)</td></tr>
<tr class="memdesc:ga40b443ced6fb40c747991e41e12494f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to lowercase.  <a href="group__group-utils-misc.html#ga40b443ced6fb40c747991e41e12494f4">More...</a><br /></td></tr>
<tr class="separator:ga40b443ced6fb40c747991e41e12494f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81d5673419396307677f905d5f4033ce"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga81d5673419396307677f905d5f4033ce">to_upper</a> (std::string str)</td></tr>
<tr class="memdesc:ga81d5673419396307677f905d5f4033ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to uppercase.  <a href="group__group-utils-misc.html#ga81d5673419396307677f905d5f4033ce">More...</a><br /></td></tr>
<tr class="separator:ga81d5673419396307677f905d5f4033ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45e3802af95f6c48e3f3173abe05e488"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga45e3802af95f6c48e3f3173abe05e488"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#ga45e3802af95f6c48e3f3173abe05e488">string_format</a> (fmt::format_string&lt; Args... &gt; format, <a class="el" href="struct_args.html">Args</a> &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga45e3802af95f6c48e3f3173abe05e488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format args according to the format string fmt, and return the result as a string.  <a href="group__group-utils-misc.html#ga45e3802af95f6c48e3f3173abe05e488">More...</a><br /></td></tr>
<tr class="separator:ga45e3802af95f6c48e3f3173abe05e488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24baf1975a97dedc1fe0cd5bd115e663"><td class="memItemLeft" align="right" valign="top"><a id="a24baf1975a97dedc1fe0cd5bd115e663" name="a24baf1975a97dedc1fe0cd5bd115e663"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_timestamp</b> (timestamp_type *t)</td></tr>
<tr class="separator:a24baf1975a97dedc1fe0cd5bd115e663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376d62c72f7326b9c70f3d4e46183671"><td class="memItemLeft" align="right" valign="top"><a id="a376d62c72f7326b9c70f3d4e46183671" name="a376d62c72f7326b9c70f3d4e46183671"></a>
timestamp_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_timestamp</b> ()</td></tr>
<tr class="separator:a376d62c72f7326b9c70f3d4e46183671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40639edff40df795d3230122ac7e046d"><td class="memItemLeft" align="right" valign="top"><a id="a40639edff40df795d3230122ac7e046d" name="a40639edff40df795d3230122ac7e046d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>timestamp_diff_in_seconds</b> (timestamp_type start, timestamp_type end)</td></tr>
<tr class="separator:a40639edff40df795d3230122ac7e046d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98fe69141d600e2405aae527b4f4d6c"><td class="memItemLeft" align="right" valign="top"><a id="ab98fe69141d600e2405aae527b4f4d6c" name="ab98fe69141d600e2405aae527b4f4d6c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>timestamp_diff_in_seconds</b> (timestamp_type start)</td></tr>
<tr class="separator:ab98fe69141d600e2405aae527b4f4d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b4dc54ffcfd57bf369e3044f567467"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ad6b4dc54ffcfd57bf369e3044f567467"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ad6b4dc54ffcfd57bf369e3044f567467">triangle_area_3d</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt; a, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt; b, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt; c)</td></tr>
<tr class="memdesc:ad6b4dc54ffcfd57bf369e3044f567467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute 3D triangle area.  <a href="namespacelagrange.html#ad6b4dc54ffcfd57bf369e3044f567467">More...</a><br /></td></tr>
<tr class="separator:ad6b4dc54ffcfd57bf369e3044f567467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49eca467681fb7600745af55571bd0f3"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a49eca467681fb7600745af55571bd0f3"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a49eca467681fb7600745af55571bd0f3">triangle_area_2d</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt; a, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt; b, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt; c)</td></tr>
<tr class="memdesc:a49eca467681fb7600745af55571bd0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute 2D triangle signed area.  <a href="namespacelagrange.html#a49eca467681fb7600745af55571bd0f3">More...</a><br /></td></tr>
<tr class="separator:a49eca467681fb7600745af55571bd0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6eab98907ea478e363a44023b4dd1a"><td class="memItemLeft" align="right" valign="top">enum lagrange::Orientation short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#aba6eab98907ea478e363a44023b4dd1a">triangle_orientation</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt; a, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt; b, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt; c)</td></tr>
<tr class="memdesc:aba6eab98907ea478e363a44023b4dd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute orientation of a 2D triangle.  <a href="namespacelagrange.html#aba6eab98907ea478e363a44023b4dd1a">More...</a><br /></td></tr>
<tr class="separator:aba6eab98907ea478e363a44023b4dd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63029c7c83fee8c6f3bf5de81e4353c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__group-surfacemesh-utils.html#gadab1480827f4522cbf1f9e1d4c28db91">DistortionMetric</a> metric, typename Scalar &gt; </td></tr>
<tr class="memitem:ab63029c7c83fee8c6f3bf5de81e4353c"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#ab63029c7c83fee8c6f3bf5de81e4353c">triangle_uv_distortion</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt; V0, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt; V1, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt; V2, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt; v0, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt; v1, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt; v2)</td></tr>
<tr class="memdesc:ab63029c7c83fee8c6f3bf5de81e4353c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute uv distortion of a single triangle.  <a href="namespacelagrange.html#ab63029c7c83fee8c6f3bf5de81e4353c">More...</a><br /></td></tr>
<tr class="separator:ab63029c7c83fee8c6f3bf5de81e4353c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8536342d5f43c6fd93cf888e97aa7873"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a8536342d5f43c6fd93cf888e97aa7873"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a8536342d5f43c6fd93cf888e97aa7873">triangle_uv_distortion</a> (<a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt; V0, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt; V1, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt; V2, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt; v0, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt; v1, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt; v2, <a class="el" href="group__group-surfacemesh-utils.html#gadab1480827f4522cbf1f9e1d4c28db91">DistortionMetric</a> metric)</td></tr>
<tr class="memdesc:a8536342d5f43c6fd93cf888e97aa7873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute uv distortion of a single triangle.  <a href="namespacelagrange.html#a8536342d5f43c6fd93cf888e97aa7873">More...</a><br /></td></tr>
<tr class="separator:a8536342d5f43c6fd93cf888e97aa7873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bae2866359c59894de874831cfcefbf"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a4bae2866359c59894de874831cfcefbf"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a4bae2866359c59894de874831cfcefbf">to_degrees</a> (Scalar rad=1)</td></tr>
<tr class="memdesc:a4bae2866359c59894de874831cfcefbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert radians to degrees.  <a href="namespacelagrange.html#a4bae2866359c59894de874831cfcefbf">More...</a><br /></td></tr>
<tr class="separator:a4bae2866359c59894de874831cfcefbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e117a8f5727d6603ce84044f11c1624"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a1e117a8f5727d6603ce84044f11c1624"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a1e117a8f5727d6603ce84044f11c1624">to_radians</a> (Scalar deg=1)</td></tr>
<tr class="memdesc:a1e117a8f5727d6603ce84044f11c1624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert degrees to radians.  <a href="namespacelagrange.html#a1e117a8f5727d6603ce84044f11c1624">More...</a><br /></td></tr>
<tr class="separator:a1e117a8f5727d6603ce84044f11c1624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6379785ff623923a5a20a5bf935d5e70"><td class="memTemplParams" colspan="2"><a id="a6379785ff623923a5a20a5bf935d5e70" name="a6379785ff623923a5a20a5bf935d5e70"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6379785ff623923a5a20a5bf935d5e70"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sign</b> (T val)</td></tr>
<tr class="memdesc:a6379785ff623923a5a20a5bf935d5e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sign of the value Returns either -1, 0, or 1. <br /></td></tr>
<tr class="separator:a6379785ff623923a5a20a5bf935d5e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3da204f09c1661c538eaa8eb680b1a7"><td class="memTemplParams" colspan="2"><a id="aa3da204f09c1661c538eaa8eb680b1a7" name="aa3da204f09c1661c538eaa8eb680b1a7"></a>
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aa3da204f09c1661c538eaa8eb680b1a7"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gaussian</b> (Scalar x, Scalar sigma, Scalar center=0)</td></tr>
<tr class="memdesc:aa3da204f09c1661c538eaa8eb680b1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple evaluation of Gaussian function. <br /></td></tr>
<tr class="separator:aa3da204f09c1661c538eaa8eb680b1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb6c32297561f1bd7fa1a6fdc4396a9c"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:gaeb6c32297561f1bd7fa1a6fdc4396a9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1value__ptr.html">value_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-utils-misc.html#gaeb6c32297561f1bd7fa1a6fdc4396a9c">make_value_ptr</a> (<a class="el" href="struct_args.html">Args</a> &amp;&amp;... args)</td></tr>
<tr class="memdesc:gaeb6c32297561f1bd7fa1a6fdc4396a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a <a class="el" href="classlagrange_1_1value__ptr.html" title="Smart pointer with value semantics.">value_ptr</a> for a given type.  <a href="group__group-utils-misc.html#gaeb6c32297561f1bd7fa1a6fdc4396a9c">More...</a><br /></td></tr>
<tr class="separator:gaeb6c32297561f1bd7fa1a6fdc4396a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad759b003a1c91b6070358d952f22874"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gaad759b003a1c91b6070358d952f22874"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr-utils.html#gaad759b003a1c91b6070358d952f22874">weld_indexed_attribute</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> attr_id)</td></tr>
<tr class="memdesc:gaad759b003a1c91b6070358d952f22874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weld an indexed attribute by combining all corners around a vertex with the same attribute value.  <a href="group__group-surfacemesh-attr-utils.html#gaad759b003a1c91b6070358d952f22874">More...</a><br /></td></tr>
<tr class="separator:gaad759b003a1c91b6070358d952f22874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4639d28876aa6acd034f6abc47f626"><td class="memTemplParams" colspan="2"><a id="a5a4639d28876aa6acd034f6abc47f626" name="a5a4639d28876aa6acd034f6abc47f626"></a>
template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a5a4639d28876aa6acd034f6abc47f626"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_vertex_based_components</b> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id)</td></tr>
<tr class="separator:a5a4639d28876aa6acd034f6abc47f626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78069956ecc144b426fc2313dbca11c4"><td class="memTemplParams" colspan="2"><a id="a78069956ecc144b426fc2313dbca11c4" name="a78069956ecc144b426fc2313dbca11c4"></a>
template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a78069956ecc144b426fc2313dbca11c4"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_edge_based_components</b> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id)</td></tr>
<tr class="separator:a78069956ecc144b426fc2313dbca11c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32edc074e3e366c1748b3a27ea86caed"><td class="memItemLeft" align="right" valign="top"><a id="a32edc074e3e366c1748b3a27ea86caed" name="a32edc074e3e366c1748b3a27ea86caed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>exactinit</b> ()</td></tr>
<tr class="separator:a32edc074e3e366c1748b3a27ea86caed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633699e93adf7aeb678afa1f7b52cfca"><td class="memItemLeft" align="right" valign="top"><a id="a633699e93adf7aeb678afa1f7b52cfca" name="a633699e93adf7aeb678afa1f7b52cfca"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>orient2d</b> (const double *pa, const double *pb, const double *pc)</td></tr>
<tr class="separator:a633699e93adf7aeb678afa1f7b52cfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f1dfa7b25071a43c79b61a395bc33c"><td class="memItemLeft" align="right" valign="top"><a id="a39f1dfa7b25071a43c79b61a395bc33c" name="a39f1dfa7b25071a43c79b61a395bc33c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>orient3d</b> (const double *pa, const double *pb, const double *pc, const double *pd)</td></tr>
<tr class="separator:a39f1dfa7b25071a43c79b61a395bc33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e80c1453f31da3814a9e4ab0797f35"><td class="memItemLeft" align="right" valign="top"><a id="a53e80c1453f31da3814a9e4ab0797f35" name="a53e80c1453f31da3814a9e4ab0797f35"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>incircle</b> (const double *pa, const double *pb, const double *pc, const double *pd)</td></tr>
<tr class="separator:a53e80c1453f31da3814a9e4ab0797f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8bed876cba2a60bd590bc1dedf0fcd"><td class="memItemLeft" align="right" valign="top"><a id="a2a8bed876cba2a60bd590bc1dedf0fcd" name="a2a8bed876cba2a60bd590bc1dedf0fcd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>insphere</b> (const double *pa, const double *pb, const double *pc, const double *pd, const double *pe)</td></tr>
<tr class="separator:a2a8bed876cba2a60bd590bc1dedf0fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77489867dd5a42647265c6f7ef4f129"><td class="memItemLeft" align="right" valign="top"><a id="ad77489867dd5a42647265c6f7ef4f129" name="ad77489867dd5a42647265c6f7ef4f129"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>grow_expansion</b> (int elen, REAL *e, REAL b, REAL *h)</td></tr>
<tr class="separator:ad77489867dd5a42647265c6f7ef4f129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8fca6854d6a2ed3249fcd24b47a1a9"><td class="memItemLeft" align="right" valign="top"><a id="a2e8fca6854d6a2ed3249fcd24b47a1a9" name="a2e8fca6854d6a2ed3249fcd24b47a1a9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>grow_expansion_zeroelim</b> (int elen, REAL *e, REAL b, REAL *h)</td></tr>
<tr class="separator:a2e8fca6854d6a2ed3249fcd24b47a1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205c9564b62316ed9249e2d3651505c5"><td class="memItemLeft" align="right" valign="top"><a id="a205c9564b62316ed9249e2d3651505c5" name="a205c9564b62316ed9249e2d3651505c5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>expansion_sum</b> (int elen, REAL *e, int flen, REAL *f, REAL *h)</td></tr>
<tr class="separator:a205c9564b62316ed9249e2d3651505c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38daa3df2459b9b2bab42702a87883e"><td class="memItemLeft" align="right" valign="top"><a id="ac38daa3df2459b9b2bab42702a87883e" name="ac38daa3df2459b9b2bab42702a87883e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>expansion_sum_zeroelim1</b> (int elen, REAL *e, int flen, REAL *f, REAL *h)</td></tr>
<tr class="separator:ac38daa3df2459b9b2bab42702a87883e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51616333dc680aa848d522b1ba44862"><td class="memItemLeft" align="right" valign="top"><a id="ab51616333dc680aa848d522b1ba44862" name="ab51616333dc680aa848d522b1ba44862"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>expansion_sum_zeroelim2</b> (int elen, REAL *e, int flen, REAL *f, REAL *h)</td></tr>
<tr class="separator:ab51616333dc680aa848d522b1ba44862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0eab651328372abd17e2f1f8c01dff8"><td class="memItemLeft" align="right" valign="top"><a id="ab0eab651328372abd17e2f1f8c01dff8" name="ab0eab651328372abd17e2f1f8c01dff8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fast_expansion_sum</b> (int elen, REAL *e, int flen, REAL *f, REAL *h)</td></tr>
<tr class="separator:ab0eab651328372abd17e2f1f8c01dff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37646a7e0014e10c612e946bc95aeeea"><td class="memItemLeft" align="right" valign="top"><a id="a37646a7e0014e10c612e946bc95aeeea" name="a37646a7e0014e10c612e946bc95aeeea"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fast_expansion_sum_zeroelim</b> (int elen, REAL *e, int flen, REAL *f, REAL *h)</td></tr>
<tr class="separator:a37646a7e0014e10c612e946bc95aeeea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0c13a3de573bce6190d5db3138be98"><td class="memItemLeft" align="right" valign="top"><a id="a6e0c13a3de573bce6190d5db3138be98" name="a6e0c13a3de573bce6190d5db3138be98"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>linear_expansion_sum</b> (int elen, REAL *e, int flen, REAL *f, REAL *h)</td></tr>
<tr class="separator:a6e0c13a3de573bce6190d5db3138be98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa54a82f07d2f72d3807b9a78aa2da8b"><td class="memItemLeft" align="right" valign="top"><a id="afa54a82f07d2f72d3807b9a78aa2da8b" name="afa54a82f07d2f72d3807b9a78aa2da8b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>linear_expansion_sum_zeroelim</b> (int elen, REAL *e, int flen, REAL *f, REAL *h)</td></tr>
<tr class="separator:afa54a82f07d2f72d3807b9a78aa2da8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5873b19d855d3ace3c375c0b89933acb"><td class="memItemLeft" align="right" valign="top"><a id="a5873b19d855d3ace3c375c0b89933acb" name="a5873b19d855d3ace3c375c0b89933acb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>scale_expansion</b> (int elen, REAL *e, REAL b, REAL *h)</td></tr>
<tr class="separator:a5873b19d855d3ace3c375c0b89933acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcdaa8948d9a2937154d9d67f67da8d"><td class="memItemLeft" align="right" valign="top"><a id="abdcdaa8948d9a2937154d9d67f67da8d" name="abdcdaa8948d9a2937154d9d67f67da8d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>scale_expansion_zeroelim</b> (int elen, REAL *e, REAL b, REAL *h)</td></tr>
<tr class="separator:abdcdaa8948d9a2937154d9d67f67da8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e05cf94eeeea515483f825d7a3b7dd6"><td class="memItemLeft" align="right" valign="top"><a id="a0e05cf94eeeea515483f825d7a3b7dd6" name="a0e05cf94eeeea515483f825d7a3b7dd6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>compress</b> (int elen, REAL *e, REAL *h)</td></tr>
<tr class="separator:a0e05cf94eeeea515483f825d7a3b7dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3487d9f90ea72da543d5d38b3dab1fbc"><td class="memItemLeft" align="right" valign="top"><a id="a3487d9f90ea72da543d5d38b3dab1fbc" name="a3487d9f90ea72da543d5d38b3dab1fbc"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>estimate</b> (int elen, REAL *e)</td></tr>
<tr class="separator:a3487d9f90ea72da543d5d38b3dab1fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de6f7de113918ac01301cb7d3e14786"><td class="memItemLeft" align="right" valign="top"><a id="a4de6f7de113918ac01301cb7d3e14786" name="a4de6f7de113918ac01301cb7d3e14786"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient2dfast</b> (REAL *pa, REAL *pb, REAL *pc)</td></tr>
<tr class="separator:a4de6f7de113918ac01301cb7d3e14786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e440a5722811168c73e48978b84f93"><td class="memItemLeft" align="right" valign="top"><a id="ab0e440a5722811168c73e48978b84f93" name="ab0e440a5722811168c73e48978b84f93"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient2dexact</b> (REAL *pa, REAL *pb, REAL *pc)</td></tr>
<tr class="separator:ab0e440a5722811168c73e48978b84f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8669878673de09a9a154846be57f19f5"><td class="memItemLeft" align="right" valign="top"><a id="a8669878673de09a9a154846be57f19f5" name="a8669878673de09a9a154846be57f19f5"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient2dslow</b> (REAL *pa, REAL *pb, REAL *pc)</td></tr>
<tr class="separator:a8669878673de09a9a154846be57f19f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98596b32fd1caf2b23c65bd243bf8dd1"><td class="memItemLeft" align="right" valign="top"><a id="a98596b32fd1caf2b23c65bd243bf8dd1" name="a98596b32fd1caf2b23c65bd243bf8dd1"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient2dadapt</b> (const REAL *pa, const REAL *pb, const REAL *pc, REAL detsum)</td></tr>
<tr class="separator:a98596b32fd1caf2b23c65bd243bf8dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c9489af9abe034e0fae3d135cce9eb"><td class="memItemLeft" align="right" valign="top"><a id="a21c9489af9abe034e0fae3d135cce9eb" name="a21c9489af9abe034e0fae3d135cce9eb"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient2d</b> (const REAL *pa, const REAL *pb, const REAL *pc)</td></tr>
<tr class="separator:a21c9489af9abe034e0fae3d135cce9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae109597f942156531a1ecda4f969eee0"><td class="memItemLeft" align="right" valign="top"><a id="ae109597f942156531a1ecda4f969eee0" name="ae109597f942156531a1ecda4f969eee0"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient3dfast</b> (REAL *pa, REAL *pb, REAL *pc, REAL *pd)</td></tr>
<tr class="separator:ae109597f942156531a1ecda4f969eee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfff1cef21b648cd6d91b475e56b025d"><td class="memItemLeft" align="right" valign="top"><a id="acfff1cef21b648cd6d91b475e56b025d" name="acfff1cef21b648cd6d91b475e56b025d"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient3dexact</b> (REAL *pa, REAL *pb, REAL *pc, REAL *pd)</td></tr>
<tr class="separator:acfff1cef21b648cd6d91b475e56b025d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1934247c9105903d0c78aed2ddd9bad4"><td class="memItemLeft" align="right" valign="top"><a id="a1934247c9105903d0c78aed2ddd9bad4" name="a1934247c9105903d0c78aed2ddd9bad4"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient3dslow</b> (REAL *pa, REAL *pb, REAL *pc, REAL *pd)</td></tr>
<tr class="separator:a1934247c9105903d0c78aed2ddd9bad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44430e0f71de8d6d1ea4c52f173d0ca4"><td class="memItemLeft" align="right" valign="top"><a id="a44430e0f71de8d6d1ea4c52f173d0ca4" name="a44430e0f71de8d6d1ea4c52f173d0ca4"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient3dadapt</b> (const REAL *pa, const REAL *pb, const REAL *pc, const REAL *pd, REAL permanent)</td></tr>
<tr class="separator:a44430e0f71de8d6d1ea4c52f173d0ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6eb31d36e3b5da6421f59a5955dd67"><td class="memItemLeft" align="right" valign="top"><a id="a4a6eb31d36e3b5da6421f59a5955dd67" name="a4a6eb31d36e3b5da6421f59a5955dd67"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>orient3d</b> (const REAL *pa, const REAL *pb, const REAL *pc, const REAL *pd)</td></tr>
<tr class="separator:a4a6eb31d36e3b5da6421f59a5955dd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa358dce9bc5bbf293a1be51525c96d"><td class="memItemLeft" align="right" valign="top"><a id="aeaa358dce9bc5bbf293a1be51525c96d" name="aeaa358dce9bc5bbf293a1be51525c96d"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>incirclefast</b> (REAL *pa, REAL *pb, REAL *pc, REAL *pd)</td></tr>
<tr class="separator:aeaa358dce9bc5bbf293a1be51525c96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705a8050600c953887fd80345a1ac5de"><td class="memItemLeft" align="right" valign="top"><a id="a705a8050600c953887fd80345a1ac5de" name="a705a8050600c953887fd80345a1ac5de"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>incircleexact</b> (REAL *pa, REAL *pb, REAL *pc, REAL *pd)</td></tr>
<tr class="separator:a705a8050600c953887fd80345a1ac5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9a93684c5ea8169252aa43ffb59e6c"><td class="memItemLeft" align="right" valign="top"><a id="a5b9a93684c5ea8169252aa43ffb59e6c" name="a5b9a93684c5ea8169252aa43ffb59e6c"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>incircleslow</b> (REAL *pa, REAL *pb, REAL *pc, REAL *pd)</td></tr>
<tr class="separator:a5b9a93684c5ea8169252aa43ffb59e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332bcbf3be22a2d0338cf9b454b5b5cc"><td class="memItemLeft" align="right" valign="top"><a id="a332bcbf3be22a2d0338cf9b454b5b5cc" name="a332bcbf3be22a2d0338cf9b454b5b5cc"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>incircleadapt</b> (const REAL *pa, const REAL *pb, const REAL *pc, const REAL *pd, REAL permanent)</td></tr>
<tr class="separator:a332bcbf3be22a2d0338cf9b454b5b5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc16adfeb6d48f4bd0ec9449d1172a9"><td class="memItemLeft" align="right" valign="top"><a id="a7cc16adfeb6d48f4bd0ec9449d1172a9" name="a7cc16adfeb6d48f4bd0ec9449d1172a9"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>incircle</b> (const REAL *pa, const REAL *pb, const REAL *pc, const REAL *pd)</td></tr>
<tr class="separator:a7cc16adfeb6d48f4bd0ec9449d1172a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7537ecb7c72fae4f1b6db1468a5880f1"><td class="memItemLeft" align="right" valign="top"><a id="a7537ecb7c72fae4f1b6db1468a5880f1" name="a7537ecb7c72fae4f1b6db1468a5880f1"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>inspherefast</b> (REAL *pa, REAL *pb, REAL *pc, REAL *pd, REAL *pe)</td></tr>
<tr class="separator:a7537ecb7c72fae4f1b6db1468a5880f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6eb5ac1cde6468e1f454d21dc64ae7"><td class="memItemLeft" align="right" valign="top"><a id="aac6eb5ac1cde6468e1f454d21dc64ae7" name="aac6eb5ac1cde6468e1f454d21dc64ae7"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>insphereexact</b> (const REAL *pa, const REAL *pb, const REAL *pc, const REAL *pd, const REAL *pe)</td></tr>
<tr class="separator:aac6eb5ac1cde6468e1f454d21dc64ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e92ae77aba844dc30a687db61f532a"><td class="memItemLeft" align="right" valign="top"><a id="a31e92ae77aba844dc30a687db61f532a" name="a31e92ae77aba844dc30a687db61f532a"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>insphereslow</b> (REAL *pa, REAL *pb, REAL *pc, REAL *pd, REAL *pe)</td></tr>
<tr class="separator:a31e92ae77aba844dc30a687db61f532a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0061ee1271975940ac16d6e7cad7100"><td class="memItemLeft" align="right" valign="top"><a id="ae0061ee1271975940ac16d6e7cad7100" name="ae0061ee1271975940ac16d6e7cad7100"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>insphereadapt</b> (const REAL *pa, const REAL *pb, const REAL *pc, const REAL *pd, const REAL *pe, REAL permanent)</td></tr>
<tr class="separator:ae0061ee1271975940ac16d6e7cad7100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0970b35d7363dfcbb19c763718c1355c"><td class="memItemLeft" align="right" valign="top"><a id="a0970b35d7363dfcbb19c763718c1355c" name="a0970b35d7363dfcbb19c763718c1355c"></a>
REAL&#160;</td><td class="memItemRight" valign="bottom"><b>insphere</b> (const REAL *pa, const REAL *pb, const REAL *pc, const REAL *pd, const REAL *pe)</td></tr>
<tr class="separator:a0970b35d7363dfcbb19c763718c1355c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affac1ab4e519692a2e1cd091f8acfbb4"><td class="memTemplParams" colspan="2"><a id="affac1ab4e519692a2e1cd091f8acfbb4" name="affac1ab4e519692a2e1cd091f8acfbb4"></a>
template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:affac1ab4e519692a2e1cd091f8acfbb4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>append_triangles_from_quad</b> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Index f, std::vector&lt; Index &gt; &amp;new_to_old_corners, std::vector&lt; Index &gt; &amp;new_to_old_facets)</td></tr>
<tr class="separator:affac1ab4e519692a2e1cd091f8acfbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf4543e9076f6d820d599afaa1579a8"><td class="memTemplParams" colspan="2"><a id="aaaf4543e9076f6d820d599afaa1579a8" name="aaaf4543e9076f6d820d599afaa1579a8"></a>
template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:aaaf4543e9076f6d820d599afaa1579a8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Vector3&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>facet_normal</b> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Index f)</td></tr>
<tr class="separator:aaaf4543e9076f6d820d599afaa1579a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d2341b9bb37b7365dfe933ac99606e"><td class="memTemplParams" colspan="2"><a id="a80d2341b9bb37b7365dfe933ac99606e" name="a80d2341b9bb37b7365dfe933ac99606e"></a>
template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a80d2341b9bb37b7365dfe933ac99606e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_best_2d_axes</b> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Index f)</td></tr>
<tr class="separator:a80d2341b9bb37b7365dfe933ac99606e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15945a257d25e1f114676a4c0c32342e"><td class="memTemplParams" colspan="2"><a id="a15945a257d25e1f114676a4c0c32342e" name="a15945a257d25e1f114676a4c0c32342e"></a>
template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a15945a257d25e1f114676a4c0c32342e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>append_triangles_from_polygon</b> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Index f, std::vector&lt; std::array&lt; Scalar, 2 &gt; &gt; &amp;polygon, <a class="el" href="classlagrange_1_1mapbox_1_1detail_1_1_earcut.html">mapbox::detail::Earcut</a>&lt; Index &gt; &amp;earcut, std::vector&lt; Index &gt; &amp;new_to_old_corners, std::vector&lt; Index &gt; &amp;new_to_old_facets)</td></tr>
<tr class="separator:a15945a257d25e1f114676a4c0c32342e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a88279224c2babdfdd5441776f883d0"><td class="memItemLeft" align="right" valign="top"><a id="a5a88279224c2babdfdd5441776f883d0" name="a5a88279224c2babdfdd5441776f883d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LA_SURFACE_MESH_SCALAR_X</b> (<a class="el" href="namespacelagrange.html#ab63029c7c83fee8c6f3bf5de81e4353c">triangle_uv_distortion</a>, 0)</td></tr>
<tr class="separator:a5a88279224c2babdfdd5441776f883d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af340c73b9a59c952f039a0e458b517cb"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedE &gt; </td></tr>
<tr class="memitem:af340c73b9a59c952f039a0e458b517cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#af340c73b9a59c952f039a0e458b517cb">save_graph_off</a> (const fs::path &amp;filename, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E)</td></tr>
<tr class="memdesc:af340c73b9a59c952f039a0e458b517cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a 2D undirected graph (V,E) using off format.  <a href="namespacelagrange.html#af340c73b9a59c952f039a0e458b517cb">More...</a><br /></td></tr>
<tr class="separator:af340c73b9a59c952f039a0e458b517cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27242b785bed719baa0d9e79f341aa72"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedE &gt; </td></tr>
<tr class="memitem:a27242b785bed719baa0d9e79f341aa72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a27242b785bed719baa0d9e79f341aa72">save_graph</a> (const fs::path &amp;filename, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E)</td></tr>
<tr class="memdesc:a27242b785bed719baa0d9e79f341aa72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a 2D undirected graph (V,E) based on filename extension.  <a href="namespacelagrange.html#a27242b785bed719baa0d9e79f341aa72">More...</a><br /></td></tr>
<tr class="separator:a27242b785bed719baa0d9e79f341aa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Sequential iteration for read operations</div></td></tr>
<tr class="memitem:ga5ea46712095e5d6919e88f0eab95cf0b"><td class="memTemplParams" colspan="2">template&lt;std::underlying_type_t&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; mask = BitField&lt;AttributeElement&gt;::all(), typename Visitor , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga5ea46712095e5d6919e88f0eab95cf0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-iterate.html#ga5ea46712095e5d6919e88f0eab95cf0b">seq_foreach_named_attribute_read</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Visitor &amp;&amp;vis)</td></tr>
<tr class="memdesc:ga5ea46712095e5d6919e88f0eab95cf0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to each attribute of a mesh.  <a href="group__group-surfacemesh-iterate.html#ga5ea46712095e5d6919e88f0eab95cf0b">More...</a><br /></td></tr>
<tr class="separator:ga5ea46712095e5d6919e88f0eab95cf0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a4985ccba2e336b05c61777ded88a2"><td class="memTemplParams" colspan="2">template&lt;std::underlying_type_t&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; mask = BitField&lt;AttributeElement&gt;::all(), typename Visitor , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga39a4985ccba2e336b05c61777ded88a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-iterate.html#ga39a4985ccba2e336b05c61777ded88a2">seq_foreach_attribute_read</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Visitor &amp;&amp;vis)</td></tr>
<tr class="memdesc:ga39a4985ccba2e336b05c61777ded88a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to each attribute of a mesh.  <a href="group__group-surfacemesh-iterate.html#ga39a4985ccba2e336b05c61777ded88a2">More...</a><br /></td></tr>
<tr class="separator:ga39a4985ccba2e336b05c61777ded88a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Sequential iteration for write operations</div></td></tr>
<tr class="memitem:ga4900f52b8a858debb6dbe3fc1b994c84"><td class="memTemplParams" colspan="2">template&lt;std::underlying_type_t&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; mask = BitField&lt;AttributeElement&gt;::all(), typename Visitor , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga4900f52b8a858debb6dbe3fc1b994c84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-iterate.html#ga4900f52b8a858debb6dbe3fc1b994c84">seq_foreach_named_attribute_write</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Visitor &amp;&amp;vis)</td></tr>
<tr class="memdesc:ga4900f52b8a858debb6dbe3fc1b994c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to each attribute of a mesh.  <a href="group__group-surfacemesh-iterate.html#ga4900f52b8a858debb6dbe3fc1b994c84">More...</a><br /></td></tr>
<tr class="separator:ga4900f52b8a858debb6dbe3fc1b994c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1c41be99dab55914cfcee2ea076e84f"><td class="memTemplParams" colspan="2">template&lt;std::underlying_type_t&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; mask = BitField&lt;AttributeElement&gt;::all(), typename Visitor , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gab1c41be99dab55914cfcee2ea076e84f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-iterate.html#gab1c41be99dab55914cfcee2ea076e84f">seq_foreach_attribute_write</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Visitor &amp;&amp;vis)</td></tr>
<tr class="memdesc:gab1c41be99dab55914cfcee2ea076e84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to each attribute of a mesh.  <a href="group__group-surfacemesh-iterate.html#gab1c41be99dab55914cfcee2ea076e84f">More...</a><br /></td></tr>
<tr class="separator:gab1c41be99dab55914cfcee2ea076e84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Parallel iteration for read operations</div></td></tr>
<tr class="memitem:ga876d75297484ac51714bc23bf2395900"><td class="memTemplParams" colspan="2">template&lt;std::underlying_type_t&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; mask = BitField&lt;AttributeElement&gt;::all(), typename Visitor , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga876d75297484ac51714bc23bf2395900"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-iterate.html#ga876d75297484ac51714bc23bf2395900">par_foreach_named_attribute_read</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Visitor &amp;&amp;vis)</td></tr>
<tr class="memdesc:ga876d75297484ac51714bc23bf2395900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function in parallel to each attribute of a mesh.  <a href="group__group-surfacemesh-iterate.html#ga876d75297484ac51714bc23bf2395900">More...</a><br /></td></tr>
<tr class="separator:ga876d75297484ac51714bc23bf2395900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c78ea8fd989ff704df6fb04b4a70797"><td class="memTemplParams" colspan="2">template&lt;std::underlying_type_t&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; mask = BitField&lt;AttributeElement&gt;::all(), typename Visitor , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga0c78ea8fd989ff704df6fb04b4a70797"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-iterate.html#ga0c78ea8fd989ff704df6fb04b4a70797">par_foreach_attribute_read</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Visitor &amp;&amp;vis)</td></tr>
<tr class="memdesc:ga0c78ea8fd989ff704df6fb04b4a70797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function in parallel to each attribute of a mesh.  <a href="group__group-surfacemesh-iterate.html#ga0c78ea8fd989ff704df6fb04b4a70797">More...</a><br /></td></tr>
<tr class="separator:ga0c78ea8fd989ff704df6fb04b4a70797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Parallel iteration for write operations</div></td></tr>
<tr class="memitem:ga071cbcb7d6bbefab8034138af08a6a7e"><td class="memTemplParams" colspan="2">template&lt;std::underlying_type_t&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; mask = BitField&lt;AttributeElement&gt;::all(), typename Visitor , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga071cbcb7d6bbefab8034138af08a6a7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-iterate.html#ga071cbcb7d6bbefab8034138af08a6a7e">par_foreach_named_attribute_write</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Visitor &amp;&amp;vis)</td></tr>
<tr class="memdesc:ga071cbcb7d6bbefab8034138af08a6a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function in parallel to each attribute of a mesh.  <a href="group__group-surfacemesh-iterate.html#ga071cbcb7d6bbefab8034138af08a6a7e">More...</a><br /></td></tr>
<tr class="separator:ga071cbcb7d6bbefab8034138af08a6a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19bb2dad60b7ae26ae8149b50e3d5e7e"><td class="memTemplParams" colspan="2">template&lt;std::underlying_type_t&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> &gt; mask = BitField&lt;AttributeElement&gt;::all(), typename Visitor , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga19bb2dad60b7ae26ae8149b50e3d5e7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-iterate.html#ga19bb2dad60b7ae26ae8149b50e3d5e7e">par_foreach_attribute_write</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Visitor &amp;&amp;vis)</td></tr>
<tr class="memdesc:ga19bb2dad60b7ae26ae8149b50e3d5e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function in parallel to each attribute of a mesh.  <a href="group__group-surfacemesh-iterate.html#ga19bb2dad60b7ae26ae8149b50e3d5e7e">More...</a><br /></td></tr>
<tr class="separator:ga19bb2dad60b7ae26ae8149b50e3d5e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Attribute remapping</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Mapping attributes between different element types.</p>
<ul>
<li>When mapping indexed to value attributes, values are duplicated for each corner, since otherwise the mapping corner -&gt; value would be lost.</li>
<li>When mapping value to indexed attributes, the size of the value buffer must be equal to the number of corners. The values are not deduplicated in the new indexed attribute. </li>
</ul>
</div></td></tr>
<tr class="memitem:gad7a1e90b26e460f8b9afc7efbca95cc4"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gad7a1e90b26e460f8b9afc7efbca95cc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr-utils.html#gad7a1e90b26e460f8b9afc7efbca95cc4">map_attribute</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id, std::string_view new_name, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> new_element)</td></tr>
<tr class="memdesc:gad7a1e90b26e460f8b9afc7efbca95cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map attribute values to a new attribute with a different element type.  <a href="group__group-surfacemesh-attr-utils.html#gad7a1e90b26e460f8b9afc7efbca95cc4">More...</a><br /></td></tr>
<tr class="separator:gad7a1e90b26e460f8b9afc7efbca95cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38348fa42743d4cb72a1a2975483acc1"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga38348fa42743d4cb72a1a2975483acc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr-utils.html#ga38348fa42743d4cb72a1a2975483acc1">map_attribute</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view old_name, std::string_view new_name, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> new_element)</td></tr>
<tr class="memdesc:ga38348fa42743d4cb72a1a2975483acc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map attribute values to a new attribute with a different element type.  <a href="group__group-surfacemesh-attr-utils.html#ga38348fa42743d4cb72a1a2975483acc1">More...</a><br /></td></tr>
<tr class="separator:ga38348fa42743d4cb72a1a2975483acc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd6500c173df1a5bc53e2c9b32e08309"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gacd6500c173df1a5bc53e2c9b32e08309"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr-utils.html#gacd6500c173df1a5bc53e2c9b32e08309">map_attribute_in_place</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> new_element)</td></tr>
<tr class="memdesc:gacd6500c173df1a5bc53e2c9b32e08309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map attribute values to a different element type.  <a href="group__group-surfacemesh-attr-utils.html#gacd6500c173df1a5bc53e2c9b32e08309">More...</a><br /></td></tr>
<tr class="separator:gacd6500c173df1a5bc53e2c9b32e08309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a2e525bede1624580d71782861b0cd6"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga4a2e525bede1624580d71782861b0cd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr-utils.html#ga4a2e525bede1624580d71782861b0cd6">map_attribute_in_place</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> new_element)</td></tr>
<tr class="memdesc:ga4a2e525bede1624580d71782861b0cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map attribute values to a different element type.  <a href="group__group-surfacemesh-attr-utils.html#ga4a2e525bede1624580d71782861b0cd6">More...</a><br /></td></tr>
<tr class="separator:ga4a2e525bede1624580d71782861b0cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Index buffer unification</div></td></tr>
<tr class="memitem:gae8deb2977d6d78e0b8e3a9a7773b6c72"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gae8deb2977d6d78e0b8e3a9a7773b6c72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr-utils.html#gae8deb2977d6d78e0b8e3a9a7773b6c72">unify_index_buffer</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const std::vector&lt; <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> &gt; &amp;attribute_ids={})</td></tr>
<tr class="memdesc:gae8deb2977d6d78e0b8e3a9a7773b6c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unify index buffers of the input <code>mesh</code> for all attributes specified in <code>attribute_ids</code>.  <a href="group__group-surfacemesh-attr-utils.html#gae8deb2977d6d78e0b8e3a9a7773b6c72">More...</a><br /></td></tr>
<tr class="separator:gae8deb2977d6d78e0b8e3a9a7773b6c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40817d91add1d124cc9f362f019d1f0c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga40817d91add1d124cc9f362f019d1f0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-attr-utils.html#ga40817d91add1d124cc9f362f019d1f0c">unify_named_index_buffer</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, const std::vector&lt; std::string_view &gt; &amp;attribute_names)</td></tr>
<tr class="memdesc:ga40817d91add1d124cc9f362f019d1f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="group__group-surfacemesh-attr-utils.html#ga40817d91add1d124cc9f362f019d1f0c">More...</a><br /></td></tr>
<tr class="separator:ga40817d91add1d124cc9f362f019d1f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adc37a853021fc87c80d53f7cb0a21ae5"><td class="memTemplParams" colspan="2">template&lt;typename Index &gt; </td></tr>
<tr class="memitem:adc37a853021fc87c80d53f7cb0a21ae5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_chain_edges_result.html">ChainEdgesResult</a>&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#adc37a853021fc87c80d53f7cb0a21ae5">chain_directed_edges</a> (const <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; edges, const <a class="el" href="structlagrange_1_1_chain_edges_options.html">ChainEdgesOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:adc37a853021fc87c80d53f7cb0a21ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain a set of directed edges into loops and chains.  <a href="namespacelagrange.html#adc37a853021fc87c80d53f7cb0a21ae5">More...</a><br /></td></tr>
<tr class="separator:adc37a853021fc87c80d53f7cb0a21ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a228fdc8080ef275f963576cd9b4c9"><td class="memTemplParams" colspan="2">template&lt;typename Index &gt; </td></tr>
<tr class="memitem:a85a228fdc8080ef275f963576cd9b4c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1_chain_edges_result.html">ChainEdgesResult</a>&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange.html#a85a228fdc8080ef275f963576cd9b4c9">chain_undirected_edges</a> (const <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; edges, const <a class="el" href="structlagrange_1_1_chain_edges_options.html">ChainEdgesOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:a85a228fdc8080ef275f963576cd9b4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain a set of undirected edges into loops and chains.  <a href="namespacelagrange.html#a85a228fdc8080ef275f963576cd9b4c9">More...</a><br /></td></tr>
<tr class="separator:a85a228fdc8080ef275f963576cd9b4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a30c54699aaf23b17c9d68bbb4f2f32ab"><td class="memTemplParams" colspan="2"><a id="a30c54699aaf23b17c9d68bbb4f2f32ab" name="a30c54699aaf23b17c9d68bbb4f2f32ab"></a>
template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a30c54699aaf23b17c9d68bbb4f2f32ab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structlagrange_1_1_stack_set.html">StackSet</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structlagrange_1_1_stack_set.html">StackSet</a>&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="separator:a30c54699aaf23b17c9d68bbb4f2f32ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab44e7d151e258869e43efba3e80b998c"><td class="memTemplParams" colspan="2"><a id="ab44e7d151e258869e43efba3e80b998c" name="ab44e7d151e258869e43efba3e80b998c"></a>
template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:ab44e7d151e258869e43efba3e80b998c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structlagrange_1_1_stack_vector.html">StackVector</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structlagrange_1_1_stack_vector.html">StackVector</a>&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="separator:ab44e7d151e258869e43efba3e80b998c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Generic attribute views</div></td></tr>
<tr class="memitem:gaf2e0d4ab50ffdc84c4431d699f6741fe"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:gaf2e0d4ab50ffdc84c4431d699f6741fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga06ca3172e4577c726eaf8d2ab26a1ab5">RowMatrixView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#gaf2e0d4ab50ffdc84c4431d699f6741fe">matrix_ref</a> (<a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp;attribute)</td></tr>
<tr class="memdesc:gaf2e0d4ab50ffdc84c4431d699f6741fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writable view of a given attribute in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#gaf2e0d4ab50ffdc84c4431d699f6741fe">More...</a><br /></td></tr>
<tr class="separator:gaf2e0d4ab50ffdc84c4431d699f6741fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ae9d0742709686405adad75e20e8bc8"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ga0ae9d0742709686405adad75e20e8bc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#gabdf68813d2c56704e10b6ba3c5b9aa6d">ConstRowMatrixView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga0ae9d0742709686405adad75e20e8bc8">matrix_view</a> (const <a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp;attribute)</td></tr>
<tr class="memdesc:ga0ae9d0742709686405adad75e20e8bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only view of a given attribute in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#ga0ae9d0742709686405adad75e20e8bc8">More...</a><br /></td></tr>
<tr class="separator:ga0ae9d0742709686405adad75e20e8bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fe8e6f4f2ff0c10903d49ec085e541a"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ga1fe8e6f4f2ff0c10903d49ec085e541a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga373c385fbf8ee25f008de6d6575118ab">VectorView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga1fe8e6f4f2ff0c10903d49ec085e541a">vector_ref</a> (<a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp;attribute)</td></tr>
<tr class="memdesc:ga1fe8e6f4f2ff0c10903d49ec085e541a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writable view of a scalar attribute in the form of an Eigen vector.  <a href="group__group-surfacemesh-views.html#ga1fe8e6f4f2ff0c10903d49ec085e541a">More...</a><br /></td></tr>
<tr class="separator:ga1fe8e6f4f2ff0c10903d49ec085e541a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga217fb9661440df5dd7025d26cfeaf4d6"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ga217fb9661440df5dd7025d26cfeaf4d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#gab4f42fe9cfd8b46f3f4a0c81ab791c1f">ConstVectorView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga217fb9661440df5dd7025d26cfeaf4d6">vector_view</a> (const <a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp;attribute)</td></tr>
<tr class="memdesc:ga217fb9661440df5dd7025d26cfeaf4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only view of a scalar attribute in the form of an Eigen vector.  <a href="group__group-surfacemesh-views.html#ga217fb9661440df5dd7025d26cfeaf4d6">More...</a><br /></td></tr>
<tr class="separator:ga217fb9661440df5dd7025d26cfeaf4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c3faebd019aa5400b5c97d8558f5f21"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ga8c3faebd019aa5400b5c97d8558f5f21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga06ca3172e4577c726eaf8d2ab26a1ab5">RowMatrixView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga8c3faebd019aa5400b5c97d8558f5f21">reshaped_ref</a> (<a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp;attribute, size_t num_cols)</td></tr>
<tr class="memdesc:ga8c3faebd019aa5400b5c97d8558f5f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writable view of a given single-channel attribute in the form of an Eigen matrix with a prescribed number of columns.  <a href="group__group-surfacemesh-views.html#ga8c3faebd019aa5400b5c97d8558f5f21">More...</a><br /></td></tr>
<tr class="separator:ga8c3faebd019aa5400b5c97d8558f5f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85cdda0a43cfba607a3145feebcdb5c8"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ga85cdda0a43cfba607a3145feebcdb5c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#gabdf68813d2c56704e10b6ba3c5b9aa6d">ConstRowMatrixView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga85cdda0a43cfba607a3145feebcdb5c8">reshaped_view</a> (const <a class="el" href="classlagrange_1_1_attribute.html">Attribute</a>&lt; ValueType &gt; &amp;attribute, size_t num_cols)</td></tr>
<tr class="memdesc:ga85cdda0a43cfba607a3145feebcdb5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only view of a given single-channel attribute in the form of an Eigen matrix with a prescribed number of columns.  <a href="group__group-surfacemesh-views.html#ga85cdda0a43cfba607a3145feebcdb5c8">More...</a><br /></td></tr>
<tr class="separator:ga85cdda0a43cfba607a3145feebcdb5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Generic attribute views (mesh)</div></td></tr>
<tr class="memitem:ga4bef44f19fd375bf20e21bfecba3012d"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga4bef44f19fd375bf20e21bfecba3012d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga06ca3172e4577c726eaf8d2ab26a1ab5">RowMatrixView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga4bef44f19fd375bf20e21bfecba3012d">attribute_matrix_ref</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view name)</td></tr>
<tr class="memdesc:ga4bef44f19fd375bf20e21bfecba3012d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writable view of a mesh attribute in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#ga4bef44f19fd375bf20e21bfecba3012d">More...</a><br /></td></tr>
<tr class="separator:ga4bef44f19fd375bf20e21bfecba3012d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66fb9a3cd6aa7916b0be5316e4c5b735"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga66fb9a3cd6aa7916b0be5316e4c5b735"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga06ca3172e4577c726eaf8d2ab26a1ab5">RowMatrixView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga66fb9a3cd6aa7916b0be5316e4c5b735">attribute_matrix_ref</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id)</td></tr>
<tr class="memdesc:ga66fb9a3cd6aa7916b0be5316e4c5b735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writable view of a mesh attribute in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#ga66fb9a3cd6aa7916b0be5316e4c5b735">More...</a><br /></td></tr>
<tr class="separator:ga66fb9a3cd6aa7916b0be5316e4c5b735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eac5d03d3893046ab95ea62407c4dd7"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga0eac5d03d3893046ab95ea62407c4dd7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#gabdf68813d2c56704e10b6ba3c5b9aa6d">ConstRowMatrixView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga0eac5d03d3893046ab95ea62407c4dd7">attribute_matrix_view</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view name)</td></tr>
<tr class="memdesc:ga0eac5d03d3893046ab95ea62407c4dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only view of a mesh attribute in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#ga0eac5d03d3893046ab95ea62407c4dd7">More...</a><br /></td></tr>
<tr class="separator:ga0eac5d03d3893046ab95ea62407c4dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7515287d007f73bb5e32388420ac7c9e"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga7515287d007f73bb5e32388420ac7c9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#gabdf68813d2c56704e10b6ba3c5b9aa6d">ConstRowMatrixView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga7515287d007f73bb5e32388420ac7c9e">attribute_matrix_view</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id)</td></tr>
<tr class="memdesc:ga7515287d007f73bb5e32388420ac7c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only view of a mesh attribute in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#ga7515287d007f73bb5e32388420ac7c9e">More...</a><br /></td></tr>
<tr class="separator:ga7515287d007f73bb5e32388420ac7c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5edab3687afa62046eaf874ceae232f8"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga5edab3687afa62046eaf874ceae232f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga373c385fbf8ee25f008de6d6575118ab">VectorView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga5edab3687afa62046eaf874ceae232f8">attribute_vector_ref</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view name)</td></tr>
<tr class="memdesc:ga5edab3687afa62046eaf874ceae232f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writable view of a mesh attribute in the form of an Eigen vector.  <a href="group__group-surfacemesh-views.html#ga5edab3687afa62046eaf874ceae232f8">More...</a><br /></td></tr>
<tr class="separator:ga5edab3687afa62046eaf874ceae232f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cb1140345c1029da1566dc095aabb4a"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga2cb1140345c1029da1566dc095aabb4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga373c385fbf8ee25f008de6d6575118ab">VectorView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga2cb1140345c1029da1566dc095aabb4a">attribute_vector_ref</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id)</td></tr>
<tr class="memdesc:ga2cb1140345c1029da1566dc095aabb4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writable view of a mesh attribute in the form of an Eigen vector.  <a href="group__group-surfacemesh-views.html#ga2cb1140345c1029da1566dc095aabb4a">More...</a><br /></td></tr>
<tr class="separator:ga2cb1140345c1029da1566dc095aabb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ff70d67260c645c51ea43c8d95de74"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gad4ff70d67260c645c51ea43c8d95de74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#gab4f42fe9cfd8b46f3f4a0c81ab791c1f">ConstVectorView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#gad4ff70d67260c645c51ea43c8d95de74">attribute_vector_view</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view name)</td></tr>
<tr class="memdesc:gad4ff70d67260c645c51ea43c8d95de74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only view of a mesh attribute in the form of an Eigen vector.  <a href="group__group-surfacemesh-views.html#gad4ff70d67260c645c51ea43c8d95de74">More...</a><br /></td></tr>
<tr class="separator:gad4ff70d67260c645c51ea43c8d95de74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga397ee663ce6493e1acba89814482c971"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga397ee663ce6493e1acba89814482c971"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#gab4f42fe9cfd8b46f3f4a0c81ab791c1f">ConstVectorView</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga397ee663ce6493e1acba89814482c971">attribute_vector_view</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> id)</td></tr>
<tr class="memdesc:ga397ee663ce6493e1acba89814482c971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only view of a mesh attribute in the form of an Eigen vector.  <a href="group__group-surfacemesh-views.html#ga397ee663ce6493e1acba89814482c971">More...</a><br /></td></tr>
<tr class="separator:ga397ee663ce6493e1acba89814482c971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Specific attribute views</div></td></tr>
<tr class="memitem:ga6b51e5a79a66e11c3dff4c1d68015c1c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga6b51e5a79a66e11c3dff4c1d68015c1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga06ca3172e4577c726eaf8d2ab26a1ab5">RowMatrixView</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga6b51e5a79a66e11c3dff4c1d68015c1c">vertex_ref</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga6b51e5a79a66e11c3dff4c1d68015c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writable view of the mesh vertices in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#ga6b51e5a79a66e11c3dff4c1d68015c1c">More...</a><br /></td></tr>
<tr class="separator:ga6b51e5a79a66e11c3dff4c1d68015c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e034be5f010e6956225e15059825146"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga2e034be5f010e6956225e15059825146"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#gabdf68813d2c56704e10b6ba3c5b9aa6d">ConstRowMatrixView</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga2e034be5f010e6956225e15059825146">vertex_view</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga2e034be5f010e6956225e15059825146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only view of the mesh vertices in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#ga2e034be5f010e6956225e15059825146">More...</a><br /></td></tr>
<tr class="separator:ga2e034be5f010e6956225e15059825146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8c34105b292c12cff41b1dec4bca137"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:gae8c34105b292c12cff41b1dec4bca137"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#ga06ca3172e4577c726eaf8d2ab26a1ab5">RowMatrixView</a>&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#gae8c34105b292c12cff41b1dec4bca137">facet_ref</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:gae8c34105b292c12cff41b1dec4bca137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a writable view of a mesh facets in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#gae8c34105b292c12cff41b1dec4bca137">More...</a><br /></td></tr>
<tr class="separator:gae8c34105b292c12cff41b1dec4bca137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a158f542405b5b869533b691f18ed8d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ga8a158f542405b5b869533b691f18ed8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-views.html#gabdf68813d2c56704e10b6ba3c5b9aa6d">ConstRowMatrixView</a>&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-surfacemesh-views.html#ga8a158f542405b5b869533b691f18ed8d">facet_view</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh)</td></tr>
<tr class="memdesc:ga8a158f542405b5b869533b691f18ed8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only view of a mesh facets in the form of an Eigen matrix.  <a href="group__group-surfacemesh-views.html#ga8a158f542405b5b869533b691f18ed8d">More...</a><br /></td></tr>
<tr class="separator:ga8a158f542405b5b869533b691f18ed8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Main namespace for Lagrange. </p>
<p >This header exposes functionality of previously registered mesh types To register new mesh type, include &lt;<a class="el" href="mesh_8impl_8h_source.html">lagrange/ui/utils/mesh.impl.h</a>&gt; and call register_mesh_type&lt;MeshType&gt;</p>
<p >Events triggered by the default systems Use <code>ui::on&lt;Event&gt;(registry, [](Event&amp; e){})</code> to register a listener Use <code><a class="el" href="namespacelagrange_1_1ui.html#a36e5624fbced4d83d418db72dd328e2d" title="Trigger an event of type Event.">ui::publish</a>&lt;Event&gt;(registry, args ...)</code> to trigger a custom event See &lt;<a class="el" href="events_8h_source.html">lagrange/ui/utils/events.h</a>&gt; for more details.</p>
<p >Private methods.</p>
<p >Utility functions that don't belong anywhere else.</p>
<p >Evaluates a function for each mesh element and stores the result as an attribute.</p>
<p >Consider refactoring this file if it becomes too big, or categories emerge. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a312f57b0318728667933d7254778058b" name="a312f57b0318728667933d7254778058b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312f57b0318728667933d7254778058b">&#9670;&nbsp;</a></span>ConnectivityType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacelagrange.html#a312f57b0318728667933d7254778058b">ConnectivityType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This type defines the condition when two facets are considered as "connected". </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a312f57b0318728667933d7254778058bab22b929ba52471a02d18bb3a4e4472e6" name="a312f57b0318728667933d7254778058bab22b929ba52471a02d18bb3a4e4472e6"></a>Vertex&#160;</td><td class="fielddoc"><p >Two facets are considered connected if they share a vertex. </p>
</td></tr>
<tr><td class="fieldname"><a id="a312f57b0318728667933d7254778058bae4a297a0f76119a442c2595ac040673e" name="a312f57b0318728667933d7254778058bae4a297a0f76119a442c2595ac040673e"></a>Edge&#160;</td><td class="fielddoc"><p >Two facets are considered connected if they share an edge. </p>
</td></tr>
</table>

</div>
</div>
<a id="af15e960c877b7516935402a9080b7e1a" name="af15e960c877b7516935402a9080b7e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15e960c877b7516935402a9080b7e1a">&#9670;&nbsp;</a></span>MappingPolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacelagrange.html#af15e960c877b7516935402a9080b7e1a">MappingPolicy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mapping policy control the behavior when two or more elements are mapped into the same output element. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af15e960c877b7516935402a9080b7e1aab1897515d548a960afe49ecf66a29021" name="af15e960c877b7516935402a9080b7e1aab1897515d548a960afe49ecf66a29021"></a>Average&#160;</td><td class="fielddoc"><p >Take the average of all involved elements. </p>
</td></tr>
<tr><td class="fieldname"><a id="af15e960c877b7516935402a9080b7e1aa0e86b31f0ceff2268f199fa31e7b1369" name="af15e960c877b7516935402a9080b7e1aa0e86b31f0ceff2268f199fa31e7b1369"></a>KeepFirst&#160;</td><td class="fielddoc"><p >Keep the value of the first elements. </p>
</td></tr>
<tr><td class="fieldname"><a id="af15e960c877b7516935402a9080b7e1aa902b0d55fddef6f8d651fe1035b7d4bd" name="af15e960c877b7516935402a9080b7e1aa902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"><p >Throw an error if collision is detected. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad919806f4b5cd1dfc507fe3e9173a5f8" name="ad919806f4b5cd1dfc507fe3e9173a5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad919806f4b5cd1dfc507fe3e9173a5f8">&#9670;&nbsp;</a></span>chain_corners_around_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chain_corners_around_edges </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>corner_to_edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_to_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>next_corner_around_edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chains facet corners around edges of a mesh. </p>
<p >The mesh is assumed have polygonal faces of constant degree k. There are #C = #F * k facet corners in this mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">facets</td><td>#F x k array of facet indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">corner_to_edge</td><td>#C x 1 array mapping facet corners to edge indices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">edge_to_corner</td><td>#E x 1 array of first facet corner in the chain starting from a given edge. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next_corner_around_edge</td><td>#C x 1 array of next facet corner in the chain at a given facet corner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedF</td><td>Type of facet array. </td></tr>
    <tr><td class="paramname">DerivedC</td><td>Type of corner to edge vector. </td></tr>
    <tr><td class="paramname">DerivedE</td><td>Type of edge to corner vector. </td></tr>
    <tr><td class="paramname">DerivedN</td><td>Type of next corner vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae56e9b69f19b41be755dbe5a7d7f1897" name="ae56e9b69f19b41be755dbe5a7d7f1897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56e9b69f19b41be755dbe5a7d7f1897">&#9670;&nbsp;</a></span>chain_corners_around_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chain_corners_around_vertices </td>
          <td>(</td>
          <td class="paramtype">typename DerivedF::Scalar&#160;</td>
          <td class="paramname"><em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_to_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>next_corner_around_vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chains facet corners around vertices of a mesh. </p>
<p >The mesh is assumed have polygonal faces of constant degree k. There are #C = #F * k facet corners in this mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_vertices</td><td>Number of vertices in the mesh. This information is necessary since there may be isolated vertices, and thus computing it from the facet array may be misleading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facets</td><td>#F x k array of facet indices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vertex_to_corner</td><td>#E x 1 array of first facet corner in the chain starting from a given vertex. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next_corner_around_vertex</td><td>#C x 1 array of next facet corner in the chain at a given facet corner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedF</td><td>Type of facet array. </td></tr>
    <tr><td class="paramname">DerivedE</td><td>Type of vertex to corner vector. </td></tr>
    <tr><td class="paramname">DerivedN</td><td>Type of next corner vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45f1c6cc55a36fae54bcd3723d8255e2" name="a45f1c6cc55a36fae54bcd3723d8255e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f1c6cc55a36fae54bcd3723d8255e2">&#9670;&nbsp;</a></span>move_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void move_data </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move data from one Eigen obj to another. </p>
<p >Both objects will be in valid state after the move. </p>

</div>
</div>
<a id="a63cc672971ecc26849450a45db354f6b" name="a63cc672971ecc26849450a45db354f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63cc672971ecc26849450a45db354f6b">&#9670;&nbsp;</a></span>compute_dijkstra_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::vector&lt; Index &gt; &gt; compute_dijkstra_distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_dijkstra_distance_options.html">DijkstraDistanceOptions</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes dijkstra distance from a seed facet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>Input mesh. </td></tr>
    <tr><td class="paramname">options</td><td>Options for computing dijkstra distance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optionally, a vector of indices of vertices involved </dd></dl>

</div>
</div>
<a id="aa044d2770f886a9d400b161400c971b3" name="aa044d2770f886a9d400b161400c971b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa044d2770f886a9d400b161400c971b3">&#9670;&nbsp;</a></span>compute_lift_operator_from_sampling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto compute_lift_operator_from_sampling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Cloud &amp;&#160;</td>
          <td class="paramname"><em>closest_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Indices &amp;&#160;</td>
          <td class="paramname"><em>element_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This compute the sparse bilinear map from mesh vertex attributes to point cloud attributes. </p>
<p >Input points are supposed to lie on facets on the input mesh. Each row of element_indices is a input triangle index of which the point at the same row is supposed to lie. It uses barycentric coordinates on each triangle to fill in coeffs of a sparse matrix which is then returned. This bilinear sparse mapping (a.k.a. the returned sparse matrix) can used extend mesh defined fields to fields defined in R^3. This is useful for interpolating positions or scalar curvatures to a sampled point cloud for example. This is suited for use with sampling functions like random_sample_uniform that naturally build the third arg.</p>
<dl class="section return"><dt>Returns</dt><dd>Sparse n*m matrix, where n is the number of vertex in the input mesh and m is the number of vertex in the input point cloud. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Input triangular mesh.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">closest_points</td><td>Input point cloud. should lie on input mesh.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element_indices</td><td>Input mesh triangle indices for each point of the input point cloud. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa066ff40e856a0b5dffac1b7e141ce6c" name="aa066ff40e856a0b5dffac1b7e141ce6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa066ff40e856a0b5dffac1b7e141ce6c">&#9670;&nbsp;</a></span>compute_lift_operator_from_projections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto compute_lift_operator_from_projections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ClosestPoints &amp;&#160;</td>
          <td class="paramname"><em>projections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This compute the sparse bilinear map from mesh vertex attributes to point cloud attributes. </p>
<p >It uses barycentric coordinates on each triangle to fill in coeffs of a sparse matrix which is then returned. This bilinear sparse mapping (a.k.a. the returned sparse matrix) can used extend mesh defined fields to fields defined in R^3. This is useful for interpolating positions or scalar curvatures to a sampled point cloud for example. This is suited for use with bvh structure whose data return by batch_query can be used as the second arg.</p>
<dl class="section return"><dt>Returns</dt><dd>Sparse n*m matrix, where n is the number of vertex in the input mesh and m is the number of vertex in the input point cloud. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>input triangular mesh.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projections</td><td>projections data returned by a call to BVH batch_query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9c124c65e79e319a4aefc92ccb5ce7f" name="aa9c124c65e79e319a4aefc92ccb5ce7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c124c65e79e319a4aefc92ccb5ce7f">&#9670;&nbsp;</a></span>compute_uv_tile_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; int32_t, int32_t &gt; &gt; compute_uv_tile_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the list of all UV tiles that a mesh's parametrization spans. </p>
<p >UV tiles are usually understood to be a regular unit grid in UV space. This process thus reads UV for all vertices of the input mesh, and adds an entry to the output for each new integer pair that it finds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> to be analyzed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of integer coordinates with one entry for each UV tile of mesh. </dd></dl>

</div>
</div>
<a id="ad34583bdda68644dcd9c7175ce179735" name="ad34583bdda68644dcd9c7175ce179735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34583bdda68644dcd9c7175ce179735">&#9670;&nbsp;</a></span>corner_to_edge_mapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Index corner_to_edge_mapping </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C2E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a mapping from mesh corners (k*f+i) to unique edge ids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F x k matrix of facet indices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C2E</td><td>#F*k vector of unique edge ids per corner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedF</td><td>Type of facet array. </td></tr>
    <tr><td class="paramname">DerivedC</td><td>Type of corner to edge vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of unique edges created. </dd></dl>

</div>
</div>
<a id="a01a55c916bd22d4ee64baa54c4993344" name="a01a55c916bd22d4ee64baa54c4993344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a55c916bd22d4ee64baa54c4993344">&#9670;&nbsp;</a></span>create_mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto create_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>facets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function create a new mesh given the vertex and facet arrays by copying data into the <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object. </p>
<p >Both arrays can be of type <code>Eigen::Matrix</code> or <code>Eigen::Map</code>. </p>

</div>
</div>
<a id="a1b5e551dc6fb8002b1263d47ce4aa8b8" name="a1b5e551dc6fb8002b1263d47ce4aa8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5e551dc6fb8002b1263d47ce4aa8b8">&#9670;&nbsp;</a></span>create_mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a>&lt; DerivedV, DerivedF &gt; &gt; create_mesh </td>
          <td>(</td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>facets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function create a new mesh given the vertex and facet arrays by moving data into the <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object. </p>
<p >Both arrays must be of type <code>Eigen::Matrix</code>. </p>

</div>
</div>
<a id="ae14b46e06f926a32bb0cb2d0ce2052d3" name="ae14b46e06f926a32bb0cb2d0ce2052d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14b46e06f926a32bb0cb2d0ce2052d3">&#9670;&nbsp;</a></span>wrap_with_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto wrap_with_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; VertexArray &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; FacetArray &gt; &amp;&#160;</td>
          <td class="paramname"><em>facets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method creates a <a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object that wraps around vertices and facets. </p>
<p >Warning: vertices and facets are referenced instead of copied, and thus they have to be valid throughout the duration of the lifetime of the object. It is the user's responsibility of ensure it is the case. </p>

</div>
</div>
<a id="aa79f233ab5cedf00d807bc3f8c3c203e" name="aa79f233ab5cedf00d807bc3f8c3c203e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79f233ab5cedf00d807bc3f8c3c203e">&#9670;&nbsp;</a></span>marching_triangles_general()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlagrange_1_1_marching_triangles_output.html">MarchingTrianglesOutput</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; marching_triangles_general </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td>
          <td class="paramname"><em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueFn &amp;&#160;</td>
          <td class="paramname"><em>get_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform marching triangles to extract isocontour on a field defined as the linear interpolation of values provided by the <code>get_value</code> function. </p>
<p >Adapted from <a href="https://www.cs.ubc.ca/~rbridson/download/common_2008_nov_12.tar.gz">https://www.cs.ubc.ca/~rbridson/download/common_2008_nov_12.tar.gz</a> (code released to the <b>public domain</b> by Robert Bridson)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh_ref</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isovalue</td><td>The isovalue of the field at which to contour. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">get_value</td><td>A function that takes the facet id and a local corner id and returns the field value at that corner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted isocontour. </dd></dl>

</div>
</div>
<a id="a303f43cd9a9728efee71e5b5d2534927" name="a303f43cd9a9728efee71e5b5d2534927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303f43cd9a9728efee71e5b5d2534927">&#9670;&nbsp;</a></span>marching_triangles_indexed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlagrange_1_1_marching_triangles_output.html">MarchingTrianglesOutput</a>&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; marching_triangles_indexed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename MeshType::Scalar&#160;</td>
          <td class="paramname"><em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>indexed_attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename MeshType::Index&#160;</td>
          <td class="paramname"><em>attribute_col_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform marching triangles to extract isocontours on a field defined as the linear interpolation of an indexed attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh_ref</td><td>The input triangle mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isovalue</td><td>The isovalue of the field at which to contour. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indexed_attribute_name</td><td>The indexed attribute name defining the field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attribute_col_index</td><td>The attribute channel to use (for vector attributes only). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted isocontour.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The indexed attribute can be used to define fields with discontinuities. However, result may contain artifacts if the desired iso-contour passes through such discontiuity. </dd></dl>

</div>
</div>
<a id="ac88e5e2a3cb45c21980d4d676a08c8b3" name="ac88e5e2a3cb45c21980d4d676a08c8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88e5e2a3cb45c21980d4d676a08c8b3">&#9670;&nbsp;</a></span>close_small_holes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; close_small_holes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_hole_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close small topological holes. </p>
<p >For holes with &gt; 3 vertices, inserts a vertex at the barycenter of the hole polygon. If a hole is not a simple polygon, we attempt to turn it into simple polygons by cutting ears.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Remap attribute. For now all input mesh attributes are dropped.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Input mesh whose holes to close. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_hole_size</td><td>Maximum number of vertices on a hole to be closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new mesh with the holes closed. </dd></dl>

</div>
</div>
<a id="ae47e0b414a04c27b736ffb61985ae3e1" name="ae47e0b414a04c27b736ffb61985ae3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47e0b414a04c27b736ffb61985ae3e1">&#9670;&nbsp;</a></span>detect_degenerate_facets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Index &gt; detect_degenerate_facets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detects degenerate facets in a mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>Input mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of indices of degenerate facets.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only exactly degenerate facets are detected. For polygonal facets, degeneracy is defined as all vertices are colinear.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>remove_degenerate_facets </dd></dl>

</div>
</div>
<a id="ad6fd3adb44b0b3a38ad087cb6f631b16" name="ad6fd3adb44b0b3a38ad087cb6f631b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6fd3adb44b0b3a38ad087cb6f631b16">&#9670;&nbsp;</a></span>remove_duplicate_facets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; remove_duplicate_facets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removal all duplicate facets from the mesh. </p>
<p >Arguments: input_mesh</p>
<p >Returns: output_mesh without any duplicate facets.</p>
<p >All vertex/facet/corner attributes are mapped from the input to the output. For facet/corner attributes, only the attributes for one of the duplicate facets are used in the output. The ordering of the facets may change even if the input contains no duplicate facets. </p>

</div>
</div>
<a id="a027de7d500f4a17245fa0f7450a1d433" name="a027de7d500f4a17245fa0f7450a1d433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027de7d500f4a17245fa0f7450a1d433">&#9670;&nbsp;</a></span>remove_duplicate_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_duplicate_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_remove_duplicate_vertices_options.html">RemoveDuplicateVerticesOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes duplicate vertices from a mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>The mesh to remove duplicate vertices from. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>The options for duplicate vertex detection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52c66ca364fc0c9eb6d9b63052fa80ab" name="a52c66ca364fc0c9eb6d9b63052fa80ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c66ca364fc0c9eb6d9b63052fa80ab">&#9670;&nbsp;</a></span>remove_isolated_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_isolated_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes isolated vertices of a mesh. </p>
<p >Facets incident to any removed vertex will be deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> to modify in place.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0ed135d2a082f05bbbc207aa379459a" name="ac0ed135d2a082f05bbbc207aa379459a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ed135d2a082f05bbbc207aa379459a">&#9670;&nbsp;</a></span>remove_null_area_facets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_null_area_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_remove_null_area_facets_options.html">RemoveNullAreaFacetsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all facets with unsigned area &lt;= options.null_area_threshold. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td>Input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options settings for removing null area facets. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a221bf945904e20d8ba77a7661247a226" name="a221bf945904e20d8ba77a7661247a226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221bf945904e20d8ba77a7661247a226">&#9670;&nbsp;</a></span>remove_short_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; remove_short_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>in_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::Scalar&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove edges shorter than a given tolerance. </p>
<p >Arguments: mesh: input mesh. tol: edges with length &lt;= tol will be removed.</p>
<p >Returns: An output mesh without edge &lt;= tol. </p>

</div>
</div>
<a id="a9a4e0328e98859931047b51f9096260e" name="a9a4e0328e98859931047b51f9096260e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4e0328e98859931047b51f9096260e">&#9670;&nbsp;</a></span>remove_topologically_degenerate_triangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; remove_topologically_degenerate_triangles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove topologically degenerate triangles. </p>
<p >Arguments: input_mesh</p>
<p >Returns: output_mesh without any topologically degnerate facets.</p>
<p >All vertex and facet attributes are mapped over. The output_mesh's vertices are exactly the same as input_mesh's vertices. The output_mesh's facets are a subset of input_mesh's facets. </p>

</div>
</div>
<a id="a1f7a74bc68094461dfaa0ee5914be465" name="a1f7a74bc68094461dfaa0ee5914be465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7a74bc68094461dfaa0ee5914be465">&#9670;&nbsp;</a></span>resolve_nonmanifoldness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; resolve_nonmanifoldness </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve <b>all</b> non-manifold edges and vertices in the mesh. </p>
<p >Arguments: mesh: The input mesh.</p>
<p >Returns: A mesh same as the input mesh except non-manifold vertices and edges are pulled apart topologically. </p>
<p >Return true iff Edge e is consistently oriented with the specified facet.</p>
<p >This method assumes e is a valid edge in the facet.</p>
<p >Return true iff facets around an edge are <b>inconsistently</b> oriented. E.g. f0: * [0, 1, 2] and f1: [1, 2, 3], with e=[1, 2]</p>
<dl class="section note"><dt>Note</dt><dd>: This method does not depend on the orientaiton of the edge e. This method also assumes the edge <code>ei</code> has exactly 2 adjacent facets.</dd></dl>
<p>Return true iff f0 and f1 are consistantly oriented with respect to edge ei. This is <b>almost</b> the same as <code>is_inconsistently_oriented</code>. With <code>f0</code> and <code>f1</code> specified, this version can work with non-manifold edges.</p>
<p >Return true iff edge e has more than 2 incident facets or it has exactly 2 incident facet but they are inconsistently oriented.</p>

</div>
</div>
<a id="a8cab1ac1fad3b7dd8c0e5a816e2fa057" name="a8cab1ac1fad3b7dd8c0e5a816e2fa057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cab1ac1fad3b7dd8c0e5a816e2fa057">&#9670;&nbsp;</a></span>resolve_vertex_nonmanifoldness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; resolve_vertex_nonmanifoldness </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove nonmanifold vertices topologically by pulling disconnected 1-ring neighborhood apart. </p>
<p >Warning: This function assumes the input mesh contains <b>no</b> nonmanifold edges or inconsistently oriented triangles. If that is not the case, consider using <code><a class="el" href="namespacelagrange.html#a1f7a74bc68094461dfaa0ee5914be465" title="Resolve all non-manifold edges and vertices in the mesh.">lagrange::resolve_nonmanifoldness()</a></code> instead. </p>

</div>
</div>
<a id="a9228a710975bd87aa58b98ac1d8fbc06" name="a9228a710975bd87aa58b98ac1d8fbc06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9228a710975bd87aa58b98ac1d8fbc06">&#9670;&nbsp;</a></span>split_triangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::Matrix&lt; Index, 3, 1 &gt; &gt; split_triangle </td>
          <td>(</td>
          <td class="paramtype">const VertexArray &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split triangle into smaller triangles based on the chain of spliting points. </p>
<p >Arguments: vertices: list of vertices that contains all 3 corner of the triangle and all splitting points. chain: A chain of indices into vertices that iterates all splitting points and corners in counterclockwise order. v0: index into chain that represents corner 0. v1: index into chain that represents corner 1. v2: index into chain that represents corner 2.</p>
<p >Returns: facets: output facets. </p>

</div>
</div>
<a id="abb5fc3fc93e8d973bcc534398eeb0aa9" name="abb5fc3fc93e8d973bcc534398eeb0aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5fc3fc93e8d973bcc534398eeb0aa9">&#9670;&nbsp;</a></span>to_surface_mesh_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; to_surface_mesh_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a legacy mesh object to a surface mesh object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Output mesh scalar type. Must be either float or double. </td></tr>
    <tr><td class="paramname">Index</td><td>Output mesh index type. Must be either uint32_t or uint64_t. </td></tr>
    <tr><td class="paramname">MeshType</td><td>Input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New mesh object. </dd></dl>

</div>
</div>
<a id="a68ad17ee5b7475decfbaf17fcfa63d65" name="a68ad17ee5b7475decfbaf17fcfa63d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ad17ee5b7475decfbaf17fcfa63d65">&#9670;&nbsp;</a></span>to_surface_mesh_wrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; to_surface_mesh_wrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap a legacy mesh object as a surface mesh object. </p>
<p >The mesh scalar &amp; index types must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object to convert. The mesh object must be a lvalue reference (no temporary).</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Output mesh scalar type. Must be either float or double. </td></tr>
    <tr><td class="paramname">Index</td><td>Output mesh index type. Must be either uint32_t or uint64_t. </td></tr>
    <tr><td class="paramname">MeshType</td><td>Input mesh type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New mesh object. </dd></dl>

</div>
</div>
<a id="ac349d354b36d62bc2efeb93dd2b7f078" name="ac349d354b36d62bc2efeb93dd2b7f078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac349d354b36d62bc2efeb93dd2b7f078">&#9670;&nbsp;</a></span>to_legacy_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; to_legacy_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a surface mesh object to a legacy mesh object. </p>
<p >The mesh must be a regular mesh object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> object to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>Output mesh type. </td></tr>
    <tr><td class="paramname">Scalar</td><td>Input mesh scalar type. Must be either float or double. </td></tr>
    <tr><td class="paramname">Index</td><td>Input mesh index type. Must be either uint32_t or uint64_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New mesh object. </dd></dl>

</div>
</div>
<a id="ad4d4b75c350742efbcde9bab3781edcf" name="ad4d4b75c350742efbcde9bab3781edcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d4b75c350742efbcde9bab3781edcf">&#9670;&nbsp;</a></span>orient_outward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void orient_outward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">lagrange::Mesh</a>&lt; VertexArray, FacetArray &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>positive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orient the facets of a mesh so that the signed volume of each connected component is positive or negative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> whose facets needs to be re-oriented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">positive</td><td>Orient to have positive signed volume.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VertexArray</td><td>Type of vertex array. </td></tr>
    <tr><td class="paramname">FacetArray</td><td>Type of facet array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1bc8764fc5a64c99f00713d7b034580" name="ac1bc8764fc5a64c99f00713d7b034580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1bc8764fc5a64c99f00713d7b034580">&#9670;&nbsp;</a></span>segment_segment_squared_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto segment_segment_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>U0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>U1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>closest_pointU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>closest_pointV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambdaU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambdaV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ScalarOf&lt;PointType&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the squared distance between two N-d line segments, and the closest pair of points whose separation is this distance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">U0</td><td>first extremity of the first segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U1</td><td>second extremity of the first segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V0</td><td>first extremity of the second segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>second extremity of the second segment </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest_pointU</td><td>the closest point on segment [<code>U0</code>, <code>U1</code>] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest_pointV</td><td>the closest point on segment [<code>V0</code>, <code>V1</code>] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lambdaU</td><td>barycentric coordinate of the closest point relative to [<code>U0</code>, U1] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lambdaV</td><td>barycentric coordinate of the closest point relative to [<code>V0</code>, V1]</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>the class that represents the points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the squared distance between the segments [<code>U0</code>, <code>U1</code>] and [<code>V0</code>, <code>V1</code>]</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Adapted from Real-Time Collision Detection by Christer Ericson, published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc. This function was modified for use by Siddhartha Chaudhuri in the Thea library, from where this version was taken on 28 Sep 2022. All modifications beyond Thea are Copyright 2022 Adobe. </dd></dl>

</div>
</div>
<a id="a7192854f01f61a0e17c45e411265b648" name="a7192854f01f61a0e17c45e411265b648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7192854f01f61a0e17c45e411265b648">&#9670;&nbsp;</a></span>select_facets_in_frustum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool select_facets_in_frustum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>n0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>n3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Point3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>greedy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select all facets that intersect the cone/frustrum bounded by 4 planes defined by (n_i, p_i), where n_i is the plane normal and p_i is a point on the plane. </p>
<p >When <code>greedy</code> is true, return as soon as the first facet is selected.</p>
<p >When <code>greedy</code> is false, check all facets and store the result in a facet attribute named <code>is_selected</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ni</td><td>normal vector of plane i. </td></tr>
    <tr><td class="paramname">pi</td><td>a point on plane i. </td></tr>
    <tr><td class="paramname">greedy</td><td>whether to stop as soon as the first facet is selected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether any facet is selected. </dd></dl>

</div>
</div>
<a id="a5e74586d94cbe3ec2e2e361b66d01faf" name="a5e74586d94cbe3ec2e2e361b66d01faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e74586d94cbe3ec2e2e361b66d01faf">&#9670;&nbsp;</a></span>thicken_and_close_mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; thicken_and_close_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>input_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;, 3, 1 &gt;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td>
          <td class="paramname"><em>offset_amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td>
          <td class="paramname"><em>mirror_amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::Index&#160;</td>
          <td class="paramname"><em>num_segments</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thicken a mesh by offsetting it in a fixed direction. </p>
<p >Close the shape into a thick 3D solid. The mesh is assumed to have a disk topology. Input mesh vertices are duplicated and projected onto a target plane and can be additionally mirrored wrt to this plane.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_mesh</td><td>Input mesh, assumed to have a disk topology. Must have edge information included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>Offset direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset_amount</td><td>Coordinate along the direction vector to project onto. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mirror_amount</td><td>Mirror amount (between -1 and 1). -1 means fully mirrored, 0 means flat region, and 1 means fully translated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>Number of segments the stitched are should be split in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mesh of the offset and closed surface. </dd></dl>

</div>
</div>
<a id="a392649a5d76a59dc2500d9b9d094c0ea" name="a392649a5d76a59dc2500d9b9d094c0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392649a5d76a59dc2500d9b9d094c0ea">&#9670;&nbsp;</a></span>thicken_and_close_mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; thicken_and_close_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>input_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;&#160;</td>
          <td class="paramname"><em>offset_amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::Index&#160;</td>
          <td class="paramname"><em>num_segments</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thicken a mesh vertices along normals, and close the shape into a thick 3D solid. </p>
<p >This function makes no assumption on the shape's topology and will apply its effect nicely to any surface, even those that have no holes (e.g. a solid sphere will become a hollow sphere with a solid shell).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_mesh</td><td>Input mesh. Must have edge information included. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset_amount</td><td>Coordinate along the direction vector to project onto. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>Number of segments the stitched are should be split in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mesh of the offset and closed surface. </dd></dl>

</div>
</div>
<a id="a256e7ab23f324bc2f7fb5fd977405932" name="a256e7ab23f324bc2f7fb5fd977405932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256e7ab23f324bc2f7fb5fd977405932">&#9670;&nbsp;</a></span>compute_euler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compute_euler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Euler characteristic of a mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type of the mesh. </td></tr>
    <tr><td class="paramname">Index</td><td>The index type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Euler characteristic of the mesh. </dd></dl>

</div>
</div>
<a id="a8c7a15cae60d68a94bac4068de177b4a" name="a8c7a15cae60d68a94bac4068de177b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7a15cae60d68a94bac4068de177b4a">&#9670;&nbsp;</a></span>is_vertex_manifold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_vertex_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a mesh is vertex-manifold. </p>
<p >A mesh is vertex-manifold if and only if the one-ring neighborhood of each vertex is of disc topology. I.e. The boundary of the 1-ring neighborhood is a simple loop for interior vertices, and a simple chain for boundary vertices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type of the mesh. </td></tr>
    <tr><td class="paramname">Index</td><td>The index type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the mesh is vertex-manifold. </dd></dl>
<p >&lt; initial value of the result.</p>
<p >&lt; initial value of the result.</p>

</div>
</div>
<a id="a52aec6a70ed2240fe977f81f393d1259" name="a52aec6a70ed2240fe977f81f393d1259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52aec6a70ed2240fe977f81f393d1259">&#9670;&nbsp;</a></span>is_edge_manifold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_edge_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a mesh is edge-manifold. </p>
<p >A mesh is edge-manifold if and only if every interior edge is incident to exactly two facets, and every boundary edge is incident to exactly one facet.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type of the mesh. </td></tr>
    <tr><td class="paramname">Index</td><td>The index type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the mesh is edge-manifold. </dd></dl>

</div>
</div>
<a id="a4b70a6e7c30cd0524e2fc2490f280b69" name="a4b70a6e7c30cd0524e2fc2490f280b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b70a6e7c30cd0524e2fc2490f280b69">&#9670;&nbsp;</a></span>is_manifold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a mesh is both vertex-manifold and edge-manifold. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type of the mesh. </td></tr>
    <tr><td class="paramname">Index</td><td>The index type of the mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the mesh is both vertex-manifold and edge-manifold. </dd></dl>

</div>
</div>
<a id="adc37a853021fc87c80d53f7cb0a21ae5" name="adc37a853021fc87c80d53f7cb0a21ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc37a853021fc87c80d53f7cb0a21ae5">&#9670;&nbsp;</a></span>chain_directed_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlagrange_1_1_chain_edges_result.html">ChainEdgesResult</a>&lt; Index &gt; chain_directed_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_chain_edges_options.html">ChainEdgesOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chain a set of directed edges into loops and chains. </p>
<p >This methods guarantees that all simple loops and simple chains are extracted. This method will also iteratively extract all ear loops and hanging chains.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>The Index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>The input set of edges. </td></tr>
    <tr><td class="paramname">options</td><td>Options controlling the behavior of this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of loops and chains extracted from the input edge set.</dd></dl>
<p>Both loops and chains are stored as an array of edges indices if <code>options.output_edge_index</code> is true, otherwise, they are an array of vertex indices.</p>
<p >If <code>options.output_edge_vertex</code> is false and <code>options.close_loop_with_identical_vertices</code> is true, the first and last vertices of a loop is identical.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelagrange.html#a85a228fdc8080ef275f963576cd9b4c9" title="Chain a set of undirected edges into loops and chains.">chain_undirected_edges</a> </dd></dl>

</div>
</div>
<a id="a85a228fdc8080ef275f963576cd9b4c9" name="a85a228fdc8080ef275f963576cd9b4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a228fdc8080ef275f963576cd9b4c9">&#9670;&nbsp;</a></span>chain_undirected_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlagrange_1_1_chain_edges_result.html">ChainEdgesResult</a>&lt; Index &gt; chain_undirected_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlagrange_1_1_chain_edges_options.html">ChainEdgesOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chain a set of undirected edges into loops and chains. </p>
<p >This methods guarantees that all simple loops and simple chains are extracted. This method will also iteratively extract all ear loops and hanging chains.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>The Index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>The input set of edges. </td></tr>
    <tr><td class="paramname">options</td><td>Options controlling the behavior of this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of loops and chains extracted from the input edge set.</dd></dl>
<p>Both loops and chains are stored as an array of edges indices if <code>options.output_edge_index</code> is true, otherwise, they are an array of vertex indices.</p>
<p >If <code>options.output_edge_vertex</code> is false and <code>options.close_loop_with_identical_vertices</code> is true, the first and last vertices of a loop is identical.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacelagrange.html#adc37a853021fc87c80d53f7cb0a21ae5" title="Chain a set of directed edges into loops and chains.">chain_directed_edges</a> </dd></dl>

</div>
</div>
<a id="ac2b272a2ed8be41e680505c957dceac2" name="ac2b272a2ed8be41e680505c957dceac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b272a2ed8be41e680505c957dceac2">&#9670;&nbsp;</a></span>cos_angle_between()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar cos_angle_between </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the cosine of the angle between two 3d vectors. </p>
<p >Assumes both vectors are normalized (unit vector). </p>

</div>
</div>
<a id="aa1d014fa874bb0ee627f729b81ba3065" name="aa1d014fa874bb0ee627f729b81ba3065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d014fa874bb0ee627f729b81ba3065">&#9670;&nbsp;</a></span>project_on_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; project_on_line </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project the vector v1 on the line defined by its vector v2. </p>
<p >Assumes the vector v2 is normalized (unit vector). </p>

</div>
</div>
<a id="a774928c90a837bc834efbda24e4cf62a" name="a774928c90a837bc834efbda24e4cf62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774928c90a837bc834efbda24e4cf62a">&#9670;&nbsp;</a></span>project_on_plane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; project_on_plane </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project the vector on the plane defined by its normal n. </p>
<p >Assumes the normal n is a unit vector. </p>

</div>
</div>
<a id="a422d9aff461fac92045512a733336e16" name="a422d9aff461fac92045512a733336e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422d9aff461fac92045512a733336e16">&#9670;&nbsp;</a></span>projected_cos_angle_between()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar projected_cos_angle_between </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the angle between the vectors v1 and v2 projected on the plane defined by its normal n. </p>
<p >Assumes the normal n is a unit vector. </p>

</div>
</div>
<a id="a53daef46b0377ad840fd8f74f4d2d942" name="a53daef46b0377ad840fd8f74f4d2d942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53daef46b0377ad840fd8f74f4d2d942">&#9670;&nbsp;</a></span>projected_angle_between()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar projected_angle_between </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, _Rows, _Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the angle between the vectors v1 and v2 projected on the plane defined by its normal n. </p>
<p >Assumes the normal n is a unit vector. </p>

</div>
</div>
<a id="a98c72eb4eeff6cc742a7bfbbbe6c9337" name="a98c72eb4eeff6cc742a7bfbbbe6c9337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c72eb4eeff6cc742a7bfbbbe6c9337">&#9670;&nbsp;</a></span>vector_between()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vector_between </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::Index&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MeshType::Index&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vector from v1 to v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>first vertex index (from). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>second vertex index (to)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 3D vector </dd></dl>

</div>
</div>
<a id="a14b0f2917fb3bd337e8bbe09d221f4e3" name="a14b0f2917fb3bd337e8bbe09d221f4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b0f2917fb3bd337e8bbe09d221f4e3">&#9670;&nbsp;</a></span>orthogonal_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void orthogonal_frame </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an orthogonal frame given a single vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>First vector of the frame. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>Second vector of the frame. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">z</td><td>Third vector of the frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Scalar type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9ae6ac12cb08b0c98d8cb28938dbe6a" name="ae9ae6ac12cb08b0c98d8cb28938dbe6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ae6ac12cb08b0c98d8cb28938dbe6a">&#9670;&nbsp;</a></span>point_on_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool point_on_segment </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a point lies exactly on a segment [a,b] using exact predicates. </p>
<p >If the points are collinear, each individual coordinate is examined to determine if the query point lies inside the segment or outside of it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Query point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First segment endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second segment endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>Point type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the query point lies exactly on the segment, False otherwise. </dd></dl>

</div>
</div>
<a id="a2140a37f0d569beaf4878f9ab100f84f" name="a2140a37f0d569beaf4878f9ab100f84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2140a37f0d569beaf4878f9ab100f84f">&#9670;&nbsp;</a></span>point_segment_squared_distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto point_segment_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>closest_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ScalarOf&lt;PointType&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the point closest to a given point in a nd segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>the query point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V0</td><td>first extremity of the segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>second extremity of the segment </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest_point</td><td>the point closest to <code>point</code> in the segment [<code>V0</code>, <code>V1</code>] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lambda0</td><td>barycentric coordinate of the closest point relative to <code>V0</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lambda1</td><td>barycentric coordinate of the closest point relative to <code>V1</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>the class that represents the points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the squared distance between the point and the segment [<code>V0</code>, <code>V1</code>] </dd></dl>

</div>
</div>
<a id="a2ec127acd481e2443483e8243de40ca5" name="a2ec127acd481e2443483e8243de40ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec127acd481e2443483e8243de40ca5">&#9670;&nbsp;</a></span>point_segment_squared_distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto point_segment_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ScalarOf&lt;PointType&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the point closest to a given point in a nd segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>the query point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V0</td><td>first extremity of the segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>second extremity of the segment</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>the class that represents the points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the squared distance between the point and the segment [<code>V0</code>, <code>V1</code>] </dd></dl>

</div>
</div>
<a id="aa226d603d77fc8036aaa59760a4067ff" name="aa226d603d77fc8036aaa59760a4067ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa226d603d77fc8036aaa59760a4067ff">&#9670;&nbsp;</a></span>point_triangle_squared_distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto point_triangle_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>closest_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarOf&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ScalarOf&lt;PointType&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the point closest to a given point in a nd triangle. </p>
<p >See <a href="http://www.geometrictools.com/LibMathematics/Distance/Distance.html">http://www.geometrictools.com/LibMathematics/Distance/Distance.html</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>the query point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V0</td><td>first vertex of the triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>second vertex of the triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V2</td><td>third vertex of the triangle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest_point</td><td>the point closest to <code>point</code> in the triangle (<code>V0</code>, <code>V1</code>, <code>V2</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lambda0</td><td>barycentric coordinate of the closest point relative to <code>V0</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lambda1</td><td>barycentric coordinate of the closest point relative to <code>V1</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lambda2</td><td>barycentric coordinate of the closest point relative to <code>V2</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>the class that represents the points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the squared distance between the point and the triangle (<code>V0</code>, <code>V1</code>, <code>V2</code>) </dd></dl>

</div>
</div>
<a id="a84b00ad408ddd582aaa24613f799aa65" name="a84b00ad408ddd582aaa24613f799aa65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b00ad408ddd582aaa24613f799aa65">&#9670;&nbsp;</a></span>point_triangle_squared_distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto point_triangle_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; PointType &gt; &amp;&#160;</td>
          <td class="paramname"><em>V2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ScalarOf&lt;PointType&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the squared distance between a point and a nd triangle. </p>
<p >See <a href="http://www.geometrictools.com/LibMathematics/Distance/Distance.html">http://www.geometrictools.com/LibMathematics/Distance/Distance.html</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>the query point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V0</td><td>first vertex of the triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>second vertex of the triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V2</td><td>third vertex of the triangle</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointType</td><td>the class that represents the points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the squared distance between the point and the triangle (<code>V0</code>, <code>V1</code>, <code>V2</code>) </dd></dl>

</div>
</div>
<a id="a158ad6f7a5217fcc67b5963f57d77ba9" name="a158ad6f7a5217fcc67b5963f57d77ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158ad6f7a5217fcc67b5963f57d77ba9">&#9670;&nbsp;</a></span>quad_area_2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar quad_area_2d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute 2D quad signed area. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b,c,d</td><td>Quad vertex coordinates in counterclockwise order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed area of the quad. </dd></dl>

</div>
</div>
<a id="a44f789cf2a823e2d86eb5721012008de" name="a44f789cf2a823e2d86eb5721012008de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f789cf2a823e2d86eb5721012008de">&#9670;&nbsp;</a></span>quad_area_3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar quad_area_3d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute 3D quad area. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b,c,d</td><td>Quad vertex coordinates in counterclockwise order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The area of the quad. </dd></dl>

</div>
</div>
<a id="ad6b4dc54ffcfd57bf369e3044f567467" name="ad6b4dc54ffcfd57bf369e3044f567467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b4dc54ffcfd57bf369e3044f567467">&#9670;&nbsp;</a></span>triangle_area_3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar triangle_area_3d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute 3D triangle area. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b,c</td><td>Triangle vertex coordinates in counterclockwise order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The area of the triangle. </dd></dl>

</div>
</div>
<a id="a49eca467681fb7600745af55571bd0f3" name="a49eca467681fb7600745af55571bd0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49eca467681fb7600745af55571bd0f3">&#9670;&nbsp;</a></span>triangle_area_2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar triangle_area_2d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute 2D triangle signed area. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b,c</td><td>Triangle vertex coordinates in counterclockwise order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed area of the triangle. </dd></dl>

</div>
</div>
<a id="aba6eab98907ea478e363a44023b4dd1a" name="aba6eab98907ea478e363a44023b4dd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6eab98907ea478e363a44023b4dd1a">&#9670;&nbsp;</a></span>triangle_orientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum lagrange::Orientation short triangle_orientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute orientation of a 2D triangle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b,c</td><td>2D coordinates of the triangle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>Orientation::Positive</code> if positively oriented. <code>Orientation::Negative</code> if negatively oriented. <code>Orientation::Zero</code> if the triangle is degenerate. </dd></dl>

</div>
</div>
<a id="ab63029c7c83fee8c6f3bf5de81e4353c" name="ab63029c7c83fee8c6f3bf5de81e4353c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63029c7c83fee8c6f3bf5de81e4353c">&#9670;&nbsp;</a></span>triangle_uv_distortion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar triangle_uv_distortion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt;&#160;</td>
          <td class="paramname"><em>V0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt;&#160;</td>
          <td class="paramname"><em>V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute uv distortion of a single triangle. </p>
<p >Let  be the mapping from the 3D triangle (V0, V1, V2) to the uv triangle (v0, v1, v2), and let J =  be its Jacobian. A distortion metric measures the amount of deviation from isotropic or conformal mapping. It can often be expressed concisely in terms of the singular values, (s0, s1) of J. Here are a list of supported distortion metrics:</p>
<ul>
<li>Dirichlet: s0*s0 + s1*s1</li>
<li>Inverse Dirichlet: 1/(s0*s0) + 1/(s1*s1)</li>
<li>Symmetric Dirichlet: s0*s0 + s1*s1 + 1/(s0*s0) + 1/(s1*s1)</li>
<li>MIPS: s0/s1 + s1/s0</li>
<li>Area ratio: s0*s1</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>While it is easy to express distortion measures in terms of s0 and s1, it is often computationally unstable or expensive to explicitly compute these singular values. Instead, this method computes the distortion measures geometrically.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">metric</td><td>The type of distortion metric to use. </td></tr>
    <tr><td class="paramname">Scalar</td><td>The scalar type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V0,V1,V2</td><td>The coordinates of the 3D triangle. </td></tr>
    <tr><td class="paramname">v0,v1,v2</td><td>The coordinates of the uv triangle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distortion measure of the uv mapping for this triangle. </dd></dl>

</div>
</div>
<a id="a8536342d5f43c6fd93cf888e97aa7873" name="a8536342d5f43c6fd93cf888e97aa7873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8536342d5f43c6fd93cf888e97aa7873">&#9670;&nbsp;</a></span>triangle_uv_distortion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar triangle_uv_distortion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt;&#160;</td>
          <td class="paramname"><em>V0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 3 &gt;&#160;</td>
          <td class="paramname"><em>V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar, 2 &gt;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-utils.html#gadab1480827f4522cbf1f9e1d4c28db91">DistortionMetric</a>&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute uv distortion of a single triangle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V0,V1,V2</td><td>The coordinates of the 3D triangle. </td></tr>
    <tr><td class="paramname">v0,v1,v2</td><td>The coordinates of the uv triangle. </td></tr>
    <tr><td class="paramname">metric</td><td>The distorsion metric to compute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distortion measure of the uv mapping for this triangle.</dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a4bae2866359c59894de874831cfcefbf" name="a4bae2866359c59894de874831cfcefbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bae2866359c59894de874831cfcefbf">&#9670;&nbsp;</a></span>to_degrees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar to_degrees </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>rad</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert radians to degrees. </p>
<p >Use either as to_degrees(x) or x * <a class="el" href="namespacelagrange.html#a4bae2866359c59894de874831cfcefbf" title="Convert radians to degrees.">to_degrees&lt;double&gt;()</a>; </p>

</div>
</div>
<a id="a1e117a8f5727d6603ce84044f11c1624" name="a1e117a8f5727d6603ce84044f11c1624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e117a8f5727d6603ce84044f11c1624">&#9670;&nbsp;</a></span>to_radians()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar to_radians </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>deg</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert degrees to radians. </p>
<p >Use either as to_degrees(x) or x * <a class="el" href="namespacelagrange.html#a4bae2866359c59894de874831cfcefbf" title="Convert radians to degrees.">to_degrees&lt;double&gt;()</a>; </p>

</div>
</div>
<a id="af340c73b9a59c952f039a0e458b517cb" name="af340c73b9a59c952f039a0e458b517cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af340c73b9a59c952f039a0e458b517cb">&#9670;&nbsp;</a></span>save_graph_off()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void save_graph_off </td>
          <td>(</td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a 2D undirected graph (V,E) using off format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Target filename path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V x 2 array of vertices positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E x 2 array of edge indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>Vertex array type. </td></tr>
    <tr><td class="paramname">DerivedE</td><td>Edge array type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27242b785bed719baa0d9e79f341aa72" name="a27242b785bed719baa0d9e79f341aa72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27242b785bed719baa0d9e79f341aa72">&#9670;&nbsp;</a></span>save_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void save_graph </td>
          <td>(</td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a 2D undirected graph (V,E) based on filename extension. </p>
<p >For now only .off is supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Target filename path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V x 2 array of vertices positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E x 2 array of edge indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>Vertex array type. </td></tr>
    <tr><td class="paramname">DerivedE</td><td>Edge array type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelagrange.html">lagrange</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>

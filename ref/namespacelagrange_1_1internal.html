<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lagrange: lagrange::internal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lagrange
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelagrange.html">lagrange</a></li><li class="navelem"><a class="el" href="namespacelagrange_1_1internal.html">internal</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">lagrange::internal Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>nullptr_t, size_t, ptrdiff_t basic_ostream bad_weak_ptr extent, remove_extent, is_array, is_void, common_type move, forward, swap  
<a href="namespacelagrange_1_1internal.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlagrange_1_1internal_1_1_bucket_sort_result.html">BucketSortResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket sort result object.  <a href="structlagrange_1_1internal_1_1_bucket_sort_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1control__block.html">control_block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOT implemented: custom allocator support.  <a href="classlagrange_1_1internal_1_1control__block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1control__block__base.html">control_block_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1default__delete.html">default_delete</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1default__delete_3_01_t_0f_0e_4.html">default_delete&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1ptr.html">ptr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOT implemented: custom allocator support.  <a href="classlagrange_1_1internal_1_1shared__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr__access.html">shared_ptr_access</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr__access_3_01_t_00_01false_00_01true_01_4.html">shared_ptr_access&lt; T, false, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr__access_3_01_t_00_01true_00_01false_01_4.html">shared_ptr_access&lt; T, true, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlagrange_1_1internal_1_1weak__ptr.html">weak_ptr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad55f96a0a38571fab295b3dcfa5ccaac"><td class="memItemLeft" align="right" valign="top"><a id="ad55f96a0a38571fab295b3dcfa5ccaac" name="ad55f96a0a38571fab295b3dcfa5ccaac"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>ResetToDefault</b> { <b>Yes</b>
, <b>No</b>
 }</td></tr>
<tr class="separator:ad55f96a0a38571fab295b3dcfa5ccaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a75620c5bbf993b0bfa83ed00aa5d225e"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a75620c5bbf993b0bfa83ed00aa5d225e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a75620c5bbf993b0bfa83ed00aa5d225e">compute_triangle_areas</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh) -&gt; AttributeArrayOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;</td></tr>
<tr class="memdesc:a75620c5bbf993b0bfa83ed00aa5d225e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the triangle areas.  <a href="namespacelagrange_1_1internal.html#a75620c5bbf993b0bfa83ed00aa5d225e">More...</a><br /></td></tr>
<tr class="separator:a75620c5bbf993b0bfa83ed00aa5d225e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5614fafdf0f5351cb9a4e1c9ef289007"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt; </td></tr>
<tr class="memitem:a5614fafdf0f5351cb9a4e1c9ef289007"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a5614fafdf0f5351cb9a4e1c9ef289007">compute_quad_areas</a> (const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;mesh) -&gt; AttributeArrayOf&lt; <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &gt;</td></tr>
<tr class="memdesc:a5614fafdf0f5351cb9a4e1c9ef289007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the quad areas.  <a href="namespacelagrange_1_1internal.html#a5614fafdf0f5351cb9a4e1c9ef289007">More...</a><br /></td></tr>
<tr class="separator:a5614fafdf0f5351cb9a4e1c9ef289007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1094c838f626d32cbbd591b269c17aba"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a1094c838f626d32cbbd591b269c17aba">to_string</a> (<a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> element)</td></tr>
<tr class="memdesc:a1094c838f626d32cbbd591b269c17aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of an attribute element type.  <a href="namespacelagrange_1_1internal.html#a1094c838f626d32cbbd591b269c17aba">More...</a><br /></td></tr>
<tr class="separator:a1094c838f626d32cbbd591b269c17aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ef58c4f14fd3da88c3ddfb8541c1fb"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#ad1ef58c4f14fd3da88c3ddfb8541c1fb">to_string</a> (<a class="el" href="group__group-surfacemesh-attr.html#ga35b5eb426384b257452ee0ffdb732c27">AttributeUsage</a> usage)</td></tr>
<tr class="memdesc:ad1ef58c4f14fd3da88c3ddfb8541c1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of an attribute usage.  <a href="namespacelagrange_1_1internal.html#ad1ef58c4f14fd3da88c3ddfb8541c1fb">More...</a><br /></td></tr>
<tr class="separator:ad1ef58c4f14fd3da88c3ddfb8541c1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164efbffcd1a35b7336c33a4706fd70b"><td class="memTemplParams" colspan="2"><a id="a164efbffcd1a35b7336c33a4706fd70b" name="a164efbffcd1a35b7336c33a4706fd70b"></a>
template&lt;typename DerivedF , typename DerivedFF , typename DerivedC &gt; </td></tr>
<tr class="memitem:a164efbffcd1a35b7336c33a4706fd70b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bfs_orient</b> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;FF, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="separator:a164efbffcd1a35b7336c33a4706fd70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318ef64371a044ade0e7bf035cd67490"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a318ef64371a044ade0e7bf035cd67490"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a318ef64371a044ade0e7bf035cd67490">dijkstra</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt; seed_vertices, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar &gt; seed_vertex_dist, Scalar radius, const <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; Scalar(Index, Index)&gt; &amp;dist, const <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; bool(Index, Scalar)&gt; &amp;process)</td></tr>
<tr class="memdesc:a318ef64371a044ade0e7bf035cd67490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the mesh based on Dijkstra's algorithm with customized distance metric and process functions.  <a href="namespacelagrange_1_1internal.html#a318ef64371a044ade0e7bf035cd67490">More...</a><br /></td></tr>
<tr class="separator:a318ef64371a044ade0e7bf035cd67490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d5ac709de31cf2ebd9e4fb8ea16ea5"><td class="memTemplParams" colspan="2"><a id="a75d5ac709de31cf2ebd9e4fb8ea16ea5" name="a75d5ac709de31cf2ebd9e4fb8ea16ea5"></a>
template&lt;typename DerivedV , typename DerivedF , typename DeriveddblA &gt; </td></tr>
<tr class="memitem:a75d5ac709de31cf2ebd9e4fb8ea16ea5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>doublearea</b> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DeriveddblA &gt; &amp;dblA)</td></tr>
<tr class="separator:a75d5ac709de31cf2ebd9e4fb8ea16ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c39bc37d94110b14f4792bfdc7bef3"><td class="memTemplParams" colspan="2">template&lt;typename ExpectedValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a26c39bc37d94110b14f4792bfdc7bef3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a26c39bc37d94110b14f4792bfdc7bef3">find_matching_attribute</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> expected_element, <a class="el" href="group__group-surfacemesh-attr.html#ga35b5eb426384b257452ee0ffdb732c27">AttributeUsage</a> expected_usage, size_t expected_channels)</td></tr>
<tr class="memdesc:a26c39bc37d94110b14f4792bfdc7bef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an attribute with a given name, ensuring the usage and element type match an expected target.  <a href="namespacelagrange_1_1internal.html#a26c39bc37d94110b14f4792bfdc7bef3">More...</a><br /></td></tr>
<tr class="separator:a26c39bc37d94110b14f4792bfdc7bef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3d205c163fe8029969edecca3fb3f3"><td class="memTemplParams" colspan="2">template&lt;typename ExpectedValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a8a3d205c163fe8029969edecca3fb3f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a8a3d205c163fe8029969edecca3fb3f3">find_attribute</a> (const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> expected_element, <a class="el" href="group__group-surfacemesh-attr.html#ga35b5eb426384b257452ee0ffdb732c27">AttributeUsage</a> expected_usage, size_t expected_channels)</td></tr>
<tr class="memdesc:a8a3d205c163fe8029969edecca3fb3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an attribute with a given name, ensuring the usage and element type match an expected target.  <a href="namespacelagrange_1_1internal.html#a8a3d205c163fe8029969edecca3fb3f3">More...</a><br /></td></tr>
<tr class="separator:a8a3d205c163fe8029969edecca3fb3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcff88ab81e30f4cd399e5fd3fb2ab2"><td class="memTemplParams" colspan="2">template&lt;typename ExpectedValueType , typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:adbcff88ab81e30f4cd399e5fd3fb2ab2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#adbcff88ab81e30f4cd399e5fd3fb2ab2">find_or_create_attribute</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, std::string_view name, <a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a> expected_element, <a class="el" href="group__group-surfacemesh-attr.html#ga35b5eb426384b257452ee0ffdb732c27">AttributeUsage</a> expected_usage, size_t expected_channels, ResetToDefault reset_tag)</td></tr>
<tr class="memdesc:adbcff88ab81e30f4cd399e5fd3fb2ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either retrieve or create an attribute with a prescribed name, element type and usage.  <a href="namespacelagrange_1_1internal.html#adbcff88ab81e30f4cd399e5fd3fb2ab2">More...</a><br /></td></tr>
<tr class="separator:adbcff88ab81e30f4cd399e5fd3fb2ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f31f304c06ec267113e8de9bda65c8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedK &gt; </td></tr>
<tr class="memitem:a42f31f304c06ec267113e8de9bda65c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a42f31f304c06ec267113e8de9bda65c8">internal_angles</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;vertices, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;facets, Eigen::PlainObjectBase&lt; DerivedK &gt; &amp;angles)</td></tr>
<tr class="memdesc:a42f31f304c06ec267113e8de9bda65c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute internal angles for a triangle mesh.  <a href="namespacelagrange_1_1internal.html#a42f31f304c06ec267113e8de9bda65c8">More...</a><br /></td></tr>
<tr class="separator:a42f31f304c06ec267113e8de9bda65c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa878c7ef9728c61631ce0998c23b9b11"><td class="memTemplParams" colspan="2"><a id="aa878c7ef9728c61631ce0998c23b9b11" name="aa878c7ef9728c61631ce0998c23b9b11"></a>
template&lt;typename DerivedF , typename DerivedC , typename AScalar &gt; </td></tr>
<tr class="memitem:aa878c7ef9728c61631ce0998c23b9b11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>orientable_patches</b> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::SparseMatrix&lt; AScalar &gt; &amp;A)</td></tr>
<tr class="separator:aa878c7ef9728c61631ce0998c23b9b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb48b6c9c79ac5367563750ada2c7929"><td class="memTemplParams" colspan="2"><a id="afb48b6c9c79ac5367563750ada2c7929" name="afb48b6c9c79ac5367563750ada2c7929"></a>
template&lt;typename DerivedF , typename DerivedC &gt; </td></tr>
<tr class="memitem:afb48b6c9c79ac5367563750ada2c7929"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>orientable_patches</b> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="separator:afb48b6c9c79ac5367563750ada2c7929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d86607b5fc6de15e582cab32d69840"><td class="memTemplParams" colspan="2"><a id="a48d86607b5fc6de15e582cab32d69840" name="a48d86607b5fc6de15e582cab32d69840"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a48d86607b5fc6de15e582cab32d69840"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_shared</b> (<a class="el" href="struct_args.html">Args</a> &amp;&amp;... args)</td></tr>
<tr class="memdesc:a48d86607b5fc6de15e582cab32d69840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html" title="NOT implemented: custom allocator support.">shared_ptr</a> that manages a new object. <br /></td></tr>
<tr class="separator:a48d86607b5fc6de15e582cab32d69840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac983516e9c667f7c38e5a29acd05fda8"><td class="memTemplParams" colspan="2"><a id="ac983516e9c667f7c38e5a29acd05fda8" name="ac983516e9c667f7c38e5a29acd05fda8"></a>
template&lt;typename T , typename A , typename... Args&gt; </td></tr>
<tr class="memitem:ac983516e9c667f7c38e5a29acd05fda8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>allocate_shared</b> (const A &amp;a, <a class="el" href="struct_args.html">Args</a> &amp;&amp;... args)=delete</td></tr>
<tr class="separator:ac983516e9c667f7c38e5a29acd05fda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b3d9be30d2364d90d3a79f8040562a"><td class="memTemplParams" colspan="2"><a id="a51b3d9be30d2364d90d3a79f8040562a" name="a51b3d9be30d2364d90d3a79f8040562a"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a51b3d9be30d2364d90d3a79f8040562a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;sp1, const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;sp2)</td></tr>
<tr class="memdesc:a51b3d9be30d2364d90d3a79f8040562a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator == overloading. <br /></td></tr>
<tr class="separator:a51b3d9be30d2364d90d3a79f8040562a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d627724b0d3648e7524cefcf0859f71"><td class="memTemplParams" colspan="2"><a id="a7d627724b0d3648e7524cefcf0859f71" name="a7d627724b0d3648e7524cefcf0859f71"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d627724b0d3648e7524cefcf0859f71"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;sp, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a7d627724b0d3648e7524cefcf0859f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2aada2dab72be8fa84872ae0d239d5"><td class="memTemplParams" colspan="2"><a id="abb2aada2dab72be8fa84872ae0d239d5" name="abb2aada2dab72be8fa84872ae0d239d5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abb2aada2dab72be8fa84872ae0d239d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (std::nullptr_t, const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;sp) noexcept</td></tr>
<tr class="separator:abb2aada2dab72be8fa84872ae0d239d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae513f6584104034f265c6f3caf564810"><td class="memTemplParams" colspan="2"><a id="ae513f6584104034f265c6f3caf564810" name="ae513f6584104034f265c6f3caf564810"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae513f6584104034f265c6f3caf564810"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;sp1, const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;sp2)</td></tr>
<tr class="memdesc:ae513f6584104034f265c6f3caf564810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator != overloading. <br /></td></tr>
<tr class="separator:ae513f6584104034f265c6f3caf564810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e79dc757ca02068edab9abe4aa88e74"><td class="memTemplParams" colspan="2"><a id="a3e79dc757ca02068edab9abe4aa88e74" name="a3e79dc757ca02068edab9abe4aa88e74"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3e79dc757ca02068edab9abe4aa88e74"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;sp, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a3e79dc757ca02068edab9abe4aa88e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad381ca889691248956af1477f0302cce"><td class="memTemplParams" colspan="2"><a id="ad381ca889691248956af1477f0302cce" name="ad381ca889691248956af1477f0302cce"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad381ca889691248956af1477f0302cce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (std::nullptr_t, const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;sp) noexcept</td></tr>
<tr class="separator:ad381ca889691248956af1477f0302cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759519f1112bbc9f87c5a6e9a2520e78"><td class="memTemplParams" colspan="2"><a id="a759519f1112bbc9f87c5a6e9a2520e78" name="a759519f1112bbc9f87c5a6e9a2520e78"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a759519f1112bbc9f87c5a6e9a2520e78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;sp1, <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt; &amp;sp2)</td></tr>
<tr class="memdesc:a759519f1112bbc9f87c5a6e9a2520e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps with another <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html" title="NOT implemented: custom allocator support.">shared_ptr</a>. <br /></td></tr>
<tr class="separator:a759519f1112bbc9f87c5a6e9a2520e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6baf8f3d3d83d378d7ab71f80b445793"><td class="memTemplParams" colspan="2"><a id="a6baf8f3d3d83d378d7ab71f80b445793" name="a6baf8f3d3d83d378d7ab71f80b445793"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a6baf8f3d3d83d378d7ab71f80b445793"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>static_pointer_cast</b> (const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;sp) noexcept</td></tr>
<tr class="separator:a6baf8f3d3d83d378d7ab71f80b445793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087a431b81c73f799a9474a7215e5f5a"><td class="memTemplParams" colspan="2"><a id="a087a431b81c73f799a9474a7215e5f5a" name="a087a431b81c73f799a9474a7215e5f5a"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a087a431b81c73f799a9474a7215e5f5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>const_pointer_cast</b> (const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;sp) noexcept</td></tr>
<tr class="separator:a087a431b81c73f799a9474a7215e5f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26770dc6ae8003560302d54204fbacfc"><td class="memTemplParams" colspan="2"><a id="a26770dc6ae8003560302d54204fbacfc" name="a26770dc6ae8003560302d54204fbacfc"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a26770dc6ae8003560302d54204fbacfc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dynamic_pointer_cast</b> (const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;sp) noexcept</td></tr>
<tr class="separator:a26770dc6ae8003560302d54204fbacfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae216efaf5ff4631b1f8b38ae2e0eeb62"><td class="memTemplParams" colspan="2"><a id="ae216efaf5ff4631b1f8b38ae2e0eeb62" name="ae216efaf5ff4631b1f8b38ae2e0eeb62"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae216efaf5ff4631b1f8b38ae2e0eeb62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reinterpret_pointer_cast</b> (const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; U &gt; &amp;sp) noexcept</td></tr>
<tr class="separator:ae216efaf5ff4631b1f8b38ae2e0eeb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d21645fd2bd1ee784c4c56d258aec47"><td class="memTemplParams" colspan="2"><a id="a6d21645fd2bd1ee784c4c56d258aec47" name="a6d21645fd2bd1ee784c4c56d258aec47"></a>
template&lt;class E , class T , class Y &gt; </td></tr>
<tr class="memitem:a6d21645fd2bd1ee784c4c56d258aec47"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; E, T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::basic_ostream&lt; E, T &gt; &amp;os, const <a class="el" href="classlagrange_1_1internal_1_1shared__ptr.html">shared_ptr</a>&lt; Y &gt; &amp;sp)</td></tr>
<tr class="separator:a6d21645fd2bd1ee784c4c56d258aec47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415445505ef9233ee7e3c0b99f4622e4"><td class="memTemplParams" colspan="2"><a id="a415445505ef9233ee7e3c0b99f4622e4" name="a415445505ef9233ee7e3c0b99f4622e4"></a>
template&lt;typename DerivedX , typename DerivedIX &gt; </td></tr>
<tr class="memitem:a415445505ef9233ee7e3c0b99f4622e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sortrows</b> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const bool ascending, Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;Y, Eigen::PlainObjectBase&lt; DerivedIX &gt; &amp;IX)</td></tr>
<tr class="separator:a415445505ef9233ee7e3c0b99f4622e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e031946bcdeb31606ad781d81b0db11"><td class="memTemplParams" colspan="2"><a id="a4e031946bcdeb31606ad781d81b0db11" name="a4e031946bcdeb31606ad781d81b0db11"></a>
template&lt;typename DerivedX &gt; </td></tr>
<tr class="memitem:a4e031946bcdeb31606ad781d81b0db11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sortrows</b> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const bool ascending, Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;Y)</td></tr>
<tr class="separator:a4e031946bcdeb31606ad781d81b0db11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2448028bee21427c93b0ab7d1e3578"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a6f2448028bee21427c93b0ab7d1e3578"><td class="memTemplItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a6f2448028bee21427c93b0ab7d1e3578">string_from_scalar</a> ()</td></tr>
<tr class="memdesc:a6f2448028bee21427c93b0ab7d1e3578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a human-readable string from any supported attribute value type.  <a href="namespacelagrange_1_1internal.html#a6f2448028bee21427c93b0ab7d1e3578">More...</a><br /></td></tr>
<tr class="separator:a6f2448028bee21427c93b0ab7d1e3578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3e4205a0420da13f1eee41281179c9"><td class="memTemplParams" colspan="2"><a id="a1a3e4205a0420da13f1eee41281179c9" name="a1a3e4205a0420da13f1eee41281179c9"></a>
template&lt;typename DerivedA , typename DerivedC , typename DerivedIA , typename DerivedIC &gt; </td></tr>
<tr class="memitem:a1a3e4205a0420da13f1eee41281179c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unique_rows</b> (const Eigen::DenseBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedIA &gt; &amp;IA, Eigen::PlainObjectBase&lt; DerivedIC &gt; &amp;IC)</td></tr>
<tr class="separator:a1a3e4205a0420da13f1eee41281179c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab791c4d7d82e249e56c4f008864389"><td class="memTemplParams" colspan="2"><a id="a9ab791c4d7d82e249e56c4f008864389" name="a9ab791c4d7d82e249e56c4f008864389"></a>
template&lt;typename DerivedA , typename DerivedC , typename Derivedcounts &gt; </td></tr>
<tr class="memitem:a9ab791c4d7d82e249e56c4f008864389"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vertex_components</b> (const Eigen::SparseCompressedBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; Derivedcounts &gt; &amp;counts)</td></tr>
<tr class="separator:a9ab791c4d7d82e249e56c4f008864389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d2dc4586fa83f4341b9f525ed90384"><td class="memTemplParams" colspan="2"><a id="aa1d2dc4586fa83f4341b9f525ed90384" name="aa1d2dc4586fa83f4341b9f525ed90384"></a>
template&lt;typename DerivedA , typename DerivedC &gt; </td></tr>
<tr class="memitem:aa1d2dc4586fa83f4341b9f525ed90384"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vertex_components</b> (const Eigen::SparseCompressedBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="separator:aa1d2dc4586fa83f4341b9f525ed90384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e4a61e1667955adfabd183eb47a81f"><td class="memTemplParams" colspan="2"><a id="ad7e4a61e1667955adfabd183eb47a81f" name="ad7e4a61e1667955adfabd183eb47a81f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7e4a61e1667955adfabd183eb47a81f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classlagrange_1_1internal_1_1weak__ptr.html">weak_ptr</a>&lt; T &gt; &amp;wp1, <a class="el" href="classlagrange_1_1internal_1_1weak__ptr.html">weak_ptr</a>&lt; T &gt; &amp;wp2)</td></tr>
<tr class="memdesc:ad7e4a61e1667955adfabd183eb47a81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps with another <a class="el" href="classlagrange_1_1internal_1_1weak__ptr.html">weak_ptr</a>. <br /></td></tr>
<tr class="separator:ad7e4a61e1667955adfabd183eb47a81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da8227f5c8773ded8a4c9f18a906252"><td class="memTemplParams" colspan="2"><a id="a0da8227f5c8773ded8a4c9f18a906252" name="a0da8227f5c8773ded8a4c9f18a906252"></a>
template&lt;typename DerivedA , typename Index &gt; </td></tr>
<tr class="memitem:a0da8227f5c8773ded8a4c9f18a906252"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unique_rows</b> (const Eigen::DenseBase&lt; DerivedA &gt; &amp;A, Index &amp;num_unique_vertices, std::vector&lt; Index &gt; &amp;forward_mapping)</td></tr>
<tr class="separator:a0da8227f5c8773ded8a4c9f18a906252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1913ecb96655b3d75c05d2814d01e8d"><td class="memItemLeft" align="right" valign="top"><a id="ac1913ecb96655b3d75c05d2814d01e8d" name="ac1913ecb96655b3d75c05d2814d01e8d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>point_on_segment_2d</b> (Eigen::Vector2d p, Eigen::Vector2d a, Eigen::Vector2d b)</td></tr>
<tr class="separator:ac1913ecb96655b3d75c05d2814d01e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736a015927ef32c48b086e91011056a5"><td class="memItemLeft" align="right" valign="top"><a id="a736a015927ef32c48b086e91011056a5" name="a736a015927ef32c48b086e91011056a5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>point_on_segment_3d</b> (Eigen::Vector3d p, Eigen::Vector3d a, Eigen::Vector3d b)</td></tr>
<tr class="separator:a736a015927ef32c48b086e91011056a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad68547ec10b7b75ce31414844e5166"><td class="memTemplParams" colspan="2">template&lt;typename Index &gt; </td></tr>
<tr class="memitem:a0ad68547ec10b7b75ce31414844e5166"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlagrange_1_1internal_1_1_bucket_sort_result.html">BucketSortResult</a>&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a0ad68547ec10b7b75ce31414844e5166">bucket_sort</a> (<a class="el" href="classlagrange_1_1_disjoint_sets.html">DisjointSets</a>&lt; Index &gt; &amp;unified_indices, <a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; Index &gt; element_representative)</td></tr>
<tr class="memdesc:a0ad68547ec10b7b75ce31414844e5166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a bucket sort over a range of elements.  <a href="namespacelagrange_1_1internal.html#a0ad68547ec10b7b75ce31414844e5166">More...</a><br /></td></tr>
<tr class="separator:a0ad68547ec10b7b75ce31414844e5166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425b6670a3b7465f0b6a712b35f91b7c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a425b6670a3b7465f0b6a712b35f91b7c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, 3, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelagrange_1_1internal.html#a425b6670a3b7465f0b6a712b35f91b7c">compute_weighted_corner_normal</a> (<a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;mesh, Index ci, <a class="el" href="group__group-surfacemesh-utils.html#gaa88e833ed770762b02e187f0c2377d3d">NormalWeightingType</a> weighting=<a class="el" href="group__group-surfacemesh-utils.html#ggaa88e833ed770762b02e187f0c2377d3da84f023fc44b6b158de6ccc157c8dab06">NormalWeightingType::CornerTriangleArea</a>)</td></tr>
<tr class="memdesc:a425b6670a3b7465f0b6a712b35f91b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute weighted corner normal based on the weighting type.  <a href="namespacelagrange_1_1internal.html#a425b6670a3b7465f0b6a712b35f91b7c">More...</a><br /></td></tr>
<tr class="separator:a425b6670a3b7465f0b6a712b35f91b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >nullptr_t, size_t, ptrdiff_t basic_ostream bad_weak_ptr extent, remove_extent, is_array, is_void, common_type move, forward, swap </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a75620c5bbf993b0bfa83ed00aa5d225e" name="a75620c5bbf993b0bfa83ed00aa5d225e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75620c5bbf993b0bfa83ed00aa5d225e">&#9670;&nbsp;</a></span>compute_triangle_areas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto lagrange::internal::compute_triangle_areas </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> -&gt; AttributeArrayOf&lt;<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the triangle areas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Input triangle mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#F x 1 array of triangle areas. </dd></dl>

</div>
</div>
<a id="a5614fafdf0f5351cb9a4e1c9ef289007" name="a5614fafdf0f5351cb9a4e1c9ef289007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5614fafdf0f5351cb9a4e1c9ef289007">&#9670;&nbsp;</a></span>compute_quad_areas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto lagrange::internal::compute_quad_areas </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_mesh.html">MeshType</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> -&gt; AttributeArrayOf&lt;<a class="el" href="classlagrange_1_1_mesh.html">MeshType</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the quad areas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Input quad mesh.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#F x 1 array of quad areas. </dd></dl>

</div>
</div>
<a id="a1094c838f626d32cbbd591b269c17aba" name="a1094c838f626d32cbbd591b269c17aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1094c838f626d32cbbd591b269c17aba">&#9670;&nbsp;</a></span>to_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a>&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of an attribute element type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> element type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String representation. </dd></dl>

</div>
</div>
<a id="ad1ef58c4f14fd3da88c3ddfb8541c1fb" name="ad1ef58c4f14fd3da88c3ddfb8541c1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ef58c4f14fd3da88c3ddfb8541c1fb">&#9670;&nbsp;</a></span>to_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga35b5eb426384b257452ee0ffdb732c27">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>usage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of an attribute usage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">usage</td><td><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> usage.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String representation. </dd></dl>

</div>
</div>
<a id="a318ef64371a044ade0e7bf035cd67490" name="a318ef64371a044ade0e7bf035cd67490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318ef64371a044ade0e7bf035cd67490">&#9670;&nbsp;</a></span>dijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dijkstra </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Index &gt;&#160;</td>
          <td class="paramname"><em>seed_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; const Scalar &gt;&#160;</td>
          <td class="paramname"><em>seed_vertex_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; Scalar(Index, Index)&gt; &amp;&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1function__ref.html">function_ref</a>&lt; bool(Index, Scalar)&gt; &amp;&#160;</td>
          <td class="paramname"><em>process</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse the mesh based on Dijkstra's algorithm with customized distance metric and process functions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramname">seed_vertices</td><td>Seed vertices. </td></tr>
    <tr><td class="paramname">seed_vertex_dist</td><td>Initial distance to the seed vertices. </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of the search. Radius &lt;= 0 denotes the search is over the entire mesh. </td></tr>
    <tr><td class="paramname">dist</td><td>The distance metric. e.g. <code>d = dist(v0, v1)</code> </td></tr>
    <tr><td class="paramname">process</td><td>Call back function to process each new vertex reached. Its return type indicates whether the search is done. e.g. <code>done = process(vid, v_dist)</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26c39bc37d94110b14f4792bfdc7bef3" name="a26c39bc37d94110b14f4792bfdc7bef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c39bc37d94110b14f4792bfdc7bef3">&#9670;&nbsp;</a></span>find_matching_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> find_matching_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a>&#160;</td>
          <td class="paramname"><em>expected_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga35b5eb426384b257452ee0ffdb732c27">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>expected_usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expected_channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an attribute with a given name, ensuring the usage and element type match an expected target. </p>
<p >If the provided name is empty, the first attribute with matching properties is returned. If no such attribute is found, <a class="el" href="group__group-surfacemesh-attr.html#ga12026ae46c9a750646928c51111bfeb8" title="Invalid attribute id.">invalid_attribute_id()</a> is returned instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> where to look for attributes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Optional name of the attribute to find. If empty, the first matching attribute id will be returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_element</td><td>Expected element type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_usage</td><td>Expected attribute usage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_channels</td><td>Expected number of channels. If 0, then the check is skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpectedValueType</td><td>Expected attribute value type. </td></tr>
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> id of the first matching attribute. </dd></dl>

</div>
</div>
<a id="a8a3d205c163fe8029969edecca3fb3f3" name="a8a3d205c163fe8029969edecca3fb3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3d205c163fe8029969edecca3fb3f3">&#9670;&nbsp;</a></span>find_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> find_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a>&#160;</td>
          <td class="paramname"><em>expected_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga35b5eb426384b257452ee0ffdb732c27">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>expected_usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expected_channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an attribute with a given name, ensuring the usage and element type match an expected target. </p>
<p >This function does not allow empty names to be provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> where to look for attributes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Optional name of the attribute to find. If empty, the first matching attribute id will be returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_element</td><td>Expected element type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_usage</td><td>Expected attribute usage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_channels</td><td>Expected number of channels. If 0, then the check is skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpectedValueType</td><td>Expected attribute value type. </td></tr>
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> id of the first matching attribute. </dd></dl>

</div>
</div>
<a id="adbcff88ab81e30f4cd399e5fd3fb2ab2" name="adbcff88ab81e30f4cd399e5fd3fb2ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcff88ab81e30f4cd399e5fd3fb2ab2">&#9670;&nbsp;</a></span>find_or_create_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group-surfacemesh-attr.html#ga4d115376c2c766084ef808c837348fc3">AttributeId</a> find_or_create_attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga9d8ab208822bab9987e9652dda49d89a">AttributeElement</a>&#160;</td>
          <td class="paramname"><em>expected_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-attr.html#ga35b5eb426384b257452ee0ffdb732c27">AttributeUsage</a>&#160;</td>
          <td class="paramname"><em>expected_usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expected_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResetToDefault&#160;</td>
          <td class="paramname"><em>reset_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either retrieve or create an attribute with a prescribed name, element type and usage. </p>
<p >When retrieving an existing attribute, this function performs additional sanity checks, such as ensuring that the attribute usage is correctly set, that the number of channels is correct, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mesh</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> whose attribute to retrieve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the attribute to retrieve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_element</td><td>Expected element type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_usage</td><td>Expected attribute usage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_channels</td><td>Expected number of channels. If 0, then the check is skipped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reset_tag</td><td>Whether to reset attribute values to default (if attribute is not created).</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpectedValueType</td><td>Expected attribute value type. </td></tr>
    <tr><td class="paramname">Scalar</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> scalar type. </td></tr>
    <tr><td class="paramname">Index</td><td><a class="el" href="classlagrange_1_1_mesh.html">Mesh</a> index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlagrange_1_1_attribute.html" title="Derived attribute class that stores the actual information.">Attribute</a> id for the retrieved attribute. </dd></dl>

</div>
</div>
<a id="a42f31f304c06ec267113e8de9bda65c8" name="a42f31f304c06ec267113e8de9bda65c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f31f304c06ec267113e8de9bda65c8">&#9670;&nbsp;</a></span>internal_angles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lagrange::internal::internal_angles </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>facets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedK &gt; &amp;&#160;</td>
          <td class="paramname"><em>angles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute internal angles for a triangle mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>#vertices by dim Eigen matrix of mesh vertex nD positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facets</td><td>#facets by 3 eigen Matrix of face (triangle) indices, </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">angles</td><td>#facets by 3 eigen Matrix of internal angles for triangles, columns correspond to edges [1,2],[2,0],[0,1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>Vertices matrix type. </td></tr>
    <tr><td class="paramname">DerivedF</td><td>Facets matrix type. </td></tr>
    <tr><td class="paramname">DerivedK</td><td>Angles matrix type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f2448028bee21427c93b0ab7d1e3578" name="a6f2448028bee21427c93b0ab7d1e3578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2448028bee21427c93b0ab7d1e3578">&#9670;&nbsp;</a></span>string_from_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view lagrange::internal::string_from_scalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a human-readable string from any supported attribute value type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>Can be any supported attribute value type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A human-readable string view of the type name. </dd></dl>

</div>
</div>
<a id="a0ad68547ec10b7b75ce31414844e5166" name="a0ad68547ec10b7b75ce31414844e5166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad68547ec10b7b75ce31414844e5166">&#9670;&nbsp;</a></span>bucket_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlagrange_1_1internal_1_1_bucket_sort_result.html">BucketSortResult</a>&lt; Index &gt; lagrange::internal::bucket_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_disjoint_sets.html">DisjointSets</a>&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>unified_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-utils-misc.html#ga4afead0b9ccc53fe4fca896787595d26">span</a>&lt; Index &gt;&#160;</td>
          <td class="paramname"><em>element_representative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a bucket sort over a range of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">unified_indices</td><td>Disjoint sets covering the range of elements to sort. Due to path compression in the disjoint sets' find() method, this argument is not const. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">element_representative</td><td>Output buffer storing the representative index for each element in the range. Typically this will be the index buffer of a target indexed attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Index type to sort.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bucket sort result containing a list of sorted element indices and an offset for each representative element. </dd></dl>

</div>
</div>
<a id="a425b6670a3b7465f0b6a712b35f91b7c" name="a425b6670a3b7465f0b6a712b35f91b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425b6670a3b7465f0b6a712b35f91b7c">&#9670;&nbsp;</a></span>compute_weighted_corner_normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; Scalar, 3, 1 &gt; compute_weighted_corner_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlagrange_1_1_surface_mesh.html">SurfaceMesh</a>&lt; Scalar, Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>ci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group-surfacemesh-utils.html#gaa88e833ed770762b02e187f0c2377d3d">NormalWeightingType</a>&#160;</td>
          <td class="paramname"><em>weighting</em> = <code><a class="el" href="group__group-surfacemesh-utils.html#ggaa88e833ed770762b02e187f0c2377d3da84f023fc44b6b158de6ccc157c8dab06">NormalWeightingType::CornerTriangleArea</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute weighted corner normal based on the weighting type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ci</td><td>The target corner index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weighting</td><td>The weighting type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the weighted normal vector corresponding to the target corner. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
